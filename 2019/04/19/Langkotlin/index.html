<!DOCTYPE html>
<html style="display: none;" lang="zh">
    <head>
    <meta charset="utf-8">
    <!--
        © Material Theme
        https://github.com/viosey/hexo-theme-material
        Version: 1.4.0 -->
    <script>window.materialVersion = "1.4.0"</script>

    <!-- Title -->
    
    <title>
        
            kotlin 语法详解 | 
        
        Albert&#39;s Blog
    </title>

    <!-- dns prefetch -->
    <meta http-equiv="x-dns-prefetch-control" content="on">
    
    
    
    
    
    
    
    
    
    

    <!-- Meta & Info -->
    <meta http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="theme-color" content="#0097A7">
    <meta name="author" content="Albert Humbert">
    <meta name="description" itemprop="description" content="-">
    <meta name="keywords" content="null,notes">

    <!-- Site Verification -->
    
    

    <!-- Favicons -->
    <link rel="icon shortcut" type="image/ico" href="/img/favicon.png">
    <link rel="icon" sizes="192x192" href="/img/favicon.png">
    <link rel="apple-touch-icon" href="/img/favicon.png">

    <!--iOS -->
    <meta name="apple-mobile-web-app-title" content="Title">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="480">

    <!-- Add to homescreen for Chrome on Android -->
    <meta name="mobile-web-app-capable" content="yes">

    <!-- Add to homescreen for Safari on iOS -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="Albert&#39;s Blog">

    <!-- The Open Graph protocol -->
    <meta property="og:url" content="https://alberthumbert.github.io">
    <meta property="og:type" content="blog">
    <meta property="og:title" content="kotlin 语法详解 | Albert&#39;s Blog">
    <meta property="og:image" content="/img/favicon.png" />
    <meta property="og:description" content="-">
    <meta property="og:article:tag" content="notes"> 

    
        <meta property="article:published_time" content="4月 19, 2019" />
        <meta property="article:modified_time" content="5月 10, 2019" />
    

    <!-- The Twitter Card protocol -->
    <meta name="twitter:title" content="kotlin 语法详解 | Albert&#39;s Blog">
    <meta name="twitter:description" content="-">
    <meta name="twitter:image" content="/img/favicon.png">
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:url" content="https://alberthumbert.github.io" />

    <!-- Add canonical link for SEO -->
    
        <link rel="canonical" href="https://alberthumbert.github.io/2019/04/19/Langkotlin/index.html" />
    

    <!-- Structured-data for SEO -->
    
        


<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "publisher": {
        "@type": "Organization",
        "name": "Albert&#39;s Blog",
        "logo": "/img/favicon.png"
    },
    "author": {
        "@type": "Person",
        "name": "Albert Humbert",
        "image": {
            "@type": "ImageObject",
            "url": "/img/favicon.png"
        },
        "description": "Paranoid Android"
    },
    "headline": "kotlin 语法详解",
    "url": "https://alberthumbert.github.io/2019/04/19/Langkotlin/index.html",
    "datePublished": "4月 19, 2019",
    "dateModified": "5月 10, 2019",
    "description": "-",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://alberthumbert.github.io"
    }
}
</script>


    

    <!--[if lte IE 9]>
        <link rel="stylesheet" href="/css/ie-blocker.css">

        
            <script src="/js/ie-blocker.zhCN.js"></script>
        
    <![endif]-->

    <!-- Import lsloader -->
    <script>(function(){window.lsloader={jsRunSequence:[],jsnamemap:{},cssnamemap:{}};lsloader.removeLS=function(key){try{localStorage.removeItem(key)}catch(e){}};lsloader.setLS=function(key,val){try{localStorage.setItem(key,val)}catch(e){}};lsloader.getLS=function(key){var val="";try{val=localStorage.getItem(key)}catch(e){val=""}return val};versionString="/*"+materialVersion+"*/";lsloader.clean=function(){try{var keys=[];for(var i=0;i<localStorage.length;i++){keys.push(localStorage.key(i))}keys.forEach(function(key){var data=lsloader.getLS(key);if(data&&data.indexOf(versionString)===-1){lsloader.removeLS(key)}})}catch(e){}};lsloader.clean();lsloader.load=function(jsname,jspath,cssonload){cssonload=cssonload||function(){};var code;code=this.getLS(jsname);if(code&&code.indexOf(versionString)===-1){this.removeLS(jsname);this.requestResource(jsname,jspath,cssonload);return}if(code){var versionNumber=code.split(versionString)[0];if(versionNumber!=jspath){console.log("reload:"+jspath);this.removeLS(jsname);this.requestResource(jsname,jspath,cssonload);return}code=code.split(versionString)[1];if(/\.js?.+$/.test(versionNumber)){this.jsRunSequence.push({name:jsname,code:code});this.runjs(jspath,jsname,code)}else{document.getElementById(jsname).appendChild(document.createTextNode(code));cssonload()}}else{this.requestResource(jsname,jspath,cssonload)}};lsloader.requestResource=function(name,path,cssonload){var that=this;if(/\.js?.+$/.test(path)){this.iojs(path,name,function(path,name,code){that.setLS(name,path+versionString+code);that.runjs(path,name,code)})}else if(/\.css?.+$/.test(path)){this.iocss(path,name,function(code){document.getElementById(name).appendChild(document.createTextNode(code));that.setLS(name,path+versionString+code)},cssonload)}};lsloader.iojs=function(path,jsname,callback){var that=this;that.jsRunSequence.push({name:jsname,code:""});try{var xhr=new XMLHttpRequest;xhr.open("get",path,true);xhr.onreadystatechange=function(){if(xhr.readyState==4){if(xhr.status>=200&&xhr.status<300||xhr.status==304){if(xhr.response!=""){callback(path,jsname,xhr.response);return}}that.jsfallback(path,jsname)}};xhr.send(null)}catch(e){that.jsfallback(path,jsname)}};lsloader.iocss=function(path,jsname,callback,cssonload){var that=this;try{var xhr=new XMLHttpRequest;xhr.open("get",path,true);xhr.onreadystatechange=function(){if(xhr.readyState==4){if(xhr.status>=200&&xhr.status<300||xhr.status==304){if(xhr.response!=""){callback(xhr.response);cssonload();return}}that.cssfallback(path,jsname,cssonload)}};xhr.send(null)}catch(e){that.cssfallback(path,jsname,cssonload)}};lsloader.iofonts=function(path,jsname,callback,cssonload){var that=this;try{var xhr=new XMLHttpRequest;xhr.open("get",path,true);xhr.onreadystatechange=function(){if(xhr.readyState==4){if(xhr.status>=200&&xhr.status<300||xhr.status==304){if(xhr.response!=""){callback(xhr.response);cssonload();return}}that.cssfallback(path,jsname,cssonload)}};xhr.send(null)}catch(e){that.cssfallback(path,jsname,cssonload)}};lsloader.runjs=function(path,name,code){if(!!name&&!!code){for(var k in this.jsRunSequence){if(this.jsRunSequence[k].name==name){this.jsRunSequence[k].code=code}}}if(!!this.jsRunSequence[0]&&!!this.jsRunSequence[0].code&&this.jsRunSequence[0].status!="failed"){var script=document.createElement("script");script.appendChild(document.createTextNode(this.jsRunSequence[0].code));script.type="text/javascript";document.getElementsByTagName("head")[0].appendChild(script);this.jsRunSequence.shift();if(this.jsRunSequence.length>0){this.runjs()}}else if(!!this.jsRunSequence[0]&&this.jsRunSequence[0].status=="failed"){var that=this;var script=document.createElement("script");script.src=this.jsRunSequence[0].path;script.type="text/javascript";this.jsRunSequence[0].status="loading";script.onload=function(){that.jsRunSequence.shift();if(that.jsRunSequence.length>0){that.runjs()}};document.body.appendChild(script)}};lsloader.tagLoad=function(path,name){this.jsRunSequence.push({name:name,code:"",path:path,status:"failed"});this.runjs()};lsloader.jsfallback=function(path,name){if(!!this.jsnamemap[name]){return}else{this.jsnamemap[name]=name}for(var k in this.jsRunSequence){if(this.jsRunSequence[k].name==name){this.jsRunSequence[k].code="";this.jsRunSequence[k].status="failed";this.jsRunSequence[k].path=path}}this.runjs()};lsloader.cssfallback=function(path,name,cssonload){if(!!this.cssnamemap[name]){return}else{this.cssnamemap[name]=1}var link=document.createElement("link");link.type="text/css";link.href=path;link.rel="stylesheet";link.onload=link.onerror=cssonload;var root=document.getElementsByTagName("script")[0];root.parentNode.insertBefore(link,root)};lsloader.runInlineScript=function(scriptId,codeId){var code=document.getElementById(codeId).innerText;this.jsRunSequence.push({name:scriptId,code:code});this.runjs()};lsloader.loadCombo=function(jslist){var updateList="";var requestingModules={};for(var k in jslist){var LS=this.getLS(jslist[k].name);if(!!LS){var version=LS.split(versionString)[0];var code=LS.split(versionString)[1]}else{var version=""}if(version==jslist[k].path){this.jsRunSequence.push({name:jslist[k].name,code:code,path:jslist[k].path})}else{this.jsRunSequence.push({name:jslist[k].name,code:null,path:jslist[k].path,status:"comboloading"});requestingModules[jslist[k].name]=true;updateList+=(updateList==""?"":";")+jslist[k].path}}var that=this;if(!!updateList){var xhr=new XMLHttpRequest;xhr.open("get",combo+updateList,true);xhr.onreadystatechange=function(){if(xhr.readyState==4){if(xhr.status>=200&&xhr.status<300||xhr.status==304){if(xhr.response!=""){that.runCombo(xhr.response,requestingModules);return}}else{for(var i in that.jsRunSequence){if(requestingModules[that.jsRunSequence[i].name]){that.jsRunSequence[i].status="failed"}}that.runjs()}}};xhr.send(null)}this.runjs()};lsloader.runCombo=function(comboCode,requestingModules){comboCode=comboCode.split("/*combojs*/");comboCode.shift();for(var k in this.jsRunSequence){if(!!requestingModules[this.jsRunSequence[k].name]&&!!comboCode[0]){this.jsRunSequence[k].status="comboJS";this.jsRunSequence[k].code=comboCode[0];this.setLS(this.jsRunSequence[k].name,this.jsRunSequence[k].path+versionString+comboCode[0]);comboCode.shift()}}this.runjs()}})();</script>

    <!-- Import CSS & jQuery -->
    
        <style id="css/material.min.css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("css/material.min.css","/css/material.min.css?fJTiM/K1J3dWIruo3pxtAw==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";})</script>
        <style id="css/style.min.css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("css/style.min.css","/css/style.min.css?oCSEO3ST+aEypEwttTDI9g==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";})</script>
        
        
            <style>
    
    .footer-sns-facebook {
        background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgY2xhc3M9Imljb24iIHZpZXdCb3g9IjAgMCAxMDI0IDEwMjQiPjxwYXRoIGQ9Ik0xMzguNiA3OGMtMjIuNCA1LjItNTUuOCA0MC4yLTYwLjYgNjMuNC0xLjQgNi40LTIgMTI5LjgtMS42IDM2Ny42LjYgMjk4LjYgMSAzNTguOCAzLjQgMzYzIDExIDIwLjIgMjEuNiAzMi40IDM3LjIgNDMgMTUgMTAuMiAxNy40IDExLjIgMzMgMTMgMTEuMiAxLjQgMTM2IDIgMzY1IDEuNiAzMTQtLjYgMzQ4LjYtMSAzNTUtMy44IDE1LjgtNy4yIDMzLjgtMjIgNDMuMi0zNS40IDUuMi03LjQgMTAuOC0xNi42IDEyLjYtMjAuNCAyLjgtNi40IDMuMi00MC44IDMuOC0zNTQgLjQtMjIzLS4yLTM1My40LTEuNC0zNjUtMi0xNy0yLjYtMTguNi0xMy0zNC04LjYtMTIuNi0xNC4yLTE4LjQtMjUuMi0yNS44LTcuOC01LjQtMTcuNC0xMS0yMS42LTEyLjQtNi0yLjItNzIuOC0yLjYtMzY1LjQtMi42LTE5Ni44LjItMzYxIC44LTM2NC40IDEuOHptNjU3LjYgODcuOGw0LjggMy44djU1LjJjMCA1NC42IDAgNTUuMi00LjYgNTkuNi00LjQgNC40LTYgNC42LTUwLjIgNS42bC00NS42IDEtNy4yIDUuNmMtMTAuNCA4LTE2LjggMTcuMi0xOS4yIDI3LjQtMSA1LTEuOCAyNC44LTEuOCA0NCAuMiAzOCAxLjYgNDQuNiAxMC44IDQ4IDIuOCAxLjIgMjguNCAyIDU2LjggMiA0Ny44IDAgNTIgLjIgNTYuMiAzLjhsNC44IDMuOHY1NS4yYzAgNTQuNiAwIDU1LjItNC42IDU5LjYtNC40IDQuNi01LjQgNC42LTU3IDUuMi0yOC44LjItNTQuNC44LTU2LjggMS40LTIuNC42LTUuNiAzLTYuOCA1LjQtMS44IDMuMi0yLjQgNDEuNC0yLjYgMTQzLjJsLS4yIDEzOC44LTUuNiA0LjgtNS42IDQuOEg2MDljLTUyLjQgMC01Mi44IDAtNTguMi00LjZsLTUuNC00LjYtLjItMTQwLjYtLjItMTQwLjYtNC44LTMuOGMtNC4yLTMuNC04LTMuOC0zNS42LTMuOC0zMi44IDAtNDEtMS44LTQzLjYtMTAtLjYtMi4yLTEuMi0yNS40LTEuMi01MS40IDAtNjAuOC0uMi01NyAzLjQtNjEuNiAyLjgtMy42IDYtNCAzNy44LTUgMzMtMSAzNS4yLTEuMiAzOS40LTUuNiA0LjYtNC40IDQuNi01LjIgNS44LTcxIDEuMi03My40LjItNjcuMiAxNi42LTk5LjQgOC0xNS44IDEyLjgtMjIgMjgtMzcgMTUuMi0xNS4yIDIxLjQtMTkuNiAzOC4yLTI4IDExLTUuNCAyNC0xMSAyOS0xMi4yIDYuMi0xLjggMjguNi0yLjYgNzEuMi0yLjYgNTguNi0uMiA2Mi42IDAgNjcgMy42eiIvPjwvc3ZnPg==);
    }
    
    
    .footer-sns-twitter {
        background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgY2xhc3M9Imljb24iIHZpZXdCb3g9IjAgMCAxMDI0IDEwMjQiPjxwYXRoIGQ9Ik0xMzguNiA3OGMtMjIuNCA1LjItNTUuOCA0MC4yLTYwLjYgNjMuNC0xLjQgNi40LTIgMTI5LjgtMS42IDM2Ny42LjYgMjk4LjYgMSAzNTguOCAzLjQgMzYzIDExIDIwLjIgMjEuNiAzMi40IDM3LjIgNDMgMTUgMTAuMiAxNy40IDExLjIgMzMgMTMgMTEuMiAxLjQgMTM2IDIgMzY1IDEuNiAzMTQtLjYgMzQ4LjYtMSAzNTUtMy44IDE1LjgtNy4yIDMzLjgtMjIgNDMuMi0zNS40IDUuMi03LjQgMTAuOC0xNi42IDEyLjYtMjAuNCAyLjgtNi40IDMuMi00MC44IDMuOC0zNTQgLjQtMjIzLS4yLTM1My40LTEuNC0zNjUtMi0xNy0yLjYtMTguNi0xMy0zNC04LjYtMTIuNi0xNC4yLTE4LjQtMjUuMi0yNS44LTcuOC01LjQtMTcuNC0xMS0yMS42LTEyLjQtNi0yLjItNzIuOC0yLjYtMzY1LjQtMi42LTE5Ni44LjItMzYxIC44LTM2NC40IDEuOHptNTMyLjggMjA1YzEwIDQgMjMgMTAuOCAyOC44IDE1LjIgMTIuNiA5LjIgMTYuNiAxMC42IDI5LjQgOS40IDYuNi0uNiAxMy0zLjIgMjAuNC04LjIgMTEuMi03LjYgMTkuNC05LjIgMjMuNi01IDMuNiAzLjYgMi44IDktMi44IDE4LjYtNy4yIDEyLjQtNiAxOC44IDQuMiAyNC4yIDQuNCAyLjIgOC4yIDUuNiA4LjYgNy40IDEgNC44LTEyLjYgMjQuMi0yMiAzMS44LTExLjggOS4yLTE3LjIgMjIuNi0xOS42IDQ3LjgtNC44IDUwLjQtNy44IDY2LjYtMTYuNCA4NS40LTMgNy03IDE3LjgtOC44IDI0LTEuOCA2LjQtNSAxNC42LTcuNCAxOC40LTIuMiAzLjgtNy40IDEzLTExLjQgMjAuNC0xNy4yIDMwLjgtNDMuNCA2MS40LTcxLjQgODMuOC0yNS42IDIwLjQtNDYgMzMuMi02NC4yIDQwLjItOC40IDMuMi0xOCA3LjYtMjEuNCA5LjYtNy40IDQuNi0yMi40IDguNi01Ny4yIDE1LTYyLjIgMTEuNi03OS4yIDExLjQtMTM1LjYtMS0zMi40LTctMzguNi05LTUyLTE2LjgtMjEuNC0xMi42LTI0LjItMTQuOC0yNC4yLTE5LjQgMC02LjIgMTAuMi05LjIgMzUtMTAuNCAyMi40LTEgMjguNi0yLjYgNTctMTQuMiAyMy44LTkuOCAyOS40LTEyLjggMzAuNC0xNi44IDIuMi04LjItMy0xMy4yLTI2LjgtMjUuNC0yNS44LTEzLjItMzIuMi0xOC40LTQzLjgtMzUuOC05LTEzLjYtMTAtMjEuMi0zLjYtMzMuNiA1LjQtMTAuOCAzLjYtMTUtMTEuOC0yNS40LTktNi0xNC0xMS42LTIwLjgtMjIuNi0yMy40LTM3LjgtMjUtNTAuOC03LjItNTkuOCA0LjgtMi40IDkuNC01LjQgMTAuMi02LjYgMi44LTQuMi0uNC0xNS42LTguNC0yOS0xMS42LTE5LjYtMTMuMi0yNS44LTEzLjItNTUuMiAwLTI4LjggMi42LTM3LjggMTItNDAuMiA5LTIuMiAxNC44IDEgMzUuNiAyMC4yIDI0LjggMjIuOCA0My42IDM2LjYgNjIuOCA0NS44IDggMy44IDE3LjggOS4yIDIyIDEyIDQuMiAyLjggMTQuOCA3IDIzLjQgOS4yIDguNiAyLjIgMjQuMiA2LjggMzQuOCAxMC4yIDEzLjQgNC40IDIzLjYgNi40IDMzIDYuNiAxMi44LjIgMTQuMi0uMiAxOC42LTUuNCA0LTQuOCA0LjgtNy44IDQuOC0xOS4yIDAtMTQuNCA1LjYtMzkuNiAxMS4yLTUwLjYgNC4yLTguNCAyOS4yLTM0LjIgMzkuOC00MS40IDcuOC01LjQgMzUuNi0xNiA1Mi0yMCAxNC4yLTMuNiAzMi42LTEuMiA1Mi40IDYuOHoiLz48L3N2Zz4=);
    }
    
    
    .footer-sns-gplus {
        background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgY2xhc3M9Imljb24iIHZpZXdCb3g9IjAgMCAxMDI0IDEwMjQiPjxwYXRoIGQ9Ik0xMzguNiA3OGMtMjIuNCA1LjItNTUuOCA0MC4yLTYwLjYgNjMuNC0xLjQgNi40LTIgMTI5LjgtMS42IDM2Ny42LjYgMjk4LjYgMSAzNTguOCAzLjQgMzYzIDExIDIwLjIgMjEuNiAzMi40IDM3LjIgNDMgMTUgMTAuMiAxNy40IDExLjIgMzMgMTMgMTEuMiAxLjQgMTM2IDIgMzY1IDEuNiAzMTQtLjYgMzQ4LjYtMSAzNTUtMy44IDE1LjgtNy4yIDMzLjgtMjIgNDMuMi0zNS40IDUuMi03LjQgMTAuOC0xNi42IDEyLjYtMjAuNCAyLjgtNi40IDMuMi00MC44IDMuOC0zNTQgLjQtMjIzLS4yLTM1My40LTEuNC0zNjUtMi0xNy0yLjYtMTguNi0xMy0zNC04LjYtMTIuNi0xNC4yLTE4LjQtMjUuMi0yNS44LTcuOC01LjQtMTcuNC0xMS0yMS42LTEyLjQtNi0yLjItNzIuOC0yLjYtMzY1LjQtMi42LTE5Ni44LjItMzYxIC44LTM2NC40IDEuOHpNNDMwIDI5NS40YzQwLjYgMTUuNCA1Ni42IDIzLjggNzIuNiAzOC40IDYuOCA2LjIgNy4yIDE1LjIgMSAyMy40LTYuMiA4LTMzLjYgMzMuOC0zOSAzNi42LTUuNiAyLjgtMTcuNiAyLjgtMjMuMi0uMi0yLjQtMS4yLTguMi01LjItMTMtOC44LTExLjItOC42LTI0LjYtMTEuMi01NS4yLTExLjItMjcuNCAwLTQwLjYgMi42LTUyLjIgMTAuNC00LjQgMi44LTEyLjIgNy42LTE3LjIgMTAuNi0yMyAxMy4yLTUxLjQgNTUtNTUuOCA4Mi40LTIuNiAxNS42LTIuNCAzNC44LjIgNTEgMi44IDE3LjQgMTkuOCA0OC44IDM1LjIgNjUuMiAxNiAxNi42IDQ1IDMzLjYgNjIuOCAzNi42IDI2LjggNC40IDY1LjggMS42IDc5LjQtNS44IDIwLjYtMTEuNCAzMS0xOSA0MS0zMC40IDE4LjgtMjEuNiAyMy40LTM0LjIgMTUuNi00My44LTMuOC00LjgtNC40LTQuOC01MS01LjgtNjAuOC0xLjItNTYuMiAyLjItNTYuMi00My4yIDAtMzIuNC4yLTMzLjIgNC44LTM3IDQuNC0zLjYgOS0zLjggOTItMy44IDc5IDAgODcuOC40IDk0LjIgMy42IDExLjIgNS42IDEzIDExLjQgMTIuOCA0My40IDAgMjUuNC0uOCAzMC44LTcuNiA1OC00IDE2LjYtOS44IDM0LTEyLjYgMzktMi44IDUtOC4yIDE0LjItMTEuNiAyMC42LTguNCAxNS40LTI3LjIgMzYuOC00MC44IDQ2LjYtNS44IDQuNC0xMy44IDEwLjItMTcuNiAxMy4yLTMuOCAzLTExIDctMTYuMiA4LjgtNS4yIDEuOC0xNi4yIDYuNC0yNC40IDEwLTIyLjQgOS42LTM0LjggMTEuNi03MyAxMS42LTM3LjYuMi00Ny0xLjQtNzEtMTItOC4yLTMuNi0xNy42LTcuMi0yMC44LTgtMTUuOC0zLjgtNjctNDUuMi03Ny44LTYyLjgtMi4yLTMuOC03LjYtMTEuNi0xMS44LTE3LjItNC4yLTUuNC05LTE0LTEwLjYtMTktMS44LTQuOC02LjItMTYtMTAtMjQuOC0zLjYtOC44LTcuOC0yMi4yLTkuMi0yOS42LTMuMi0xOC44LTEuNC03OS40IDIuOC05MS40IDEzLjgtNDAuNiAzNS42LTc4IDU4LjgtMTAwLjIgMTQtMTMuNiA0Ny4yLTM2LjQgNTgtMzkuOCA0LjItMS40IDEzLjQtNS4yIDIwLjYtOC40IDIyLTEwIDMyLjgtMTEuNiA3Ni0xMSAzMy44LjYgNDAuNCAxLjIgNTAgNC44em0zNDAuOCA4MC44YzggMy42IDkuNiAxMS4yIDkuMiAzOS4yLS42IDM0LjQtLjYgMzQgNSAzOS42IDQuOCA1IDUuNCA1IDM3LjYgNSA0My40IDAgNDQuNC44IDQzLjIgMzYuMi0uOCAxNy0xLjIgMTguNC02LjQgMjMtNS40IDQuNi02LjYgNC44LTM3LjYgNC44LTMxLjIgMC0zMiAuMi0zNi44IDUtNS42IDUuNC01LjYgNC40LTUgNDEuMi40IDI2LjQuMiAyNy40LTQuNiAzMy00LjggNS42LTYgNS44LTI0LjQgNi40LTIwLjguOC0yOS42LTEuNC0zMy40LTguNC0xLjQtMi42LTItMTUuNi0xLjgtMzUuNi40LTMxLjIuNC0zMS42LTQuNi0zNi42cy01LjYtNS0zNi01Yy0xOC44IDAtMzMtLjgtMzYtMi4yLTcuNi0zLjYtOS42LTExLjItOC44LTMzLjguOC0yOC4yLjQtMjggNDEtMjggNDUuNCAwIDQ1LjQgMCA0NC42LTQyLjYtLjYtMzMtLjYtMzMgNS0zOC40IDQuNC00LjYgNi4yLTUgMjQuOC01IDExIDAgMjIuMiAxIDI1IDIuMnoiLz48L3N2Zz4=);
    }
    
    
    
    
    
    
    
    
    
</style>

        
        <!-- Config CSS -->

<!-- Other Styles -->
<style>
  body, html {
    font-family: Roboto, "Helvetica Neue", Helvetica, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", "微软雅黑", Arial, sans-serif;
  }

  a {
    color: #00838F;
  }

  .mdl-card__media,
  #search-label,
  #search-form-label:after,
  #scheme-Paradox .hot_tags-count,
  #scheme-Paradox .sidebar_archives-count,
  #scheme-Paradox .sidebar-colored .sidebar-header,
  #scheme-Paradox .sidebar-colored .sidebar-badge{
    background-color: #0097A7 !important;
  }

  /* Sidebar User Drop Down Menu Text Color */
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:hover,
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:focus {
    color: #0097A7 !important;
  }

  #post_entry-right-info,
  .sidebar-colored .sidebar-nav li:hover > a,
  .sidebar-colored .sidebar-nav li:hover > a i,
  .sidebar-colored .sidebar-nav li > a:hover,
  .sidebar-colored .sidebar-nav li > a:hover i,
  .sidebar-colored .sidebar-nav li > a:focus i,
  .sidebar-colored .sidebar-nav > .open > a,
  .sidebar-colored .sidebar-nav > .open > a:hover,
  .sidebar-colored .sidebar-nav > .open > a:focus,
  #ds-reset #ds-ctx .ds-ctx-entry .ds-ctx-head a {
    color: #0097A7 !important;
  }

  .toTop {
    background: #757575 !important;
  }

  .material-layout .material-post>.material-nav,
  .material-layout .material-index>.material-nav,
  .material-nav a {
    color: #757575;
  }

  #scheme-Paradox .MD-burger-layer {
    background-color: #757575;
  }

  #scheme-Paradox #post-toc-trigger-btn {
    color: #757575;
  }

  .post-toc a:hover {
    color: #00838F;
    text-decoration: underline;
  }

</style>


<!-- Theme Background Related-->

    <style>
      body{
        background-color: #F5F5F5;
      }

      /* blog_info bottom background */
      #scheme-Paradox .material-layout .something-else .mdl-card__supporting-text{
        background-color: #fff;
      }
    </style>




<!-- Fade Effect -->

    <style>
      .fade {
        transition: all 800ms linear;
        -webkit-transform: translate3d(0,0,0);
        -moz-transform: translate3d(0,0,0);
        -ms-transform: translate3d(0,0,0);
        -o-transform: translate3d(0,0,0);
        transform: translate3d(0,0,0);
        opacity: 1;
      }

      .fade.out{
        opacity: 0;
      }
    </style>


<!-- Import Font -->

    <link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons"rel="stylesheet">


        <script>lsloader.load("js/jquery.min.js","/js/jquery.min.js?qcusAULNeBksqffqUM2+Ig==")</script>
    
    
    <script>function Queue(){this.dataStore=[];this.offer=b;this.poll=d;this.execNext=a;this.debug=false;this.startDebug=c;function b(e){if(this.debug){console.log("Offered a Queued Function.")}if(typeof e==="function"){this.dataStore.push(e)}else{console.log("You must offer a function.")}}function d(){if(this.debug){console.log("Polled a Queued Function.")}return this.dataStore.shift()}function a(){var e=this.poll();if(e!==undefined){if(this.debug){console.log("Run a Queued Function.")}e()}}function c(){this.debug=true}}var queue=new Queue();</script>

    <!-- Analytics -->
    

    <!-- Custom Head -->
    
</head>


    
        <body id="scheme-Paradox" class="lazy">
            <div class="material-layout  mdl-js-layout has-drawer is-upgraded">
                

                <!-- Main Container -->
                <main class="material-layout__content" id="main">

                    <!-- Top Anchor -->
                    <div id="top"></div>

                    
                        <!-- Hamburger Button -->
                        <button class="MD-burger-icon sidebar-toggle">
                            <span class="MD-burger-layer"></span>
                        </button>
                    

                    <!-- Post TOC -->

    
    <!-- Back Button -->
    <!--
    <div class="material-back" id="backhome-div" tabindex="0">
        <a class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon"
           href="#" onclick="window.history.back();return false;"
           target="_self"
           role="button"
           data-upgraded=",MaterialButton,MaterialRipple">
            <i class="material-icons" role="presentation">arrow_back</i>
            <span class="mdl-button__ripple-container">
                <span class="mdl-ripple"></span>
            </span>
        </a>
    </div>
    -->

    <!-- Left aligned menu below button -->
    <button id="post-toc-trigger-btn"
        class="mdl-button mdl-js-button mdl-button--icon">
        <i class="material-icons">format_list_numbered</i>
    </button>

    
    <ul class="post-toc-wrap mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect" for="post-toc-trigger-btn" style="max-height:80vh; overflow-y:scroll;">
        <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#前言"><span class="post-toc-number">1.</span> <span class="post-toc-text">前言</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#函数和变量"><span class="post-toc-number">2.</span> <span class="post-toc-text">函数和变量</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#函数"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">函数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#基础"><span class="post-toc-number">2.1.1.</span> <span class="post-toc-text">基础</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#主函数-main"><span class="post-toc-number">2.1.2.</span> <span class="post-toc-text">主函数 main</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#代码块体"><span class="post-toc-number">2.1.3.</span> <span class="post-toc-text">代码块体 {}</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#表达式体"><span class="post-toc-number">2.1.4.</span> <span class="post-toc-text">表达式体 =</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#变量-var-val"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">变量 var val</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#省略类型"><span class="post-toc-number">2.2.1.</span> <span class="post-toc-text">省略类型</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#字符串模板"><span class="post-toc-number">2.2.2.</span> <span class="post-toc-text">字符串模板 ${}</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#类基础和属性"><span class="post-toc-number">3.</span> <span class="post-toc-text">类基础和属性</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#属性-field"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">属性 field</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#包-import-package"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">包 import package</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#枚举-enum"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">枚举 enum</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#条件和分支"><span class="post-toc-number">4.</span> <span class="post-toc-text">条件和分支</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#分支-when"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">分支 when</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#when-支持任意对象"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">when 支持任意对象</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#when-不带参数"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">when 不带参数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#类型检查-is"><span class="post-toc-number">4.4.</span> <span class="post-toc-text">类型检查 is</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#迭代和区间"><span class="post-toc-number">5.</span> <span class="post-toc-text">迭代和区间</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#while"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">while</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#区间-in"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">区间 in</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#map-迭代"><span class="post-toc-number">5.3.</span> <span class="post-toc-text">map 迭代</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#in-检查区间"><span class="post-toc-number">5.4.</span> <span class="post-toc-text">in 检查区间</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#异常"><span class="post-toc-number">6.</span> <span class="post-toc-text">异常</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#try-catch-finally"><span class="post-toc-number">6.1.</span> <span class="post-toc-text">try catch finally</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#try-表达式"><span class="post-toc-number">6.2.</span> <span class="post-toc-text">try 表达式</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#集合"><span class="post-toc-number">7.</span> <span class="post-toc-text">集合</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#函数参数"><span class="post-toc-number">8.</span> <span class="post-toc-text">函数参数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#命名参数"><span class="post-toc-number">8.1.</span> <span class="post-toc-text">命名参数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#默认参数"><span class="post-toc-number">8.2.</span> <span class="post-toc-text">默认参数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#可变参数"><span class="post-toc-number">8.3.</span> <span class="post-toc-text">可变参数</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#扩展功能"><span class="post-toc-number">9.</span> <span class="post-toc-text">扩展功能</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#包扩展"><span class="post-toc-number">9.1.</span> <span class="post-toc-text">包扩展</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#类扩展"><span class="post-toc-number">9.2.</span> <span class="post-toc-text">类扩展</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#局部函数"><span class="post-toc-number">9.3.</span> <span class="post-toc-text">局部函数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#中缀和解构"><span class="post-toc-number">9.4.</span> <span class="post-toc-text">中缀和解构</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#字符串"><span class="post-toc-number">10.</span> <span class="post-toc-text">字符串</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#正则扩展"><span class="post-toc-number">10.1.</span> <span class="post-toc-text">正则扩展</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#三重引号"><span class="post-toc-number">10.2.</span> <span class="post-toc-text">三重引号</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#类和接口"><span class="post-toc-number">11.</span> <span class="post-toc-text">类和接口</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#接口"><span class="post-toc-number">11.1.</span> <span class="post-toc-text">接口</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#继承"><span class="post-toc-number">11.2.</span> <span class="post-toc-text">继承</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#访问修饰符"><span class="post-toc-number">11.3.</span> <span class="post-toc-text">访问修饰符</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#内部类-inner"><span class="post-toc-number">11.4.</span> <span class="post-toc-text">内部类 inner</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#封装类-sealed"><span class="post-toc-number">11.5.</span> <span class="post-toc-text">封装类 sealed</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#主构造函数"><span class="post-toc-number">11.6.</span> <span class="post-toc-text">主构造函数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#从构造函数"><span class="post-toc-number">11.7.</span> <span class="post-toc-text">从构造函数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#接口属性"><span class="post-toc-number">11.8.</span> <span class="post-toc-text">接口属性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#object-函数"><span class="post-toc-number">11.9.</span> <span class="post-toc-text">object 函数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#数据类-data"><span class="post-toc-number">11.10.</span> <span class="post-toc-text">数据类 data</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#类委托-by"><span class="post-toc-number">11.11.</span> <span class="post-toc-text">类委托 by</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#对象类声明-object"><span class="post-toc-number">11.12.</span> <span class="post-toc-text">对象类声明 object</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#伴生对象-companion"><span class="post-toc-number">11.13.</span> <span class="post-toc-text">伴生对象 companion</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#lambda和序列"><span class="post-toc-number">12.</span> <span class="post-toc-text">lambda和序列</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#lambda"><span class="post-toc-number">12.1.</span> <span class="post-toc-text">lambda</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#成员引用"><span class="post-toc-number">12.2.</span> <span class="post-toc-text">成员引用 ::</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#SAM-构造方法"><span class="post-toc-number">12.3.</span> <span class="post-toc-text">SAM 构造方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#带接受者的lambda"><span class="post-toc-number">12.4.</span> <span class="post-toc-text">带接受者的lambda</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#with"><span class="post-toc-number">12.5.</span> <span class="post-toc-text">with</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#apply"><span class="post-toc-number">12.6.</span> <span class="post-toc-text">apply</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#集合函数式api"><span class="post-toc-number">12.7.</span> <span class="post-toc-text">集合函数式api</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#序列-sequence"><span class="post-toc-number">12.8.</span> <span class="post-toc-text">序列 sequence</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#可空性"><span class="post-toc-number">13.</span> <span class="post-toc-text">可空性</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#非空类型"><span class="post-toc-number">13.1.</span> <span class="post-toc-text">非空类型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#可空类型"><span class="post-toc-number">13.2.</span> <span class="post-toc-text">可空类型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#安全调用运算符"><span class="post-toc-number">13.3.</span> <span class="post-toc-text">安全调用运算符 ?.</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Elvis-运算符"><span class="post-toc-number">13.4.</span> <span class="post-toc-text">Elvis 运算符: ?:</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#安全转换-as"><span class="post-toc-number">13.5.</span> <span class="post-toc-text">安全转换 as?</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#非空断言"><span class="post-toc-number">13.6.</span> <span class="post-toc-text">非空断言 !!</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#let函数"><span class="post-toc-number">13.7.</span> <span class="post-toc-text">let函数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#延迟初始化-lateinit"><span class="post-toc-number">13.8.</span> <span class="post-toc-text">延迟初始化 lateinit</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#可空类性扩展函数"><span class="post-toc-number">13.9.</span> <span class="post-toc-text">可空类性扩展函数</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#类型系统"><span class="post-toc-number">14.</span> <span class="post-toc-text">类型系统</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#平台类型"><span class="post-toc-number">14.1.</span> <span class="post-toc-text">平台类型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#可空基本类型"><span class="post-toc-number">14.2.</span> <span class="post-toc-text">可空基本类型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#数字转换"><span class="post-toc-number">14.3.</span> <span class="post-toc-text">数字转换</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#unit类型"><span class="post-toc-number">14.4.</span> <span class="post-toc-text">unit类型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#nothing"><span class="post-toc-number">14.5.</span> <span class="post-toc-text">nothing</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#文档注释"><span class="post-toc-number">15.</span> <span class="post-toc-text">文档注释</span></a></li></ol>
        <!--
        <li class="mdl-menu__item">
            Some Action
        </li>
        -->
    </ul>
    





<!-- Layouts -->

    <!-- Post Module -->
    <div class="material-post_container">

        <div class="material-post mdl-grid">
            <div class="mdl-card mdl-shadow--4dp mdl-cell mdl-cell--12-col">

                <!-- Post Header(Thumbnail & Title) -->
                
    <!-- Paradox Post Header -->
    
        
            <!-- Random Thumbnail -->
            <div class="post_thumbnail-random mdl-card__media mdl-color-text--grey-50">
            <script type="text/ls-javascript" id="post-thumbnail-script">
    var randomNum = Math.floor(Math.random() * 19 + 1);

    $('.post_thumbnail-random').attr('data-original', '/img/random/material-' + randomNum + '.png');
    $('.post_thumbnail-random').addClass('lazy');
</script>

        
    
            <p class="article-headline-p">
                kotlin 语法详解
            </p>
        </div>





                
                    <!-- Paradox Post Info -->
                    <div class="mdl-color-text--grey-700 mdl-card__supporting-text meta">

    <!-- Author Avatar -->
    <div id="author-avatar">
        <img src="/img/avatar.png" width="44px" height="44px" alt="Author Avatar"/>
    </div>
    <!-- Author Name & Date -->
    <div>
        <strong>Albert Humbert</strong>
        <span>4月 19, 2019</span>
    </div>

    <div class="section-spacer"></div>

    <!-- Favorite -->
    <!--
        <button id="article-functions-like-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon btn-like">
            <i class="material-icons" role="presentation">favorite</i>
            <span class="visuallyhidden">favorites</span>
        </button>
    -->

    <!-- Qrcode -->
    

    <!-- Tags (bookmark) -->
    
    <button id="article-functions-viewtags-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
        <i class="material-icons" role="presentation">bookmark</i>
        <span class="visuallyhidden">bookmark</span>
    </button>
    <ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-functions-viewtags-button">
        <li class="mdl-menu__item">
        <a class="post_tag-link" href="/tags/notes/">notes</a>
    </ul>
    

    <!-- Share -->
    <button id="article-fuctions-share-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
    <i class="material-icons" role="presentation">share</i>
    <span class="visuallyhidden">share</span>
</button>
<ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-fuctions-share-button">
    

    

    <!-- Share Weibo -->
    
        <a class="post_share-link" href="http://service.weibo.com/share/share.php?appkey=&title=kotlin 语法详解&url=https://alberthumbert.github.io/2019/04/19/Langkotlin/index.html&pic=&searchPic=false&style=simple" target="_blank">
            <li class="mdl-menu__item">
                分享到微博
            </li>
        </a>
    

    <!-- Share Twitter -->
    
        <a class="post_share-link" href="https://twitter.com/intent/tweet?text=kotlin 语法详解&url=https://alberthumbert.github.io/2019/04/19/Langkotlin/index.html&via=Albert Humbert" target="_blank">
            <li class="mdl-menu__item">
                分享到 Twitter
            </li>
        </a>
    

    <!-- Share Facebook -->
    
        <a class="post_share-link" href="https://www.facebook.com/sharer/sharer.php?u=https://alberthumbert.github.io/2019/04/19/Langkotlin/index.html" target="_blank">
            <li class="mdl-menu__item">
                分享到 Facebook
            </li>
        </a>
    

    <!-- Share Google+ -->
    
        <a class="post_share-link" href="https://plus.google.com/share?url=https://alberthumbert.github.io/2019/04/19/Langkotlin/index.html" target="_blank">
            <li class="mdl-menu__item">
                分享到 Google+
            </li>
        </a>
    

    <!-- Share LinkedIn -->
    
        <a class="post_share-link" href="https://www.linkedin.com/shareArticle?mini=true&url=https://alberthumbert.github.io/2019/04/19/Langkotlin/index.html&title=kotlin 语法详解" target="_blank">
            <li class="mdl-menu__item">
                分享到 LinkedIn
            </li>
        </a>
    

    <!-- Share QQ -->
    
        <a class="post_share-link" href="http://connect.qq.com/widget/shareqq/index.html?site=Albert&#39;s Blog&title=kotlin 语法详解&summary=developing&pics=https://alberthumbert.github.io/img/favicon.png&url=https://alberthumbert.github.io/2019/04/19/Langkotlin/index.html" target="_blank">
            <li class="mdl-menu__item">
                分享到 QQ
            </li>
        </a>
    

    <!-- Share Telegram -->
    
        <a class="post_share-link" href="https://telegram.me/share/url?url=https://alberthumbert.github.io/2019/04/19/Langkotlin/index.html&text=kotlin 语法详解" target="_blank">
            <li class="mdl-menu__item">
                分享到 Telegram
            </li>
        </a>
    
</ul>

</div>

                

                <!-- Post Content -->
                <div id="post-content" class="mdl-color-text--grey-700 mdl-card__supporting-text fade out">
    
        <p>-</p>
<a id="more"></a>
<p><a href="https://try.kotlinlang.org/" target="_blank" rel="external">你可以在这个网站中在线编译并运行kotlin代码</a></p>
<p><br></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>kotlin是一门野心非常大的语言，它不但能与能与现有的java框架并存，向人证明它可以以更加简洁的方式代替java，还不断向着更多的领域发展。android开发者可以结合anko编写应用，永久告别xml，前端开发者可以编写kotlin代码然后编译成JavaScript，Kotlin_Native更是支持直接编译机器码在linux，ios，mac os上运行</li>
</ul>
<ul>
<li>kotlin最大的特点是简洁的语法，自动类型推断，互操作性，成吨语法糖</li>
</ul>
<ul>
<li>java中已有并且在kotlin中相同的特性不会拿出来讲</li>
</ul>
<p><br></p>
<h2 id="函数和变量"><a href="#函数和变量" class="headerlink" title="函数和变量"></a>函数和变量</h2><p><br></p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p><br></p>
<h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><p><strong>构成kotlin程序的基本要素是函数和变量，这即是某些语言以及函数式编程中强调的“函数是第一等公民”的概念的体现</strong></p>
<pre><code>fun main(args:Array&lt;String&gt;){
    println(&quot;hello world&quot;)
}
</code></pre><ul>
<li>上面是一个hello world的kotlin实现，从这个简单的例子中我们已经可以看到kotlin与java有很多不同</li>
</ul>
<pre><code>1.使用关键字 fun 声明一个函数，也就是方法
2.参数类型写在名称的后面，与go语言如出一辙，对于能够自动推断类型的语言来说，我们总是更关注变量的名名称所表达的抽象含义而不是它的类型
3.函数可以定义在文件的最外层，而不是类里面，你可以直接把这个函数放到任何一个kt文件中运行，不需要找到一个合适的花括号然后把它塞进去
4.println代替了system.out.println，kotlin简化了很多这样啰嗦的代码
5.可以省略代码结尾的分号，这点和python很像，你不用担心你的代码会被go编译器那样胡乱的添加上分号
</code></pre><p><br></p>
<h4 id="主函数-main"><a href="#主函数-main" class="headerlink" title="主函数 main"></a>主函数 main</h4><ul>
<li>两种写法</li>
</ul>
<pre><code>fun main(){
//...
}
fun main(Array&lt;String&gt;){
//...
}
</code></pre><p><br></p>
<h4 id="代码块体"><a href="#代码块体" class="headerlink" title="代码块体 {}"></a>代码块体 {}</h4><pre><code>fun max(a: Int, b: Int): Int {
    return if (a &gt; b) a else b
}
</code></pre><ul>
<li>函数以fun开头，然后是函数名和参数列表，参数类型写在参数名后，以冒号隔开，最后是冒号和返回类型</li>
</ul>
<ul>
<li>注意在kotlin中大多数控制结果都是表达式，而不是语句，语句与表达式的最大区别在于表达式有值，允许直接嵌套使用</li>
</ul>
<p><br></p>
<h4 id="表达式体"><a href="#表达式体" class="headerlink" title="表达式体 ="></a>表达式体 =</h4><pre><code>fun max(a: Int, b: Int): Int = if (a &gt; b) a else b
</code></pre><ul>
<li><p>表达式也可以作为一个完整的函数体，现在你知道为什么kotlin要把返回类型放在函数头的最后面了</p>
</li>
<li><p>我们说过kotlin支持自动类型推断，因此上面的代码还可以简洁一下</p>
</li>
</ul>
<pre><code>fun max(a: Int, b: Int) = if (a \&gt; b) a else b
</code></pre><ul>
<li>在函数中支持表达式体的意义在于，向kotlin这种支持闭包的语言可以在任何地方将代码重用的粒度降到最细</li>
</ul>
<p><br></p>
<h3 id="变量-var-val"><a href="#变量-var-val" class="headerlink" title="变量 var val"></a>变量 var val</h3><p><br></p>
<h4 id="省略类型"><a href="#省略类型" class="headerlink" title="省略类型"></a>省略类型</h4><pre><code>val aString = &quot;I am String&quot;
val aInt = 1;
var aDouble = 2e6
var aFloat:Float
</code></pre><ul>
<li>在Java(jdk 10之前)中，声明变量时必须在最前面写出变量类型，在kotlin中，你甚至都不需要给出类型，编译器根据初始化的值可以知道你要的是什么，如果你不想那么快赋值，那就必须给出变量类型了</li>
</ul>
<ul>
<li>上面我们用到了var和val来声明变量，var表示可变引用，val表示不可变引用（final），并且val仅仅保证引用的不可变性，它指向的对象仍然是可变的</li>
</ul>
<pre><code>val aList = arrayListOf(&quot;java&quot;)
aList.add(&quot;kotlin&quot;)
</code></pre><ul>
<li>你应该尽可能地使用val来声明所有的变量，这会让代码更安全，也更接近函数式编程的风格</li>
</ul>
<p><br></p>
<h4 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板 ${}"></a>字符串模板 ${}</h4><pre><code>val he = &quot;Albert&quot;
val languages = arrayListOf(&quot;java&quot;)
languages.add(&quot;kotlin&quot;)
println(&quot;$he said, ${languages[1]} is the best language in the world &quot;)

//猜猜输出什么？
</code></pre><ul>
<li><p>字符串模板的作用是允许字符串字面量中存在变量和表达式，这显然让字符串拼接显得更加简洁紧凑，易于理解</p>
</li>
<li><p>可以使用$中支持变量，使用${}支持表达式</p>
</li>
</ul>
<p><br></p>
<h2 id="类基础和属性"><a href="#类基础和属性" class="headerlink" title="类基础和属性"></a>类基础和属性</h2><p><strong>Java常为人诟病的一点就是创建一个类需要非常多的样板代码（特别是对于bean类而言），为此不少ide或插件都提供了自动生成getter，setter，构造器，代码模板，万能tab的功能</strong></p>
<p><strong>但就像很多人认为的那样，某种程度上Java逐渐变成了一门“依赖ide”的语言</strong></p>
<p><strong>kotlin的开发者们为了解决这些问题可谓下足了功夫</strong></p>
<p><br></p>
<h3 id="属性-field"><a href="#属性-field" class="headerlink" title="属性 field"></a>属性 field</h3><pre><code>class Person(var name:String)
</code></pre><ul>
<li>上面这行kotlin代码展开成Java代码之后如下，你一定见过很多这样的Java代码，尽管从语法的角度来讲它们处处都有意义，但实际上你需要的关键词真的只有 class，Person，var，name ，String，这就是kotlin所谓的简洁，在kotlin当中，类通常很小</li>
</ul>
<pre><code>public class Person{
    private String name;

    public Person(String name){
        this.name = name;
    }

    public String getName(){
        return name;
    }

    public void setName(String name){
        this.name = name;
    }
}
</code></pre><ul>
<li>对于使用var修饰的属性，kotlin编译器会自动为其生成getter，setter，对于使用val修饰的属性，编译器则只生成getter，同时在访问和修改任何属性时，你不需要显式地调用它们的访问方法，对于构造方法而言，你也不用再写关键字new了</li>
</ul>
<pre><code>val albert = Person(&quot;Albert&quot;)
albert.name = &quot;Albert Lin&quot;
println(albert.name)
</code></pre><ul>
<li>所有属性都像Java中访问公有属性那样访问，但实际上走的是内部的getter和setter方法,当然这也包括了你所编写的getter和setter方法</li>
</ul>
<pre><code>class Rectangle(val height: Int, val width: Int) {
    val isSquare: Boolean
        get() {
            return height == width
        }

    //也可以简化为val isSquare: Boolean get() = height == width
}
</code></pre><ul>
<li>对于val属性，只允许有get方法而不允许设置set方法，同时val属性本身不允许修改。然而由于get方法本身并非需要与关联的属性有实际关系，所以get方法返回值不一定是固定的</li>
</ul>
<pre><code>class Rectangle(var height:Int, var width:Int){
    val isSquare: Boolean
        get() {
            return width == height
        }
}
fun main() {
    val p = Rectangle(1,1)
    assert(p.isSquare)
    p.width = 2
    assert(!p.isSquare)
}
</code></pre><ul>
<li>对于var属性，同时支持get和set方法，var属性的需要设置初始值，可以借助构造函数提供的属性。还要注意不管是get还是set方法，需要访问关联的属性时最好都使用关键字field，而不是变量名，否则容易因为自动调用的get和set方法造成循环递归导致栈溢出</li>
</ul>
<pre><code>class Rectangle(var height: Int, var width: Int) {
    var isSquare: Boolean = width == height &amp;&amp; width * height != 0
        get() {
            return width == height
        }

    set(value){
        field = value
    }
}
</code></pre><ul>
<li>具体来说，原因是在get和set方法中，get和set的自动调用依然是开启的，所以容易出现以下情况。注意有的情况lint无法检测出来，同时只有运行时访问到该属性时才会抛出StackOverflowError。本来get和set方法中就不应该有过多复杂的操作，尽量使用fiel关键字，谨慎调用其他方法即可</li>
</ul>
<pre><code>//无限递归get，ide有提示  
var isSquare: Boolean = false
        get() {
            if (isSquare) return true
            return false
        }
//无限递归set，ide有提示
var isSquare: Boolean = false
        set(value) {
            isSquare = value
        }
//get与set循环造成栈溢出，ide无提示
var isSquare: Boolean =false
        get() {
            isSquare = false
            return field
        }

            set(value){
            if(isSquare){
                field = true
            }else{
                field = value
            }
        }
//get与普通方法循环造成栈溢出，ide无提示
    var isSquare: Boolean =false
        get() {
            test()
            isSquare = false
            return field
        }

    private fun test(){
        var a = isSquare
    }
</code></pre><ul>
<li>如果需要限制访问权限，可以使用在get和set方法前使用修饰符，注意get的修饰符需要与属性前的修饰符一直，而set的修饰符访问权限需要小于或等于属性前的修饰符</li>
</ul>
<pre><code>var isSquare: Boolean = width == height &amp;&amp; width * height != 0
    get() {
        return width == height
    }
 private set(value) {
        field = value
    }
</code></pre><p><br></p>
<h3 id="包-import-package"><a href="#包-import-package" class="headerlink" title="包 import package"></a>包 import package</h3><ul>
<li>kotlin当中依然使用import和package关键字来组织代码结构，不同的是，在Java中，包结构需要与实际上的文件目录结构一致，kotlin则不做这种要求，你可以把所有文件都放到一个目录，只在package关键字后面声明它们所在的包</li>
</ul>
<ul>
<li>在通常情况下，程序员依然应该使用Java那样去管理文件，但是对于那些短小的类而言,你应该按照具体职责将它们放到同一个文件中</li>
</ul>
<pre><code>package  com.linjiamin.kt.play
class Rectangle(val height: Int, val width: Int) {
    val isSquare: Boolean get() = height == width
}
class Person(var name:String)
</code></pre><p><br></p>
<h3 id="枚举-enum"><a href="#枚举-enum" class="headerlink" title="枚举 enum"></a>枚举 enum</h3><ul>
<li>在kotlin当中，声明一个枚举类，需要 enum class 两个关键字</li>
</ul>
<pre><code>enum class Color{
    RED,ORANGE,YELLOW,GREEN,BLUE,INDIGO,VIOLET
}
</code></pre><ul>
<li>更常规的用法,为其添加构造方法和其他特定的方法，注意枚举列表必须与其他方法用分号隔开，这是kotlin中唯一一个必须使用分号结尾的地方。虽然使用val属性可以让其看起来更像枚举，但var属性也是可以的，这里和java没什么区别</li>
</ul>
<pre><code>enum class Color(val r: Int, val g: Int, val b: Int) {
    RED(255, 9, 9), ORANGE(255, 165, 0),
    GREEN(0, 255, 0), YELLOW(255, 255, 0),
    BLUE(0, 0, 255), INDIGO(75, 0, 130), VIOLET(238, 130, 238);

    fun rgb() = (r * 256 + g) * 256 + b
}
fun main(args:Array&lt;String&gt;){
    println(Color.BLUE.rgb())
}
</code></pre><p><br></p>
<h2 id="条件和分支"><a href="#条件和分支" class="headerlink" title="条件和分支"></a>条件和分支</h2><p><br></p>
<h3 id="分支-when"><a href="#分支-when" class="headerlink" title="分支 when"></a>分支 when</h3><ul>
<li>when 是 switch 的高级替代品</li>
</ul>
<ul>
<li>when 不但是分支控制语句，还是一个表达式，因此它具有返回值,并且不需要使用break语句，同时这个例子也体现了kotlin可以在函数中声明函数</li>
</ul>
<pre><code>fun main(args: Array&lt;String&gt;) {
    fun getColorName(color: Color) =
            when (color) {
                Color.RED -&gt; &quot;Red&quot;
                Color.ORANGE -&gt; &quot;Orange&quot;
                Color.GREEN -&gt; &quot;Green&quot;
                Color.BLUE -&gt; &quot;Blue&quot;
                Color.YELLOW -&gt; &quot;Yellow&quot;
                Color.INDIGO -&gt; &quot;Indigo&quot;
                Color.VIOLET -&gt; &quot;Violet&quot;
            }

    println(getColorName(Color.BLUE))
}
</code></pre><ul>
<li>你可以使用列表的形式合并分支减少重复代码,使用import语句可以导入枚举类的所有常量，不再需要使用类名来引用</li>
</ul>
<pre><code>import com.linjiamin.kt.play.Color.\*
fun main(args: Array&lt;String&gt;) {
    fun getWarmth(color: Color) =
            when (color) {
                RED,
                ORANGE,
                YELLOW -&gt; &quot;warm&quot;

                BLUE,
                INDIGO,
                VIOLET -&gt; &quot;cold&quot;

                GREEN -&gt; &quot;neutral&quot;
            }

    println(getWarmth(Color.ORANGE))
}
</code></pre><ul>
<li>在java 12(预览版，需使用参数开启)当中已经在switch中提供了上面这两个例子中一模一样的特性，下面为java暂时不会提供的特性，估计以后也不太可能提供这样的语法糖</li>
</ul>
<p><br></p>
<h3 id="when-支持任意对象"><a href="#when-支持任意对象" class="headerlink" title="when 支持任意对象"></a>when 支持任意对象</h3><ul>
<li>在java中，case标签只支持枚举常量，字符串和数字字面量，而在 kotlin中，when支持所有对象,在下面这个例子当中，我们传入两个Color并使用setOf函数将他们合成为一个set对象，编译器能够推断出这种set共有多少种可能的情况，但注意当前版本中下面的else不是必须的，也就是说不必列出所有可能的情况</li>
</ul>
<pre><code>fun mix(c1: Color, c2: Color) =
        when (setOf(c1, c2)) {
            setOf(RED, YELLOW) -&gt; ORANGE
            setOf(YELLOW, BLUE) -&gt; GREEN
            setOf(BLUE, VIOLET) -&gt; INDIGO
            else -&gt; throw Exception(&quot;Dirty Color&quot;)
        }
fun main(args: Array&lt;String&gt;) {
    println(mix(RED,YELLOW))
}
</code></pre><p><br></p>
<h3 id="when-不带参数"><a href="#when-不带参数" class="headerlink" title="when 不带参数"></a>when 不带参数</h3><ul>
<li>在 when 当中 构造 setOf 会带来性能上的损耗，使用不带参数的when可以解决这种问题，但是可读性会下降，else同样不是必须的</li>
</ul>
<pre><code>fun mixOptimized(c1: Color, c2: Color) = when {
    (c1 == RED &amp;&amp; c2 == YELLOW) || (c1 == YELLOW &amp;&amp; c2 == RED) -&gt;
        ORANGE

    (c1 == YELLOW &amp;&amp; c2 == BLUE) || (c1 == BLUE &amp;&amp; c2 == YELLOW) -&gt;
        GREEN

    (c1 == BLUE &amp;&amp; c2 == VIOLET) || (c1 == VIOLET &amp;&amp; c2 == BLUE) -&gt;
        INDIGO

    else -&gt; throw Exception(&quot;dirty color&quot;)
}
fun main(args: Array&lt;String&gt;) {
    println(mixOptimized(RED, YELLOW))
}
</code></pre><p><br></p>
<h3 id="类型检查-is"><a href="#类型检查-is" class="headerlink" title="类型检查 is"></a>类型检查 is</h3><ul>
<li>使用 is 关键字可以进行类型检查和自动转换类型，类似java中的instanceOf，但 is 显然更加简洁</li>
</ul>
<pre><code>class Dog {
    fun bark() {
        println(&quot;bark&quot;)
    }
}
class Duck {
    fun swim() {
        println(&quot;swim&quot;)
    }
}
fun test(animal: Any) = when (animal) {
    is Dog -&gt; {
        print(&quot;I am a dog,I can &quot;)
        animal.bark()
        &quot;wan !&quot;
    }

    is Duck -&gt; {
        print(&quot;I am a duck,I can &quot;)
        animal.swim()
        &quot;ga !&quot;
    }
    else -&gt; throw IllegalArgumentException()
}
fun main(args: Array&lt;String&gt;) {
    println(test(Dog()))
    println(test(Duck()))
}
//输出
//I am a dog,I can bark
//wan !
//I am a duck,I can swim
//ga !
</code></pre><ul>
<li>注意在kotlin中，分支可以是代码块，这个时候代码块中的最后一个表达式会作为when或其他表达式的值，实际上在局部定义域中可以放入下面这样的代码，除了最后一行有可能作为表达式值利用以外，其他都是无意义的</li>
</ul>
<pre><code>1
1.0
&quot;1&quot;
true
</code></pre><p><br></p>
<h2 id="迭代和区间"><a href="#迭代和区间" class="headerlink" title="迭代和区间"></a>迭代和区间</h2><p><br></p>
<h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><ul>
<li>在 kotlin 中的 while 和 do while 结构和 java 没有任何区别，这里就不讲解了</li>
</ul>
<p><br></p>
<h3 id="区间-in"><a href="#区间-in" class="headerlink" title="区间 in"></a>区间 in</h3><ul>
<li>使用 in 可以使用在for中指示一个区间，在kotlin中区间是包含的，或者说闭合的</li>
</ul>
<pre><code>fun main(args: Array&lt;String&gt;) {
    for(i in 1..100){
        print(&quot; $i&quot;)
    }
}
</code></pre><ul>
<li>上面的操作没什么新意，看看下面这几行，kotlin 中的迭代区间不仅支持数字还支持字符，在区间可以使用downto指定方向，使用step指定步长</li>
</ul>
<pre><code>fun main(args: Array&lt;String&gt;) {
    for(c in &apos;A&apos;..&apos;Z&apos; step 3 )
        print(&quot;$c&quot;)
}
fun main(args: Array&lt;String&gt;) {
    for(i in 100 downTo 1 step 3 )
        print(&quot;$i&quot;)
}
</code></pre><ul>
<li>更多时候我们需要的是半闭合的区间，这种时候可以使用 until 关键字,下面这个例子中100不会被输出</li>
</ul>
<pre><code>fun main(args: Array&lt;String&gt;) {
    for(i in 0 until 100 )
        print(&quot; $i&quot;)
}
</code></pre><p><br></p>
<h3 id="map-迭代"><a href="#map-迭代" class="headerlink" title="map 迭代"></a>map 迭代</h3><ul>
<li>for 循环允许展开迭代中的集合的元素，例如下面这个例子中将map的键值对存储到两个独立的变量当中，在这个例子中集合看起来更像数组，是的，kotlin中可以使用中括号来代替get和put方法</li>
</ul>
<pre><code>val binReps = TreeMap&lt;Char,String&gt;()
fun test() {
    for(c in &apos;a&apos; .. &apos;f&apos;){
        val bin = Integer.toBinaryString(c.toInt())
        binReps[c] = bin
    }
    for ((letter,binary) in binReps){
        println(&quot;$letter = $binary&quot;)
    }
}
val list = arrayListOf(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;)
fun test() {
    for ((index,element) in list.withIndex()){
            println(&quot;$index = $element&quot;)
    }
}
</code></pre><p><br></p>
<h3 id="in-检查区间"><a href="#in-检查区间" class="headerlink" title="in 检查区间"></a>in 检查区间</h3><ul>
<li>使用in和!in可以检查区间中的成员，即检查某个值是否在区间当中</li>
</ul>
<pre><code>fun isLetter(c: Char) = c in &apos;a&apos;..&apos;z&apos; || c in &apos;A&apos;..&apos;z&apos;
fun isNotDigit(c: Char) = c !in &apos;0&apos;..&apos;9&apos;
fun main(args: Array&lt;String&gt;) {
    print(isLetter(&apos;c&apos;))
    print(isNotDigit(&apos;c&apos;))
}
</code></pre><p><br></p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ul>
<li>kotlin中异常与java相似，不过不必使用new关键字来创建一个异常的实例，同时throw结构是一个表达式</li>
</ul>
<pre><code>val percentage = if (number in 0..100)
    number
else throw IllegalArgumentException(&quot;a percentage value must be between 0 and 100:$number&quot;)
</code></pre><p><br></p>
<h3 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try catch finally"></a>try catch finally</h3><ul>
<li>kotlin不区分受检异常和未受检异常，因此不需要使用throw关键字来声明方法可能抛出的异常</li>
</ul>
<pre><code>fun readNumber(reader: BufferedReader) :Int? {
    try {
        val line = reader.readLine()
        return Integer.parseInt(line)

    }catch (e:NumberFormatException){
        return null
    }finally {
        reader.close()
    }
}
</code></pre><p><br></p>
<h3 id="try-表达式"><a href="#try-表达式" class="headerlink" title="try 表达式"></a>try 表达式</h3><ul>
<li>在kotlin中try和when以及if一样，引入了表达式，如果语句中包括多个表达式，那么最后一个表达式的值就是try表达式的值，如果中间抛出了异常，那么catch表达式的值就是最终的值</li>
</ul>
<pre><code>fun readNumber(reader: BufferedReader) {
    val number = try {
        Integer.parseInt(reader.readLine())
    }catch (e:NumberFormatException){
        null
    }
    print(number)
</code></pre><p><br></p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><ul>
<li>使用 xxxOf 可以直接创建集合实例，对于map这种基于键值对的集合，使用to关键字</li>
</ul>
<pre><code>var arrayList = arrayListOf(1, 2, 3)
var hashSet = hashSetOf(1, 2, 3)
var hashmap = hashMapOf(1 to &quot;one&quot;, 2 to &quot;two&quot;, 3 to &quot;3&quot;)

var list = listOf(1,2,3)
var set = setOf(1,2,3)
var map = mapOf(1 to &quot;one&quot;, 2 to &quot;two&quot;, 3 to &quot;3&quot;)
</code></pre><ul>
<li>kotlin没有使用自己的集合类，而是直接使用了java的集合类，比如arrayList，hashSet这种指定了明确类型的就对应到指定的类，list，set，map则对应到，arraylist，linkedHashSet，linkedHashMap</li>
</ul>
<pre><code>println(list.javaClass)
</code></pre><ul>
<li>除了java集合中本来提供的方法外，kotlin还添加了许多很方便的方法以供调用</li>
</ul>
<pre><code>println(list.first())
println(list.last())
println(list.max())
println(list.asReversed())
</code></pre><p><br></p>
<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p><br></p>
<h3 id="命名参数"><a href="#命名参数" class="headerlink" title="命名参数"></a>命名参数</h3><ul>
<li>使用 参数名 = 参数值 可以显式指定参数名称，让代码可读性更强，一旦一个参数使用了命名，随后的参数都需要命名，开始命名之后，参数的位置就不重要了，不需要按函数声明的顺序一样传入</li>
</ul>
<pre><code>fun main() {
    println(joinToString(
            listOf(1, 2, 3)
            , separator = &quot;,&quot;
            , postfix = &quot;]&quot;
            , prefix = &quot;[&quot;
        )
    )
}
fun &lt;T&gt; joinToString(
    collection: Collection&lt;T&gt;,
    separator: String,
    prefix: String,
    postfix: String
): String {
    val result = StringBuilder(prefix)
    for ((index, element) in collection.withIndex()) {
        if (index &gt; 0) result.append(separator)
        result.append(element)
    }
    result.append(postfix)
    return result.toString()
}
</code></pre><p><br></p>
<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><ul>
<li>使用 xxx:xxx = 默认值 可以指定参数的默认值，某参数指定默认值之后就可以不传入其值了</li>
</ul>
<pre><code>fun main() {
    println(joinToString(listOf(1, 2, 3)))
}
fun &lt;T&gt; joinToString(
    collection: Collection&lt;T&gt;,
    separator: String = &quot;,&quot;,
    prefix: String = &quot;[&quot;,
    postfix: String = &quot;]&quot;
): String {
    val result = StringBuilder(prefix)
    for ((index, element) in collection.withIndex()) {
        if (index &gt; 0) result.append(separator)
        result.append(element)
    }
    result.append(postfix)
    return result.toString()
}
</code></pre><ul>
<li>但是引入默认值之后时的函数的动态绑定会更加复杂，比如再上面的例子中我们再加入名称相同的函数，但添加一个具有默认值的参数，这个时候如果不知道内部调用规则我们无法判断哪个函数会被执行。实际上简单的函数的优先级更高，所以下面这个函数不会被调用</li>
</ul>
<pre><code>fun &lt;T&gt; joinToString(
    collection: Collection&lt;T&gt;,
    separator: String = &quot;,&quot;,
    prefix: String = &quot;[&quot;,
    postfix: String = &quot;]&quot;,
    test: Boolean = false
): String {
    return &quot;&quot;
}
</code></pre><ul>
<li>假如现在我们给原来的 joinToString 函数也添加一个带默认值的参数，这个时候编译会不通过，因为无法判断需要调用那个函数，但值得注意的是如果这个时候没有任何地方调用了这（两）个函数，那么编译是不会报错的，因为没有地方需要进行静态类型检查</li>
</ul>
<pre><code>fun main() {
    println(joinToString(listOf(1, 2, 3),prefix = &quot;[&quot;))
}
fun &lt;T&gt; joinToString(
    collection: Collection&lt;T&gt;,
    separator: String = &quot;,&quot;,
    prefix: String,
    postfix: String = &quot;]&quot;,
    test:Int = 0
): String {
    val result = StringBuilder(prefix)
    for ((index, element) in collection.withIndex()) {
        if (index &gt; 0) result.append(separator)
        result.append(element)
    }
    result.append(postfix)
    return result.toString()
}
fun &lt;T&gt; joinToString(
    collection: Collection&lt;T&gt;,
    separator: String = &quot;,&quot;,
    prefix: String = &quot;[&quot;,
    test: Boolean = false,
    postfix: String = &quot;]&quot;
): String {
    return &quot;&quot;
}
</code></pre><p><br></p>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><ul>
<li>kotlin提供java类似的可变参数，但是使用起来比java更具有弹性。使用可变参数，需要指定关键字vararg，可变参数既可以传入不定个数量的指定类型参数，也可以传入数组，传入数组时需要使用展开运算符*，展开运算符的意义是将数组中的对象展开为参数列表，因此数组的前后依然可以添加参数，比java方便 </li>
</ul>
<pre><code>fun test(vararg values:Int){
}
fun main(){
    test(1,2,3)

    var array = intArrayOf(1,2,3)
    test(0,*array,4)
}
</code></pre><p><br></p>
<h2 id="扩展功能"><a href="#扩展功能" class="headerlink" title="扩展功能"></a>扩展功能</h2><p><br></p>
<h3 id="包扩展"><a href="#包扩展" class="headerlink" title="包扩展"></a>包扩展</h3><ul>
<li>给已有的包提供扩展的函数，在一个独立的文件中将package指定为需要扩展的包即可，这时候函数不属于任何类，在需要调用时直接import即可，比起java中常见的util类，由于不用使用类名，相对简洁，同时也减少了重复功能的函数，因为这样的函数相对容易查找。</li>
</ul>
<pre><code>package strings
fun &lt;T&gt; joinToString ...
import strings.\*
//或者
import strings.joinToString
fun test() {
    joinToString()
}
</code></pre><ul>
<li>包扩展函数的实现原理是生成将函数编译为带对应静态方法的java类，类名默认为首字母大写的文件名+Kt，也可以使用 @file:JvmName(\“类名\”)进行自定义</li>
</ul>
<pre><code>//in join.kt  
JoinKt.joinToString();
</code></pre><ul>
<li>同样可以给已有的包提供扩展的属性，可以指定为val或var，get set特性的在这里依然支持，如果需要指定常量（java中的public static final）可以使用const val，const val不支持get set特性</li>
</ul>
<pre><code>package strings
var test:Int = 0
get() {
    return field
}
</code></pre><p><br></p>
<h3 id="类扩展"><a href="#类扩展" class="headerlink" title="类扩展"></a>类扩展</h3><ul>
<li>给已有的类提供扩展的函数，只是在普通的函数声明中的名称之前加上 类名. 即可，在方法体中使用this来访问对象，但依然受访问权限的限制，比如可能无法访问prviate或protected成员和函数</li>
</ul>
<pre><code>fun String.lastChar():Char = this.get(this.length-1)
//...
fun main(){
    println(&quot;a&quot;.lastChar())
}
</code></pre><ul>
<li>扩展函数和成员函数之间都可以互相调用</li>
</ul>
<pre><code>fun AAA.aTest(){
}
fun AAA.BTest(){
    this.aTest()
}
</code></pre><ul>
<li>类的扩展函数同样被编译为静态函数，只是第一个参数是类的实例，其他规则和包扩展函数一致，这里不重复</li>
</ul>
<ul>
<li>同样也可以对属性进行扩展，由于并不能实际给类添加属性，因此内部并没有实际的空间来存储这个属性的值，所以扩展属性不能初始化，也不能使用field关键字。kotlin实战中的例子不是很好，书中说不可变类型不能使用var，这非常容易让人误解，实际上不管什么类型，从语法上都是可以使用var和val的，只是对于不可变类型，一般没有可以修改属性的方法，同时内部属性通常为final，所以常规实现中我们在set函数中没有途径修改对象的属性，对于可变类型，就没有这种约束，我们可以修改它的属性。以上只针对不借用其他对象来手动存储的情况。</li>
</ul>
<pre><code>//不可变类
//val.
val String.lastChar: Char
get() = get(length-1)
//var
var String.lastChar: Char
get() = get(length-1)
set(value:Char){
//nothing we can do here
}
fun main(){
    println(&quot;a&quot;.lastChar)
}
//可变类
var StringBuilder.lastChar: Char
get() = get(length-1)
set(value:Char){
    this.setCharAt(length-1,value)
}
</code></pre><p><br></p>
<h3 id="局部函数"><a href="#局部函数" class="headerlink" title="局部函数"></a>局部函数</h3><ul>
<li>相比java，kotlin支持真正的闭包，在函数当中可以定义局部函数，局部函数可以调用外部函数中的局部变量，局部函数在扩展函数，get set函数中都适用</li>
</ul>
<pre><code>fun checkUser(user:User) {
    val throwEx = true
    fun checkEmpty(str:String){
        if(str.isEmpty()){
           if(throwEx)throw IllegalArgumentException()
        }
    }
    checkEmpty(user.name)
    checkEmpty(user.address)
}
</code></pre><p><br></p>
<h3 id="中缀和解构"><a href="#中缀和解构" class="headerlink" title="中缀和解构"></a>中缀和解构</h3><ul>
<li>infix：我们在使用map时遇到过to来构造键值对，实际上to不是一个关键字，而是一个特殊的函数，只不过需要使用中缀调用，中缀函数和类扩展函数的声明类似，只是需要在前面加入infix关键字</li>
</ul>
<pre><code>fun main() {
    val array = 1 fillTo 100
    println(array[2])
}
infix fun Int.fillTo(other: Int): Array&lt;Int&gt; {
    val result = Array(init = {0}, size = other - this)

    for (i in this until other) {
        result[i - this] = i
    }
    return result
}
</code></pre><ul>
<li>to函数的实现如下</li>
</ul>
<pre><code>infix fun Any.to(other: Int) = Pair(this,other)
</code></pre><ul>
<li>对于pair和其他key value的地方我们可以使用类似js中的解构声明来创建类实例</li>
</ul>
<pre><code>val(number,name) = 1 to &quot;one&quot;
</code></pre><p><br></p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p><br></p>
<h3 id="正则扩展"><a href="#正则扩展" class="headerlink" title="正则扩展"></a>正则扩展</h3><ul>
<li>split：string 支持和java相同的正则功能，不过对于常用的split函数，kotlin更加人性化，类似 . | 等在正则中使用的符号会被当做普通的字符来使用，同时支持可变参数</li>
</ul>
<pre><code>println(&quot;a.b.c-d|e&quot;.split(&quot;.&quot;,&quot;-&quot;,&quot;|&quot;))
</code></pre><ul>
<li>Regex：相对的如果想要使用正则字符串，则可以通过string的扩展函数toRegex，转化为正则对应的类</li>
</ul>
<pre><code>println(&quot;a.b.c-d-e&quot;.split(&quot;\\.|-&quot;.toRegex()))
</code></pre><p><br></p>
<h3 id="三重引号"><a href="#三重引号" class="headerlink" title="三重引号"></a>三重引号</h3><ul>
<li>三重引号可以用于避免转义字符，并且三重字符串中包括了缩进，可以包括换行</li>
</ul>
<pre><code>var str =
    &quot;&quot;&quot;
    .
    &quot;&quot;
    \AAAA
    [BBBBB
    ////
    ///
    //
    /
    /
    &quot;&quot;
</code></pre><ul>
<li>trimMargin：string还提供了一个很方便的trimMargin扩展函数，可以将三重字符串中的字符用空格和特殊字符串将整体内容移动到合适的位置，在需要使用的时候调用该函数进行还原</li>
</ul>
<pre><code>var str =
    &quot;&quot;&quot;
    |.
    |&quot;&quot;
    |\AAAA
    |[BBBBB
    |////
    |///
    |//
    |/
    |/
    &quot;&quot;&quot;

println(str.trimMargin(&quot;|&quot;))
</code></pre><p><br></p>
<h2 id="类和接口"><a href="#类和接口" class="headerlink" title="类和接口"></a>类和接口</h2><p><strong>kotlin的类和接口和java中的类和接口具有一定的区别，比如接口可以包含属性，嵌套类默认不是内部类，类同时提供默认了</strong></p>
<p><br></p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul>
<li>kotlin和java中接口类似，只是用冒号替代了implements和extends关键字，同时提供了override关键字，override关键字是强制要求的，如果缺少将不能通过编译</li>
</ul>
<pre><code>interface  Clickable{
    fun click()
}
class Button:Clickable{
    override fun click() = println(&quot;click&quot;)
}
</code></pre><ul>
<li>接口中支持默认函数，不同于java8的默认方法，它不需要default关键字，注意不管是在kotlin还是在java当中，如果类或接口相关联的多个接口中有相同的函数（方法），则该类或接口必须对该函数（方法）进行重写，否则编译不通过</li>
</ul>
<pre><code>interface  Clickable{
    fun click() = println(&quot;default&quot;)
}
</code></pre><p><br></p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul>
<li>open &amp; final：kotlin使用open和final关键字来表面类是否允许继承以及函数是否允许重写，若不声明则默认为final，这是基于如果没有为继承做好准备就不应该提供继承功能这种思想而设计的，子类默认还是final的，但子类中重写子父类的函数默认是open的，除非显式指定为final</li>
</ul>
<pre><code>open class Button: Clickable{
    override fun click(){}
    open fun disable(){}
}
class SubButton: Button() {
    override fun disable(){}
}
</code></pre><ul>
<li>abstract：kotlin支持和java类似的abstract关键字，没有需要特别注意的地方</li>
</ul>
<pre><code>abstract class Button: Clickable{ 
    override fun click(){}
    abstract fun animate()
}
</code></pre><p><br></p>
<h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><ul>
<li>protected：kotlin支持 public protected private 修饰符，作用与java中的类似，需要关注的是默认的修饰符是public而不是protected，并且protected的行为与java有差异，protected只提供类自身和子类范围的可见性而不提供包级别的可见性，同时限制于之前提到的protected的实现机制，扩展函数也不允许访问private和protected属性</li>
</ul>
<pre><code>open class Button : Clickable {
     protected val aProtectedField: Int = 0
}
class Test {
    fun test() {
        var obj = Button()
        //报错
        obj.aProtectedField
    }
}
</code></pre><ul>
<li>internal：另外kotlin还支持internal关键字，用于将类型限制在模块范围内，类似dart提供的特性，模块也就是idea或android studio中的module，本质是一组一起编译的文件，可以在函数或类级别上使用internal关键字</li>
</ul>
<pre><code>internal class ClassInAnotherMoudle{
    internal fun test(){
        println()
    }
}
</code></pre><p><br></p>
<h3 id="内部类-inner"><a href="#内部类-inner" class="headerlink" title="内部类 inner"></a>内部类 inner</h3><ul>
<li>inner：kotlin支持类似java中的内部类和静态内部类，但kotlin中并没有static关键字，因为在kotlin中定义在一个class中的class默认是嵌套类（类比java中的静态内部类），如果需要指定为内部类则需要使用inner关键字，嵌套类不会持有外部类的引用，因此更加有利于实现序列化和反序列化</li>
</ul>
<pre><code>class Button : Clickable {
    var aField: Int = 0

    inner class Test {

        fun test{ aField = 1 }

        fun getOuter():Button = this@Button
    }
}
</code></pre><ul>
<li>this@：在内部类获取外部类的引用不是使用java中的 类型.this 而是使用 this@ 类型</li>
</ul>
<p><br></p>
<h3 id="封装类-sealed"><a href="#封装类-sealed" class="headerlink" title="封装类 sealed"></a>封装类 sealed</h3><ul>
<li>在使用when控制分支时，如果使用了when的返回值，则需要覆盖所有分支情况，因此通常需要使用else关键字处理省缺的情况，这样在软件迭代过程中很出现漏判的情况，kotlin提供了解决这种问题的方法</li>
</ul>
<pre><code>interface Expr
class Num(val value: Int) : Expr
class Sum(val left: Expr, val right: Expr) : Expr
fun eval(e: Expr): Int = when (e) {
    is Num -&gt; e.value
    is Sum -&gt; eval(e.right) + eval(e.left)
    else -&gt; throw IllegalArgumentException()
}
</code></pre><ul>
<li>sealed：使用封装类将需要的类型全部定义为嵌套类，则不需要指定所有分支，但注意前提条件是指定为sealed的类型没有其嵌套类以外的子类，sealed可以使添加新类型之后，未经过处理的when语句报错，而不是像上一段代码一样正常通过。注意sealed修饰的类默认是open的</li>
</ul>
<pre><code>sealed class Expr{
class Num(val value: Int) : Expr()
class Sum(val left: Expr, val right: Expr) : Expr()
}
fun eval(e: Expr): Int = when (e) {
    is Expr.Num -&gt; e.value
    is Expr.Sum -&gt; eval(e.right) + eval(e.left)
}
</code></pre><p><br></p>
<h3 id="主构造函数"><a href="#主构造函数" class="headerlink" title="主构造函数"></a>主构造函数</h3><ul>
<li>在kotlin中可以使用非常简短的代码生成一个构造完整的类，下面的代码其实是主构造函数的简略形式，所有类都包含一个主构造函数</li>
</ul>
<pre><code>class User(val nickname:String)
</code></pre><ul>
<li>constructor &amp; init：上面的代码展开之后其实是这样子的，constructor用于声明一个构造函数，当用在类声明的行中说明是主构造函数，当用在类内部时则是从构造函数。init关键字类似java中的初始化块，因为在class的代码块体内只能做属性的声明和初始化语句，以及函数的声明和定义，而init闭包中可以有普通的逻辑代码，可以处理复杂的初始化情况，当然对于简单的情况则完全可以省略</li>
</ul>
<pre><code>class User constructor(nickname:String){
    val nickname:String 

    init {
        this.nickname = nickname
    }
}
//等价于
class User constructor(nickname:String){
    val nickname:String = nickname
}
//等价于
class User constructor(val nickname: String)
//等价于
class User (val nickname: String)
</code></pre><ul>
<li>和普通函数一样，构造函数也支持使用默认参数</li>
</ul>
<pre><code>class User (val nickname: String = &quot;&quot;)
</code></pre><ul>
<li>如果子类的主构造函数需要调用父类的主构造函数，则可以直接在父类声明之后调用，如果子类没有提供任何构造函数或只声明了主构造函数，则需要显示调用父类的构造函数，当一个基类没有声明任何构造函数，编译器将会自动生成一个没有参数的构造函数，即()</li>
</ul>
<pre><code>open class Person (val nickname: String){
    //...
}
class User (nickname:String): Person(nickname)
</code></pre><ul>
<li>如果希望类不能被外部实例化（用于静态工具或单例）则可以使用private关键字</li>
</ul>
<pre><code>class User private constructor() : Person()
//报错
val usr = User()
</code></pre><p><br></p>
<h3 id="从构造函数"><a href="#从构造函数" class="headerlink" title="从构造函数"></a>从构造函数</h3><ul>
<li>为了给一个类提供更多的构造函数，可以使用从构造函数，不像主构造函数，从构造函数可以定义多个，需要调用同一类的其他构造函数可以使用this关键字，同时init关键字依然可以使用</li>
</ul>
<pre><code>class User{
    init{
        //...
    }

    constructor(aInt:Int){
        //...
    }

    constructor(aInt:Int,aStr:String):this(aInt,aStr,false){
        //...
    }

    constructor(aInt:Int,aString:String,aBoolean:Boolean){
        //...
    }
}
</code></pre><ul>
<li>如果一个类具有主构造函数，则从构造函数必须调用主构造函数</li>
</ul>
<pre><code>class User(){
    constructor(aInt:Int) : this() {
        //...
    }
}
</code></pre><ul>
<li>另外一个特殊的限制是，如果父类没有无参的构造函数，则子类的从构造函数必须调用super或者this，这里的无参构造函数即可以是父类的主构造函数又可以是从构造函数</li>
</ul>
<pre><code>class NewUser: User {
    constructor(aInt:Int,aBoolean:Boolean) : super(aInt) {

        //...
    }
}
</code></pre><p><br></p>
<h3 id="接口属性"><a href="#接口属性" class="headerlink" title="接口属性"></a>接口属性</h3><ul>
<li>kotlin的接口中允许声明属性，但这种属性声明是抽象的，需要由实现类来实现，实现的方法由三种，通过主构造函数，通过属性覆盖，通过get函数，注意其中get函数的实现，不会为属性创建空间</li>
</ul>
<pre><code>interface User{
    val nickname:String
}
class User1(override var nickname:String):User
class User3 :User{
    override val nickname = &quot;&quot;
}
class User2 :User{
    override val nickname:String
    get() = &quot;&quot;
}
</code></pre><p><br></p>
<h3 id="object-函数"><a href="#object-函数" class="headerlink" title="object 函数"></a>object 函数</h3><ul>
<li>在kotlin中所有类的根类型都是Any，Any类只提供了和java中object类相似的几个方法，包括 equals，hashcode，toString，any类如下</li>
</ul>
<pre><code>package kotlin
/\*\*
 * The root of the Kotlin class hierarchy. Every Kotlin class has [Any] as a superclass.
 \*/
public open class Any {
    /**
     * Indicates whether some other object is &quot;equal to&quot; this one. Implementations must fulfil the following
     * requirements:
     *
     * * Reflexive: for any non-null value `x`, `x.equals(x)` should return true.
     * * Symmetric: for any non-null values `x` and `y`, `x.equals(y)` should return true if and only if `y.equals(x)` returns true.
     * * Transitive:  for any non-null values `x`, `y`, and `z`, if `x.equals(y)` returns true and `y.equals(z)` returns true, then `x.equals(z)` should return true.
     * * Consistent:  for any non-null values `x` and `y`, multiple invocations of `x.equals(y)` consistently return true or consistently return false, provided no information used in `equals` comparisons on the objects is modified.
     * * Never equal to null: for any non-null value `x`, `x.equals(null)` should return false.
     *
     * Read more about [equality](https://kotlinlang.org/docs/reference/equality.html) in Kotlin.
     */
    public open operator fun equals(other: Any?): Boolean

    /**
     * Returns a hash code value for the object.  The general contract of `hashCode` is:
     *
     * * Whenever it is invoked on the same object more than once, the `hashCode` method must consistently return the same integer, provided no information used in `equals` comparisons on the object is modified.
     * * If two objects are equal according to the `equals()` method, then calling the `hashCode` method on each of the two objects must produce the same integer result.
     */
    public open fun hashCode(): Int

    /**
     * Returns a string representation of the object.
     */
    public open fun toString(): String
}
</code></pre><ul>
<li>any类的方法都支持重写，同时在java中的经验同样也适用于kotlin</li>
</ul>
<pre><code>class User(val name:String){
    override fun toString():String = name
}
val a = &quot;&quot; + User(&quot;a&quot;)
</code></pre><ul>
<li>特别需要注意的是，equals和 == 在 kotlin当中是等价的，equals返回true则 == 表达式的值也是 true</li>
</ul>
<pre><code>fun main() {
    println(User(&quot;&quot;) == User(&quot;&quot;))
}
class User(val name:String){
    override fun equals(other: Any?): Boolean {
        if(other == null || other !is User){
            return false
        }
        return this.name.equals(other.name)
    }
}
</code></pre><p><br></p>
<h3 id="数据类-data"><a href="#数据类-data" class="headerlink" title="数据类 data"></a>数据类 data</h3><ul>
<li>data：java的idea通常都提供快捷生成toString，equals方法的功能，但在kotlin当中则直接提供了语言层面上的支持，使用data关键字声明为数据类即可，数据类非常适合用于我们java中的bean（pojo）类</li>
</ul>
<pre><code>fun main() {
    println(Client(&quot;&quot;,1).toString())
    println(Client(&quot;&quot;,1).hashCode())
    println(Client(&quot;&quot;,1) == Client(&quot;&quot;,1))
}
data class Client(val name:String,val postalCode:Int)
</code></pre><p><br></p>
<h3 id="类委托-by"><a href="#类委托-by" class="headerlink" title="类委托 by"></a>类委托 by</h3><ul>
<li>如果不依赖语言特性，在kotlin使用装饰器模式是想下面这个样子的，非常繁琐</li>
</ul>
<pre><code>class DelegatingCollection&lt;T&gt; : Collection&lt;T&gt; {
    private val innerList = arrayListOf&lt;T&gt;()

    override val size: Int get() = innerList.size
    override fun contains(element: T) = innerList.contains(element)
    override fun containsAll(elements: Collection&lt;T&gt;) = innerList.containsAll(elements)
    override fun isEmpty() = innerList.isEmpty()
    override fun iterator() = innerList.iterator()
}
</code></pre><ul>
<li>by：kotlin为委托提供了语言层面上的支持，需要在主构造函数中声明被委托的实例，然后使用by关键字，委托类中的函数会自动生成，如有需要可以自己重写</li>
</ul>
<pre><code>class DelegatingCollection&lt;T&gt; (
    innerList:Collection&lt;T&gt; = ArrayList()
) : Collection&lt;T&gt; by innerList{
    override fun isEmpty(): Boolean {
        // ...
    }
}
</code></pre><p><br></p>
<h3 id="对象类声明-object"><a href="#对象类声明-object" class="headerlink" title="对象类声明 object"></a>对象类声明 object</h3><ul>
<li>object：object关键字用于在声明类的同时创建唯一实例，原本在class内部中的语法都适用，在顶层object声明对象可以像其他顶层对象一样访问</li>
</ul>
<pre><code>fun main() {
    Singleleton.meth()
    Singleleton.aInt = 1
}
object Singleleton {
    var aInt: Int = 1

    fun meth(){
        println(aInt)
    }
}
</code></pre><ul>
<li>object声明也支持嵌套类，访问时需要加上类名</li>
</ul>
<pre><code>fun main() {
    val persons = listOf(Person(&quot;bob&quot;),Person(&quot;Alice&quot;))
    persons.sortedWith(Person.NameComparator)
}
data class Person(val name:String){
    object NameComparator : Comparator&lt;Person&gt;{
        override fun compare(o1: Person?, o2: Person?) 
                = o1.name.compareTo(o2.name)
    }
}
</code></pre><p><br></p>
<h3 id="伴生对象-companion"><a href="#伴生对象-companion" class="headerlink" title="伴生对象 companion"></a>伴生对象 companion</h3><ul>
<li>引用嵌套类对象声明，看起来像在引用一个类的静态成员，但是kotlin中类并不能拥有静态成员，实际上kotlin也没有static关键字，但可以使用伴生对象实现类似的语法功能</li>
</ul>
<pre><code>fun main() {
    Person.fromJson(&quot;{ ... }&quot;)
}

class Person(val name:String){
    companion object{
        fun fromJson(jsonText:String) : Person = 
    }
}
</code></pre><ul>
<li>伴生对象可以有可选的命名，默认命名为Companion，调用时命名也是可选的</li>
</ul>
<pre><code>class Person(val name:String){
    companion object Loader{
        var aInt:Int = 1
        fun fromJson(jsonText:String) : Person = Person(&quot;&quot;)
    }
}
</code></pre><ul>
<li>伴生对象可以有父类或实现接口，同时可以使用其命名添加扩展函数</li>
</ul>
<pre><code>class Person(val name:String){
    companion object: Test() {
        var aInt:Int = 1
        fun fromJson(jsonText:String) : Person = Person(&quot;&quot;)
    }
}
fun Person.Companion.meth(){
}
</code></pre><ul>
<li>object还可以用于声明匿名内部类，与java不同函数中的局部变量可以被匿名内部类访问和修改，不需要被final限制</li>
</ul>
<pre><code>window.addMouseListener(object : MouseAdapter(){
    override fun mouseClicked(e: MouseEvent?) {

    }

    override fun mouseEntered(e: MouseEvent?) {

    }
})

var count = 0
val listener = object : MouseAdapter(){
    override fun mouseClicked(e: MouseEvent?) {
        count ++
    }

    override fun mouseEntered(e: MouseEvent?) {

    }
}

window.addMouseListener(listener)
</code></pre><p><br></p>
<h2 id="lambda和序列"><a href="#lambda和序列" class="headerlink" title="lambda和序列"></a>lambda和序列</h2><p><br></p>
<h3 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h3><ul>
<li>lambda表达式一般由 花括号 参数声明 箭头 一般表达式 组成，在kotlin当中lambda表达式可以作为变量存储和传递</li>
</ul>
<pre><code>fun main() {
    var lambda = { x:Int, y:Int -&gt; x + y}
}
</code></pre><ul>
<li>调用值：lambda表达式可以使用括号调用，也可以使用run函数调用，后者只支持无参的lambda表达式，当lambda表达式被调用时，花括号中最后一个表达式的值就是整个lambda表达式的值</li>
</ul>
<pre><code>fun main() {
    val result = { x:Int, y:Int -&gt; x + y}(1,1)
    //或
    val lambda = { x:Int, y:Int -&gt; x + y}
    lambda(1,1)

    run { println(1) }
}
</code></pre><ul>
<li>简化：kotlin中使用lambda时支持一定的简化，表达式是最后一个参数，花括号可以移动到小括号的后面，当表达式是唯一参数时小括号可以省略，同时lambda支持类型推断，无需指明类型，而且如果表达式是唯一参数那么可以直接使用默认的参数命名it。注意如果表达式是用变量存储的话，类型声明就不可以省略，因为无法推断</li>
</ul>
<pre><code>//最完整的写法  
var oldest = people.maxBy({ p: Person -\&gt; p.age })
//1.因为表达式是最后一个参数
var oldest = people.maxBy(){ p: Person -\&gt; p.age }
//2.因为表达式是唯一的参数
var oldest = people.maxBy{ p: Person -\&gt; p.age }
//3.因为可以进行类型推断
var oldest = people.maxBy{ p -\&gt; p.age }
//4.编译器提供默认命名参数it，因此命名也不需要
var oldest = people.maxBy{ it.age }
</code></pre><ul>
<li>lambda表达式中可以访问函数中的非final变量，实现的机制是将变量封装到包装器中，而包装器是final的，注意在异步调用的情况下，局部变量的修改只会在lambda执行时被修改，此时函数可能已经返回，不可能返回一个未来的值</li>
</ul>
<pre><code>fun printProblemCounts(response: Collection&lt;String&gt;){
    var clientErrors =0
    var serverErrors =0
    response.forEach{
        if(it.startsWith(&quot;4&quot;)){
            clientErrors++
        }else if(it.startsWith(&quot;5&quot;)){
            serverErrors++
        }
    }

    println(&quot;$clientErrors $serverErrors&quot;)
}
</code></pre><p><br></p>
<h3 id="成员引用"><a href="#成员引用" class="headerlink" title="成员引用 ::"></a>成员引用 ::</h3><ul>
<li>kotlin可以像java一样使用 :: 将函数转换为lambda表达式，如果使用的是顶层函数，则 :: 前面不需要类名</li>
</ul>
<pre><code>data class Person(val name: String, val age: Int)
var getAge = Person::age
fun main() {
    val people = listOf(Person(&quot;Alice&quot;, 29), Person(&quot;Bob&quot;, 31))

    var oldest = people.maxBy(getAge)
}
</code></pre><ul>
<li>如果需要将构造函数转换为lambda表达式，则使用 ::类名</li>
</ul>
<pre><code>var creator = ::Person
var obj = creator(&quot;&quot;,0)
</code></pre><p><br></p>
<h3 id="SAM-构造方法"><a href="#SAM-构造方法" class="headerlink" title="SAM 构造方法"></a>SAM 构造方法</h3><ul>
<li>SAM构造方法允许我们使用lambda表达式来实现函数式接口，也就是Runnable和OnClickListener这样的接口，这样可以实现实例重用</li>
</ul>
<pre><code>fun main() {
    runnable.run()
}
val runnable = Runnable {
    println(&quot;run&quot;)
}
</code></pre><ul>
<li>需要注意的是SAM构造方法创建对象和使用object声明创建对象是有区别的，因为普通lambda本质上被视为代码块，因此普通lambda表达式内部不允许使用this关键字，做不到传出自身的引用，如果需要使用this，请改用object声明。另外在扩展函数时使用的lambda是一种特殊的情况，被称为带接受者的lambda，我们将在后面讲解这种情况</li>
</ul>
<p><br></p>
<h3 id="带接受者的lambda"><a href="#带接受者的lambda" class="headerlink" title="带接受者的lambda"></a>带接受者的lambda</h3><ul>
<li>之前我们看过如何静态地声明类扩展函数，也可以动态地实现这种效果，下面动态声明了一个类的扩展函数并调用，该扩展函数的声明使用到了一种特殊的lambda，它是带接受者（也就是this）的，表达式中的this与静态声明的扩展函数中的this一致，指向的是被扩展的类的实例，可以省略。这个特性看起来有点多余，但它可以实现一些很重要的功能</li>
</ul>
<pre><code>fun main() {

    val newMeth:AClass.()-&gt;Boolean = {
        this.oldMeth()
        println(&quot;newMeth&quot;)
        true
    }
    val t = AClass().newMeth()
}

class AClass{

    fun oldMeth(){
        println(&quot;oldMeth&quot;)
    }
}
</code></pre><p><br></p>
<h3 id="with"><a href="#with" class="headerlink" title="with"></a>with</h3><ul>
<li>有时候我们会经常对同一个对象进行操作，这个时候需要不但重复变量的名称，这时代码显得臃肿，不直观，特别是在变量名比较长的情况下</li>
</ul>
<pre><code>fun main() {

    println(alphabet())
}

fun alphabet():String{

    val result = StringBuilder()
    for(letter in &apos;A&apos; .. &apos;Z&apos;){
        result.append(letter)
    }

    result.append(&quot;\n now i know the alphabet&quot;)
    return result.toString()
}
</code></pre><ul>
<li>with：使用with可以对上述情况进行简化，with是一个顶层函数，而不是内置在语法中的特性</li>
</ul>
<pre><code>fun alphabet():String = with(StringBuilder()){
    for(letter in &apos;A&apos; .. &apos;Z&apos;){
        append(letter)
    }

    append(&quot;\n now I know the alphabet&quot;)
    toString()
}
</code></pre><ul>
<li>with的实现基于带接受者的lambda，从函数声明可以看出这一点</li>
</ul>
<pre><code>public inline fun \&lt;T, R\&gt; with(receiver: T, block: T.() -\&gt; R): R 
</code></pre><p><br></p>
<h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><ul>
<li>apply与with类似，只是apply返回的是被用于函数扩展的实例，这对于初始化对象的情况非常合适</li>
</ul>
<pre><code>fun alphabet()=StringBuilder().apply { 
    for (letter in &apos;A&apos; .. &apos;Z&apos;){
        append(letter)
    }
    append(&quot;\n now I know the alphabet&quot;)
}.toString()
</code></pre><p><br></p>
<h3 id="集合函数式api"><a href="#集合函数式api" class="headerlink" title="集合函数式api"></a>集合函数式api</h3><ul>
<li>filter，对集合中满足判断式的元素进行过滤得到新集合</li>
</ul>
<pre><code>val numbers = listOf(1,2,3,4,5,6,7,8,9)
println(numbers.filter { it % 2 == 0 })

val people = listOf(Person(&quot;Alice&quot;, 29), Person(&quot;Bob&quot;, 31))
println(people.filter{ it.age&gt;30 })
</code></pre><ul>
<li>map，将集合的元素进行转换得到新集合，元素类型可以改变</li>
</ul>
<pre><code>val numbers = listOf(1, 2, 3, 4, 5, 6, 7, 8, 9)
println(numbers.map { it * it })

val people = listOf(Person(&quot;Alice&quot;, 29), Person(&quot;Bob&quot;, 31))
println(people.map(Person::name))
println(
    people
        .filter { it.age &gt; 30 }
        .map(Person::name)
)
</code></pre><ul>
<li>all，判断是否所有元素都满足某个条件</li>
</ul>
<pre><code>val people = listOf(Person(&quot;Alice&quot;, 27), Person(&quot;bob&quot;, 31))
println(people.all { it.age &gt; 30 })
</code></pre><ul>
<li>any，判断是否存在符合条件的元素</li>
</ul>
<pre><code>val people = listOf(Person(&quot;Alice&quot;, 27), Person(&quot;bob&quot;, 31))
println(people.any { it.age &gt; 30 })
</code></pre><ul>
<li>count，计算符合条件的元素个数</li>
</ul>
<pre><code>val people = listOf(Person(&quot;Alice&quot;, 27), Person(&quot;bob&quot;, 31))
println(people.count { it.age &gt; 30 })
</code></pre><ul>
<li>find，查找符合条件的第一个元素</li>
</ul>
<pre><code>val people = listOf(Person(&quot;Alice&quot;, 27), Person(&quot;bob&quot;, 31))
val person = people.find { it.age &gt; 30 }
</code></pre><ul>
<li>groupBy，将符合元素的条件进行分组，返回一个map，元素依然还是集合</li>
</ul>
<pre><code>val people = listOf(
    Person(&quot;Alice&quot;, 27)
    , Person(&quot;bob&quot;, 31)
    , Person(&quot;Carol&quot;, 31)
)
val map = people.groupBy(getAge)
println(map)
</code></pre><ul>
<li>flatten，用于将多个集合合并成为一个</li>
</ul>
<pre><code>    val listOfList = listOf(
        listOf(1, 2, 3)
        , listOf(4, 5, 6)
        , listOf(7, 8, 9)
    )

    println(listOfList.flatten())
//输出 [1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre><ul>
<li>flatMap，用于将集合中的元素通过某种方式构造集合，然后将每个元素得到的新结合合并，通常用于将一个集合装换为其他内容的集合</li>
</ul>
<pre><code>val list = listOf(&quot;123&quot;,&quot;45&quot;,&quot;6789&quot;)
println(list.flatMap { it.toList() })
</code></pre><p><br></p>
<h3 id="序列-sequence"><a href="#序列-sequence" class="headerlink" title="序列 sequence"></a>序列 sequence</h3><ul>
<li>类似filter和map的操作都会返回一个新的集合，如果较多或者操作或者元素较多，则会带来不必要的消耗</li>
</ul>
<pre><code>people.map(Person::name)
    .filter { it.startsWith(&quot;A&quot;) }
</code></pre><ul>
<li>asSequence：可以使用asSequence将操作变成序列，对序列进行链式操作不会创建额外的集合来保存过程中产生的中间结果，序列的操作分为中间操作和末端操作，中间操作返回的是另一个序列，末端操作返回的是一个结果，中间操作都是惰性的。如下面的map和filter就是中间操作，而toList就是末端操作</li>
</ul>
<pre><code>people.asSequence()
    .map(Person::name)
    .filter { it.startsWith(&quot;A&quot;) }
    .toList()
</code></pre><ul>
<li>在不调用末端操作时中间操作是不会执行的</li>
</ul>
<pre><code>//没有输出  
listOf(1, 2, 3, 4).asSequence()
        .map { println(&quot;do map&quot;);it * it }
        .filter { println(&quot;do filter&quot;);it % 2 == 0 }
</code></pre><ul>
<li>惰性还有一个好处是，序列会依次对每个元素进行所有的操作，对于find这样并非需要访问所有元素的末端操作，则可以忽略不需要访问的元素，另外一些中间操作可以作为后续操作的先决条件，比如filter这样的操作优先执行可以减少操作的总次数</li>
</ul>
<pre><code>listOf(1, 2, 3, 4).asSequence()
    .map { println(&quot;do map&quot;);it * it }
    .filter { println(&quot;do filter&quot;);it % 2 == 0 }
    .find { it == 4 }
</code></pre><ul>
<li>generateSequence：使用generateSequence可以不依赖集合类来创建一个序列，创建一个序列需要一个称谓seed的起始值（可以直接传入其值，也可以传入一个lambda表达式），还需要一个用于获取下一个元素的lambda表达式</li>
</ul>
<pre><code>println(
        //或者generateSequence({0}, { it + 1 })
    generateSequence(0) { it + 1 }
        .takeWhile { it &lt; 100 }
        .sum()
)
</code></pre><p><br></p>
<h2 id="可空性"><a href="#可空性" class="headerlink" title="可空性"></a>可空性</h2><p><br></p>
<h3 id="非空类型"><a href="#非空类型" class="headerlink" title="非空类型"></a>非空类型</h3><ul>
<li>kotlin当中null也作为类型检查的一部分，默认情况下，所有类型都是非空的，所以当显式赋值为null时会报错</li>
</ul>
<pre><code>    var a:String
//Error:(14, 9) Kotlin: Null can not be a value of a non-null type String
a = null 
</code></pre><ul>
<li>对于函数调用也是如此，无法将null传给普通声明的参数</li>
</ul>
<pre><code>fun main() {
    strLen(null)
    //Error:(9, 12) Kotlin: Null can not be a value of a non-null type String
}
fun strLen(s:String) = s.length
</code></pre><p><br></p>
<h3 id="可空类型"><a href="#可空类型" class="headerlink" title="可空类型"></a>可空类型</h3><ul>
<li>可空类型：如果需要赋值null时，可以使用 ？进行可空类型声明</li>
</ul>
<pre><code>var a:String?
fun main() {
    strLen(null)
}
fun strLen(s:String?) = s?.length
</code></pre><ul>
<li>可空类型并不是简单地可以存储null值而已，因为编译器已经知道了变量很可能为空，因此可以做更严格的编译检查</li>
</ul>
<ul>
<li>不能直接调用其函数</li>
</ul>
<pre><code>fun strLenSafe(s:String?) = s.length
</code></pre><ul>
<li>不能直接赋值给非空类型</li>
</ul>
<pre><code>val x: String? = null
val y: String = x
</code></pre><ul>
<li>不能直接传给非空参数</li>
</ul>
<pre><code>fun main() {

    val x: String? = null
    strLen(x)
}

fun strLen(s:String)=s.length
</code></pre><p><br></p>
<h3 id="安全调用运算符"><a href="#安全调用运算符" class="headerlink" title="安全调用运算符 ?."></a>安全调用运算符 ?.</h3><ul>
<li>我们需要一些特定的操作来使得上面对可空类型的调用可以工作，最直接的是添加判空，但这样的语句非常啰嗦，kotlin中可以使用安全调用运算符来简化这种语句</li>
</ul>
<pre><code>val x: String? = null
if (x != null) {
    strLen(x)
}
</code></pre><ul>
<li>?.: 安全调用运算符，用于调用可空类型的函数或获取属性（虽然非空类型也可以使用），可以理解为上面判空形式的简写，但注意安全调用在对象为null时，表达式的值也为null</li>
</ul>
<pre><code>fun main() {
    printAllCaps(&quot;abc&quot;)
    printAllCaps(null)
}

fun printAllCaps(s:String?){
    val allCaps: String? = s?.toUpperCase()
    println(allCaps)
}
</code></pre><ul>
<li>安全调用运算符也可以用于获取属性</li>
</ul>
<pre><code>    person.manager?.name

class Employee(val name: String, val manager: Employee?)
</code></pre><ul>
<li>安全调用运算符可以嵌套使用</li>
</ul>
<pre><code>person.manager?.manager?.manager?.manager
</code></pre><p><br></p>
<h3 id="Elvis-运算符"><a href="#Elvis-运算符" class="headerlink" title="Elvis 运算符: ?:"></a>Elvis 运算符: ?:</h3><ul>
<li>Elvis: 用于赋值时为null提供可用的替换值，即如果符号左边的参数不为null，则使用左边的参数作为表达式值，否则使用右边的参数作为表达式值</li>
</ul>
<pre><code>fun foo(s:String?){
    val t:String = s?:&quot;&quot;
}
</code></pre><ul>
<li>Elvis可以像上面一样将可空类型转换成非空类型，在这种场景之下，替换值不可设置为null，当然如果是付给可空类型则可用使用null作为替换值，但这样做并没有什么意义</li>
</ul>
<pre><code>val t:String = s?:null //报错
val t:String? = s?:null//正确
</code></pre><p><br></p>
<h3 id="安全转换-as"><a href="#安全转换-as" class="headerlink" title="安全转换 as?"></a>安全转换 as?</h3><ul>
<li>as?：安全转换运算符，类似于is和as的结合，用于类型检测，如果类似匹配，返回原值并且自动进行as操作，否则返回null，注意通过与Elvis结合使用，我们还可以在类型不对时直接返回</li>
</ul>
<pre><code>fun isEmployee(obj: Any?):Boolean {

//或 val e = obj as? Employee?: Employee(&quot;&quot;,null)
    val e = obj as?Employee?: return false 
//as? 匹配成功之后即可以调用对应类型的属性和函数
    println(e.name)
    return true
}
</code></pre><p><br></p>
<h3 id="非空断言"><a href="#非空断言" class="headerlink" title="非空断言 !!"></a>非空断言 !!</h3><ul>
<li>!!：非空断言，顾名思义用于断言对象不是null，如果对象为null，则直接抛出nullpointerException，否则返回该对象，通常不建议使用非空断言，除非只是在开发阶段做测试调试</li>
</ul>
<pre><code>fun main() {
    test(null)
}

fun test(obj: Any?){
    obj!!
    //或者
    //val a = obj!!
}
</code></pre><p><br></p>
<h3 id="let函数"><a href="#let函数" class="headerlink" title="let函数"></a>let函数</h3><ul>
<li>let: 用于将对象传递到lambda函数当中，let与安全调用运算符一起使用，可以很方便地对一个可空类型进行频繁的操作</li>
</ul>
<pre><code>fun main() {
    val obj:String? = null
    obj?.let { send(it) }

    val map:HashMap&lt;String,String&gt;? = null
    map?.let { 
        it.clear()
        it.put(&quot;&quot;,&quot;&quot;)
    }
}

fun send(obj:String){
}
</code></pre><p><br></p>
<h3 id="延迟初始化-lateinit"><a href="#延迟初始化-lateinit" class="headerlink" title="延迟初始化 lateinit"></a>延迟初始化 lateinit</h3><ul>
<li>lateinit：用于进行延迟初始化，由于通常情况下kotlin要求所有字段在构造阶段初始化，有些需要在其他方法中初始化的字段，虽然我们可以使用可空类型赋值为null，但这样每次访问时就需要使用?或!!等操作，而使用 lateinit 则可以直接使用非空类型并且不需要马上初始化</li>
</ul>
<pre><code>class Test{
    lateinit var str:String
}

fun main() {
    val test = Test()
    //test.str = &quot;&quot;
    //Exception in thread &quot;main&quot; kotlin.UninitializedPropertyAccessException
    println(test.str)
}
</code></pre><ul>
<li>需要注意的是lateinit的字段在初始化前是不可以访问的，甚至不可以对他进行判空，只要访问了，就会抛出异常</li>
</ul>
<p><br></p>
<h3 id="可空类性扩展函数"><a href="#可空类性扩展函数" class="headerlink" title="可空类性扩展函数"></a>可空类性扩展函数</h3><ul>
<li>可以为可空类型添加特殊的扩展函数，这种函数在对象为空的情况下依然可以直接调用，而不需要添加安全调用运算符和其他操作</li>
</ul>
<pre><code>fun main() {
    val str:String? = null

    println(str.isNullOrBlank())
}

fun String?.isNullOrBlank():Boolean = 
    this == null || this.isBlank()
</code></pre><p><br></p>
<h2 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h2><p><br></p>
<h3 id="平台类型"><a href="#平台类型" class="headerlink" title="平台类型"></a>平台类型</h3><ul>
<li>平台类型指java当中不知道是否为空的类型，这个时候kotlin允许使用可空也允许使用非空类型来指向其实例，这种情况下，如果调用了空对象的属性或函数，则会抛出nullpointer异常</li>
</ul>
<pre><code>val a = Person().getName()
println(a.length) //nullpointer
</code></pre><ul>
<li>在继承java类时，重写方法可以将参数指定为可空或非空，原理类似上文</li>
</ul>
<p><br></p>
<h3 id="可空基本类型"><a href="#可空基本类型" class="headerlink" title="可空基本类型"></a>可空基本类型</h3><ul>
<li>kotlin当中不区分基本类型和包装类型，统一使用一种类型，同时为这些类型提供了很多便利的函数，大多数情况下kotlin当中的基本类型都会被编译成java中的基本类型，因此不用担心效率问题</li>
</ul>
<pre><code>val a = 10000
val b = a.coerceIn(0,1)
</code></pre><ul>
<li>不过当使用可空类型时就不可以用java中的基本类型来表示了，因为需要存储null值，泛型也是如此。注意对于可空类型，只有确定其为非空之后才可以</li>
</ul>
<p><br></p>
<h3 id="数字转换"><a href="#数字转换" class="headerlink" title="数字转换"></a>数字转换</h3><ul>
<li>在kotlin当中基本类型之间赋值不会自动进行类型转换，而需要调用转换函数</li>
</ul>
<pre><code>val i = 1
val l:Long = i

val l:Long = i.toLong()
</code></pre><ul>
<li>对于参数类型也是如此需要手动调用转换函数</li>
</ul>
<pre><code>val x = 1
println(x.toLong() in listOf(1L, 2L, 3L))
</code></pre><ul>
<li>当表达式具有多种类型时，则编译器则会进行自动转换，同时由于我们使用类型推断，通常不用太关心这样的细节</li>
</ul>
<pre><code>val x:Int = 1
val y:Long = 1
val z = x+y
</code></pre><ul>
<li>字面常量支持使用下划线</li>
</ul>
<pre><code>fun main() {
    val x = 1_100_111
    println(x)
}
</code></pre><p><br></p>
<h3 id="unit类型"><a href="#unit类型" class="headerlink" title="unit类型"></a>unit类型</h3><ul>
<li>Unit：类似java的void，kotlin当中如果一个函数没有需要显式指明的返回值，则使用Unit声明，如果我们显式地指明它们则是下面这样的，Unit也是一种实际的类型，但它只有一个唯一的实例 Unit，这就是它名称的由来</li>
</ul>
<pre><code>fun main() {
    val unit = test()
}

fun test():Unit{
    println(&quot;1&quot;)
    return Unit
}
</code></pre><ul>
<li>像void一样，编译器会自动为我们添加返回语句</li>
</ul>
<pre><code>fun main() {
    test()
}

fun test() {
    println(&quot;1&quot;)
}
</code></pre><p><br></p>
<h3 id="nothing"><a href="#nothing" class="headerlink" title="nothing"></a>nothing</h3><ul>
<li>Nothing：用于真正不需要返回值的函数，这种函数不需要返回值的原因是无法返回，函数内部不能使用return关键字，只有函数中有抛出异常或者死循环才能编译通过</li>
</ul>
<pre><code>fun fail(message: String): Nothing {

   throw IllegalStateException(message)
}

fun fail(message: String): Nothing {

    while (true){
    }
}
</code></pre><ul>
<li>可以尝试接受这种返回值，但实际上函数永远不会返回</li>
</ul>
<pre><code>val a :Nothing = fail(&quot;&quot;)
</code></pre><ul>
<li>一种很方便的用法是在Elvis运算符中</li>
</ul>
<pre><code>fun fail(message: String): Nothing {

    throw IllegalStateException(message)
}

fun main() {

    val str:String? = null
    val address = str?: fail(&quot;no address&quot;)
}
</code></pre><p><br></p>
<h2 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h2><ul>
<li>kotlin中的文档注释和java中的文档注释一样以/和两个星号开头，差别在于kotlin中的文档注释使用markdown语法而不是html，另外引用声明使用中括号表示</li>
</ul>
<p><br><br><strong>本篇未完</strong></p>

    

    
</div>


                

                <!-- Post Comments -->
                
                    
                
            </div>

            <!-- Post Prev & Next Nav -->
            <nav class="material-nav mdl-color-text--grey-50 mdl-cell mdl-cell--12-col">
    <!-- Prev Nav -->
    

    <!-- Section Spacer -->
    <div class="section-spacer"></div>

    <!-- Next Nav -->
    
        <a href="/2019/04/17/BugFlutter/" id="post_nav-older" class="next-content">
            旧篇
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                <i class="material-icons">arrow_forward</i>
            </button>
        </a>
    
</nav>

        </div>
    </div>



                    
                        <!-- Overlay For Active Sidebar -->
<div class="sidebar-overlay"></div>

<!-- Material sidebar -->
<aside id="sidebar" class="sidebar sidebar-colored sidebar-fixed-left" role="navigation">
    <div id="sidebar-main">
        <!-- Sidebar Header -->
        <div class="sidebar-header header-cover" style="background-image: url(/img/sidebar_header.jpg);">
    <!-- Top bar -->
    <div class="top-bar"></div>

    <!-- Sidebar toggle button -->
    <button type="button" class="sidebar-toggle mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon" style="display: initial;" data-upgraded=",MaterialButton,MaterialRipple">
        <i class="material-icons">clear_all</i>
        <span class="mdl-button__ripple-container">
            <span class="mdl-ripple">
            </span>
        </span>
    </button>

    <!-- Sidebar Avatar -->
    <div class="sidebar-image">
        <img src="/img/avatar.png" alt="Albert Humbert's avatar">
    </div>

    <!-- Sidebar Email -->
    <a data-toggle="dropdown" class="sidebar-brand" href="#settings-dropdown">
        709913148@qq.com
        <b class="caret"></b>
    </a>
</div>


        <!-- Sidebar Navigation  -->
        <ul class="nav sidebar-nav">
    <!-- User dropdown  -->
    <li class="dropdown">
        <ul id="settings-dropdown" class="dropdown-menu">
            
                <li>
                    <a href="#" target="_blank" title="Email Me">
                        
                            <i class="material-icons sidebar-material-icons sidebar-indent-left1pc-element">email</i>
                        
                        Email Me
                    </a>
                </li>
            
        </ul>
    </li>

    <!-- Homepage -->
    
        <li id="sidebar-first-li">
            <a href="/">
                
                    <i class="material-icons sidebar-material-icons">home</i>
                
                主页
            </a>
        </li>
        
    

    <!-- Archives  -->
    
        <li class="dropdown">
            <a href="#" class="ripple-effect dropdown-toggle" data-toggle="dropdown">
                
                    <i class="material-icons sidebar-material-icons">inbox</i>
                
                    归档
                <b class="caret"></b>
            </a>
            <ul class="dropdown-menu">
            <li>
                <a class="sidebar_archives-link" href="/archives/2019/04/">四月 2019<span class="sidebar_archives-count">3</span></a></li><li><a class="sidebar_archives-link" href="/archives/2019/03/">三月 2019<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2019/01/">一月 2019<span class="sidebar_archives-count">16</span></a></li><li><a class="sidebar_archives-link" href="/archives/2018/12/">十二月 2018<span class="sidebar_archives-count">5</span></a></li><li><a class="sidebar_archives-link" href="/archives/2018/11/">十一月 2018<span class="sidebar_archives-count">14</span></a></li><li><a class="sidebar_archives-link" href="/archives/2018/10/">十月 2018<span class="sidebar_archives-count">9</span></a></li><li><a class="sidebar_archives-link" href="/archives/2018/09/">九月 2018<span class="sidebar_archives-count">7</span></a></li><li><a class="sidebar_archives-link" href="/archives/2018/05/">五月 2018<span class="sidebar_archives-count">4</span></a></li><li><a class="sidebar_archives-link" href="/archives/2018/03/">三月 2018<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/12/">十二月 2017<span class="sidebar_archives-count">2</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/11/">十一月 2017<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/09/">九月 2017<span class="sidebar_archives-count">2</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/08/">八月 2017<span class="sidebar_archives-count">6</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/07/">七月 2017<span class="sidebar_archives-count">4</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/05/">五月 2017<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/02/">二月 2017<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2016/11/">十一月 2016<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2016/10/">十月 2016<span class="sidebar_archives-count">1</span></a>
            </ul>
        </li>
        
    

    <!-- Categories  -->
    

    <!-- Pages  -->
    
        <li>
            <a href="/about" title="关于我">
                
                    <i class="material-icons sidebar-material-icons">person</i>
                
                关于我
            </a>
        </li>
        
    
        <li>
            <a href="/tags" title="标签索引">
                
                    <i class="material-icons sidebar-material-icons">inbox</i>
                
                标签索引
            </a>
        </li>
        
    
        <li>
            <a href="/links" title="友情链接">
                
                    <i class="material-icons sidebar-material-icons">inbox</i>
                
                友情链接
            </a>
        </li>
        
    
        <li>
            <a href="/whatever" title="Writers &amp; Weirdos">
                
                    <i class="material-icons sidebar-material-icons">inbox</i>
                
                Writers &amp; Weirdos
            </a>
        </li>
        
    

    <!-- Article Number  -->
    
</ul>


        <!-- Sidebar Footer -->
        <!--
I'm glad you use this theme, the development is no so easy, I hope you can keep the copyright, I will thank you so much.
If you still want to delete the copyrights, could you still retain the first one? Which namely "Theme Material"
It will not impact the appearance and can give developers a lot of support :)

很高兴您使用并喜欢该主题，开发不易 十分谢谢与希望您可以保留一下版权声明。
如果您仍然想删除的话 能否只保留第一项呢？即 "Theme Material"
它不会影响美观并可以给开发者很大的支持和动力。 :)
-->

<!-- Sidebar Divider -->

    <div class="sidebar-divider"></div>


<!-- Theme Material -->

    <a href="https://github.com/viosey/hexo-theme-material"  class="sidebar-footer-text-a" target="_blank">
        <div class="sidebar-text mdl-button mdl-js-button mdl-js-ripple-effect sidebar-footer-text-div" data-upgraded=",MaterialButton,MaterialRipple">
            主题 - Material
            <span class="sidebar-badge badge-circle">i</span>
        </div>
    </a>


<!-- Help & Support -->
<!--

-->

<!-- Feedback -->
<!--

-->

<!-- About Theme -->
<!--

-->

    </div>

    <!-- Sidebar Image -->
    

</aside>

                    

                    
                        <!-- Footer Top Button -->
                        <div id="back-to-top" class="toTop-wrap">
    <a href="#top" class="toTop">
        <i class="material-icons footer_top-i">expand_less</i>
    </a>
</div>

                    

                    <!--Footer-->
<footer class="mdl-mini-footer" id="bottom">
    
        <!-- Paradox Footer Left Section -->
        <div class="mdl-mini-footer--left-section sns-list">
    <!-- Twitter -->
    
        <a href="https://twitter.com/twitter" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-twitter">
                <span class="visuallyhidden">Twitter</span>
            </button><!--
     --></a>
    

    <!-- Facebook -->
    
        <a href="https://www.facebook.com/facebook" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-facebook">
                <span class="visuallyhidden">Facebook</span>
            </button><!--
     --></a>
    

    <!-- Google + -->
    
        <a href="https://www.google.com/" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-gplus">
                <span class="visuallyhidden">Google Plus</span>
            </button><!--
     --></a>
    

    <!-- Weibo -->
    

    <!-- Instagram -->
    

    <!-- Tumblr -->
    

    <!-- Github -->
    

    <!-- LinkedIn -->
    

    <!-- Zhihu -->
    

    <!-- Bilibili -->
    

    <!-- Telegram -->
    
</div>


        <!--Copyright-->
        <div id="copyright">
            Copyright&nbsp;©&nbsp;2016&nbsp;-<script type="text/javascript">var fd = new Date();document.write("&nbsp;" + fd.getFullYear() + "&nbsp;");</script>Albert's Blog
        </div>

        <!-- Paradox Footer Right Section -->

        <!--
        I am glad you use this theme, the development is no so easy, I hope you can keep the copyright.
        It will not impact the appearance and can give developers a lot of support :)

        很高兴您使用该主题，开发不易，希望您可以保留一下版权声明。
        它不会影响美观并可以给开发者很大的支持。 :)
        -->

        <div class="mdl-mini-footer--right-section">
            <div>
                <div class="footer-develop-div">Powered by <a href="https://hexo.io" target="_blank" class="footer-develop-a">Hexo</a></div>
                <div class="footer-develop-div">Theme - <a href="https://github.com/viosey/hexo-theme-material" target="_blank" class="footer-develop-a">Material</a></div>
            </div>
        </div>
    
</footer>


                    <!-- Import File -->


    <script>lsloader.load("js/lazyload.min.js","/js/lazyload.min.js?1BcfzuNXqV+ntF6gq+5X3Q==")</script>
    <script>lsloader.load("js/js.min.js","/js/js.min.js?oAl/+lvaqTFV31JXTmbrNA==")</script>



    <script>lsloader.load("js/nprogress.js","/js/nprogress.js?pl3Qhb9lvqR1FlyLUna1Yw==")</script>


<script type="text/ls-javascript" id="NProgress-script">
    NProgress.configure({
        showSpinner: true
    });
    NProgress.start();
    $('#nprogress .bar').css({
        'background': '#29d'
    });
    $('#nprogress .peg').css({
        'box-shadow': '0 0 10px #29d, 0 0 15px #29d'
    });
    $('#nprogress .spinner-icon').css({
        'border-top-color': '#29d',
        'border-left-color': '#29d'
    });
    setTimeout(function() {
        NProgress.done();
        $('.fade').removeClass('out');
    }, 800);
</script>













<!-- UC Browser Compatible -->
<script>
	var agent = navigator.userAgent.toLowerCase();
	if(agent.indexOf('ucbrowser')>0) {
		document.write('<link rel="stylesheet" href="/css/uc.css">');
	   alert('由于 UC 浏览器使用极旧的内核，而本网站使用了一些新的特性。\n为了您能更好的浏览，推荐使用 Chrome 或 Firefox 浏览器。');
	}
</script>

<!-- Window Load-->
<script type="text/ls-javascript" id="window-load">
    $(window).on('load', function() {
        // Post_Toc parent position fixed
        $('.post-toc-wrap').parent('.mdl-menu__container').css('position', 'fixed');
    });
</script>

<!-- MathJax Load-->

<script type="text/ls-javascript" id="lazy-load">
    // Offer LazyLoad
    queue.offer(function(){
        $('.lazy').lazyload({
            effect : 'show'
        });
    });

    // Start Queue
    $(document).ready(function(){
        setInterval(function(){
            queue.execNext();
        },200);
    });
</script>

<!-- Bing Background -->


<script>
    (function(){
        var scriptList = document.querySelectorAll('script[type="text/ls-javascript"]')

        for (var i = 0; i < scriptList.length; ++i) {
            var item = scriptList[i];
            lsloader.runInlineScript(item.id,item.id);
        }
    })()
console.log('\n %c © Material Theme | Version: 1.4.0 | https://github.com/viosey/hexo-theme-material %c \n', 'color:#455a64;background:#e0e0e0;padding:5px 0;border-top-left-radius:5px;border-bottom-left-radius:5px;', 'color:#455a64;background:#e0e0e0;padding:5px 0;border-top-right-radius:5px;border-bottom-right-radius:5px;');
</script>

                </main>
            </div>
        </body>
    
</html>
