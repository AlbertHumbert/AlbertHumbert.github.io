<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[深入JVM系列 2 - gdb 调试 HotSpot]]></title>
      <url>/2018/10/17/JVMUseGdb/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><a href="https://tocreate.app/2018/09/05/jvm/" target="_blank" rel="external">本文为深入JVM系列的一部分</a></p>
<p><a href="https://tocreate.app/2018/09/26/JVMCompileOpenJdk7/" target="_blank" rel="external">可能需要阅读前文</a></p>
<p><br></p>
<h3 id="安装-gdb"><a href="#安装-gdb" class="headerlink" title="安装 gdb"></a>安装 gdb</h3><ul>
<li>Linux自带gdb，mac上安装<a href="https://blog.csdn.net/qq_34290780/article/details/79898696?utm_source=blogxgwz7" target="_blank" rel="external">看这里</a></li>
</ul>
<p><br></p>
<h3 id="启动-HotSpot"><a href="#启动-HotSpot" class="headerlink" title="启动 HotSpot"></a>启动 HotSpot</h3><ul>
<li>可以参考这个路径找到启动脚本，注意必须为 debug 版本，否则可能无法调试</li>
</ul>
<pre><code>/Users/alberthumbert/jdk7u-dev/build/macosx-x86\_64-debug/hotspot/outputdir/bsd\_amd64\_compiler2/jvmg
</code></pre><ul>
<li>在 env.sh 中将 JavaPath 改为编译出来的版本</li>
</ul>
<ul>
<li>使用如下命令可以启动虚拟机，其中 Test 为我们编译出来的 class 文件</li>
</ul>
<pre><code>./hotspot -gdb -classpath /Users/alberthumbert/jdk7u-dev/build/macosx-x86\_64/hotspot/outputdir/bsd\_amd64\_compiler2/product Test
</code></pre><p><br></p>
<h3 id="使用-gdb"><a href="#使用-gdb" class="headerlink" title="使用 gdb"></a>使用 gdb</h3><p><strong>gdb虽然没有可视化的调试程序直观，但提供了足够丰富的命令</strong></p>
<p><br></p>
<h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><ul>
<li>调试程序,注意文件必须是可执行文件而且是可以调试的，如果使用 gcc 编译 那么编译时带上 -g 参数即可</li>
</ul>
<pre><code>gdb &lt;file&gt;
run
</code></pre><p><br></p>
<h4 id="浏览"><a href="#浏览" class="headerlink" title="浏览"></a>浏览</h4><ul>
<li>查看代码</li>
</ul>
<pre><code># 显示 10 行
list

# 显示第 5 到 10 行
list 5,10

# 显示某个文件的第 5 到 10 行
list &lt;file&gt;:5,10
</code></pre><ul>
<li>查找代码</li>
</ul>
<pre><code># 查找关键字
search &lt;word&gt;

# 向前查找
reverse-search
</code></pre><p><br></p>
<h4 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h4><ul>
<li>设置断点</li>
</ul>
<pre><code># 按行号设置断点
break &lt;number&gt;

# 按函数名设置断点
break &lt;fun&gt;

# 按条件表达式设置断点
break7 if &lt;state&gt;
</code></pre><ul>
<li>查看断点</li>
</ul>
<pre><code>info breakpoints
</code></pre><ul>
<li>删除断点</li>
</ul>
<pre><code>&apos;Deleted breakpoint 1
</code></pre><p><br></p>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ul>
<li>打印变量 </li>
</ul>
<pre><code>print &lt;var&gt;
</code></pre><ul>
<li>查看变量或表达式类型</li>
</ul>
<pre><code>whatis &lt;var&gt;
</code></pre><ul>
<li>赋值</li>
</ul>
<pre><code>set variable &lt;var&gt; = &lt;value&gt;
</code></pre><p><br></p>
<h4 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h4><ul>
<li>单行执行</li>
</ul>
<pre><code>next
</code></pre><ul>
<li>进入函数</li>
</ul>
<pre><code>step
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入操作系统 4 - 系统库函数]]></title>
      <url>/2018/10/15/OSBaseLib/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><a href="https://tocreate.app/2018/09/21/OperatingSystem/" target="_blank" rel="external">本文为深入操作系统系列的一部分</a></p>
<p><a href="https://tocreate.app/2018/10/15/OSBootstrap/" target="_blank" rel="external">可能需要阅读前文</a></p>
<p><strong>本文大概内容为在现有环境上搭建一个操作系统基础开发框架，包括基本的库函数，makefile等</strong></p>
<p><br></p>
<h2 id="基础条件"><a href="#基础条件" class="headerlink" title="基础条件"></a>基础条件</h2><p><strong>下面所有的条件除了 make 以外都在前几篇文章中提及了</strong></p>
<ul>
<li><p>cross-gcc</p>
</li>
<li><p>GRUB 与 Xorriso</p>
</li>
<li><p>Qemu</p>
</li>
<li><p>make，4.0以上</p>
</li>
</ul>
<p><br></p>
<h2 id="sysroot"><a href="#sysroot" class="headerlink" title="sysroot"></a>sysroot</h2><ul>
<li>在交叉编译环境中如果我们不指定 sysroot，编译器会默认在 /usr/include 和 /usr/lib 中寻找头文件和库，我们这里应该使用自己编写的库，因此需要指定 sysroot</li>
</ul>
<h2 id="系统头文件"><a href="#系统头文件" class="headerlink" title="系统头文件"></a>系统头文件</h2>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入操作系统 3 -  GRUB 引导 & multiboot 镜像]]></title>
      <url>/2018/10/15/OSBootstrap/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><a href="https://tocreate.app/2018/09/21/OperatingSystem/" target="_blank" rel="external">本文为深入操作系统系列的一部分</a></p>
<p><a href="https://tocreate.app/2018/09/22/OSCrossGcc/" target="_blank" rel="external">可能需要阅读前文</a></p>
<p><strong>本文中我们首先编写编译一个简单的内核，使用 GRUB 制作一个镜像，然后使用 qemu 的CDROM模式启动，最后再来详细解释发生了什么</strong></p>
<p><strong>到了这一步理论上你已经可以制作一个可以在真实硬件上跑的系统了</strong></p>
<p><strong>本文中的所有代码可以在 <a href="https://github.com/AlbertHumbert/Chaos" target="_blank" rel="external">https://github.com/AlbertHumbert/Chaos</a> 获取</strong><br><strong>对应 commit版本为 835238a3761e600b7b881f5480deeb560965c3d3 </strong></p>
<p><br></p>
<h4 id="安装-GRUB"><a href="#安装-GRUB" class="headerlink" title="安装 GRUB"></a>安装 GRUB</h4><p><strong>准确地说是 GRUB2 ，如果是使用 Linux 由于其自带了 GRUB ，所以这一步可以跳过</strong></p>
<ul>
<li>首先需要编译 objconv 库</li>
</ul>
<pre><code>https://github.com/vertis/objconv
</code></pre><ul>
<li>使用 g++ 编译, 编译过程中遇到一个变量溢出的问题，看起来是 windows 相关的问题，我是直接注释掉了，编译完之后将文件夹添加到环境变量</li>
</ul>
<pre><code>g++ -o objconv -O2 src/\*.cpp
</code></pre><ul>
<li>下载源码，注意被不是所有版本都适合在 osx 上使用,建议使用 commit id 为 77063f4cb6 的版本</li>
</ul>
<pre><code>git clone git://git.savannah.gnu.org/grub.git
</code></pre><ul>
<li>执行目录中的 autogen.sh 脚本，然后执行 config</li>
</ul>
<pre><code>../grub/configure --disable-werror TARGET\_CC=i386-elf-gcc TARGET\_OBJCOPY=i386-elf-objcopy TARGET\_STRIP=i386-elf-strip TARGET\_NM=i386-elf-nm TARGET\_RANLIB=i386-elf-ranlib --target=i386-elf
</code></pre><ul>
<li><p>然后 make 和 make install 即可，注意一定要 install，否则制作出来的镜像是损坏的</p>
</li>
<li><p>安装 xorriso</p>
</li>
</ul>
<pre><code>brew install xorriso
</code></pre><p><br></p>
<h4 id="bootloader-file"><a href="#bootloader-file" class="headerlink" title="bootloader file"></a>bootloader file</h4><pre><code>/* Declare constants for the multiboot header. */
.set ALIGN,    1&lt;&lt;0             /* align loaded modules on page boundaries */
.set MEMINFO,  1&lt;&lt;1             /* provide memory map */
.set FLAGS,    ALIGN | MEMINFO  /* this is the Multiboot &apos;flag&apos; field */
.set MAGIC,    0x1BADB002       /* &apos;magic number&apos; lets bootloader find the header */
.set CHECKSUM, -(MAGIC + FLAGS) /* checksum of above, to prove we are multiboot */

/*
 Declare a multiboot header that marks the program as a kernel. These are magic
 values that are documented in the multiboot standard. The bootloader will
 search for this signature in the first 8 KiB of the kernel file, aligned at a
 32-bit boundary. The signature is in its own section so the header can be
 forced to be within the first 8 KiB of the kernel file.
 */
.section .multiboot
.align 4
.long MAGIC
.long FLAGS
.long CHECKSUM

/*
 The multiboot standard does not define the value of the stack pointer register
 (esp) and it is up to the kernel to provide a stack. This allocates room for a
 small stack by creating a symbol at the bottom of it, then allocating 16384
 bytes for it, and finally creating a symbol at the top. The stack grows
 downwards on x86. The stack is in its own section so it can be marked nobits,
 which means the kernel file is smaller because it does not contain an
 uninitialized stack. The stack on x86 must be 16-byte aligned according to the
 System V ABI standard and de-facto extensions. The compiler will assume the
 stack is properly aligned and failure to align the stack will result in
 undefined behavior.
 */
.section .bss
.align 16
stack_bottom:
.skip 16384 # 16 KiB
stack_top:

/*
 The linker script specifies _start as the entry point to the kernel and the
 bootloader will jump to this position once the kernel has been loaded. It
 doesn&apos;t make sense to return from this function as the bootloader is gone.
 */
.section .text
.global _start
.type _start, @function
_start:
/*
    The bootloader has loaded us into 32-bit protected mode on a x86
    machine. Interrupts are disabled. Paging is disabled. The processor
    state is as defined in the multiboot standard. The kernel has full
    control of the CPU. The kernel can only make use of hardware features
    and any code it provides as part of itself. There&apos;s no printf
    function, unless the kernel provides its own &lt;stdio.h&gt; header and a
    printf implementation. There are no security restrictions, no
    safeguards, no debugging mechanisms, only what the kernel provides
    itself. It has absolute and complete power over the
    machine.
    */

/*
    To set up a stack, we set the esp register to point to the top of the
    stack (as it grows downwards on x86 systems). This is necessarily done
    in assembly as languages such as C cannot function without a stack.
    */
mov $stack_top, %esp

/*
    This is a good place to initialize crucial processor state before the
    high-level kernel is entered. It&apos;s best to minimize the early
    environment where crucial features are offline. Note that the
    processor is not fully initialized yet: Features such as floating
    point instructions and instruction set extensions are not initialized
    yet. The GDT should be loaded here. Paging should be enabled here.
    C++ features such as global constructors and exceptions will require
    runtime support to work as well.
    */

/*
    Enter the high-level kernel. The ABI requires the stack is 16-byte
    aligned at the time of the call instruction (which afterwards pushes
    the return pointer of size 4 bytes). The stack was originally 16-byte
    aligned above and we&apos;ve since pushed a multiple of 16 bytes to the
    stack since (pushed 0 bytes so far) and the alignment is thus
    preserved and the call is well defined.
    */
call kernel_main

/*
    If the system has nothing more to do, put the computer into an
    infinite loop. To do that:
    1) Disable interrupts with cli (clear interrupt enable in eflags).
 They are already disabled by the bootloader, so this is not needed.
 Mind that you might later enable interrupts and return from
 kernel_main (which is sort of nonsensical to do).
    2) Wait for the next interrupt to arrive with hlt (halt instruction).
 Since they are disabled, this will lock up the computer.
    3) Jump to the hlt instruction if it ever wakes up due to a
 non-maskable interrupt occurring or due to system management mode.
    */
cli
1:  hlt
jmp 1b

/*
 Set the size of the _start symbol to the current location &apos;.&apos; minus its start.
 This is useful when debugging or when you implement call tracing.
 */
.size _start, . - _start
</code></pre><ul>
<li>上面是一份引导文件,使用汇编编写，有足够的注释，这里简单讲解一下这个文件，建议之后再倒回来阅读</li>
</ul>
<ul>
<li>首先考虑一个问到烂了的问题，我们平时编写的 main 函数是由谁来调用的，答案自然是操作系统，那么再问一个问题，现在我们准备使用 c 来编写操作系统，那么操作系统的入口又由谁来调用？</li>
</ul>
<ul>
<li>Bootloader 就解决了这个问题，它是在操作系统之前启动的一段程序，它将内核带入内存，为内核提供合适的环境并将控制权交给内核</li>
</ul>
<ul>
<li>但真正如何启动操作系统还需要有开发者来决定，在这份文件中我们首先设置了 multiboot header，这是给 GRUB multiboot 强制要求的文件头结构，如果要使用 GRUB 就必须这么做。然后我们创建大小为 16k 的栈并将 esp 寄存器指向栈顶（这也就是 esp是栈顶指针寄存器的由来），准备工作完毕，我们调用我们编写的 c 文件的入口函数，这里将其命名为 kernel_main</li>
</ul>
<ul>
<li>从某种角度来说，操作系统就是一个巨大的，永无止境的函数，它不会返回。不过还是来处理一下 kernel_main 返回的情况，开启一个没有实际意义的无限循环即可，毕竟我们没别的事情可做了</li>
</ul>
<p><br></p>
<h4 id="简单-VGA-输出"><a href="#简单-VGA-输出" class="headerlink" title="简单 VGA 输出"></a>简单 VGA 输出</h4><ul>
<li>下一步，来编写一个 VGA 输出函数库，这将是除了编译器内置的库以外，我们操作系统的第一个函数库，头文件定义如下</li>
</ul>
<pre><code># include \&lt;stdbool.h\&gt;
# include \&lt;stddef.h\&gt;
# include \&lt;stdint.h\&gt;

void terminal\_initialize(void);

void terminal\_setcolor(uint8\_t color);

void terminal\_putentryat(char c, uint8\_t color, size\_t x, size\_t y) ;

void terminal\_putchar(char c) ;

void terminal\_write(const char\* data, size\_t size) ;

void terminal\_writestring(const char\* data) ;
</code></pre><ul>
<li>在 intel PCI 总线 VGA 显示模式的编址为 0xA0000 -> 0xBFFFF，其中 0xB8000 开始为彩色字符模式，每字节前4位为背景色后4位为字符色（也就是只支持16色），我们要做的只是通过  0xB8000 这个地址拿到缓冲区，并填入数据即可，实现起来很简单不多说了</li>
</ul>
<pre><code># include &quot;tty.h&quot;

enum vga\_color {
    VGA_COLOR_BLACK = 0,
    VGA_COLOR_BLUE = 1,
    VGA_COLOR_GREEN = 2,
    VGA_COLOR_CYAN = 3,
    VGA_COLOR_RED = 4,
    VGA_COLOR_MAGENTA = 5,
    VGA_COLOR_BROWN = 6,
    VGA_COLOR_LIGHT_GREY = 7,
    VGA_COLOR_DARK_GREY = 8,
    VGA_COLOR_LIGHT_BLUE = 9,
    VGA_COLOR_LIGHT_GREEN = 10,
    VGA_COLOR_LIGHT_CYAN = 11,
    VGA_COLOR_LIGHT_RED = 12,
    VGA_COLOR_LIGHT_MAGENTA = 13,
    VGA_COLOR_LIGHT_BROWN = 14,
    VGA_COLOR_WHITE = 15,
};

static inline uint8\_t vga\_entry\_color(enum vga\_color fg, enum vga\_color bg) 
{
    return fg | bg &lt;&lt; 4;
}

static inline uint16\_t vga\_entry(unsigned char uc, uint8\_t color) 
{
    return (uint16_t) uc | (uint16_t) color &lt;&lt; 8;
}

size\_t strlen(const char\* str) 
{
    size_t len = 0;
    while (str[len])
        len++;
    return len;
}

static const size\_t VGA\_WIDTH = 80;
static const size\_t VGA\_HEIGHT = 25;

size\_t terminal\_row;
size\_t terminal\_column;
uint8\_t terminal\_color;
uint16\_t\* terminal\_buffer;

void terminal\_initialize(void) 
{
    terminal_row = 0;
    terminal_column = 0;
    terminal_color = vga_entry_color(VGA_COLOR_LIGHT_GREY, VGA_COLOR_BLACK);
    terminal_buffer = (uint16_t*) 0xB8000;
    for (size_t y = 0; y &lt; VGA_HEIGHT; y++) {
        for (size_t x = 0; x &lt; VGA_WIDTH; x++) {
            const size_t index = y * VGA_WIDTH + x;
            terminal_buffer[index] = vga_entry(&apos; &apos;, terminal_color);
        }
    }
}

void terminal\_setcolor(uint8\_t color) 
{
    terminal_color = color;
}

void terminal\_putentryat(char c, uint8\_t color, size\_t x, size\_t y) 
{
    size_t index;
    if(c == &apos;\n&apos;){
        terminal_column = VGA_WIDTH-1;
    }else{
        index = y * VGA_WIDTH + x;
        terminal_buffer[index] = vga_entry(c, color);
    }
}

void terminal\_putchar(char c) 
{
    terminal_putentryat(c, terminal_color, terminal_column, terminal_row);
    if (++terminal_column == VGA_WIDTH) {
        terminal_column = 0;
        ++terminal_row;
        if (++terminal_row == VGA_HEIGHT)
            terminal_row = 0;
    }
}

void terminal\_write(const char\* data, size\_t size) 
{
    for (size_t i = 0; i &lt; size; i++)
        terminal_putchar(data[i]);
}

void terminal\_writestring(const char\* data) 
{
    terminal_write(data, strlen(data));
}
</code></pre><p><br></p>
<h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><ul>
<li>现在调用我们刚刚实现的函数，编写一个内核，它除了在屏幕上打印 hello world 之外什么也不干</li>
</ul>
<pre><code># include &quot;tty.h&quot;

void kernel\_main()
{
    terminal_initialize();
    terminal_writestring(&quot;          \n\n\n&quot;);
    terminal_writestring(&quot;          Hello, World!\n&quot;);
    terminal_writestring(&quot;          \n\n\n&quot;);
}
</code></pre><p><br></p>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><ul>
<li>核心代码已经实现了，现在需要一份连接脚本，然后使用交叉编译器编译它们</li>
</ul>
<pre><code>/\* The bootloader will look at this image and start execution at the symbol
   designated as the entry point. \*/
ENTRY(\_start)

/\* Tell where the various sections of the object files will be put in the final
   kernel image. \*/
SECTIONS
{
    /* Begin putting sections at 1 MiB, a conventional place for kernels to be
       loaded at by the bootloader. */
    . = 1M;

    /* First put the multiboot header, as it is required to be put very early
       early in the image or the bootloader won&apos;t recognize the file format.
       Next we&apos;ll put the .text section. */
    .text BLOCK(4K) : ALIGN(4K)
    {
        *(.multiboot)
        *(.text)
    }

    /* Read-only data. */
    .rodata BLOCK(4K) : ALIGN(4K)
    {
        *(.rodata)
    }

    /* Read-write data (initialized) */
    .data BLOCK(4K) : ALIGN(4K)
    {
        *(.data)
    }

    /* Read-write data (uninitialized) and stack */
    .bss BLOCK(4K) : ALIGN(4K)
    {
        *(COMMON)
        *(.bss)
    }

    /* The compiler may produce other sections, by default it will put them in
       a segment with the same name. Simply add stuff here as needed. */
}
</code></pre><ul>
<li><p>注意文件的先后依赖，这里为将产出文件放到 build 目录下</p>
<p>  i686-elf-as ./src/start.s -o ./build/start.o<br>  i686-elf-gcc -std=gnu99 -ffreestanding -g -c ./src/kernel.c -o ./build/kernel.o<br>  i686-elf-gcc -std=gnu99 -ffreestanding -g -c ./src/tty.c -o ./build/tty.o<br>  i686-elf-gcc -ffreestanding -nostdlib -g -T ./src/linker.ld ./build/start.o ./build/kernel.o ./build/tty.o -o ./build/chaos.bin -lgcc</p>
</li>
</ul>
<p><br></p>
<h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><ul>
<li>上面最后生成的 chaos.bin 就是符合 multiboot 规范的文件，你可以使用 grub-file<br>文件来检验它</li>
</ul>
<pre><code>grub-file --is-x86-multiboot chaos.bin
# 什么都没发生，意味着一切正常
</code></pre><ul>
<li>qemu 支持你不使用任何媒介之前引导镜像，执行下面命令，如无意外，你的第一个操作系统就会运行起来，输出 hello world</li>
</ul>
<pre><code>qemu-system-i386 -kernel chaos.bin
</code></pre><ul>
<li>下面我们让其能在 CD-ROM 上启动,编写grub.cfg，指明镜像位置</li>
</ul>
<pre><code>menuentry &quot;chaos&quot; {
    multiboot /boot/chaos.bin
}
</code></pre><ul>
<li>然后按照grub.cfg的配置准备好目录</li>
</ul>
<pre><code>mkdir -p isodir/boot/grub
cp build/chaos.bin isodir/boot/chaos.bin
cp src/grub.cfg isodir/boot/grub/grub.cfg
</code></pre><ul>
<li>使用 grub 创建镜像</li>
</ul>
<pre><code>grub-mkrescue -o ./build/chaos.iso isodir
</code></pre><ul>
<li>使用 qemu CD-ROM 模式启动 </li>
</ul>
<pre><code>qemu-system-i386 -cdrom ./build/chaos.iso
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 注解进阶 AnnotationProcessor & Javapoet]]></title>
      <url>/2018/10/06/AndroidAnnotation/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><br></p>
<h2 id="Java-注解基础"><a href="#Java-注解基础" class="headerlink" title="Java 注解基础"></a>Java 注解基础</h2><p><strong>简单回顾一下注解，加入了一些Java 8中的新特性</strong></p>
<p><br></p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>注解 (Annotation)，也叫元数据。一种代码级别的说明。它是 JDK1.5 及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释</li>
</ul>
<ul>
<li>注解中的数据可以在编译、运行时进行解析和使用，也可以单纯为编码人员提供很多的信息</li>
</ul>
<p><br></p>
<h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><ul>
<li>元注解是使用在注解上的注解，它为注解提供构成信息，是最基本的注解，Java中的元注解包括，@Retention, @Documented, @Target, @Inherited，@Repeatable（Java 8）</li>
</ul>
<p><br></p>
<h4 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h4><p><strong>Retention用于指示注解的生命周期，即存活时间</strong></p>
<pre><code>@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
public @interface Retention {
    /**
     * Returns the retention policy.
     * @return the retention policy
     */
    RetentionPolicy value();
}
</code></pre><ul>
<li>RetentionPolicy.SOURCE, 注解会被编译器抛弃，即注解只在源码阶段中使用，一般用于程序员阅读</li>
</ul>
<ul>
<li>RetentionPolicy.CLASS，注解会被记录在class文件中，但不会被JVM加载，即注解可以在编译期使用</li>
</ul>
<ul>
<li>RetentionPolicy.RUNTIME，注解会被JVM加载，即注解可以在运行时使用</li>
</ul>
<pre><code>public enum RetentionPolicy {
    /**
     * Annotations are to be discarded by the compiler.
     */
    SOURCE,

    /**
     * Annotations are to be recorded in the class file by the compiler
     * but need not be retained by the VM at run time.  This is the default
     * behavior.
     */
    CLASS,

    /**
     * Annotations are to be recorded in the class file by the compiler and
     * retained by the VM at run time, so they may be read reflectively.
     *
     * @see java.lang.reflect.AnnotatedElement
     */
    RUNTIME
}
</code></pre><p><br></p>
<h4 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h4><p><strong> Target用于指示注解的标注对象，如类，方法，变量等</strong></p>
<pre><code>@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
public @interface Target {
    /**
     * Returns an array of the kinds of elements an annotation type
     * can be applied to.
     * @return an array of the kinds of elements an annotation type
     * can be applied to
     */
    ElementType[] value();
}
</code></pre><ul>
<li>ElementType.CONSTRUCTOR: 作用于构造方法</li>
<li>ElementType.ANNOTATION_TYPE:  作用于注解</li>
<li>ElementType.FIELD: 作用于域（包括枚举）</li>
<li>ElementType.LOCAL_VARIABLE: 作用于局部变量</li>
<li>ElementType.METHOD: 作用于方法</li>
<li>ElementType.PACKAGE: 作用于包，一般使用在编译器生成的package-info.java类当中</li>
<li>ElementType.PARAMETER: 作用于方法参数</li>
<li>ElementType.TYPE: 作用于类、接口、枚举</li>
<li>ElementType.TYPE_PARAMETER: 作用于提供给泛型的类型参数（Java 8）</li>
<li>ElementType.TYPE_USE：作用于变量类型（Java 8）</li>
</ul>
<pre><code>public enum ElementType {
    /** Class, interface (including annotation type), or enum declaration */
    TYPE,

    /** Field declaration (includes enum constants) */
    FIELD,

    /** Method declaration */
    METHOD,

    /** Formal parameter declaration */
    PARAMETER,

    /** Constructor declaration */
    CONSTRUCTOR,

    /** Local variable declaration */
    LOCAL_VARIABLE,

    /** Annotation type declaration */
    ANNOTATION_TYPE,

    /** Package declaration */
    PACKAGE,

    /**
     * Type parameter declaration
     *
     * @since 1.8
     */
    TYPE_PARAMETER,

    /**
     * Use of a type
     *
     * @since 1.8
     */
    TYPE_USE
}
</code></pre><p><br></p>
<h4 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h4><p><strong> Inherited用于指示使用了某个注解的类，其子类是否继承该注解</strong></p>
<pre><code>@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
public @interface Inherited {
}
</code></pre><p><br></p>
<h4 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h4><p><strong> Documented用于指示注解是否被javadoc等文档工具记录</strong></p>
<pre><code>@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
public @interface Documented {
}
</code></pre><p><br></p>
<h4 id="Repeatable（Java-8）"><a href="#Repeatable（Java-8）" class="headerlink" title="@Repeatable（Java 8）"></a>@Repeatable（Java 8）</h4><p><strong> Documented用于指示注解可以在同一个元素中多次使用</strong></p>
<pre><code>@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
public @interface Repeatable {
    /**
         * Indicates the &lt;em&gt;containing annotation type&lt;/em&gt; for the
     * repeatable annotation type.
     * @return the containing annotation type
     */
    Class&lt;? extends Annotation&gt; value();
}
</code></pre><p><br></p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul>
<li>注解的属性也叫做成员变量，使用无参方法声明的形式来声明，可以设置默认值</li>
</ul>
<pre><code>public @interface Test {

    int testInt() default 1;
    String testStr();
}
</code></pre><ul>
<li>没有设置默认值的属性必须在使用时赋值，设置了值的属性可以在使用时覆盖</li>
</ul>
<pre><code>@Test(testInt = 2,testStr = &quot;test&quot;)
public class Xxx{
}
</code></pre><p><br></p>
<h2 id="处理注解"><a href="#处理注解" class="headerlink" title="处理注解"></a>处理注解</h2><ul>
<li><p>根据注解的处理时机我们可以将注解分为如下三类</p>
</li>
<li><p>运行时处理，这一类注解拥有 RetentionPolicy.RUNTIME 生命周期，并且只使用反射处理</p>
</li>
</ul>
<ul>
<li>编译时处理，这一类注解至少拥有 RetentionPolicy.CLASS 生命周期，需要使用注解解释器处理,通常在这个阶段会使用注解生成java代码</li>
</ul>
<ul>
<li>不处理，这里指的是程序员无需使用代码去解析注解，这些注解通常只提供一些简单的信息</li>
</ul>
<p><br></p>
<h3 id="运行时注解处理"><a href="#运行时注解处理" class="headerlink" title="运行时注解处理"></a>运行时注解处理</h3><ul>
<li>运行时处理注解即通过反射获取需要解析的注解和注解的属性</li>
</ul>
<pre><code>public void process(Class clazz) {

    for (Method method : clazz.getMethods()) {
        Test annotation = method.getAnnotation(Test.class);
        handleMethodAnnotation(annotation);
    }

    for (Field field : clazz.getDeclaredFields()) {
        Test annotation = field.getAnnotation(Test.class);
        handleFieldAnnotation(annotation);
    }
}

public void handleMethodAnnotation(Test test) {
    int intValue = test.testInt();
    String strValue = test.testStr();
    //...

}

public void handleFieldAnnotation(Test test) {
    int intValue = test.testInt();
    String strValue = test.testStr();
    //...
}
</code></pre><ul>
<li>这种处理方法非常简单，很好上手，但问题是反射比较耗性能，不需要运行时处理的注解理应尽量在编译器处理</li>
</ul>
<p><br></p>
<h3 id="编译时注解处理器"><a href="#编译时注解处理器" class="headerlink" title="编译时注解处理器"></a>编译时注解处理器</h3><p><br></p>
<h4 id="Annotation-Processing-Tool"><a href="#Annotation-Processing-Tool" class="headerlink" title="Annotation Processing Tool"></a>Annotation Processing Tool</h4><ul>
<li>APT 是 Android 过去通用的注解框架，现已退出历史舞台，这里只是提一下，有兴趣的可以看一下<a href="https://blog.csdn.net/Ru_Zhan/article/details/78232851?locationNum=8&amp;fps=1" target="_blank" rel="external">这篇文档</a></li>
</ul>
<p><br></p>
<h4 id="Annotation-Processor"><a href="#Annotation-Processor" class="headerlink" title="Annotation Processor"></a>Annotation Processor</h4><p><br></p>
<h5 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h5><ul>
<li>一般来说，使用 Annotation Processor 的框架会将编译期执行的代码单独出来，这样可以使用gradle 的 annotationProcessor 使这部分代码和相关依赖不会被打包</li>
</ul>
<ul>
<li>因此框架至少包含两个模块 ，一个用于实现框架的主体功能，该模块自然也存放了注解，另一个用于解析注解并生成代码，后者依赖前者，这两个模块要么都是 Android Library 要么都是 Java Library</li>
</ul>
<ul>
<li>这里我创建两个 java 模块，test 和 testCompiler,在 app 和 testCompiler中添加如下依赖，Annotation Processor相对于apt来说添加依赖非常简单，只需要在gradle中使用 annotationProcessor 即可</li>
</ul>
<pre><code>//in app
implementation project(&apos;:test&apos;)
annotationProcessor project(&apos;:testCompiler&apos;)

//in testCompiler
implementation project(&apos;:test&apos;)
</code></pre><p><br></p>
<h5 id="AbstractProcessor"><a href="#AbstractProcessor" class="headerlink" title="AbstractProcessor"></a>AbstractProcessor</h5><pre><code>public class TestProcessor extends AbstractProcessor {
    @Override
    public boolean process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment) {
        return false;
    }
}
</code></pre><p><strong>未完待续</strong></p>
<p><br></p>
<h5 id="原生动态编译-api"><a href="#原生动态编译-api" class="headerlink" title="原生动态编译 api"></a>原生动态编译 api</h5><ul>
<li>从 Java 6 开始 Java 提供了JavaFileObject等一系列动态编译 api，我们使用这些api来实现 AbstractProcessor</li>
</ul>
<p><br></p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul>
<li>在 gradle 中添加依赖</li>
</ul>
<pre><code>dependencies {
    annotationProcessor &quot;com.google.auto.service:auto-service:1.0-rc4&quot;
}
</code></pre><p><br></p>
<h4 id="AutoService"><a href="#AutoService" class="headerlink" title="AutoService"></a>AutoService</h4><p><br></p>
<h4 id="Javapoet"><a href="#Javapoet" class="headerlink" title="Javapoet"></a>Javapoet</h4><ul>
<li>在 gradle 中添加依赖</li>
</ul>
<pre><code>dependencies {
    compileOnly &quot;com.squareup:javapoet:1.11.1&quot;
    annotationProcessor &quot;com.google.auto.service:auto-service:1.0-rc4&quot;
}
</code></pre><p><br></p>
<h2 id="注解框架实例"><a href="#注解框架实例" class="headerlink" title="注解框架实例"></a>注解框架实例</h2><p><strong>未完待续</strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入JVM系列 1 - mac平台编译调试 OpenJdk7 & HotSpot]]></title>
      <url>/2018/09/26/JVMCompileOpenJdk7/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><a href="https://tocreate.app/2018/09/05/jvm/" target="_blank" rel="external">本文为深入JVM系列的一部分</a></p>
<p><br></p>
<h3 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h3><ul>
<li>系统环境 ：osx 10.11.6</li>
<li>c 编译器 ：clang</li>
<li>openJdk ：jdk7u-dev</li>
<li>boostrap JDK ：oracle JDK 7u40</li>
<li>xcode version ：8.0 (8A218a)</li>
<li>ant version ：1.8.0</li>
<li>make 命令，请根据编译环境自行调整</li>
</ul>
<pre><code>sudo make ALT\_BOOTDIR=/Library/Java/JavaVirtualMachines/jdk1.7.0\_40.jdk/contents/home SPOT\_OS\_VERSION\_CHECK=OK LANG=C ANT\_HOME=/Users/alberthumbert/Downloads/apache-ant-1.8.0 WARNINGS\_ARE\_ERRORS=false ALLOW\_DOWNLOADS=true CC=clang COMPILER\_WARNINGS\_FATAL=false LFLAGS=&apos;-Xlinker -lstdc++&apos; USE\_CLANG=true LP64=1 LANG=C  ARCH\_DATA\_MODEL=64 HOTSPOT\_BUILD\_JOBS=8
</code></pre><p><br></p>
<h3 id="获取源码"><a href="#获取源码" class="headerlink" title="获取源码"></a>获取源码</h3><ul>
<li>本文不会有安装和配置 brew , xcode 和 boostrap jdk（oracle jdk） 的内容，对于打算动手编译jdk的人，这部分内容太基础了，就不废话了</li>
</ul>
<ul>
<li>首先确保 mercurial 已经安装，mercurial 和 git 的作用差不多</li>
</ul>
<pre><code>sudo easy\_install mercurial
</code></pre><ul>
<li>使用 mercurial 提供的 hg 工具拉取远程仓库, 这里我拉取的是 jdk 7</li>
</ul>
<pre><code>hg clone http://hg.openjdk.java.net/jdk7u/jdk7u-dev
</code></pre><ul>
<li>现在还未真正获取到所有源码，在进行下一步之前，建议先确保你有足够的权限，在trust.rc中添加当前的用户名</li>
</ul>
<pre><code>sudo vim /etc/mercurial/hgrc.d/trust.rc
</code></pre><ul>
<li>一个可供参考的版本如下</li>
</ul>
<pre><code>[trusted]
users = alberthumbert 
groups = root
</code></pre><ul>
<li>接着正式获取源码,使用任何shell都可以, 如果执行后出现 xxx not trusted，说明上一步没有设置好 </li>
</ul>
<pre><code>sudo zsh ./get\_source.sh
</code></pre><ul>
<li>如果出现 abort: stream ended unexpectedly ，可能是网络的问题，我这里试了很多次都没有拉取成功，没办法只好走代理，在当前终端中设置代理，只需执行如下命令，只在当前终端生效</li>
</ul>
<pre><code>export all_proxy=socks5://[host]:[port] # 同时配置 http 和 https代理
</code></pre><ul>
<li>如无意外，corba，jaxp，jaxws，langtools，jdk，hotspot 这些过程都将以 xxx files updated, 0 files merged, 0 files removed, 0 files unresolved 结束，不行就再试几次</li>
</ul>
<p><br></p>
<h3 id="编译环境-1"><a href="#编译环境-1" class="headerlink" title="编译环境"></a>编译环境</h3><ul>
<li>安装llvm</li>
</ul>
<pre><code>brew install llvm
</code></pre><ul>
<li>安装 freetype</li>
</ul>
<pre><code>brew install freetype
</code></pre><ul>
<li>安装完freetype和llvm后需要设置链接</li>
</ul>
<pre><code>sudo ln -s /usr/bin/llvm-g++ /Applications/Xcode.app/Contents/Developer/usr/bin/llvm-g++


sudo ln -s /usr/bin/llvm-gcc /Applications/Xcode.app/Contents/Developer/usr/bin/llvm-gcc
</code></pre><ul>
<li>安装 ant , 编译过程中提示ant版本太旧，在apache官网上下载新版本，然后设置链接，建议不要使用版本太高的ant，最好不要跟你的 OpenJdk 版本有太大差距</li>
</ul>
<pre><code>sudo ln -s Users/alberthumbert/Desktop/apache-ant-1.8.0/bin/ant /usr/bin/ant
</code></pre><ul>
<li>安装 XQuartz，在￼官网￼下载dmg并手动安装 ，然后添加链接</li>
</ul>
<pre><code>sudo ln -s /opt/X11/include/X11 /usr/local/include/X11
</code></pre><ul>
<li>注意如果上一步出现 operation not permitted ，说明你的os版本比较高，有些操作被系统保护，需要重启 Command + R 进入 recover 模式，在终端中关闭保护, 输入如下命令然后重启即可</li>
</ul>
<pre><code>csrutil disable
</code></pre><p><br></p>
<h3 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h3><ul>
<li>下面是一份可供参考的参数配置，可以写在目录的build.sh当中然后执行，注意jdk路径和ant路径需要根据实际情况自行设置</li>
</ul>
<pre><code># 语言选项，必须设置，否则编译好后会出现一个 HashTable 的 NPE错
export LANG=C
# Bootstrap JDK 解压路径，必须设置
export ALT\_BOOTDIR=/Library/Java/JavaVirtualMachines/jdk1.7.0\_40.jdk/Contents/Home
export ANT\_HOME=/Users/alberthumbert/Desktop/apache-ant-1.8.0
export ANT\_VERSION=1.7.1
# 允许自动下载
export ALLOW\_DOWNLOADS=true
# 并行编译线程数
export HOTSPOT\_BUILD\_JOBS=4
export ALT\_PARALLEL\_COMPILE\_JOBS=4
# 比较本次 build 出来的映像与先前版本的差异，对我们没有意义
# 必须设置为 false，否则 sanity 检查为报缺少先前版本 JDK 的映像的错误提示
export SKIP\_COMPARE\_IMAGE=false
# 使用预编译头文件，不加这个编译会变慢
export USE\_PRECOMPILED\_HEADER=true
# 要编译的内容
export BUILD\_LANGTOOLS=true
export BUILD\_HOTSPOT=true
export BUILD\_JDK=true
# export BUILD\_JAXWS=false
# export BUILD\_JAXP=false
# export BUILD\_CORBA=false
# 要编译的版本
# export SKIP\_DEBUG\_BUILD=false
# export SKIP\_FASTDEBUG\_BUILD=true
# export DEBUG\_NAME=debug
# 把它设置为 false 可以避开 javaws 和浏览器 Java 插件之类的部分的 build
BUILD\_DEPLOY=false
# 把它设置为 false 就不会 build 出安装包，因为安装包里有奇怪的依赖
# 但即使不 build 出它也能得到完整的 JDK 映像，所以还是别 build
BUILD\_INSTALL=false
export WARNINGS\_ARE\_ERRORS=false
export COMPILER\_WARNINGS\_FATAL=false
# 编译结果所存放的路径
export ALT\_OUTPUTDIR=/Users/alberthumbert/jdk7u-dev/build\_result
# 这两个环境变量必须去掉，不然会发生奇怪的事情
# Makefile 检查到这两个变量就会提示警告
unset JAVA\_HOME
unset CLASSPATH
make sanity
</code></pre><p><br></p>
<h3 id="开始编译"><a href="#开始编译" class="headerlink" title="开始编译"></a>开始编译</h3><p><br></p>
<h4 id="no-boostrap-dir"><a href="#no-boostrap-dir" class="headerlink" title="no boostrap dir"></a>no boostrap dir</h4><ul>
<li>执行 make 进行编译，编译过程中可能提示找不到可用的 boostrap jdk ，虽然在上面已经配置过了，不太清楚为什么，只能再手动加上参数，注意这里也需要权限</li>
</ul>
<pre><code>sudo make ALT\_BOOTDIR=/Library/Java/JavaVirtualMachines/jdk1.7.0\_71.jdk/content/home
</code></pre><p><br></p>
<h4 id="ant-版本过低"><a href="#ant-版本过低" class="headerlink" title="ant 版本过低"></a>ant 版本过低</h4><ul>
<li>如果提示 ant 版本过低，但实际上你的 ant 又高于提示中的 ant 版本，有可能实际上是 boostrap jdk 版本太低，建议使用 oracle jdk 7u40 ，详见后面踩坑记录</li>
</ul>
<pre><code>ERROR: 
The version of ant being used is older than
the required version of &apos;1.7.1&apos;.
The version of ant found was &apos;1.7.0&apos;.
</code></pre><p><br></p>
<h4 id="中文-与-ascii-乱码"><a href="#中文-与-ascii-乱码" class="headerlink" title="中文 与 ascii 乱码"></a>中文 与 ascii 乱码</h4><ul>
<li>自动生成的代码（主要是AIDL文件）中注释会带有中文，这个时候由于配置中规定了使用 ascii ，这会导致编译器无法识别而编译不通过，解决办法主要有两种，一种使用shell命令或脚本，另一种直接修改文件</li>
</ul>
<ul>
<li>使用shell命令替换可以参考下面, 有可能不成功</li>
</ul>
<pre><code>sudo find /Users/alberthumbert/jdk7u-dev/build/macosx-x86\_64/corba/gensrc/com/sun/ -name &apos;\*.java&apos; | while read p; do native2ascii -encoding UTF-8 $p \&gt; tmpj; mv tmpj $p ; done
</code></pre><ul>
<li>比较稳的做法是像这位<a href="http://0x9e370001.iteye.com/blog/1729802" target="_blank" rel="external">老哥</a>一样修改文件，看上去很多其实也没几个文件，善用字符搜索很快就能搞定</li>
</ul>
<p><br></p>
<h4 id="clang-不支持-fpch-deps"><a href="#clang-不支持-fpch-deps" class="headerlink" title="clang 不支持 -fpch-deps"></a>clang 不支持 -fpch-deps</h4><ul>
<li>参考这一位<a href="https://blog.csdn.net/j754379117/article/details/53695426" target="_blank" rel="external">老哥</a>的做法，修改 hotspot/make/bsd/makefiles/gcc.make</li>
</ul>
<pre><code># 注释216-218行
# Flags for generating make dependency flags.
# ifneq (&quot;${CC\_VER\_MAJOR}&quot;, &quot;2&quot;)
# DEPFLAGS = -fpch-deps -MMD -MP -MF $(DEP\_DIR)/$(@:%=%.d)
# endif
# 在218行下添加下面代码
DEPFLAGS = -MMD -MP -MF $(DEP\_DIR)/$(@:%=%.d)
ifeq ($(USE\_CLANG),)
  ifneq ($(CC\_VER\_MAJOR), 2)
    DEPFLAGS += -fpch-deps
  endif
endif
</code></pre><p><br></p>
<h4 id="clang-error-no-such-file-or-directory-‘false’"><a href="#clang-error-no-such-file-or-directory-‘false’" class="headerlink" title="clang: error: no such file or directory: ‘false’"></a>clang: error: no such file or directory: ‘false’</h4><ul>
<li>仔细看发现是makefile生成的编译命令中某个参数只剩了一个false，不知道是哪个参数，很蛋疼，顺藤摸瓜找到生成参数的makefile</li>
</ul>
<pre><code>sudo vim /Users/alberthumbert/jdk7u-dev/hotspot/make/bsd/makefiles/vm.make
</code></pre><ul>
<li>注释掉下面个参数配置</li>
</ul>
<pre><code># CFLAGS\_WARN holds compiler options to suppress/enable warnings.
CFLAGS += $(CFLAGS\_WARN/BYFILE)
# Do not use C++ exception handling
CFLAGS += $(CFLAGS/NOEX)
</code></pre><p><br></p>
<h4 id="形参默认值问题"><a href="#形参默认值问题" class="headerlink" title="形参默认值问题"></a>形参默认值问题</h4><ul>
<li>还是参考这位<a href="https://blog.csdn.net/j754379117/article/details/53695426" target="_blank" rel="external">老哥</a>，修改 hotspot/src/share/vm/code/relocInfo.hpp</li>
</ul>
<pre><code>//修改374行
inline friend relocInfo prefix\_relocInfo(int datalen);
//修改469行
inline relocInfo prefix\_relocInfo(int datalen = 0) {
   assert(relocInfo::fits\_into\_immediate(datalen), &quot;datalen in limits&quot;);
   return relocInfo(relocInfo::data\_prefix\_tag, relocInfo::RAW\_BITS, relocInfo::datalen\_tag | datalen);
}
</code></pre><p><br></p>
<h4 id="Undefined-symbols-for-architecture-x86-64-“-attachCurrentThread”"><a href="#Undefined-symbols-for-architecture-x86-64-“-attachCurrentThread”" class="headerlink" title="Undefined symbols for architecture x86_64: “_attachCurrentThread”"></a>Undefined symbols for architecture x86_64: “_attachCurrentThread”</h4><ul>
<li><p>这个错误是在 debug_build 时才出现的，没有保存出错信息，简单说一下情况，提示说 ThreadUtilities中的 getJNIEnv 和 getJNIEnvUncached 函数引用了一个不存在的函数 attachCurrentThread，之前写过一点jni，感觉大概是一个封装了jni线程调度函数的工具类出了问题</p>
</li>
<li><p>在osxapp目录找到这个文件</p>
</li>
</ul>
<pre><code>cd /Users/alberthumbert/jdk7u-dev/jdk/src/macosx//native/sun/osxapp
</code></pre><ul>
<li>实际上 ThreadUtilities.m 文件中可以找到这个函数,感觉是内联出了问题，把 inline 关键字去掉即可通过编译</li>
</ul>
<pre><code>inline void attachCurrentThread(void\*\* env) {
    if ([NSThread isMainThread]) {
        JavaVMAttachArgs args;
        args.version = JNI_VERSION_1_4;
        args.name = &quot;AppKit Thread&quot;;
        args.group = appkitThreadGroup;
        (*jvm)-&gt;AttachCurrentThreadAsDaemon(jvm, env, &amp;args);
    } else {
        (*jvm)-&gt;AttachCurrentThreadAsDaemon(jvm, env, NULL);
    }
}
</code></pre><p><br></p>
<h3 id="编译通过"><a href="#编译通过" class="headerlink" title="编译通过"></a>编译通过</h3><p><br></p>
<ul>
<li>任务完成，耗时将近20分钟，纪念一下</li>
</ul>
<p><br></p>
<pre><code>&gt;&gt;&gt;Finished making images @ Sat Apr  7 14:22:59 CST 2018 ...
########################################################################
##### Leaving jdk for target(s) sanity all docs images             #####
########################################################################
##### Build time 00:12:41 jdk for target(s) sanity all docs images #####
########################################################################

#-- Build times ----------
Target all_product_build
Start 2018-04-07 14:03:57
End   2018-04-07 14:22:59
00:00:16 corba
00:05:57 hotspot
00:00:02 jaxp
00:00:03 jaxws
00:12:41 jdk
00:00:03 langtools
00:19:02 TOTAL
-------------------------
</code></pre><p><br><br><br></p>
<ul>
<li>下面让我们来验证一下编译是否真的成功了</li>
</ul>
<pre><code>cd /Users/alberthumbert/jdk7u-dev/build/macosx-x86\_64/j2sdk-image/bin
</code></pre><ul>
<li>验证一下版本</li>
</ul>
<pre><code>./java -version
# 输出
openjdk version &quot;1.7.0-internal&quot;
OpenJDK Runtime Environment (build 1.7.0-internal-root\_2018\_04\_07\_14\_03-b00)
OpenJDK 64-Bit Server VM (build 24.80-b07, mixed mode)
</code></pre><ul>
<li>写个 hello world, 用 ./javac Hello.java 编译</li>
</ul>
<pre><code> public class Hello{
    public static void main(String[] args){
       System.out.println(&quot;Hello World !&quot;);
    }
}
</code></pre><ul>
<li>用 ./java Hello 运行</li>
</ul>
<pre><code>Hello World !
</code></pre><p><br><br><br></p>
<h3 id="调试源码"><a href="#调试源码" class="headerlink" title="调试源码"></a>调试源码</h3><p><strong>不单纯为了编译而去编译，在学习jvm的同时能跟着代码走才是最终目的</strong></p>
<p><br></p>
<h4 id="build-debug-build-fastdebug-build"><a href="#build-debug-build-fastdebug-build" class="headerlink" title="build debug_build fastdebug_build"></a>build debug_build fastdebug_build</h4><ul>
<li>注意 在普通的编译模式下编译出来的jdk是不能调试的，它跟你平时使用的普通jdk是一个东西，为了能够支持调试 在make 命令后面需要加上 build_debug 参数，这时在 build/macosx-x86_64-debug/ 目录可以找到另一个编译版本，这里面的 jdk 和 hotspot是可调试的</li>
</ul>
<ul>
<li>细心的玩家可能还会发现一个 macosx-x86_64-fastdebug 目录，如果你在配置文件中设置了 fastdebug 参数，那么就会有这个版本 jdk，简单说一下 fastdebug 是什么，它是由于 jdk 的开发人员无法忍受编译器极度缓慢的调试速度而打造的新调试版本，它的调试速度会比普通的 debug 快，不过替换掉了一些命令，所以它的表现和普通的 jdk 不太一样_ </li>
</ul>
<p><br></p>
<h4 id="使用-Xcode-调试运行"><a href="#使用-Xcode-调试运行" class="headerlink" title="使用 Xcode 调试运行"></a>使用 Xcode 调试运行</h4><p><strong>本来是打算使用 Clion 调试的，无奈 cmake 太难配，看了别人使用 xcode 很顺畅，于是打开了万年不用的 xcode</strong></p>
<ul>
<li>新建项目，名称随意，右键工作目录，点击 add files to (projectname)，导入整个 jdk7u-dev，注意就是你用 hg 命令拉下来的整个仓库，不是 macosx-x86_64-debug 目录</li>
</ul>
<ul>
<li>点击 product->scheme->edit scheme ，在 run -> info 中配置 executable 如下</li>
</ul>
<pre><code>/Users/alberthumbert/jdk7u-dev/build/macosx-x86\_64-debug/bin/java
</code></pre><ul>
<li>同时在这个 executable 的目录下新建一个测试用的java文件，这里用回之前的 hello world</li>
</ul>
<pre><code> public class Hello{
    public static void main(String[] args){
       System.out.println(&quot;Hello World !&quot;);
    }
}
</code></pre><ul>
<li>在 run-> arguements 中配置参数为 hello，那么效果就是 ./java hello，所以你需要先 javac 一下</li>
</ul>
<ul>
<li>在运行之前找到 main.c ，没错，这个就是你所以 java 程序的入口,路径在 /jdk/src/share/bin/main.c 找不到就 find . -iname main.c 一下</li>
</ul>
<pre><code>int
main(int argc, char \*\*argv)
{
    int margc;
    char** margv;
    const jboolean const_javaw = JNI_FALSE;
# endif /\* JAVAW \*/
# ifdef \_WIN32
    {
        int i = 0;
        if (getenv(JLDEBUG_ENV_ENTRY) != NULL) {
            printf(&quot;Windows original main args:\n&quot;);
            for (i = 0 ; i &lt; __argc ; i++) {
                printf(&quot;wwwd_args[%d] = %s\n&quot;, i, __argv[i]);
            }
        }
    }
    JLI_CmdToArgs(GetCommandLine());
    margc = JLI_GetStdArgc();
    // add one more to mark the end
    margv = (char **)JLI_MemAlloc((margc + 1) * (sizeof(char *)));
    {
        int i = 0;
        StdArg *stdargs = JLI_GetStdArgs();
        for (i = 0 ; i &lt; margc ; i++) {
            margv[i] = stdargs[i].arg;
        }
        margv[i] = NULL;
    }
# else /\* *NIXES */
    margc = argc;
    margv = argv;
# endif /\* WIN32 \*/
    return JLI_Launch(margc, margv,
                   sizeof(const_jargs) / sizeof(char *), const_jargs,
                   sizeof(const_appclasspath) / sizeof(char *), const_appclasspath,
                   FULL_VERSION,
                   DOT_VERSION,
                   (const_progname != NULL) ? const_progname : *margv,
                   (const_launcher != NULL) ? const_launcher : *margv,
                   (const_jargs != NULL) ? JNI_TRUE : JNI_FALSE,
                   const_cpwildcard, const_javaw, const_ergo_class);
}
</code></pre><ul>
<li>随便打几个断点，点击运行,先不要急着一头扎进源码，快速让调试结束，如果终端输出如下，恭喜你已经完成了所有任务</li>
</ul>
<pre><code>Hello World !
Program ended with exit code: 0
</code></pre><p><br></p>
<p><img src="https://ws1.sinaimg.cn/large/987832a0gy1fq4aw6xhmdj21kk17m1bi.jpg" alt=""></p>
<p><br></p>
<h4 id="start-the-world"><a href="#start-the-world" class="headerlink" title="start the world"></a>start the world</h4><ul>
<li>接下来我们来调试 HotSpot，在hotspot目录下的jni.cpp中找到 JNI_CreateJavaVM</li>
</ul>
<pre><code>/Users/alberthumbert/jdk7u-dev/hotspot/src/share/vm/prims/jni.cpp
</code></pre><ul>
<li><p>也是随便打上断点，如果你上一步已经成功，那么现在所有的配置参数都不需要改变，直接调试即可</p>
</li>
<li><p><strong> 现在，开始你的深入理解 java 虚拟机之旅吧 ！</strong></p>
</li>
</ul>
<p><br><br><br><br><br></p>
<h3 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h3><p><strong> 废话很多，如果运气好，上面的流程都通过了，下面就不用看了</strong></p>
<p><br></p>
<h4 id="ant-版本过低-1"><a href="#ant-版本过低-1" class="headerlink" title="ant 版本过低"></a>ant 版本过低</h4><pre><code>ERROR: The version of ant being used is older than
   the required version of &apos;1.7.1&apos;.
   The version of ant found was &apos;1.7.0&apos;.
</code></pre><ul>
<li>使用 ant -version ，如果发现版本确实过低，那么下载新版 ant 即可</li>
</ul>
<ul>
<li>然而我的机器上原先就没有 1.7.0 版本的 ant，反复使用 homebrew 安装了 ant，可以确定运行的 ant 版本是最新的，网上的说法是使用软连接将ant链接过去，看了一下源码，确实 openjdk 里面将 ant 目录写死在了/usr/bin/ant，问题是这个 ‘1.7.0’ 的ant到底是哪来的，为什么能找到这个版本的ant</li>
</ul>
<pre><code>sudo ln -s Users/alberthumbert/Desktop/apache-ant-1.10.3/bin/ant /usr/bin/ant
</code></pre><ul>
<li>再看一下make sanity的输出, 上面是我下载的ant，1.10.3 ,但下面的 ANT_VER 却是 1.7.0，这么说来这个 ant 的版本可能跟我指定的 ant 没有关系</li>
</ul>
<pre><code>ANT_HOME = /Users/alberthumbert/Desktop/apache-ant-1.10.3
…
ANT_VER = 1.7.0 [requires at least 1.7.1]
</code></pre><ul>
<li>使用 mdfind 查找 这个ant version 是怎么来的，直接 mdfind “ANT_VER”</li>
</ul>
<pre><code>/Users/alberthumbert/jdk7u-dev/build.sh
/Users/alberthumbert/jdk7u-dev/jaxp/src/com/sun/org/apache/xalan/internal/xslt/EnvironmentCheck.java
/Users/alberthumbert/Desktop/apache-ant-1.10.3/manual/api/org/apache/tools/ant/MagicNames.html
/Users/alberthumbert/Desktop/apache-ant-1.10.3/manual/api/index-all.html
/Users/alberthumbert/Desktop/apache-ant-1.10.3/manual/api/constant-values.html
</code></pre><ul>
<li>上面这个 EnvironmentCheck.java 很可疑，打开看下，有个检查 ant 版本的方法，这里用到反射，理论上查找的就是 ANT_HOME 当中 ant.jar 里的类，还是不明所以</li>
</ul>
<pre><code>/\**    * Report product version information from Ant.
  *    * @param h Hashtable to put information in
  \*/
 protected void checkAntVersion(Hashtable h)
 {
   if (null == h)
     h = new Hashtable();

   try
   {
     final String ANT_VERSION_CLASS = &quot;org.apache.tools.ant.Main&quot;;
     final String ANT_VERSION_METHOD = &quot;getAntVersion&quot;; // noArgs
     final Class noArgs[] = new Class[0];

     Class clazz = ObjectFactory.findProviderClass(ANT_VERSION_CLASS, true);

     Method method = clazz.getMethod(ANT_VERSION_METHOD, noArgs);
     Object returnValue = method.invoke(null, new Object[0]);

     h.put(VERSION + &quot;ant&quot;, (String)returnValue);
   }
   catch (Exception e)
   {
     h.put(VERSION + &quot;ant&quot;, CLASS_NOTPRESENT);
   }
   }
</code></pre><ul>
<li>尝试更换 boostrap jdk 版本，这次使用 1.8.0 然后发现 make sanity 通过了，而输出的配置列表中 ANT_VER 就等于 1.8.0  </li>
</ul>
<pre><code>ANT_VER = 1.8.0 [requires at least 1.7.1]
</code></pre><ul>
<li>下意识的想起之前使用的boostrap jdk 是1.7.0 而提示的 ANT_VER 就是1.7.0，看了下我的机子里还有 1.6.0 的 jdk ，那么用它来编译一下… 黑人问号.jpg ，所以这个 ant 版本就等于 jdk 版本 ？？？WTF ？？？</li>
</ul>
<pre><code>ERROR: The version of ant being used is older than
   the required version of &apos;1.7.1&apos;.
   The version of ant found was &apos;1.6.0.&apos;.
</code></pre><ul>
<li>总结一下，boostrap jdk 版本接近或者大于指定的ant版本，否则设定 ANT_HOME 没有作用，但是网上很多解决办法都是使用后者，可能是平台差异，具体原因不明, 推荐使用Oracle JDK 7u40</li>
</ul>
<p><br></p>
<h4 id="Bootstrap-JDK-版本过高"><a href="#Bootstrap-JDK-版本过高" class="headerlink" title="Bootstrap JDK 版本过高"></a>Bootstrap JDK 版本过高</h4><ul>
<li>如果你尝试使用 JDK 8 去编译 OpenJDK 7 ，那么肯定是行不通的，在 OpenJDK 7 当中，许多 ant 的配置中都指定了 -werror 参数，这个参数意味着参与编译的文件在编译过程中导致的 warnning 都会被视为 error ，而在用 javac 编译 java 文件时又由于 Bootstrap JDK 过高而出现大量的 warnning ，最典型的比如下面这个</li>
</ul>
<pre><code>主版本 52 比 51 新, 此编译器支持最新的主版本。建议升级此编译器
</code></pre><ul>
<li>个人推荐 Oracle JDK 7u40 ，使用这个版本搭配 1.7.1 以上并接近这个版本的 ant</li>
</ul>
<p><br></p>
<h4 id="OS-X-10-10-以上无法安装-Oracle-JDK"><a href="#OS-X-10-10-以上无法安装-Oracle-JDK" class="headerlink" title="OS X 10.10 以上无法安装 Oracle JDK"></a>OS X 10.10 以上无法安装 Oracle JDK</h4><ul>
<li>本来是觉得不需要写这部分内容的，但mac上的 Oracle JDK 有个bug ，在安装旧版本的 jdk 时你可能会收到这样一条提示</li>
</ul>
<pre><code>Java from Oracle requires Mac OS X 10.7.3 or later.
Your system has Mac OS X Version 10.11.6. This product can be installed on Version 10.7.3 or later.
Visit java.com/help for more information.
</code></pre><ul>
<li><p>MDZZ，多么清奇的脑回路，而且这个问题直到 JDK 8 的一些版本都存在，但是我们说过 Bootstrap JDK 版本不能过高，那么怎么安装这个JDK呢，无奈只好帮Oracle 修一波 bug</p>
</li>
<li><p>在 dmg 加载上来之后，用下面命令解压安装包, 第一个路径是你的 dmg 文件，第二个路径是解压目录的目标地址，命名随意</p>
</li>
</ul>
<pre><code>pkgutil --expand /Volumes/JDK\ 7\ Update\ 40/JDK\ 7\ Update\ 40.pkg
</code></pre><ul>
<li>进入解压目录在 Distribution 文件中找到 pm_instal_check() 函数，用什么方法都好，总之让它返回 true</li>
</ul>
<pre><code>function pm\_install\_check() {
//就是这么粗暴
  return true;
}
</code></pre><ul>
<li>重新打包, 然后用这个新的dmg进行安装即可</li>
</ul>
<pre><code>pkgutil --flatten /Users/alberthumbert/Desktop/740.unpkg /Users/alberthumbert/Desktop/jdk740.pkg
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[近期的一些计划]]></title>
      <url>/2018/09/22/Early/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><strong>这个学期准备笔试面试要系统地开始复习了，我大概准备从操作系统，计网，Jvm，并发，Android系统，Android常用框架 这几方面开始入手，笔记会按照下面几个系列来整理，应该会更新得比较勤快，不过基本看心情，所以完全不按顺序</strong></p>
<ul>
<li><p><a href="https://tocreate.app/2018/09/21/OperatingSystem/" target="_blank" rel="external">深入操作系统 系列</a></p>
</li>
<li><p><a href="https://tocreate.app/2018/09/05/net-0/" target="_blank" rel="external">深入计算机网络 系列</a></p>
</li>
<li><p><a href="https://tocreate.app/2018/09/05/jvm/" target="_blank" rel="external">深入 JVM 系列</a></p>
</li>
<li><p><a href="https://tocreate.app/2018/09/05/concurrent/" target="_blank" rel="external">深入 Java 并发 系列</a></p>
</li>
<li><p><a href="https://tocreate.app/2018/09/05/androidSource/" target="_blank" rel="external">深入 Android 系统 系列</a></p>
</li>
<li><p><a href="https://tocreate.app/2018/09/21/ReadAndroidLib/" target="_blank" rel="external">深入 Android 框架源码 系列</a></p>
</li>
</ul>
<p><strong>还有时间可能会去学习Android方面一些进阶的知识，比如模块化，推送等，另外算法方面打算放到寒假开始准备</strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入操作系统 2 - 交叉环境编译 & GCC]]></title>
      <url>/2018/09/22/OSCrossGcc/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><a href="https://tocreate.app/2018/09/21/OperatingSystem/" target="_blank" rel="external">本文为深入操作系统系列的一部分</a></p>
<p><a href="https://tocreate.app/2018/09/21/OSEnv/" target="_blank" rel="external">可能需要阅读前文</a></p>
<p><strong>不需要编写和编译相关例程的非硬核玩家无需阅读此文</strong></p>
<p><br></p>
<h2 id="what-amp-why"><a href="#what-amp-why" class="headerlink" title="what &amp; why"></a>what &amp; why</h2><p><strong>什么是交叉编译器，为什么需要交叉编译器，需要什么样的交叉编译器？</strong></p>
<ul>
<li><p>简单来说，交叉编译器是可以在生产平台上编译可以运行在目标平台上的程序的编译器，这里的生产平台和目标平台可以使用<strong>不同的cpu，不同的操作系统，不同的文件格式</strong></p>
</li>
<li><p>系统：注意上面提到的不同操作系统，不管选择任何操作系统作为开发平台（*nix,win）, 我们编写的系统都不会与选择的系统完全一致（当然前提是有心写一个<strong>自己</strong>的操作系统）</p>
</li>
<li><p>引导：每个操作系统都需要一套启动机制，你完全可以自己去编写引导，但是考虑一下如果每个操作系统都有一套完全不同的机制那将会带来多少麻烦，因此 GRUP 的 mutiboot 规范应运而生，我们的编译器最好能产出复合该规范的文件</p>
</li>
<li><p>文件格式：mutiboot主要面向elf 文件格式并且允许兼容各种 a.out 格式，但是使用 elf 是最省时省力的, 另外 GRUB 只允许引导 32 位的 mutiboot 内核</p>
</li>
<li><p>CPU：目标平台的 cpu 不同使用的编译器也不一样，举例来说同样是intel的 cpu 如果我们的机器比较旧你可能会需要 i386 的编译器，反之则可能是 i686</p>
</li>
</ul>
<p><br></p>
<h2 id="搭建跨平台-GCC"><a href="#搭建跨平台-GCC" class="headerlink" title="搭建跨平台 GCC"></a>搭建跨平台 GCC</h2><p><br></p>
<h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p><br></p>
<h4 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h4><ul>
<li>从源码编译 gcc 首先需要一个 gcc，就像编译 openjdk 需要一个oracle jdk 一样 鸡和蛋的问题，建议用最新的 gcc</li>
</ul>
<pre><code>brew install gcc
</code></pre><ul>
<li>mac 上 gcc 默认指向的是 clang，其实不是gcc所以你需要用别名替换替换掉</li>
</ul>
<pre><code>alias gcc=&apos;gcc-8&apos;
alias g++=&apos;g++-8&apos;
alias c++=&apos;c++-8&apos;
</code></pre><p><br></p>
<h4 id="GMP"><a href="#GMP" class="headerlink" title="GMP"></a>GMP</h4><ul>
<li><p>用于高精度计算的c函数库，这个我用 homebrew 没有安装成功，就手动编译了，不过可能是因为当时 homebrew 版本比较旧，更新之后没试过，估计现在用 homebrew 也行吧</p>
</li>
<li><p>在下面网站下载 bz2 的压缩包，注意是 bz2</p>
</li>
</ul>
<pre><code>https://gmplib.org/
</code></pre><ul>
<li>执行</li>
</ul>
<pre><code>sudo cp gmp-6.1.2.tar.bz2 /usr/local/lib
cd /usr/local/lib
bzip2 -d -k gmp-6.1.2.tar.bz2
tar -xvf gmp-6.1.2.tar
 cd gmp-6.1.2
./configure
make
make check
make install
</code></pre><ul>
<li>如果要测试是否安装成功可以试着写个小程序 #include \<gmp.h\>，然后用 gcc -lgmp 编译一下</gmp.h\></li>
</ul>
<p><br></p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li>接下来的依赖我就不一一描述了，用 homebrew 就可以安装</li>
</ul>
<pre><code>brew install bison
brew install flex
brew install libmpc
brew install texinfo
brew install CLooG
brew install binutils
brew install libiconv
</code></pre><p><br></p>
<h4 id="ISL"><a href="#ISL" class="headerlink" title="ISL"></a>ISL</h4><ul>
<li>使用 homebrew安装的 ISL 过于新，和 gcc 源码不兼容，虽然可以用很骚的方法指定 homebrew 安装版本，但是从源码安装会方便很多</li>
</ul>
<ul>
<li>这里推荐使用 <a href="http://isl.gforge.inria.fr/" target="_blank" rel="external">0.18</a> ，最好不要低于 0.15</li>
</ul>
<pre><code>./config
make
</code></pre><p><br></p>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><ul>
<li>在下面这个网站中下载源码，建议源码版本不要比现在使用的gcc版本新</li>
</ul>
<pre><code>https://ftp.gnu.org/gnu/gcc/
</code></pre><ul>
<li>下载 Binutils 源码, gcc 版本最好与 binutils相近</li>
</ul>
<pre><code>https://ftp.gnu.org/gnu/binutils/
</code></pre><p><br></p>
<h4 id="编译-cross-compile-gcc"><a href="#编译-cross-compile-gcc" class="headerlink" title="编译 cross-compile gcc"></a>编译 cross-compile gcc</h4><ul>
<li>设置编译目录</li>
</ul>
<pre><code>export PREFIX=&quot;$HOME/opt/cross&quot;
export TARGET=i686-elf
export PATH=&quot;$PREFIX/bin:$PATH&quot;
</code></pre><ul>
<li>编译 binutils</li>
</ul>
<pre><code>cd $HOME/src
mkdir build-binutils
cd build-binutils
../binutils-x.y.z/configure --target=$TARGET --prefix=&quot;$PREFIX&quot; --with-sysroot --disable-nls --disable-werror
make
make install
</code></pre><ul>
<li>编译 gcc</li>
</ul>
<pre><code>cd $HOME/src
# The $PREFIX/bin dir _must_ be in the PATH. We did that above.
which -- $TARGET-as || echo $TARGET-as is not in the PATH
mkdir build-gcc
cd build-gcc
../gcc-x.y.z/configure --target=$TARGET --prefix=&quot;$PREFIX&quot; --disable-nls --enable-languages=c,c++ --without-headers
make all-gcc
make all-target-libgcc
make install-gcc
make install-target-libgcc
</code></pre><ul>
<li>注意如果是使用上面建议的手动编译 ISL，需要在 configure 后面加入参数</li>
</ul>
<pre><code>--with-isl=...(编译目录)
</code></pre><p><br></p>
<h4 id="使用-cross-gcc"><a href="#使用-cross-gcc" class="headerlink" title="使用 cross-gcc"></a>使用 cross-gcc</h4><ul>
<li>真个系列极为重要的第一步已经完成了</li>
</ul>
<pre><code>$HOME/opt/cross/bin/$TARGET-gcc --version


    i686-elf-gcc (GCC) 8.1.0
Copyright (C) 2018 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
</code></pre><ul>
<li>也可以添加到环境变量</li>
</ul>
<pre><code>export PATH=&quot;$HOME/opt/cross/bin:$PATH&quot;
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入操作系统 1 - 源码获取 & 编译调试]]></title>
      <url>/2018/09/21/OSEnv/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><a href="https://tocreate.app/2018/09/05/OperatingSystem/" target="_blank" rel="external">本文为深入操作系统系列的一部分</a></p>
<p><strong>通过下面的xv6编译可以了解一个操作系统从编译到bochs和qemu调试运行的整个流程，这里的编译环境其实是提供好的了，只是下载下来而已，如果你不是硬核玩家，那么走这个流程就足够了</strong></p>
<p><strong>调试linux内核的流程则有些不同，因为linux允许你在boot阶段选择不同的内核，所以你需要做的是编译内核并将其放到指定的位置</strong></p>
<p><strong> 另外，如果你就是那位打算手写操作系统的硬核玩家，那么你需要了解为什么需要交叉编译，怎么编译一个gcc交叉编译器，什么是 bootstrap 等等 ，这部分内容我会慢慢补充</strong></p>
<p><br></p>
<h2 id="xv6"><a href="#xv6" class="headerlink" title="xv6"></a>xv6</h2><p><br></p>
<h3 id="安装配置-bochs"><a href="#安装配置-bochs" class="headerlink" title="安装配置 bochs"></a>安装配置 bochs</h3><ul>
<li><p>bochs 是一个用于执行与调试内核镜像的虚拟机</p>
</li>
<li><p>安装 bochs</p>
</li>
</ul>
<pre><code>$ brew install bochs
</code></pre><ul>
<li>可能会遇到如下错误</li>
</ul>
<pre><code>/usr/local/share/man/man5 is not writable
</code></pre><ul>
<li>出现该错误时 bochs 已经成功安装，但需要另外执行</li>
</ul>
<pre><code>$ sudo chown -R $(whoami):admin /usr/local/share/man/man5
$ brew link bochs
</code></pre><ul>
<li>如无意外现在可执行 bochs</li>
</ul>
<pre><code>$ bochs
1. Restore factory default configuration
2. Read options from...
3. Edit options
4. Save options to...
5. Restore the Bochs state from...
6. Begin simulation
7. Quit now
</code></pre><p><br></p>
<h3 id="安装-qemu"><a href="#安装-qemu" class="headerlink" title="安装 qemu"></a>安装 qemu</h3><pre><code>$ brew install qemu
</code></pre><ul>
<li>同样可能出现如下错误</li>
</ul>
<pre><code>/usr/local/share/man/man8 is not writable.
</code></pre><ul>
<li>对于该错误，你应该知道该怎么做了</li>
</ul>
<pre><code>$ sudo chown -R $(whoami):admin /usr/local/share/man/man8
</code></pre><ul>
<li>如无意外现在可执行</li>
</ul>
<pre><code>$ qemu-system-x86\_64
</code></pre><p><br></p>
<h3 id="获取源码"><a href="#获取源码" class="headerlink" title="获取源码"></a>获取源码</h3><ul>
<li>在github 上可获取 xv6 的代码仓库,注意这里是 git://而不是 https:// ，使用 ssh 来 clone 是为了防止 tag 太大而出错，在某些版本的git会出现这个问题 </li>
</ul>
<pre><code>$ git clone git://github.com/mit-pdos/xv6-public.git
</code></pre><p><br></p>
<h3 id="安装-MacPorts"><a href="#安装-MacPorts" class="headerlink" title="安装 MacPorts"></a>安装 MacPorts</h3><ul>
<li>请在该页面下载对应版本的 pkg 并安装  </li>
</ul>
<pre><code>https://www.macports.org/install.php
</code></pre><ul>
<li>安装过程可能会卡死，强制关闭下载器，找到相关进程 kill -9 杀死，重启，断网，再安装，具体原因不清楚</li>
</ul>
<pre><code>ps aux | grep install
</code></pre><ul>
<li>在 /etc/profile 中加入</li>
</ul>
<pre><code>export PATH=/opt/local/bin:$PATH
export PATH=/opt/local/sbin:$PATH
</code></pre><ul>
<li>更新 port, 时间比较长</li>
</ul>
<pre><code>sudo port -v selfupdate
</code></pre><h3 id="安装交叉编译器编译器"><a href="#安装交叉编译器编译器" class="headerlink" title="安装交叉编译器编译器"></a>安装交叉编译器编译器</h3><ul>
<li>安装 i386-elf-gcc</li>
</ul>
<pre><code>sudo port install i386-elf-gcc
</code></pre><p><br></p>
<h3 id="编译-xv6"><a href="#编译-xv6" class="headerlink" title="编译 xv6"></a>编译 xv6</h3><ul>
<li>老实说，到上一步我就没往下走了，因为打算自己编译交叉环境的gcc，这里就留个大致流程</li>
</ul>
<pre><code>$ cd xv6-public
$ make
</code></pre><p><br></p>
<h3 id="调试运行"><a href="#调试运行" class="headerlink" title="调试运行"></a>调试运行</h3><pre><code>$ make qemu-nox
</code></pre><p><br></p>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p><br></p>
<h3 id="获取内核源码"><a href="#获取内核源码" class="headerlink" title="获取内核源码"></a>获取内核源码</h3><ul>
<li>你可以在这个网站中获取 linux 内核进十年的各个版本（分支）</li>
</ul>
<pre><code>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git
</code></pre><ul>
<li>本人使用的是v2.6, –depth=1是只下载最近的commit，不然仓库太大会导致出错，说实在也不需要整个仓库下载下来</li>
</ul>
<pre><code>git clone --depth=1 git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6.git
</code></pre><p><br></p>
<h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><ul>
<li>Linux的编译比较简单，坑也比较好找到解决反正，网上文章非常多，这里就不写了</li>
</ul>
<p><br></p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p><br></p>
<h3 id="Android-源码获取"><a href="#Android-源码获取" class="headerlink" title="Android 源码获取"></a>Android 源码获取</h3><ul>
<li>我并不打算下载或编译 Android 系统源码，这里只给一个方便阅读源码的地方</li>
</ul>
<pre><code>http://androidxref.com/
</code></pre><p><br></p>
<h3 id="minix-源码获取"><a href="#minix-源码获取" class="headerlink" title="minix 源码获取"></a>minix 源码获取</h3><pre><code>git clone git://github.com/Stichting-MINIX-Research-Foundation/minix.git
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入操作系统 - 进程控制]]></title>
      <url>/2018/09/21/OSProcess/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><a href="https://tocreate.app/2018/09/05/OperatingSystem/" target="_blank" rel="external">本文为深入操作系统系列的一部分</a></p>
<p><br></p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p><br></p>
<h3 id="创建和运行"><a href="#创建和运行" class="headerlink" title="创建和运行"></a>创建和运行</h3><p><br></p>
<h4 id="fork-与-exec"><a href="#fork-与-exec" class="headerlink" title="fork 与 exec"></a>fork 与 exec</h4><p><br></p>
<h4 id="xv6-上的实现"><a href="#xv6-上的实现" class="headerlink" title="xv6 上的实现"></a>xv6 上的实现</h4><p><br></p>
<h4 id="linux-上的实现"><a href="#linux-上的实现" class="headerlink" title="linux 上的实现"></a>linux 上的实现</h4><p><br></p>
<h3 id="第一个进程"><a href="#第一个进程" class="headerlink" title="第一个进程"></a>第一个进程</h3><p><br></p>
<h4 id="linux-与-init"><a href="#linux-与-init" class="headerlink" title="linux 与 init"></a>linux 与 init</h4><p><br></p>
<h4 id="xv6-与-userinit"><a href="#xv6-与-userinit" class="headerlink" title="xv6 与 userinit"></a>xv6 与 userinit</h4><p><br></p>
<h4 id="Android-zygote-与-内核-init"><a href="#Android-zygote-与-内核-init" class="headerlink" title="Android zygote 与 内核 init"></a>Android zygote 与 内核 init</h4><ul>
<li>严格来说，这部分内容不应该放在这里，但是，顺便了解一下</li>
</ul>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入操作系统 系列 0]]></title>
      <url>/2018/09/21/OperatingSystem/</url>
      <content type="html"><![CDATA[<p><strong> 程序员的三大浪漫，编译原理，图形学，操作系统 </strong></p>
<a id="more"></a>
<p><strong>本文主要内容来自以下书籍和操作系统相关的网络博客文章</strong></p>
<p><strong>  OSDev社区</strong><br><strong>《计算机操作系统（第四版）》</strong><br><strong>《操作系统设计与实现（第三版）》</strong><br><strong>《Linux内核设计与实现（第三版）》</strong><br><strong><a href="https://th0ar.gitbooks.io/xv6-chinese/content/content/cover.html" target="_blank" rel="external">《xv6 一个简单，类 Unix 的教学操作系统》</a></strong></p>
<p><strong>另外，建议学习操作系统之前先系统地学习计算机组成原理，否则 io，中断等硬件相关的内容将会比较难以理解。推荐《计算机组成与设计：软件/硬件接口》</strong></p>
<p><br></p>
<h2 id="基础环境"><a href="#基础环境" class="headerlink" title="基础环境"></a>基础环境</h2><p><strong>包括了 xv6 ,linux 内核，minix, android 系统的源码获取和部分基础环境的搭建，篇幅较长，跳转到专门的文章，下同</strong></p>
<p><a href="https://tocreate.app/2018/09/21/OSEnv/" target="_blank" rel="external">详见</a></p>
<p><br></p>
<h2 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h2><p><strong>编译一个 GCC Cross-Compiler</strong></p>
<p><a href="https://tocreate.app/2018/09/22/OSCrossGcc/" target="_blank" rel="external">详见</a></p>
<p><br></p>
<h2 id="引导"><a href="#引导" class="headerlink" title="引导"></a>引导</h2><p><strong>制作并引导一个简单镜像</strong></p>
<p><a href="https://tocreate.app/2018/10/15/OSBootstrap/" target="_blank" rel="external">详见</a></p>
<p><br></p>
<h2 id="系统库函数"><a href="#系统库函数" class="headerlink" title="系统库函数"></a>系统库函数</h2><p><strong>搭建最基本的开发环境</strong><br><a href="https://tocreate.app/2018/10/15/OSBaseLib/" target="_blank" rel="external">详见</a></p>
<p><br></p>
<h2 id="内核与系统调用"><a href="#内核与系统调用" class="headerlink" title="内核与系统调用"></a>内核与系统调用</h2><ul>
<li><p>内核概念是一个向其他运行中程序提供服务的特殊程序</p>
</li>
<li><p>进程通过系统调用使用内核服务。系统调用会进入内核，让内核执行服务然后返回</p>
</li>
<li><p>内核提供的一系列系统调用就是用户程序可见的操作系统接口</p>
</li>
</ul>
<p><br></p>
<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p><a href="https://tocreate.app/2018/09/21/OSProcess/" target="_blank" rel="external">详见</a></p>
<p><br><br><br></p>
<p><strong>待续</strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入 Android 框架源码 系列]]></title>
      <url>/2018/09/21/ReadAndroidLib/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><strong>这学期Android框架源码分析文章的索引</strong><br><strong>这里的框架指的是Android官方或常用的第三方应用开发框架</strong></p>
<p><br></p>
<h3 id="Android-SDK"><a href="#Android-SDK" class="headerlink" title="Android SDK"></a>Android SDK</h3><p><br></p>
<h3 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h3>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入 Android 系统 系列]]></title>
      <url>/2018/09/05/androidSource/</url>
      <content type="html"><![CDATA[<ul>
<li>不一定开的坑</li>
</ul>
<a id="more"></a>
<p><strong>比较贴近业务相关的框架的文章写在另一个<a href="https://tocreate.app/2018/09/21/ReadAndroidLib/" target="_blank" rel="external">系列</a></strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入计算机网络 系列]]></title>
      <url>/2018/09/05/net-0/</url>
      <content type="html"><![CDATA[<ul>
<li>假装深入</li>
</ul>
<a id="more"></a>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入 Java 并发 系列]]></title>
      <url>/2018/09/05/concurrent/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入 Jvm 系列 0]]></title>
      <url>/2018/09/05/jvm/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><br></p>
<h2 id="编译与调试"><a href="#编译与调试" class="headerlink" title="编译与调试"></a>编译与调试</h2><p><strong>在mac平台上编译OpenJdk和HotSpot，如果没有兴趣，下载一份源码也是好的</strong></p>
<p><strong>编译与ide调试 <a href="http://tocreate.app/2018/09/26/JVMCompileOpenJdk7/" target="_blank" rel="external">详见</a></strong><br><strong>gdb 调试 <a href="https://tocreate.app/2018/10/17/JVMUseGdb/" target="_blank" rel="external">详见</a></strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[计算机网络 学习笔记]]></title>
      <url>/2018/06/17/ComputerNetwork/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><br></p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><br></p>
<h2 id="互联网"><a href="#互联网" class="headerlink" title="互联网"></a>互联网</h2><p><br></p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li><p>互联网(Internet、因特网)： 指由APPANET发展而来、采用 TCP/IP 协议族作为通信的规则的特定的计算机网络</p>
</li>
<li><p>互联网的组成：边缘部分（连接在互联网上的所有主机）、核心部分（由网络与路由器组成）</p>
</li>
</ul>
<p><br></p>
<h3 id="边缘部分，主机间的通信模式"><a href="#边缘部分，主机间的通信模式" class="headerlink" title="边缘部分，主机间的通信模式"></a>边缘部分，主机间的通信模式</h3><ul>
<li><p>客户端/服务器模式（C/S，Client/Server），描述进程之间服务和被服务的关系。客户知道服务器的地址并主动发起请求，不需要特殊的硬件和很复杂的操作系统。服务器同时被动处理多个请求，一般需要更强大的硬件支持</p>
</li>
<li><p>浏览器/服务器模式（B/S，Browser/Server）</p>
</li>
</ul>
<ul>
<li>对等模式（P2P，Peer-to-Peer），连接中的每一台主机即是客户又是服务器</li>
</ul>
<p><br></p>
<h3 id="核心部分，数据交换"><a href="#核心部分，数据交换" class="headerlink" title="核心部分，数据交换"></a>核心部分，数据交换</h3><ul>
<li><p>数据交换方式分为电路交换，报文交换，分组交换，互联网使用分组交换</p>
</li>
<li><p>电路交换：先建立源点到终点的链路，然后整个报文的比特流连续地从源点直达终点，通话的全部时间内，两个用户始终占用端到端的通信资源</p>
</li>
<li><p>报文交换：整个报文先传送到相邻结点，全部存储下来后查找转发表，转发到下一个结点，需要各结点存储转发</p>
</li>
<li><p>分组交换：单个分组（这只是整个报文的一部分）传送到相邻结点，存储下来后查找转发表，转发到下一个结点。需要各结点存储转发</p>
</li>
</ul>
<p><br></p>
<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><p><strong> 计算机网络：一些互相连接的、自治的计算机的集合 </strong></p>
<p><br></p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li><p>广域网（WAN）</p>
</li>
<li><p>城域网（MAN）</p>
</li>
<li><p>局域网（LAN）</p>
</li>
<li><p>个人区域网（PAN）</p>
</li>
</ul>
<p><br></p>
<h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><p><br></p>
<h4 id="速率与带宽"><a href="#速率与带宽" class="headerlink" title="速率与带宽"></a>速率与带宽</h4><ul>
<li><p>速率（信息速率、码元速率），单位 bit/s，b/s，bps，k = 10的3次方，M = 10的6次方，G = 10的9次方，T = 10的12次方</p>
</li>
<li><p>带宽，通道传递数据的能力，即所能通过的最高数据率，单位 bit/s</p>
</li>
</ul>
<p><br></p>
<h4 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h4><pre><code>总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延
</code></pre><ul>
<li>发送时延，数据路由发送数据帧所需要的时间</li>
</ul>
<pre><code>发送时延 = 数据帧长度(bit)/发送速率(bit/s)
</code></pre><ul>
<li>传播时延，电磁波在信道中传播一定距离需要的时间</li>
</ul>
<pre><code>传播时延 = 信道长度(m)/电磁波在信道上的传播速率(m/s)
</code></pre><ul>
<li>处理时延，主机或路由器处理分组花费的时间</li>
</ul>
<ul>
<li>排队时延，分组在路由器中排队等待处理的时间，丢包时为无限大</li>
</ul>
<ul>
<li>时延带宽积，以bit为单位的链路长度</li>
</ul>
<pre><code>时延带宽积 = 传播时延 \* 带宽
</code></pre><ul>
<li>往返时间（RTT），双向交互的时间</li>
</ul>
<pre><code>有效数据率 = 数据长度/（发送时间+RTT）
</code></pre><p><br></p>
<h4 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h4><ul>
<li><p>信道利用率，信道有百分之几的时间被利用</p>
</li>
<li><p>网络利用率，全网络信道利用率的加权平均值</p>
</li>
</ul>
<pre><code>D = D0/(1-U) 
D表示网络当前的时延，D0表示网络空闲时的时延，U表示网络的利用率
</code></pre><p><br></p>
<h3 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h3><ul>
<li><p>网络协议：为进行网络中心的数据交换而建立的规则、标准或约定，主要由语法、语义、同步三个要素组成</p>
</li>
<li><p>语法：数据与控制信息的结构或格式</p>
</li>
<li><p>语义：需要发出何种控制信息，完成何种动作以及做出何种响应</p>
</li>
<li><p>同步：事件实现顺序的详细说明</p>
</li>
</ul>
<p><br></p>
<h2 id="网络的体系结构"><a href="#网络的体系结构" class="headerlink" title="网络的体系结构"></a>网络的体系结构</h2><p><strong> 网络的体系结构（Architecture）：计算机网络的各层及其协议的集合，是对该网络及其构件所应完成的功能的精确定义 </strong></p>
<p><br></p>
<h3 id="网络分层"><a href="#网络分层" class="headerlink" title="网络分层"></a>网络分层</h3><ul>
<li><p>网络各层的主要功能：差错控制、流量控制、分段与重装、复用和分用、连接建立和释放</p>
</li>
<li><p>协议：对等实体间进行通信的规则，协议必须能应付各种可能的情况。协议是水平的</p>
</li>
<li><p>服务：下层为上层提供服务。上下层实体进行信息交互的地方称为服务访问点SAP。服务是垂直的</p>
</li>
</ul>
<p><br></p>
<h3 id="OSI-七层协议，TCP-IP-四层协议-五层协议"><a href="#OSI-七层协议，TCP-IP-四层协议-五层协议" class="headerlink" title="OSI 七层协议，TCP/IP 四层协议, 五层协议"></a>OSI 七层协议，TCP/IP 四层协议, 五层协议</h3><ul>
<li><p>OSI的七层协议：物理层，数据链路层，网络层，运输层，会话层，表示层，应用层</p>
</li>
<li><p>TCP/IP的四层协议：网络接口层，网际层IP，运输层，应用层</p>
</li>
<li><p>五层协议：物理层，数据链路层，网络层，运输层，应用层</p>
</li>
</ul>
<p><br></p>
<h3 id="各层作用"><a href="#各层作用" class="headerlink" title="各层作用"></a>各层作用</h3><ul>
<li>应用层：直接为用户的应用进程提供特定的服务</li>
</ul>
<ul>
<li><p>运输层：负责向两个主机中进程之间的通信提供通用的数据传输服务。运输层有复用和分用的功能。运输层提供端到端的通信服务</p>
</li>
<li><p>网络层：负责为分组交换网上的不同主机提供通信服务，其中包括封装成包和路由选择。网络层提供主机到主机的通信服务</p>
</li>
</ul>
<ul>
<li>数据链路层：将网络层交下来的IP数据报组装成帧，在两个相邻结点间的链路上“透明”地传送帧中的数据。链路层提供两相邻结点（点到点）的通信服务</li>
</ul>
<ul>
<li>物理层：透明地传送比特流。物理层要确定信号形式、物理接口规则。物理媒体不属于物理层，处于物理层的下面</li>
</ul>
<p><br></p>
<h3 id="各层的协议数据单元"><a href="#各层的协议数据单元" class="headerlink" title="各层的协议数据单元"></a>各层的协议数据单元</h3><ul>
<li><p>应用层：消息（message）</p>
</li>
<li><p>运输层：段（segment、数据报datagram）</p>
</li>
<li><p>网络层：分组（packet）</p>
</li>
<li><p>链路层：帧（frame）</p>
</li>
<li><p>物理层：bit（信号）</p>
</li>
</ul>
<p><br></p>
<h3 id="网络设备"><a href="#网络设备" class="headerlink" title="网络设备"></a>网络设备</h3><ul>
<li><p>应用层（主机）</p>
</li>
<li><p>网络层（路由器）</p>
</li>
<li><p>链路层（交换机、网桥、网络适配器）</p>
</li>
<li><p>物理层（集线器、转发器、中继器、调制解调器）</p>
</li>
</ul>
<p><br></p>
<h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><p><strong> 物理层的主要任务：确定与传输媒体的接口有关的一些特性；即机械特性，电气特性，功能特性，过程特性。 物理层可实现在传输媒体上透明地传送比特流 </strong></p>
<p><br></p>
<h2 id="数字通信系统模型"><a href="#数字通信系统模型" class="headerlink" title="数字通信系统模型"></a>数字通信系统模型</h2><ul>
<li><p>数字通信系统可划分为，源系统（发送端），传输系统（传输网络），目的系统（接收端）</p>
</li>
<li><p>源系统包括，源点（信源），发送器，接收器，终点</p>
</li>
</ul>
<p><br></p>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><ul>
<li><p>单工，只有一个方向的通信，没有反方向的交互</p>
</li>
<li><p>半双工，双方都能发送信息，但不能同时发送</p>
</li>
<li><p>全双工，双方都能同时发送和接受消息</p>
</li>
<li><p>基带信号：来自信源的（未经调制的）信号</p>
</li>
<li><p>带通信号：经过载波调制后的信号</p>
</li>
<li><p>调制：用高频率载波携带信号进行传输的过程</p>
</li>
<li><p>最基本的调制方法：调频，调幅，调相（载波的频率、振幅、相位携带信号进行传输）</p>
</li>
<li><p>信噪比,信号的平均功率和噪声的平均功率之比</p>
<p>  信噪比(dB) = 10lg(S/N) </p>
</li>
<li><p>香农公式, 信道极限信息传输速率</p>
<p>  C=Wlog2(1+S/N) W为带宽</p>
</li>
</ul>
<p><br></p>
<h2 id="传输媒体"><a href="#传输媒体" class="headerlink" title="传输媒体"></a>传输媒体</h2><ul>
<li><p>传输媒体类型：导引型，非导引型（按有线无线分类）</p>
</li>
<li><p>双绞线类型：无屏蔽双绞线，屏蔽双绞线（双绞线是两根绝缘铜导线绞合成的物理线路，按有无再套一层屏蔽层进行分类）</p>
</li>
<li><p>光纤类型：多模光纤，单模光纤（利用光反射的物理线路，按能否支持多条光线同时传输进行分类）</p>
</li>
</ul>
<p><br></p>
<h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h2><p><strong>多路复用：在一个物理信道中实现多个逻辑信道，可同时传输多路信号</strong></p>
<ul>
<li><p>频分复用FDM：多路信号占用不同的频带进行多路复用</p>
</li>
<li><p>时分复用TDM：多路信号占用不同的时隙进行多路复用</p>
</li>
<li><p>统计时分复用STDM：按需动态分配时隙</p>
</li>
<li><p>波分复用WDM：多路光信号采用不同波段的光载波进行多路复用，是光的频分复用</p>
</li>
<li><p>密集波分复用DWDM：一根光纤上复用多路数的光载波信号</p>
</li>
<li><p>码分复用CDM：各用户使用经过特殊挑选的相互正交的码序列进行扩频通信，从而实现的多路复用</p>
</li>
</ul>
<p><br></p>
<h2 id="数字传输系统标准化"><a href="#数字传输系统标准化" class="headerlink" title="数字传输系统标准化"></a>数字传输系统标准化</h2><ul>
<li><p>脉码调制PCM：通过抽样、量化、编码过程将模拟信号数字化</p>
</li>
<li><p>准同步数字系列PDH：由于历史原因而产生的两套互不兼容的数字序列。其一次群为两个互不兼容的PCM标准：T1：1.544Mb/s（美国、日本）；E1：2.048Mb/s（中国、欧洲）</p>
</li>
<li><p>同步数字系列SDH：世界统一的数字传输系列。其第一级同步传输模块STM-1：155.52Mb/s，更高等级模块由N个STM-1构成</p>
</li>
</ul>
<p><br></p>
<h2 id="因特网的宽带接入方法"><a href="#因特网的宽带接入方法" class="headerlink" title="因特网的宽带接入方法"></a>因特网的宽带接入方法</h2><p><br></p>
<h3 id="ADSL"><a href="#ADSL" class="headerlink" title="ADSL"></a>ADSL</h3><p><strong>非对称数据用户线，即用数字技术对现有的模拟电话用户线进行改造</strong></p>
<ul>
<li><p>非对称，下行带宽远远大于上行带宽</p>
</li>
<li><p>传输距离取决于用户线的粗细</p>
</li>
<li><p>需要在用户线两端各安装一个调制解调器（ATU）</p>
</li>
<li><p>VDSL，ADSL的高速版本；SDSL，ADSL的企业版本（平均分配上下行带宽）</p>
</li>
</ul>
<p><br></p>
<h3 id="HFC"><a href="#HFC" class="headerlink" title="HFC"></a>HFC</h3><p><strong>光纤同轴混合网，利用有线电视网开发的一种接入网</strong></p>
<ul>
<li><p>将有线电视网的同轴电缆主干部分换成光纤</p>
</li>
<li><p>原有模拟电视机需加装机顶盒</p>
</li>
</ul>
<p><br></p>
<h3 id="FTTx"><a href="#FTTx" class="headerlink" title="FTTx"></a>FTTx</h3><p><strong>Fiber to xxx</strong></p>
<ul>
<li><p>无源光配线网（ODN），光配线网中无需配备电源，维护成本很低</p>
</li>
<li><p>光线路终端OLT，连接光纤干线的终端设备，把下行数据发往无缘的 1：N 光分路由器，然后用广播的方式向所有用户端的光网络单元 ONU 发送</p>
</li>
<li><p>采用波分复用</p>
</li>
</ul>
<p><br></p>
<h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><p><br></p>
<h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><ul>
<li><p>数据链路层将网络层IP数据报组装成帧，提供结点到结点的透明传输</p>
</li>
<li><p>链路：是一条无源的点到点的物理线路段，中间没有任何其他的交换结点</p>
</li>
<li><p>数据链路：除了物理线路外，还必须有通信协议来控制这些数据的传输，若把实现这些协议的硬件和软件加到链路上，就构成了数据链路</p>
</li>
</ul>
<p><br></p>
<h2 id="三个基本问题"><a href="#三个基本问题" class="headerlink" title="三个基本问题"></a>三个基本问题</h2><p><br></p>
<h3 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h3><ul>
<li><p>封装成帧：在一段数据后面添加首部和尾部，构成一个帧</p>
</li>
<li><p>首部和尾部的作用是进行帧定界，和携带必要的控制信息</p>
</li>
<li><p>数据部分不能大于 MTU（最大传输单元）</p>
</li>
<li><p>帧定界使用特殊的帧定界字符，SOH（00000001），表示首部的开始，EOT（00000100），表示帧结束，只有 SOH 没有 EOT 的帧会被丢弃</p>
</li>
</ul>
<p><br></p>
<h3 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h3><ul>
<li><p>透明传输：数据链路层对数据来说是透明的，不需要主动适应数据链路层的具体设计，为此，数据中碰巧出现的定界符需要数据链路层自行处理</p>
</li>
<li><p>解决方式是字节填充，向下传输时在 SOH 和 EOT 前面插入 ESC（1B，00011011），向上传输时去掉这些填充的字符</p>
</li>
</ul>
<p><br></p>
<h3 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h3><ul>
<li>差错检测：比特差错，比特传输过程中可能出现差错，1变为0或0变为1；帧差错：帧丢失，帧重复，帧失序（在运输层处理）</li>
</ul>
<ul>
<li>解决方式是使用 CRC 校验，有差错的帧会被简单的丢弃不做处理</li>
</ul>
<p><br></p>
<h2 id="PPP协议"><a href="#PPP协议" class="headerlink" title="PPP协议"></a>PPP协议</h2><p><strong>点对点协议，用于拨号电话线接入因特网</strong></p>
<p><br></p>
<h3 id="帧结构"><a href="#帧结构" class="headerlink" title="帧结构"></a>帧结构</h3><p><br></p>
<h4 id="首部"><a href="#首部" class="headerlink" title="首部"></a>首部</h4><ul>
<li><p>首部，共四个字段，简记为 F A C 协议，分别为 1，1，1，2 字节</p>
</li>
<li><p>F（0x7e，表示帧开始）</p>
</li>
<li><p>A（0xFF,无意，未使用）</p>
</li>
<li><p>C（0x03，无意，未使用）</p>
</li>
<li><p>协议（协议标记，如 0x0021，0xC021，0x8021，信息部分为ip数据报，LCP数据，网络层的控制数据）</p>
</li>
</ul>
<p><br></p>
<h4 id="信息部分"><a href="#信息部分" class="headerlink" title="信息部分"></a>信息部分</h4><ul>
<li><p>经过字节填充的数据</p>
</li>
<li><p>类型由首部协议字段指定</p>
</li>
</ul>
<p><br></p>
<h4 id="尾部"><a href="#尾部" class="headerlink" title="尾部"></a>尾部</h4><ul>
<li><p>尾部，共两个字段，简记为 FCS F ，分别为 2，1 字节</p>
</li>
<li><p>FCS，CRC帧检验序列</p>
</li>
<li><p>F（0x7e，表示帧结束）</p>
</li>
</ul>
<p><br></p>
<h3 id="字节填充"><a href="#字节填充" class="headerlink" title="字节填充"></a>字节填充</h3><ul>
<li><p>每一个 0x7e 转变为 0x7d 0x5e</p>
</li>
<li><p>每一个 0x7d 转变为 0x7d 0x5d</p>
</li>
<li><p>小于 0x20 （ascii控制字符），转变为 0x7d 0x..（该字符）</p>
</li>
<li><p>接收端需要进行相反的转换还原原本的信息</p>
</li>
</ul>
<p><br></p>
<h4 id="零比特填充"><a href="#零比特填充" class="headerlink" title="零比特填充"></a>零比特填充</h4><ul>
<li><p>每5个连续的1后面填0</p>
</li>
<li><p>接收端需要进行相反的转换还原原本的信息</p>
</li>
</ul>
<p><br></p>
<h2 id="CSMA-CD协议"><a href="#CSMA-CD协议" class="headerlink" title="CSMA/CD协议"></a>CSMA/CD协议</h2><p><strong>载波监听多点接入/碰撞检测，用于局域网(以太网)</strong></p>
<h3 id="以太网的特点"><a href="#以太网的特点" class="headerlink" title="以太网的特点"></a>以太网的特点</h3><ul>
<li><p>无连接的工作方式，不建立连接，不进行帧编号，不要求发挥确认，帧错误直接丢弃</p>
</li>
<li><p>使用曼切斯特编码</p>
</li>
</ul>
<h3 id="CSMA-CD的特点"><a href="#CSMA-CD的特点" class="headerlink" title="CSMA/CD的特点"></a>CSMA/CD的特点</h3><ul>
<li><p>多点接入：许多计算机以多点接入的方式连接在一根总线上</p>
</li>
<li><p>载波监听：每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞</p>
</li>
</ul>
<ul>
<li><p>碰撞检测：计算机边发送数据边检测信道上的信号电压大小。 为了能及时发现碰撞，需要设置最小帧长，以太网的争用期</p>
</li>
<li><p>使用 CSMA/CD 协议只能进行半双工，但有些全双工的通信方式取用了 CSMA/CD 帧结构</p>
</li>
</ul>
<p><br></p>
<h3 id="碰撞检测"><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测</h3><ul>
<li><p>根据电压检测是否有碰撞，有就随机等待一段时间再发</p>
</li>
<li><p>碰撞有可能发生在数据发送过程当中，因为电磁波传输存在时延，这个时延最多为两倍端到端时间</p>
</li>
<li><p>等待时间使用截断二进制退避算法，从 0，1…2的k次方-1中随机取一个数r，退避时间为r倍争用时间（51.2μ，512bit时间），k = min（重传次数，10），当重传次数到达10是不再增大，当到达16时，丢弃该帧并向高层报告</p>
</li>
</ul>
<ul>
<li>凡小于 64 字节（512bit）的帧直接丢弃，且帧间最小间隔为 9.6μs</li>
</ul>
<p><br></p>
<h2 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h2><ul>
<li><p>由48位，16进制的数字组成的地址，也就是网卡的物理地址，实际上就是适配器地址或适配器标识符EUI—48</p>
</li>
<li><p>MAC地址，也称为物理地址、硬件地址，用来定义网络设备的位置</p>
</li>
<li><p>在OSI模型中，第三层网络层负责 IP地址，第二层数据链路层则负责 MAC地址。因此一个主机会有一个IP地址，而每个网络位置会有一个专属于它的MAC地址</p>
</li>
</ul>
<p><br></p>
<h3 id="MAC帧格式"><a href="#MAC帧格式" class="headerlink" title="MAC帧格式"></a>MAC帧格式</h3><ul>
<li>略</li>
</ul>
<h2 id="碰撞域与网桥"><a href="#碰撞域与网桥" class="headerlink" title="碰撞域与网桥"></a>碰撞域与网桥</h2><ul>
<li><p>也称冲突域，在以太网中，如果某个一个CSMA/CD网络上的两台计算机在同时通信时会发生冲突，那么这个CSMA/CD网络就是一个冲突域。</p>
</li>
<li><p>如果以太网中的各个网段以中继器连接，因为不能避免冲突，所以它们仍然是一个冲突域。但网桥可以隔离冲突域</p>
</li>
<li><p>网桥工作在数据链路层，它根据 MAC 帧的目的地址对收到的帧进行转发。网桥工作在数据链路层，它根据 MAC 帧的目的地址对收到的帧进行转发。以太网交换机是多端口的网桥</p>
</li>
<li><p>广播风暴：网桥并不隔离广播域，当网桥连接成较大的局域网时，会因传播过多的广播信息而产生网络拥塞。这就是所谓的广播风暴。VLAN可以隔离广播域</p>
</li>
</ul>
<p><br></p>
<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><ul>
<li><p>网络层将分组从源主机传到目的主机，网络层提供网络互连</p>
</li>
<li><p>网络层提供的两种服务：虚电路服务和数据报服务</p>
</li>
<li><p>网络层中间设备：路由器</p>
</li>
</ul>
<p><br></p>
<h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p><strong>32位的标识符</strong></p>
<p><br></p>
<h2 id="分类的IP地址"><a href="#分类的IP地址" class="headerlink" title="分类的IP地址"></a>分类的IP地址</h2><p><br></p>
<h3 id="A-类"><a href="#A-类" class="headerlink" title="A 类"></a>A 类</h3><ul>
<li><p>由网络号，主机号构成</p>
</li>
<li><p>网络号：一个类别位 0，共8位（一字节），最后一个网络号 126</p>
</li>
<li><p>主机号：三字节</p>
</li>
</ul>
<p><br></p>
<h3 id="B-类"><a href="#B-类" class="headerlink" title="B 类"></a>B 类</h3><ul>
<li><p>由网络号，主机号构成</p>
</li>
<li><p>网络号：两个类别位 10，共16位（两字节），最后一个网络号 191.255</p>
</li>
<li><p>主机号：二字节</p>
</li>
</ul>
<p><br></p>
<h3 id="C-类"><a href="#C-类" class="headerlink" title="C 类"></a>C 类</h3><ul>
<li><p>由网络号，主机号构成</p>
</li>
<li><p>网络号：三个类别位 110，共16位（三字节），最后一个网络号 223.255.255</p>
</li>
<li><p>主机号：一字节</p>
</li>
</ul>
<p><br></p>
<h3 id="D-类"><a href="#D-类" class="headerlink" title="D 类"></a>D 类</h3><ul>
<li>前四位1110，后28位多播地址</li>
</ul>
<p><br></p>
<h3 id="E-类"><a href="#E-类" class="headerlink" title="E 类"></a>E 类</h3><ul>
<li>前四位1111，后28位保留</li>
</ul>
<p><br></p>
<h2 id="IP-地址与硬件地址"><a href="#IP-地址与硬件地址" class="headerlink" title="IP 地址与硬件地址"></a>IP 地址与硬件地址</h2><ul>
<li><p>物理地址是数据链路层和物理层使用的地址</p>
</li>
<li><p>ip地址是网络层及其以上使用的地址，是一种逻辑地址</p>
</li>
<li><p>ip地址屏蔽了物理细节</p>
</li>
</ul>
<p><br></p>
<h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2><p><br></p>
<h3 id="划分子网"><a href="#划分子网" class="headerlink" title="划分子网"></a>划分子网</h3><ul>
<li><p>三级ip地址，主机号借用若干位表示子网号，减少了主机数</p>
</li>
<li><p>外界看不见子网划分，路由器需要使用子网掩码进行路由</p>
</li>
</ul>
<p><br></p>
<h3 id="子网掩码-1"><a href="#子网掩码-1" class="headerlink" title="子网掩码"></a>子网掩码</h3><ul>
<li><p>使用子网划分之后，路由表必须包括，目的网络地址，子网掩码，下一跳端口</p>
</li>
<li><p>转发时从数据报首部提取目的ip地址</p>
</li>
<li><p>对直接相连的网络的子网掩码与目的ip按位与，如果与网络ip匹配则交付</p>
</li>
<li><p>否则查找是否有为D的特定主机路由，有则交付</p>
</li>
<li><p>否则对路由表中的网络的子网掩码与目的ip按位与，如果与网络ip匹配则交付，否则报告转发报文出错</p>
</li>
</ul>
<p><br></p>
<h2 id="CIDR"><a href="#CIDR" class="headerlink" title="CIDR"></a>CIDR</h2><ul>
<li><p>CIDR 消除了 A B C 分类的概念</p>
</li>
<li><p>使用网络前缀和主机号进行二级编址</p>
</li>
<li><p>使用斜线记法，ip/网络前缀位数，或/子网掩码1的个数</p>
</li>
<li><p>路由器转发时使用最长前缀匹配</p>
</li>
</ul>
<p><br></p>
<h2 id="特殊地址"><a href="#特殊地址" class="headerlink" title="特殊地址"></a>特殊地址</h2><ul>
<li><p>本网络上的本主机（全0）</p>
</li>
<li><p>本网络上进行多播（全1）</p>
</li>
<li><p>回环地址（网络号127，主机号非全0非全1）</p>
</li>
<li><p>私有地址（10/8，172.16/12，192.168/16）</p>
</li>
</ul>
<p><br></p>
<h2 id="ARP-协议"><a href="#ARP-协议" class="headerlink" title="ARP 协议"></a>ARP 协议</h2><p><strong>ARP即地址解析协议，可以实现通过IP地址获得其物理地址。</strong></p>
<ul>
<li><p>ARP进程在本局域网上广播发送一个ARP请求分组</p>
</li>
<li><p>在本局域网上所有主机上运行的ARP进程都收到此ARP请求分组</p>
</li>
<li><p>主机B在ARP分组中见到自己的IP地址，就向主机A发送ARP响应分组，并写入自己的硬件地址</p>
</li>
<li><p>主机A收到主机B的ARP响应分组后，就在其ARP高速缓存中写入主机B的IP地址到硬件地址的映射</p>
</li>
<li><p>IP地址通过ARP转变为物理地址</p>
</li>
</ul>
<p><br></p>
<h2 id="ICMP-协议"><a href="#ICMP-协议" class="headerlink" title="ICMP 协议"></a>ICMP 协议</h2><p><br></p>
<h2 id="IGMP-协议"><a href="#IGMP-协议" class="headerlink" title="IGMP 协议"></a>IGMP 协议</h2><p><br></p>
<h2 id="IP-协议"><a href="#IP-协议" class="headerlink" title="IP 协议"></a>IP 协议</h2><p><br></p>
<h2 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h2><p><br></p>
<h3 id="IGP"><a href="#IGP" class="headerlink" title="IGP"></a>IGP</h3><p><strong>EGP （外部网关协议）：不同自治系统间路由器交流路由选择信息的协议</strong></p>
<p><br></p>
<h4 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h4><ul>
<li>路由信息协议，是一种分布式的基于距离向量的路由选择协议。相邻路由器间定时交换各自的路由表。基于UDP</li>
</ul>
<p><br></p>
<h4 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h4><ul>
<li>开放最短路径优先协议，是一种分布式的链路状态路由协议。链路状态改变时洪泛发送邻居信息。基于IP协议进行传输</li>
</ul>
<p><br></p>
<h4 id="RIP-和-OSPF-的区别"><a href="#RIP-和-OSPF-的区别" class="headerlink" title="RIP 和 OSPF 的区别"></a>RIP 和 OSPF 的区别</h4><ul>
<li><p>RIP协议是一种传统的路由协议，适合比较小型的网络，OSPF协议是在Internet网络急剧膨胀的时候制定的，克服了RIP协议的许多缺陷</p>
</li>
<li><p>RIP是距离矢量路由协议；OSPF是链路状态路由协议。RIP&amp;OSPF管理距离分别是：120和110</p>
</li>
<li><p>RIP协议一条路由有15跳的限制，如果一个RIP网络路由跨越超过15跳，则认为网络不可到达，OSPF对跨越路由器的个数没有限制。</p>
</li>
<li><p>OSPF协议支持可变长度子网掩码（VLSM），RIP则不支持，</p>
</li>
<li><p>RIP协议定期地广播路由表，对网络的带宽资源是个极大的浪费。OSPF协议的路由广播更新只发生在路由状态变化的时候，采用IP多路广播来发送链路状态更新信息</p>
</li>
<li><p>RIP对网络没有分层。OSPF在自治域中可以划分网络域，使路由的广播限制在一定的范围</p>
</li>
<li><p>OSPF在路由广播时采用了授权机制，保证了网络安全。</p>
</li>
</ul>
<p><br></p>
<h3 id="EGP"><a href="#EGP" class="headerlink" title="EGP"></a>EGP</h3><p><strong>EGP （外部网关协议）：不同自治系统间路由器交流路由选择信息的协议</strong></p>
<p><br></p>
<h4 id="BGP"><a href="#BGP" class="headerlink" title="BGP"></a>BGP</h4><ul>
<li>一种基于路径向量的路由选择协议。基于TCP。<br>路由器的构成：路由选择部分（控制部分，核心构件是路由选择处理机）和分组转发部分（交换结构，一组输入端口，一组输出端口）</li>
</ul>
<p><br></p>
<h3 id="IGMP"><a href="#IGMP" class="headerlink" title="IGMP"></a>IGMP</h3><ul>
<li>网际组管理协议：让连接在本地局域网上的多播路由器知道本局域网上是否有主机参加或退出了某个多播组。</li>
</ul>
<p><br></p>
<h3 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h3><ul>
<li>虚拟专用网：通过一个公用网络建立一个临时的、安全的连接，是一条穿过混乱的公用网络的安全、稳定的隧道。</li>
</ul>
<p><br></p>
<h3 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h3><ul>
<li>网络地址转换：将私有(保留)地址转化为合法IP地址的转换技术,被广泛应用于各种类型Internet接入方式和各种类型的网络中。原因很简单，NAT不仅完美地解决了IP地址不足的问题，而且还能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机</li>
</ul>
<p><br></p>
<h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h1><p><br></p>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p><br></p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p><br></p>
<h3 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h3><p><br></p>
<h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p><br></p>
<h4 id="选择确认"><a href="#选择确认" class="headerlink" title="选择确认"></a>选择确认</h4><p><br></p>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><ul>
<li><p>慢开始</p>
</li>
<li><p>拥塞避免</p>
</li>
</ul>
<p><br></p>
<h2 id="TCP-和-UDP-的区别"><a href="#TCP-和-UDP-的区别" class="headerlink" title="TCP 和 UDP 的区别"></a>TCP 和 UDP 的区别</h2><ul>
<li><p>TCP面向字节流;UDP面向报文</p>
</li>
<li><p>TCP面向连接;UDP是无连接的，即发送数据之前不需要建立连接</p>
</li>
</ul>
<ul>
<li>TCP提供可靠的服务，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付</li>
</ul>
<ul>
<li><p>TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</p>
</li>
<li><p>UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低</p>
</li>
<li><p>每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信</p>
</li>
<li><p>TCP首部开销20字节;UDP的首部开销小，只有8个字节</p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 模块化开发指南]]></title>
      <url>/2018/05/31/GitSubmoduleForAndroid/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><strong>本文主要内容</strong></p>
<ul>
<li>git submodule 的使用入门</li>
<li>在 android 项目中使用 git submodule</li>
<li>配置 module 以支持组件化开发</li>
</ul>
<p><strong>ARouter的使用方法不是本文主要内容，想了解 ARounter 的使用方法直接去看官方文档更快</strong></p>
<p><br></p>
<h2 id="submodule-命令概览"><a href="#submodule-命令概览" class="headerlink" title="submodule 命令概览"></a>submodule 命令概览</h2><p><strong>这一部分是通用的 git 命令，因为对新手来说这部分命令基本不常用甚至没有听说过，所以在这里先介绍一下</strong></p>
<p><br></p>
<h3 id="添加子模块-git-submodule-add"><a href="#添加子模块-git-submodule-add" class="headerlink" title="添加子模块 git submodule add"></a>添加子模块 git submodule add</h3><ul>
<li>添加一个子模块 使用 git submodule add 仓库地址</li>
</ul>
<pre><code>git submodule add https://github.com/AlbertHumbert/submodule-test-1.git
</code></pre><ul>
<li>不出意外当前仓库会出现子模块的目录和一份 .gitModule 文件,它保存了远程仓库与本地目录之间的映射，注意它和 .gitignore 文件一样会收到版本控制的影响</li>
</ul>
<pre><code>[submodule &quot;submodule-test-1&quot;]
    path = submodule-test-1
    url = https://github.com/AlbertHumbert/submodule-test-1.git
</code></pre><ul>
<li>这里继续添加两个仓库</li>
</ul>
<pre><code>[submodule &quot;submodule-test-1&quot;]
    path = submodule-test-1
    url = https://github.com/AlbertHumbert/submodule-test-1.git
[submodule &quot;submodule-test-2&quot;]
    path = submodule-test-2
    url = https://github.com/AlbertHumbert/submodule-test-2.git
[submodule &quot;submodule-test-3&quot;]
    path = submodule-test-3
    url = https://github.com/AlbertHumbert/submodule-test-3.git
</code></pre><ul>
<li>被添加的仓库会作为特殊的提交记录，而不是一个硬盘快照,这里的 160000 是这种特殊类型的标记</li>
</ul>
<pre><code>    $ git commit -m &quot;add module 1 2 3&quot;
[master 3fc2889] add module 1 2 3
 5 files changed, 12 insertions(+)
 create mode 100644 .DS\_Store
 create mode 100644 .gitmodules
 create mode 160000 submodule-test-1
 create mode 160000 submodule-test-2
 create mode 160000 submodule-test-3
</code></pre><p><br></p>
<h3 id="初始化子模块"><a href="#初始化子模块" class="headerlink" title="初始化子模块"></a>初始化子模块</h3><ul>
<li>一个模块化管理的 git 项目同样使用 clone 命令拉取</li>
</ul>
<pre><code>git clone https://github.com/AlbertHumbert/module-test-main.git
</code></pre><ul>
<li>克隆之后直属于该项目的文件会被直接拉取，但子模块只是一个空目录，需要手动拉取，首先初始化子模块仓库</li>
</ul>
<pre><code>git submodule init
</code></pre><ul>
<li>然后拉取子仓库的提交记录,现在子模块就不为空了</li>
</ul>
<pre><code>git submodule update
</code></pre><ul>
<li>上面的三条命令可以简化为下面这一条，命令提示中给出的 –recursive 的作用是 initialize all contained submodules,初始化所有被囊括的子模块</li>
</ul>
<pre><code>git clone --recursive https://github.com/AlbertHumbert/module-test-main.git
</code></pre><p><br></p>
<h3 id="更新子模块"><a href="#更新子模块" class="headerlink" title="更新子模块"></a>更新子模块</h3><ul>
<li>使用 git submodule update 可以更新所有子模块，但这个命令实际上非常的坑，很让人费解，它的实际作用是直接 checkout 本地的指定远程分支上最新的 commit ，这样会导致当前工作区处于游离状态</li>
</ul>
<pre><code>$ git status
HEAD detached at 2a70dd5
nothing to commit, working directory clean
</code></pre><ul>
<li>如果本地的指定远程分支状态和远程仓库上的一致，那么只需要在当前游离的指针创建一个分支,然后将其合并到需要的分支即可，这里不再赘述了</li>
</ul>
<pre><code>git branch tmp 2a70dd5
</code></pre><ul>
<li>正确的做法是使用 git submodule update –remote –merge , 它可以自动拉取和合并指定分支</li>
</ul>
<pre><code>git submodule update --remote --merge #更新所有子模块
git submodule update --remote --merge 子模块名 #更新指定模块
</code></pre><ul>
<li>刚刚多次提到指定分支这个概念，在没有配置的情况下，这个指定分支就是 master ，可以通过 .gitmodule 进行配置</li>
</ul>
<pre><code>[submodule &quot;submodule-test-1&quot;]
    path = submodule-test-1
    url = https://github.com/AlbertHumbert/submodule-test-1.git
    branch = master
[submodule &quot;submodule-test-2&quot;]
    path = submodule-test-2
    url = https://github.com/AlbertHumbert/submodule-test-2.git
    branch = dev
[submodule &quot;submodule-test-3&quot;]
    path = submodule-test-3
    url = https://github.com/AlbertHumbert/submodule-test-3.git
    branch = release
</code></pre><ul>
<li>如果有多个分支需要更新，可以使用 foreach 操作</li>
</ul>
<pre><code>git submodule foreach git checkout master 
git submodule foreach git pull
</code></pre><p><br></p>
<h3 id="删除子模块"><a href="#删除子模块" class="headerlink" title="删除子模块"></a>删除子模块</h3><ul>
<li>删除 gitmodules 和 .git/config,</li>
<li>然后执行 git rm –cached 模块名</li>
<li>最后执行 rm -rf .git/modules/模块名</li>
</ul>
<p><br></p>
<h2 id="在-Android-项目中创建-module"><a href="#在-Android-项目中创建-module" class="headerlink" title="在 Android 项目中创建 module"></a>在 Android 项目中创建 module</h2><p><strong>从这里开始，本文中的 module 即指 git 中的 submodule 也指 Android 项目中的 module、模块、组件</strong></p>
<ul>
<li>首先在 AS 中创建一个 module ，注意如果弹出询问是否跟踪这些新文件的弹窗，直接取消，因为我们只要把这些文件添加到新的远程仓库（对于子模块依赖的远程仓库，下文直接称之为子仓库）</li>
</ul>
<ul>
<li>在 github，gitlab，coding 或者任意服务器上创建子仓库，注意项目名应该与子模块的目录名一致，某则 git 无法识别其为子模块的仓库</li>
</ul>
<ul>
<li>然后在本地添加依赖，常见操作就不解释了</li>
</ul>
<pre><code>git init
git commit -m &quot;init&quot; 
git remote add origin https://git.coding.net/AlbertHumbert/basemodule.git  
git push -u origin master   
</code></pre><ul>
<li>在项目根目录添加这个子模块的信息，这里我们看到这里将已有的远程仓库添加到记录当中了</li>
</ul>
<pre><code>$ git submodule add https://git.coding.net/AlbertHumbert/basemodule.git 
Adding existing repo at &apos;basemodule&apos; to the index
</code></pre><p><br></p>
<h2 id="组件化环境配置"><a href="#组件化环境配置" class="headerlink" title="组件化环境配置"></a>组件化环境配置</h2><p><br></p>
<h3 id="设置编译模式"><a href="#设置编译模式" class="headerlink" title="设置编译模式"></a>设置编译模式</h3><ul>
<li>在项目根目录的 gradle.properties 中添加全局标志位，当需要单独编译某个模块，设其为真，当需要集成整个项目时设其为假,同时在各个模块的 build.gradle 中判断该模块应该当做 Library 还是 Application</li>
</ul>
<pre><code># gradle.properties
isSingleBuildModule = false

\# 
if (isSingleBuildModule.toBoolean()) {
    apply plugin: &apos;com.android.application&apos;
} else {
    apply plugin: &apos;com.android.library&apos;
}
</code></pre><p><br></p>
<h3 id="不同模式下的-manifest-文件配置"><a href="#不同模式下的-manifest-文件配置" class="headerlink" title="不同模式下的 manifest 文件配置"></a>不同模式下的 manifest 文件配置</h3><ul>
<li>每一个 android module 都可以有自己 androidmanifest 文件，但需要注意的是有些属性是不能在多分 manifest 中重复声明的，比如 launchActivity，Application</li>
</ul>
<ul>
<li>当我们单独开发某个模块的时候需要定义自己的 launchActivity，Application等信息，但集成编译时不希望产生冲突，那么我们可以借鉴上一步的思路，根据不同的编译模式，使用不同的 manifest</li>
</ul>
<ul>
<li>首先在模块的 main 目录下创建 manifest 目录，该目录下再分别创建 release 和 debug 目录，存放单独编译和集成编译时使用的 manifest 文件</li>
</ul>
<pre><code>&lt;!--单独编译使用的manifest--&gt;
\&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?\&gt;
\&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    package=&quot;com.topview.basemodule&quot;&gt;

    &lt;application
        android:allowBackup=&quot;true&quot;
        android:icon=&quot;@mipmap/ic_launcher&quot;
        android:label=&quot;@string/app_name&quot;
        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;
        android:supportsRtl=&quot;true&quot;
        android:theme=&quot;@style/AppTheme&quot;&gt;
        &lt;activity android:name=&quot;.MainActivity&quot;&gt;
            &lt;intent-filter&gt;
                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;

                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
            &lt;/intent-filter&gt;
        &lt;/activity&gt;
    &lt;/application&gt;

&lt;/manifest&gt;

&lt;!--______________________________________________--&gt;

\&lt;--集成编译使用的 manifest-\&gt;
\&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    package=&quot;com.topview.basemodule&quot; /&gt;
</code></pre><ul>
<li>在该模块的android闭包下添加判断即可</li>
</ul>
<pre><code>sourceSets {
    main {
        jniLibs.srcDirs = [&apos;libs&apos;]
        if (isSingleBuildModule.toBoolean()) {
            manifest.srcFile &apos;src/main/manifest/debug/AndroidManifest.xml&apos;
        } else {
            manifest.srcFile &apos;src/main/manifest/release/AndroidManifest.xml&apos;
        }
    }
}
</code></pre><p><br></p>
<h3 id="全局资源管理"><a href="#全局资源管理" class="headerlink" title="全局资源管理"></a>全局资源管理</h3><ul>
<li>在上一个环节中我们的manifest文件中包含了 appName,icon 这样的资源，这个 manifest 是我直接从app模块下复制过来的，但是在其他 module 不能直接使用，因为其他的 module 无法获取这部分资源</li>
</ul>
<ul>
<li>为解决这些问题，我们不妨创建一个单独的 module 用来存放公用的 字符串，图片，style 等资源，然后所有的module 都在 gradle 中依赖这个 module 即可</li>
</ul>
<pre><code>dependencies {
    //...
    api project(&quot;:commonres&quot;)
    //...
}
</code></pre><p><br></p>
<h3 id="全局-gradle-配置"><a href="#全局-gradle-配置" class="headerlink" title="全局 gradle 配置"></a>全局 gradle 配置</h3><ul>
<li>远程依赖的管理和资源文件的管理类似，没必要在每个 module 中进行重复依赖，虽然重复的依赖声明不会导致多份相同的文件被打包进 apk，但最好还是使用一个单独的 module 进行统一管理，做法跟上个环节一样，这里不再赘述</li>
</ul>
<ul>
<li>对于 compileSdkVersion，buildToolsVersion，这些配置最好能够做到全局的修改，为此可以创建一个 gradle 专门管理,对于并非所有模块都需要的远程依赖，也可以在这里管理版本号</li>
</ul>
<pre><code># congig.gradle
ext {

    COMPILE_SDK_VERSION = 27
    MIN_SDK_VERSION = 16
    TARGET_SDK_VERSION = 26

    APPCOMPAT_VERSION = &apos;27.1.1&apos;
    RXJAVA_2_VERSION = &apos;2.1.13&apos;
    RXANDROID_VERSION = &apos;2.0.2&apos;
}

# build.gradle
    compileSdkVersion COMPILE_SDK_VERSION
</code></pre><p><br></p>
<h3 id="导入-module-与-activity-模板"><a href="#导入-module-与-activity-模板" class="headerlink" title="导入 module 与 activity 模板"></a>导入 module 与 activity 模板</h3><ul>
<li>可以看到我们现在的没创建一个模块逻辑都会有很多重复的操作，其实 android studio 为简化这种重复的操作提供了一个解决途径，模板</li>
</ul>
<ul>
<li>一般比较有经验的开发者应该都知道怎么自己编写一个 Activity 的模板，达到简单点击几下按钮就能准备一个已近有了样板代码的Activity，其实 module 也是这样</li>
</ul>
<ul>
<li>最简单的实现方法，我们只需要复制 AS 目录 下的 contents -> plugins -> android -> lib -> templates -> gradle-project -> NewAndroidProject 进行修改即可</li>
</ul>
<ul>
<li>比如这里的是其中一份gradle文件,我们可以直接在这里添加相关配置，最终这些代码会出现在自动生成的文件当中，当然还有许多相关的配置需要输入或者动态获取，这方面的语法可以参考<a href="https://www.jianshu.com/p/c76facb61d69" target="_blank" rel="external">这篇文章</a>，这里就不详细介绍了</li>
</ul>
<pre><code>// Top-level build file where you can add configuration options common to all sub-projects/modules.

buildscript {
    &lt;#if includeKotlinSupport!false&gt;ext.kotlin_version = &apos;${kotlinVersion}&apos;&lt;/#if&gt;
    repositories {
        google()
        jcenter()
    }
    dependencies {
        classpath &apos;com.android.tools.build:gradle:${gradlePluginVersion}&apos;
        &lt;#if includeKotlinSupport!false&gt;classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;&lt;/#if&gt;

        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
}

allprojects {
    repositories {
        google()
        jcenter()
    }
}

task clean(type: Delete) {
    delete rootProject.buildDir
}
</code></pre><ul>
<li>我正在根据自己的项目来实现资源，底层和业务模块的模块，如果有需要可以参考<a href="https://github.com/AlbertHumbert/AndroidModuleTemplate" target="_blank" rel="external">这里</a></li>
</ul>
<p><br></p>
<h2 id="使用-ARouter"><a href="#使用-ARouter" class="headerlink" title="使用 ARouter"></a>使用 ARouter</h2><ul>
<li>在 basemodule 中添加 ARouter 的依赖,这里使用 exclude，避免与我们的 support 库产生冲突，ARouter 只由一个模块去依赖就好</li>
</ul>
<pre><code>implementation (&apos;com.alibaba:arouter-api:1.2.4&apos;){
    exclude module: &apos;support-v4&apos;
}
</code></pre><ul>
<li>在需要使用 arouter 的模块添加注解依赖</li>
</ul>
<pre><code>dependencies {
    annotationProcessor &apos;com.alibaba:arouter-compiler:1.1.4&apos;
}
</code></pre><ul>
<li>在 defaultConfig 闭包中添加</li>
</ul>
<pre><code>defaultConfig{
        javaCompileOptions {
            annotationProcessorOptions {
                arguments = [ moduleName : project.getName() ]
            }
        }
}
</code></pre><ul>
<li>在 Application 中初始化 arouter </li>
</ul>
<pre><code>@Override
public void onCreate() {
    super.onCreate();
    if (BuildConfig.DEBUG) {
        ARouter.openLog();
        ARouter.openDebug();
    }
    ARouter.init(this);
}
</code></pre><ul>
<li>在需要跳转的 Activity 中添加注解</li>
</ul>
<pre><code>@Route(path = &quot;/feature1/main&quot;)
</code></pre><ul>
<li>使用 arouter 进行跳转</li>
</ul>
<pre><code>ARouter.getInstance().build(&quot;/feature1/main&quot;).navigation();
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基于 Git Flow 模型的工作流程]]></title>
      <url>/2018/05/25/GitFlowModel/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><br></p>
<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p><br></p>
<h3 id="长期分支-amp-辅助分支"><a href="#长期分支-amp-辅助分支" class="headerlink" title="长期分支 &amp; 辅助分支"></a>长期分支 &amp; 辅助分支</h3><ul>
<li><p>在 git-flow 中最主要的五个分支是 master，release，develop，feature，hotfix</p>
</li>
<li><p>长期分支包括 master，develop</p>
</li>
<li><p>辅助分支包括 feature，release，hotfix</p>
</li>
<li><p>长期分支是相对稳定的分支，所有被认可的提交最终都会被合并到它们当中</p>
</li>
<li><p>辅助分支是临时开辟的短期分支，在完成它们的工作之后通常可以删除</p>
</li>
</ul>
<p><br></p>
<h3 id="分支概述"><a href="#分支概述" class="headerlink" title="分支概述"></a>分支概述</h3><ul>
<li><p>master，对外发布产品使用的分支，该分支的最新提交必须是一个已近对外提供的版本，不允许直接在该分支上开发，因为它必须永远保持最稳定的状态</p>
</li>
<li><p>develop，内部开发产品使用的分支，该分支的最新提交必须是一个相对稳定的测试版本，同样不允许直接在该分支上开发</p>
</li>
<li><p>feature，功能特性分支，直接在 develop 上创建的分支，feature 是不确定数量的分支的统称（如feature/a, feature/b），可以在这些分支上直接开发新特性，如果需要多人协作，则将分支推送到远程仓库，不允许在一个功能未完成之前将其合并到 develop 分支</p>
</li>
<li><p>release，测试分支，develop 分支上创建的分支，用于产品对外发布之前（即更新 master 分支）的测试工作，在创建完该分支之后最好立即推送到远程仓库</p>
</li>
<li><p>hotfix，修复分支，在 master 上创建的分支，用于对线上版本的bug的修复，每一个特定的问题创建一个分支</p>
</li>
</ul>
<p><br></p>
<h2 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h2><p><br></p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul>
<li><p>创建本地仓库，并推送到远程，这部分太基础所有略过</p>
</li>
<li><p>由于 master 分支是默认创建的，所以只需创建另一个长期分支 ——develop 并推送到远程</p>
</li>
</ul>
<pre><code>git checkout -b develop
git push origin develop:develop
</code></pre><ul>
<li>其他成员克隆后需要拉取 develop 分支,并指定好跟踪的远程分支，注意最好远程分支和本地分支使用相同的命名</li>
</ul>
<pre><code>git fetch origin develop:develop
git branch --set-upstream-to=origin/develop develop
</code></pre><p><br></p>
<h3 id="开发新特性"><a href="#开发新特性" class="headerlink" title="开发新特性"></a>开发新特性</h3><ul>
<li>开发特性a，在 develop 分支上创建新特性分支 feature/a ，注意不要在 develop 分支上直接开发</li>
</ul>
<pre><code>git checkout develop
git checkout -b feature/a
</code></pre><ul>
<li>如果有必要，将该特性分支推送到远程</li>
</ul>
<pre><code>git push origin feature/a:feature/a
</code></pre><ul>
<li>如果有必要，其他成员拉取特性分支</li>
</ul>
<pre><code>git fetch origin feature/a:feature/a
</code></pre><p><br></p>
<h3 id="完成新特性"><a href="#完成新特性" class="headerlink" title="完成新特性"></a>完成新特性</h3><ul>
<li>新特性完成之后需要将 feature 分支合并到 develop 分支</li>
</ul>
<pre><code>git checkout develop
git merge feature/a
git push origin develop
</code></pre><ul>
<li>合并完成并确定无人使用该 feature 分支之后，将其删除</li>
</ul>
<pre><code>git branch -d feature/a  #删除本地分支
git push origin --delete feature/a #删除远程分支
</code></pre><p><br></p>
<h3 id="测试新版本"><a href="#测试新版本" class="headerlink" title="测试新版本"></a>测试新版本</h3><ul>
<li>重复上面的流程完成多个新特性之后，我们开始在 release 分支上测试,用版本号创建 release 分支，版本号根据 master 分支当前最新的 tag 来确定即可，根据改动的情况选择要增加的位</li>
</ul>
<pre><code>git checkout -b release/1.0.0
git push origin release/1.0.0:release/1.0.0
</code></pre><p><br></p>
<h3 id="发布新版本"><a href="#发布新版本" class="headerlink" title="发布新版本"></a>发布新版本</h3><ul>
<li>在确定当前版本足够完善时，就可以进行发布了,注意发布前确定本地的release分支处于最新的状态</li>
</ul>
<pre><code>git pull origin release/1.0.0
</code></pre><ul>
<li>将 release 分支合并到 develop 分支</li>
</ul>
<pre><code>git checkout develop
git merge release/1.0.0
</code></pre><ul>
<li>将 release 分支合并到 maseter 分支</li>
</ul>
<pre><code>git checkout master
git merge release/1.0.0
</code></pre><ul>
<li>根据命名的tag进行真正的标签记录</li>
</ul>
<pre><code>git checkout master
git tag -a &quot;1.0.0&quot; HEAD -m &quot;新版本改动描述&quot;
</code></pre><ul>
<li>删除 release 分支</li>
</ul>
<pre><code>git branch -d release/1.0.0
git push origin --delete release/1.0.0
</code></pre><p><br></p>
<h3 id="修复线上-bug"><a href="#修复线上-bug" class="headerlink" title="修复线上 bug"></a>修复线上 bug</h3><ul>
<li><p>注意如果不是线上的版本而是开发过程中的 develop 的 bug 则在 develop 中创建分支进行修复，如果是在 release 分支上的 bug 则直接在 release 分支上修改即可</p>
</li>
<li><p>有些问题在上线之后才会被发现，那么我们需要创建 hotfix 分支进行处理,注意不要直接在 feature 上进行修复，而是在 master 分支上根据具体的问题创建分支并推到远程</p>
</li>
</ul>
<pre><code>git checkout master
git checkout -b hotfix/typo
git push origin hotfix/typo:hotfix/typo
</code></pre><ul>
<li>修改完成后重新发版,确定当前 hotfix 分支版本是最新的，再将hotfix 分支合并到 develope 分支</li>
</ul>
<pre><code>git pull origin hotfix/typo
git checkout develop
git merge hotfix/typo
</code></pre><ul>
<li>然后将 hotfix 分支合并到 master 分支,注意改动了 master 分支之后 tag 也要更新，因为是修复 bug，一般最后一位加一即可</li>
</ul>
<pre><code>git checkout master
git merge hotfix/typo
git tag -a &quot;1.0.1&quot; HEAD -m &quot;fix typo&quot;
</code></pre><ul>
<li>到这里我们从创建项目，添加特性，测试发布，修改bug的流程就走完一遍了</li>
</ul>
<p><br><br><br><br><br> </p>
<p><strong>全文完</strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[git-flow 工作流 上手指南]]></title>
      <url>/2018/05/25/git-flow/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><strong>本文中指的git-flow是一个基于git flow工作流模型的git工具，它可以使开发者更加规范地进行版本控制，使你的仓库更加clean</strong></p>
<p><strong>本来觉得这个工具已经将git flow模型简化得很好了，而且以前也或多或少了解过git flow 模型，以为使用git-flow来掌握这个模型的学习成本几乎为0，但后来确实发觉自己对很多细节了解不透，于是又从头开始学习了git flow 模型，如果需要了解这部分前期知识，请看<a href="https://tocreate.app/2018/05/25/GitFlowModel/" title="这里" target="_blank" rel="external">这里</a></strong></p>
<p><strong>主要参考</strong></p>
<p><strong><a href="http://danielkummer.github.io/git-flow-cheatsheet/index.zh_CN.html" title="备忘清单  " target="_blank" rel="external"> 备忘清单 </a></strong></p>
<p><strong><a href="https://www.git-tower.com/learn/git/ebook/cn/command-line/advanced-topics/git-flow" title="Learn Version Control with Git" target="_blank" rel="external"> Learn Version Control with Git </a></strong></p>
<p><br></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><br></p>
<h3 id="在-mac-上安装-git-flow"><a href="#在-mac-上安装-git-flow" class="headerlink" title="在 mac 上安装 git-flow"></a>在 mac 上安装 git-flow</h3><blockquote>
<p>brew install git-flow</p>
</blockquote>
<p><br></p>
<h3 id="在-linux-上安装-git-flow"><a href="#在-linux-上安装-git-flow" class="headerlink" title="在 linux 上安装 git-flow"></a>在 linux 上安装 git-flow</h3><blockquote>
<p>sudo apt-get install git-flow</p>
</blockquote>
<p><br></p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p><br></p>
<h3 id="git-flow-init"><a href="#git-flow-init" class="headerlink" title="git flow init"></a>git flow init</h3><ul>
<li>使用 git flow init 取代 git init 进行初始化操作，flow（下文中的git-flow全部简称为flow）初始化时会询问分支类别的命名规范，建议使用默认的master，develop，feature/, release/, hotfix/, support/，master和develop是默认的长期分支</li>
</ul>
<pre><code>Initialized empty Git repository in /Users/alberthumbert/Desktop/AircraftDemo/aircraft/.git/
No branches exist yet. Base branches must be created now.
Branch name for production releases: [master] 
Branch name for &quot;next release&quot; development: [develop] 

How to name your supporting branch prefixes?
Feature branches? [feature/] 
Release branches? [release/] 
Hotfix branches? [hotfix/] 
Support branches? [support/] 
Version tag prefix? [] 
</code></pre><ul>
<li><p>初始化之后，flow会为你自动创建master和develop分支，并且切换到develop分支</p>
</li>
<li><p>注意这个init操作可以在已有的git仓库上使用</p>
</li>
</ul>
<p><br></p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p><br></p>
<h3 id="git-flow-feature-start-特性名"><a href="#git-flow-feature-start-特性名" class="headerlink" title="git flow feature start (特性名)"></a>git flow feature start (特性名)</h3><ul>
<li>开发新特性（功能，接口…）请在develope分支上创建新分支，git flow feature start 特性名，特性名应该能够概括整个新特性</li>
</ul>
<pre><code>$ git flow feature start transparent-init  

Switched to a new branch &apos;feature/transparent-init&apos;

Summary of actions:
- A new branch &apos;feature/transparent-init&apos; was created, based on &apos;develop&apos;
- You are now on branch &apos;feature/transparent-init&apos;

Now, start committing on your feature. When done, use:

     git flow feature finish transparent-init
</code></pre><ul>
<li>git flow 的输出比git本身更加好懂</li>
<li>这个操作创建了一个新的 feature/transparent-init 分支，然后切换的该分支</li>
</ul>
<p><br></p>
<h3 id="git-flow-feature-finish-特性名"><a href="#git-flow-feature-finish-特性名" class="headerlink" title="git flow feature finish (特性名)"></a>git flow feature finish (特性名)</h3><pre><code>commit 08e027ba6be8bc04e1615307c4d2f1c6ce41baac
Author: AlbertHumbert &lt;709913148@qq.com&gt;
Date:   Fri May 18 23:05:22 2018 +0800

    chore(.gitignore):添加忽略文件

commit b39a7e7894844b4d593d3ae7dd522e097cd1c96a
Author: AlbertHumbert &lt;709913148@qq.com&gt;
Date:   Fri May 18 23:02:44 2018 +0800
</code></pre><ul>
<li>经过一段时间的初始化，我们有了最终成果,使用git flow feature finish 特性名</li>
</ul>
<pre><code>$ git flow feature finish transparent-init
...
Summary of actions:
- The feature branch &apos;feature/transparent-init&apos; was merged into &apos;develop&apos;
- Feature branch &apos;feature/transparent-init&apos; has been removed
- You are now on branch &apos;develop&apos;
</code></pre><ul>
<li>现在特性分支被合并到了 develop 分支，并且自动切回了develop 分支，临时的 feature/transparent-init 分支已被删除</li>
</ul>
<p><br></p>
<h3 id="git-flow-feature-publish-特性名"><a href="#git-flow-feature-publish-特性名" class="headerlink" title="git flow feature publish (特性名)"></a>git flow feature publish (特性名)</h3><ul>
<li>使用 git flow feature publish 特性名，可以将特性分支推送到远程</li>
</ul>
<pre><code>$ git flow feature publish a
Counting objects: 3, done.
Writing objects: 100% (3/3), 244 bytes | 0 bytes/s, done.
Total 3 (delta 0), reused 0 (delta 0)
To https://github.com/AlbertHumbert/git-flow-test.git
 * [new branch]      feature/a -\&gt; feature/a
Already on &apos;feature/a&apos;
Your branch is up-to-date with &apos;origin/feature/a&apos;.

Summary of actions:
- A new remote branch &apos;feature/a&apos; was created
- The local branch &apos;feature/a&apos; was configured to track the remote branch
- You are now on branch &apos;feature/a&apos;
</code></pre><ul>
<li>这个操作根据本地分支名创建并跟踪了远程分支，并切换到了本地分支</li>
</ul>
<p><br></p>
<h3 id="git-flow-feature-pull-origin-特性名"><a href="#git-flow-feature-pull-origin-特性名" class="headerlink" title="git flow feature pull origin (特性名)"></a>git flow feature pull origin (特性名)</h3><ul>
<li>使用 git flow feature pull origin 特性名，可以获取远程的提交，并自动切换到特性分支</li>
</ul>
<pre><code> $ git flow feature pull origin a
Created local branch feature/a based on origin&apos;s feature/a.
</code></pre><ul>
<li><p>注意git flow 对于远程仓库是透明的，在本地调用git flow init并进行了推送，在其他目录clone仓库之后也需要再次执行git flow init</p>
</li>
<li><p>但是这个时候init时设定的命名必须统一，一般来说一个小组也应该使用约定好的命名，基本上使用默认的就行了</p>
</li>
<li><p>在分支已经拉取之后，使用git原本的 push pull fetch 即可</p>
</li>
</ul>
<p><br></p>
<h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p><br></p>
<h3 id="git-flow-release-start-版本号"><a href="#git-flow-release-start-版本号" class="headerlink" title="git flow release start (版本号)"></a>git flow release start (版本号)</h3><ul>
<li>使用 git flow release start 版本号创建一个发布版本，注意请规范地使用版本号</li>
</ul>
<pre><code>git flow release start 1.0.0
Switched to a new branch &apos;release/1.0.0&apos;

Summary of actions:
- A new branch &apos;release/1.0.0&apos; was created, based on &apos;develop&apos;
- You are now on branch &apos;release/1.0.0&apos; 
</code></pre><ul>
<li>该操作创建并切换到了新的 release 分支</li>
</ul>
<ul>
<li>注意在一条 release 分支已经创建了且未发布的情况下是不能使用flow再创建release分支的,这也很合理</li>
</ul>
<pre><code>git flow release start 1.1.0
There is an existing release branch (1.0.0). Finish that one first.
</code></pre><p><br></p>
<h3 id="git-flow-release-publish-版本号"><a href="#git-flow-release-publish-版本号" class="headerlink" title="git flow release publish (版本号)"></a>git flow release publish (版本号)</h3><ul>
<li>和其他分支一样创建分支时，flow不会自动将分支推送到远程，这里使用 git flow release publish 版本号 进行推送</li>
</ul>
<pre><code>git push origin release/1.0.0:release/1.0.0
</code></pre><p><br></p>
<h3 id="git-flow-release-track-版本号"><a href="#git-flow-release-track-版本号" class="headerlink" title="git flow release track (版本号)"></a>git flow release track (版本号)</h3><ul>
<li>从远程仓库拉取一个release分支，使用 git flow release track 版本号</li>
</ul>
<p><br></p>
<h3 id="git-flow-release-finish-版本号"><a href="#git-flow-release-finish-版本号" class="headerlink" title="git flow release finish (版本号)"></a>git flow release finish (版本号)</h3><ul>
<li>确定一个可发布的版本已近完成之后，我们使用 git flow release finish 版本号 来将成果合并到 master 分支</li>
</ul>
<pre><code>$ git flow release finish 1.0.0
Switched to branch &apos;master&apos;
Your branch is up-to-date with &apos;origin/master&apos;.
Merge made by the &apos;recursive&apos; strategy.
 test | 2 ++
 1 file changed, 2 insertions(+)
 create mode 100644 test
Switched to branch &apos;develop&apos;
Merge made by the &apos;recursive&apos; strategy.
 test | 2 ++
 1 file changed, 2 insertions(+)
 create mode 100644 test
Deleted branch release/1.0.0 (was 5054d9b).

Summary of actions:
- Latest objects have been fetched from &apos;origin&apos;
- Release branch has been merged into &apos;master&apos;
- The release was tagged &apos;1.0.0&apos;
- Release branch has been back-merged into &apos;develop&apos;
- Release branch &apos;release/1.0.0&apos; has been deleted
</code></pre><ul>
<li>该操作拉取了最新的release分支，并且将 release 合并到 develop 和 master 分支，打上了标签后删除了release分支</li>
</ul>
<p><br></p>
<h2 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h2><p><br></p>
<h3 id="git-flow-hotfix-start-错误名"><a href="#git-flow-hotfix-start-错误名" class="headerlink" title="git flow hotfix start (错误名)"></a>git flow hotfix start (错误名)</h3><ul>
<li>有些潜在的问题会在新版本正式发布之后才显现出来，这个时候我们需要使用hotfix分支进行紧急修复工作，使用git flow hotfix start 错误名 开启一个新分支</li>
</ul>
<pre><code>$ git flow hotfix start some-bug
Switched to a new branch &apos;hotfix/some-bug&apos;

Summary of actions:
- A new branch &apos;hotfix/some-bug&apos; was created, based on &apos;master&apos;
- You are now on branch &apos;hotfix/some-bug&apos;

Follow-up actions:
- Bump the version number now!
- Start committing your hot fixes
- When done, run:

     git flow hotfix finish ‘some-bug’
</code></pre><ul>
<li>该操作创建并切换到了 hotfix 分支</li>
</ul>
<p><br></p>
<h3 id="git-flow-hotfix-finish-错误名"><a href="#git-flow-hotfix-finish-错误名" class="headerlink" title="git flow hotfix finish (错误名)"></a>git flow hotfix finish (错误名)</h3><ul>
<li>在不懈的努力下，这个顽固的bug终于被排除了，这个使用使用git flow hotfix finish 错误名 进行提交，将错误合并到master和develop分支</li>
</ul>
<pre><code>$ git flow hotfix finish some-bug
^[[ASwitched to branch &apos;master&apos;
Your branch is ahead of &apos;origin/master&apos; by 4 commits.
  (use &quot;git push&quot; to publish your local commits)
Merge made by the &apos;recursive&apos; strategy.
 test | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
Switched to branch &apos;develop&apos;
Merge made by the &apos;recursive&apos; strategy.
 test | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
Deleted branch hotfix/some-bug (was 77b7eec).

Summary of actions:
- Latest objects have been fetched from &apos;origin&apos;
- Hotfix branch has been merged into &apos;master&apos;
- The hotfix was tagged &apos;some-bug&apos;
- Hotfix branch has been back-merged into &apos;develop&apos;
- Hotfix branch &apos;hotfix/1.0.1’ has been deleted
</code></pre><ul>
<li>该操作拉取了最新的远程分支，将hotfix分支合并到 master 和 develop 然后打上标签再将 hotfix 分支删除</li>
</ul>
<p><br><br><br><br><br><br><strong>全文完</strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Architecture Components 系列 - LiveData & ViewModel]]></title>
      <url>/2018/05/24/LiveData/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><strong> LiveData 可以说是Architecture Components的核心，而从ViewModel开始可以说步入到 mvvm 的内容了，这一部分将是未来安卓开发的重中之重</strong></p>
<p><br></p>
<h3 id="LiveData"><a href="#LiveData" class="headerlink" title="LiveData"></a>LiveData</h3><p><br></p>
<h3 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h3>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[gradle 3.x 依赖方式]]></title>
      <url>/2018/05/20/gradle3/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><br></p>
<p><strong>简单记录一下 gradle 3.x 中的依赖模式</strong></p>
<h3 id="新旧对比"><a href="#新旧对比" class="headerlink" title="新旧对比"></a>新旧对比</h3><ul>
<li>gradle 3.x 与 2.x 的依赖方式有了很大区别，具体来说，有了下面这样的改动</li>
</ul>
<table>
<thead>
<tr>
<th>2.x</th>
<th>3.x</th>
</tr>
</thead>
<tbody>
<tr>
<td>无</td>
<td>implementation </td>
</tr>
<tr>
<td>compile</td>
<td>api </td>
</tr>
<tr>
<td>provided</td>
<td>compileOnly </td>
</tr>
<tr>
<td>apk</td>
<td>runtimeOnly</td>
</tr>
<tr>
<td>debugCompile</td>
<td>debugImplementation </td>
</tr>
<tr>
<td>releaseCompile</td>
<td>releaseImplementation</td>
</tr>
<tr>
<td>androidTestCompile</td>
<td>androidTestImplementation</td>
</tr>
</tbody>
</table>
<p><br></p>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><ul>
<li><p>在详述3.x依赖方法之前，我们先创建一个场景，在我们的测试项目 组件app依赖了a库和c库，另一个aar组件叫test，它依赖了b库和c库，其中 app依赖的c库为1.0版本，test库依赖的c库则为1.1版本</p>
</li>
<li><p>在 app 中我们依赖了test</p>
</li>
</ul>
<pre><code>compile project(path: &apos;:test&apos;)
</code></pre><p><br></p>
<h3 id="api"><a href="#api" class="headerlink" title="api"></a>api</h3><ul>
<li><p>api 和 compile 没有区别，也就是说 api会向外暴露它的依赖</p>
</li>
<li><p>如果 app 和 test 都是使用 api 来依赖各自的库，在 app 中可以调用到b库,但在 test 中无法调用 a 库，同时由于c库版本不同又重复依赖，所以会报错</p>
</li>
</ul>
<ul>
<li>被编译组件依赖的组件如果又含有api依赖，那么所有这些 依赖都要被gradle检查，这会增加编译时间，同时使用api时需要注意重复的库版本必须一致</li>
</ul>
<p><br></p>
<h3 id="implementation"><a href="#implementation" class="headerlink" title="implementation"></a>implementation</h3><ul>
<li>implementation，和 compile 相反，它会对外屏蔽依赖</li>
</ul>
<ul>
<li>如果场景中全部使用 implementation ，则 app 可以使用 a 库，但不能使用b库，app 和 test 都能使用各自的c库而不报错</li>
</ul>
<ul>
<li>被编译组件依赖的组件如果又含有implementation依赖，这些依赖会被忽略，因为它们对外是不可见的，准确的说编译时不可见，运行时可见</li>
</ul>
<p><br></p>
<h3 id="compileOnly"><a href="#compileOnly" class="headerlink" title="compileOnly"></a>compileOnly</h3><ul>
<li>compileOnly 和 provided 一致，编译时可见，运行时不可见</li>
</ul>
<ul>
<li>test使用compileOnly依赖b库时，app不可以调用b库，同时如果test运行时调用了b库会崩溃，compileOnly主要用于只在编译期使用的库，如注解解释器</li>
</ul>
<ul>
<li><p>compileOnly也可用于一些可配置的组件，需要某些功能时将compileOnly改为api对外开放，不需要时则使用compileOnly，不影响该组件的开发</p>
</li>
<li><p>compileOnly只在编译期存在不会将整个库打包到apk，合理使用compileOnly可以减小apk体积</p>
</li>
</ul>
<p><br></p>
<h3 id="runtimeOnly"><a href="#runtimeOnly" class="headerlink" title="runtimeOnly"></a>runtimeOnly</h3><ul>
<li>这个就厉害了，运行时可见，编译时不可见，在开发时，使用runtimeOnly依赖的库和调用者是完全解耦的</li>
</ul>
<ul>
<li>runtimeOnly主要用于组件化开发，本文不涉及这部分内容，所以略过</li>
</ul>
<p><br></p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>debugImplementation，releaseImplementation，testImplementation，这三个就好懂了，使用这三者进行依赖，被依赖的库只会在debug包，release包，和单元测试时有效</li>
</ul>
<p><br></p>
<p><br></p>
<p><strong>全文完</strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[kotlin 系列 - 语法与特性]]></title>
      <url>/2018/03/29/kotlin/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><strong>该系列主要是《Kotlin实战》（Kotlin in Action）的笔记以及个人的理解，对于移动端开发者有没有必要现在就去学kotlin之类的问题请读者自行考虑，开这个系列主要是由于个人兴趣</strong></p>
<p><a href="https://try.kotlinlang.org/" target="_blank" rel="external">你可以在这个网站中在线编译并运行kotlin代码</a></p>
<p><br></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><br></p>
<h2 id="啥是Kotlin啊"><a href="#啥是Kotlin啊" class="headerlink" title="啥是Kotlin啊"></a>啥是Kotlin啊</h2><ul>
<li>kotlin是一门野心非常大的语言，它不但能与能与现有的java框架并存，向人证明它可以以更加简洁的方式代替java，还不断向着更多的领域发展。android开发者可以结合anko编写应用，永久告别xml，前端开发者可以编写kotlin代码然后编译成JavaScript，Kotlin_Native更是支持直接编译机器码在linux，ios，mac os上运行</li>
</ul>
<ul>
<li>kotlin最大的特点是简洁的语法，自动类型推断与互操作性</li>
</ul>
<ul>
<li>再学习完kotlin的语法（糖）之后，再回来补充这章</li>
</ul>
<p><br></p>
<h2 id="学kotlin干啥啊"><a href="#学kotlin干啥啊" class="headerlink" title="学kotlin干啥啊"></a>学kotlin干啥啊</h2><ul>
<li>我宜家都唔知啊，想学就学咯</li>
</ul>
<p><br></p>
<h1 id="kotlin-基础"><a href="#kotlin-基础" class="headerlink" title="kotlin 基础"></a>kotlin 基础</h1><p><br></p>
<h2 id="基本要素：函数和变量"><a href="#基本要素：函数和变量" class="headerlink" title="基本要素：函数和变量"></a>基本要素：函数和变量</h2><p><strong>构成kotlin程序的基本要素是函数和变量，这即是某些语言以及函数式编程中强调的“函数是第一等公民”的概念的体现</strong></p>
<pre><code>fun main(args:Array&lt;String&gt;){
    println(&quot;hello world&quot;)
}
</code></pre><ul>
<li>上面是一个hello world的kotlin实现，从这个简单的例子中我们已经可以看到kotlin与java有很多不同</li>
</ul>
<pre><code>1.使用关键字 fun 声明一个函数，也就是方法
2.参数类型写在名称的后面，与go语言如出一辙，对于能够自动推断类型的语言来说，我们总是更关注变量的名名称所表达的抽象含义而不是它的类型
3.函数可以定义在文件的最外层，而不是类里面，你可以直接把这个函数放到任何一个kt文件中运行，不需要找到一个合适的花括号然后把它塞进去
4.println代替了system.out.println，kotlin简化了很多这样啰嗦的代码
5.可以省略代码结尾的分号，这点和python很像，你不用担心你的代码会被go编译器那样胡乱的添加上分号
</code></pre><p><br></p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p><br></p>
<h4 id="代码块体"><a href="#代码块体" class="headerlink" title="代码块体"></a>代码块体</h4><pre><code>fun max(a: Int, b: Int): Int {
    return if (a &gt; b) a else b
}
</code></pre><ul>
<li>函数以fun开头，然后是函数名和参数列表，参数类型写在参数名后，以冒号隔开，最后是冒号和返回类型</li>
</ul>
<ul>
<li>注意在kotlin中大多数控制结果都是表达式，而不是语句，语句与表达式的最大区别在于表达式有值，允许直接嵌套使用</li>
</ul>
<p><br></p>
<h4 id="表达式体"><a href="#表达式体" class="headerlink" title="表达式体"></a>表达式体</h4><pre><code>fun max(a: Int, b: Int): Int = if (a &gt; b) a else b
</code></pre><ul>
<li><p>表达式也可以作为一个完整的函数体，现在你知道为什么kotlin要把返回类型放在函数头的最后面了</p>
</li>
<li><p>我们说过kotlin支持自动类型推断，因此上面的代码还可以简洁一下</p>
</li>
</ul>
<pre><code>fun max(a: Int, b: Int) = if (a \&gt; b) a else b
</code></pre><ul>
<li>在函数中支持表达式体的意义在于，向kotlin这种支持闭包的语言可以在任何地方将代码重用的粒度降到最细</li>
</ul>
<p><br></p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p><br></p>
<h4 id="省略类型"><a href="#省略类型" class="headerlink" title="省略类型"></a>省略类型</h4><pre><code>val aString = &quot;I am String&quot;
val aInt = 1;
var aDouble = 2e6
var aFloat:Float
</code></pre><ul>
<li>在Java(jdk 10之前)中，声明变量时必须在最前面写出变量类型，在kotlin中，你甚至都不需要给出类型，编译器根据初始化的值可以知道你要的是什么，如果你不想那么快赋值，那就必须给出变量类型了</li>
</ul>
<ul>
<li>上面我们用到了var和val来声明变量，var表示可变引用，val表示不可变引用（final），你应该尽可能地使用val来声明所有的变量，这会让代码更安全，也更接近函数式编程的风格。</li>
</ul>
<pre><code>val aList = arrayListOf(&quot;java&quot;)
aList.add(&quot;kotlin&quot;)
</code></pre><ul>
<li>val仅仅保证引用的不可变性，它指向的对象仍然是可变的</li>
</ul>
<p><br></p>
<h4 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h4><pre><code>val he = &quot;Albert&quot;
val languages = arrayListOf(&quot;java&quot;)
languages.add(&quot;kotlin&quot;)
println(&quot;$he said, ${languages[1]} is the best language in the world &quot;)

//猜猜输出什么？
</code></pre><ul>
<li>字符串模板的作用是允许字符串字面量中存在变量和表达式，这显然让字符串拼接显得更加简洁紧凑，易于理解</li>
<li>在你的字符串中可以使用$中支持变量，使用${}支持表达式！</li>
</ul>
<p><br></p>
<h2 id="类和属性"><a href="#类和属性" class="headerlink" title="类和属性"></a>类和属性</h2><p><strong>Java常为人诟病的一点就是创建一个类需要非常多的样板代码（特别是对于bean类而言），为此不少ide或插件都提供了自动生成getter，setter，构造器，代码模板，万能tab的功能</strong></p>
<p><strong>但就像很多人认为的那样，某种程度上Java逐渐变成了一门“依赖ide”的语言</strong></p>
<p><strong>kotlin的开发者们为了解决这些问题可谓下足了功夫</strong></p>
<p><br></p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><pre><code>class Person(var name:String)
</code></pre><ul>
<li>上面这行kotlin代码展开成Java代码之后如下，你一定见过很多这样的Java代码，尽管从语法的角度来讲它们处处都有意义，但实际上你需要的关键词真的只有 class，Person，var，name ，String，这就是kotlin所谓的简洁，在kotlin当中，类通常很小</li>
</ul>
<pre><code>public class Person{
    private String name;

    public Person(String name){
        this.name = name;
    }

    public String getName(){
        return name;
    }

    public void setName(String name){
        this.name = name;
    }
}
</code></pre><ul>
<li>对于使用var修饰的属性，kotlin编译器会自动为其生成getter，setter，对于使用val修饰的属性，编译器则只生成getter，同时在访问和修改任何属性时，你不需要显式地调用它们的访问方法，对于构造方法而言，你也不用再写关键字new了</li>
</ul>
<pre><code>val albert = Person(&quot;Albert&quot;)
albert.name = &quot;Albert Lin&quot;
println(albert.name)
</code></pre><ul>
<li>所有属性都像Java中访问公有属性那样访问，但实际上走的是内部的getter和setter方法,当然这也包括了你所编写的getter和setter方法</li>
</ul>
<pre><code>class Rectangle(val height: Int, val width: Int) {
    val isSquare: Boolean
        get() {
            return height == width
        }

    //也可以简化为val isSquare: Boolean get() = height == width
}
</code></pre><p><br></p>
<h3 id="目录和包"><a href="#目录和包" class="headerlink" title="目录和包"></a>目录和包</h3><ul>
<li>kotlin当中依然使用import和package关键字来组织代码结构，不同的是，在Java中，包结构需要与实际上的文件目录结构一致，kotlin则不做这种要求，你可以把所有文件都放到一个目录，只在package关键字后面声明它们所在的包</li>
</ul>
<ul>
<li>在通常情况下，程序员依然应该使用Java那样去管理文件，但是对于那些短小的类而言,你应该按照具体职责将它们放到同一个文件中</li>
</ul>
<pre><code>package  com.linjiamin.kt.play
class Rectangle(val height: Int, val width: Int) {
    val isSquare: Boolean get() = height == width
}
class Person(var name:String)
</code></pre><p><br></p>
<h2 id="枚举和-when"><a href="#枚举和-when" class="headerlink" title="枚举和 when"></a>枚举和 when</h2><p><br></p>
<h3 id="声明枚举"><a href="#声明枚举" class="headerlink" title="声明枚举"></a>声明枚举</h3><ul>
<li>在kotlin当中，声明一个枚举类，需要 enum class 两个关键字</li>
</ul>
<pre><code>enum class Color{
    RED,ORANGE,YELLOW,GREEN,BLUE,INDIGO,VIOLET
}
</code></pre><ul>
<li>更常规的用法,并为其构造方法和其他特定的方法，注意枚举列表必须与其他方法用分号隔开，这是kotlin中唯一一个必须使用分号结尾的地方</li>
</ul>
<pre><code>enum class Color(val r: Int, val g: Int, val b: Int) {
    RED(255, 9, 9), ORANGE(255, 165, 0),
    GREEN(0, 255, 0), YELLOW(255, 255, 0),
    BLUE(0, 0, 255), INDIGO(75, 0, 130), VIOLET(238, 130, 238);

    fun rgb() = (r * 256 + g) * 256 + b
}
fun main(args:Array&lt;String&gt;){
    println(Color.BLUE.rgb())
}
</code></pre><p><br></p>
<h3 id="使用-when"><a href="#使用-when" class="headerlink" title="使用 when"></a>使用 when</h3><ul>
<li>when 是 switch 的高级替代品</li>
</ul>
<ul>
<li>when 不但是分支控制语句，还是一个表达式，因此它具有返回值,并且不需要使用break语句，同时这个例子也体现了kotlin可以在函数中声明函数</li>
</ul>
<pre><code>fun main(args: Array&lt;String&gt;) {
    fun getColorName(color: Color) =
            when (color) {
                Color.RED -&gt; &quot;Red&quot;
                Color.ORANGE -&gt; &quot;Orange&quot;
                Color.GREEN -&gt; &quot;Green&quot;
                Color.BLUE -&gt; &quot;Blue&quot;
                Color.YELLOW -&gt; &quot;Yellow&quot;
                Color.INDIGO -&gt; &quot;Indigo&quot;
                Color.VIOLET -&gt; &quot;Violet&quot;
            }

    println(getColorName(Color.BLUE))
}
</code></pre><ul>
<li>你可以使用列表的形式合并分支减少重复代码,使用import语句可以导入枚举类的所有常量，不再需要使用类名来引用</li>
</ul>
<pre><code>import com.linjiamin.kt.play.Color.\*
fun main(args: Array&lt;String&gt;) {
    fun getWarmth(color: Color) =
            when (color) {
                RED,
                ORANGE,
                YELLOW -&gt; &quot;warm&quot;

                BLUE,
                INDIGO,
                VIOLET -&gt; &quot;cold&quot;

                GREEN -&gt; &quot;neutral&quot;
            }

    println(getWarmth(Color.ORANGE))
}
</code></pre><p><br></p>
<h3 id="when支持任意对象"><a href="#when支持任意对象" class="headerlink" title="when支持任意对象"></a>when支持任意对象</h3><ul>
<li>在java中，case标签只支持枚举常量，字符串和数字字面量，而在 kotlin中，when支持所有对象,在下面这个例子当中，我们传入两个Color并使用setOf函数将他们合成为一个set对象，编译器能够推断出这种set共有多少种可能的情况</li>
</ul>
<pre><code>fun mix(c1: Color, c2: Color) =
        when (setOf(c1, c2)) {
            setOf(RED, YELLOW) -&gt; ORANGE
            setOf(YELLOW, BLUE) -&gt; GREEN
            setOf(BLUE, VIOLET) -&gt; INDIGO
            else -&gt; throw Exception(&quot;Dirty Color&quot;)
        }
fun main(args: Array&lt;String&gt;) {
    println(mix(RED,YELLOW))
}
</code></pre><p><br></p>
<h3 id="不带参数的when"><a href="#不带参数的when" class="headerlink" title="不带参数的when"></a>不带参数的when</h3><ul>
<li>在 when 当中 构造 setOf 会带来性能上的损耗，使用不带参数的when可以解决这种问题，但是可读性会下降</li>
</ul>
<pre><code>fun mixOptimized(c1: Color, c2: Color) = when {
    (c1 == RED &amp;&amp; c2 == YELLOW) || (c1 == YELLOW &amp;&amp; c2 == RED) -&gt;
        ORANGE

    (c1 == YELLOW &amp;&amp; c2 == BLUE) || (c1 == BLUE &amp;&amp; c2 == YELLOW) -&gt;
        GREEN

    (c1 == BLUE &amp;&amp; c2 == VIOLET) || (c1 == VIOLET &amp;&amp; c2 == BLUE) -&gt;
        INDIGO

    else -&gt; throw Exception(&quot;dirty color&quot;)
}
fun main(args: Array&lt;String&gt;) {
    println(mixOptimized(RED, YELLOW))
}
</code></pre><p><br></p>
<h3 id="智能转换"><a href="#智能转换" class="headerlink" title="智能转换"></a>智能转换</h3><ul>
<li>使用 is 关键字可以进行类型检查和自动转换类型，类似java中的instanceOf，但 is 显然更加简洁，注意在kotlin中，分支可以是代码块，这个时候代码块中的最后一个表达式会作为when表达式的值</li>
</ul>
<pre><code>class Dog {
    fun bark() {
        println(&quot;bark&quot;)
    }
}
class Duck {
    fun swim() {
        println(&quot;swim&quot;)
    }
}
fun test(animal: Any) = when (animal) {
    is Dog -&gt; {
        print(&quot;I am a dog,I can &quot;)
        animal.bark()
        &quot;wan !&quot;
    }

    is Duck -&gt; {
        print(&quot;I am a duck,I can &quot;)
        animal.swim()
        &quot;ga !&quot;
    }
    else -&gt; throw IllegalArgumentException()
}
fun main(args: Array&lt;String&gt;) {
    println(test(Dog()))
    println(test(Duck()))
}
//输出
//I am a dog,I can bark
//wan !
//I am a duck,I can swim
//ga !
</code></pre><p><br></p>
<h2 id="while-和-for"><a href="#while-和-for" class="headerlink" title="while 和 for"></a>while 和 for</h2><p><br></p>
<h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><ul>
<li>在 kotlin 中的 while 和 do while 结构和 java 没有任何区别，这里就不讲解了</li>
</ul>
<p><br></p>
<h3 id="迭代数字"><a href="#迭代数字" class="headerlink" title="迭代数字"></a>迭代数字</h3><p><br></p>
<h4 id="区间和数列"><a href="#区间和数列" class="headerlink" title="区间和数列"></a>区间和数列</h4><ul>
<li><p>使用 in 可以使用在for中指示一个区间，在kotlin中区间是包含的，或者说闭合的</p>
<p>  fun main(args: Array<string>) {</string></p>
<pre><code>for(i in 1..100){
    print(&quot; $i&quot;)
}
</code></pre><p>  }</p>
</li>
</ul>
<ul>
<li>你觉得上面的操作没什么新意，那么看看这几行,kotlin中的迭代不仅支持数字区间还支持字符区间,在区间中可以指定步长，而数字区间中还可以使用downto指定方向</li>
</ul>
<pre><code>fun main(args: Array&lt;String&gt;) {
    for(c in &apos;A&apos;..&apos;Z&apos; step 3 )
        print(&quot;$c&quot;)
}


fun main(args: Array&lt;String&gt;) {
    for(i in 100 downTo 1 step 3 )
        print(&quot;$i&quot;)
}
</code></pre><ul>
<li>更多时候我们需要的是半闭合的区间，这种时候可以使用 until 关键字,下面这个例子中100不会被输出</li>
</ul>
<pre><code>fun main(args: Array&lt;String&gt;) {
    for(i in 0 until 100 )
        print(&quot; $i&quot;)
}
</code></pre><p><br></p>
<h3 id="迭代map"><a href="#迭代map" class="headerlink" title="迭代map"></a>迭代map</h3><ul>
<li>for 循环允许展开迭代中的集合的元素，例如下面这个例子中将map的键值对存储到两个独立的变量当中，在这个例子中集合看起来更像数组，是的，kotlin中可以使用中括号来代替get和put方法</li>
</ul>
<pre><code>val binReps = TreeMap\&lt;Char,String\&gt;()
fun test() {
  for(c in &apos;a&apos; .. &apos;f&apos;){
      val bin = Integer.toBinaryString(c.toInt())
      binReps[c] = bin
  }
    for ((letter,binary) in binReps){
        println(&quot;$letter = $binary&quot;)
    }
}

val list = arrayListOf(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;)
fun test() {
    for ((index,element) in list.withIndex()){
        println(&quot;$index = $element&quot;)
    }
}
</code></pre><p><br></p>
<h3 id="检查区间"><a href="#检查区间" class="headerlink" title="检查区间"></a>检查区间</h3><ul>
<li>使用in和!in可以检查区间中的成员，即检查某个值是否在区间当中</li>
</ul>
<pre><code>fun isLetter(c: Char) = c in &apos;a&apos;..&apos;z&apos; || c in &apos;A&apos;..&apos;z&apos;
fun isNotDigit(c: Char) = c !in &apos;0&apos;..&apos;9&apos;
fun main(args: Array&lt;String&gt;) {
    print(isLetter(&apos;c&apos;))
    print(isNotDigit(&apos;c&apos;))
}
</code></pre><p><br></p>
<h2 id="kotlin中的异常"><a href="#kotlin中的异常" class="headerlink" title="kotlin中的异常"></a>kotlin中的异常</h2><ul>
<li>kotlin中异常与java相似，不过不必使用new关键之来创建一个异常的实例，同时throw结构是一个表达式</li>
</ul>
<pre><code>val percentage = if (number in 0..100)
    number
else throw IllegalArgumentException(&quot;a percentage value must be between 0 and 100:$number&quot;)
</code></pre><p><br></p>
<h3 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try catch finally"></a>try catch finally</h3><ul>
<li>kotlin不区分受检异常和未受检异常，因此不需要使用throw关键字来声明方法可能抛出的异常</li>
</ul>
<pre><code>fun readNumber(reader: BufferedReader) :Int? {

    try {
        val line = reader.readLine()
        return Integer.parseInt(line)

    }catch (e:NumberFormatException){
        return null
    }finally {
        reader.close()
    }
}
</code></pre><p><br></p>
<h3 id="try-作为表达式"><a href="#try-作为表达式" class="headerlink" title="try 作为表达式"></a>try 作为表达式</h3><ul>
<li>在kotlin中try和when以及if一样，引入了表达式，如果语句中包括多个表达式，那么最后一个表达式的值就是try表达式的值，如果中间抛出了异常，那么catch表达式的值就是最终的值</li>
</ul>
<pre><code>fun readNumber(reader: BufferedReader) {
    val number = try {
        Integer.parseInt(reader.readLine())
    }catch (e:NumberFormatException){
        null
    }
     print(number)
}
</code></pre><p><br></p>
<h1 id="函数的定义和调用"><a href="#函数的定义和调用" class="headerlink" title="函数的定义和调用"></a>函数的定义和调用</h1><p><br></p>
<h2 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h2><p><br></p>
<h2 id="让函数更好调用"><a href="#让函数更好调用" class="headerlink" title="让函数更好调用"></a>让函数更好调用</h2><p><br></p>
<h3 id="命名参数"><a href="#命名参数" class="headerlink" title="命名参数"></a>命名参数</h3><p><br></p>
<h3 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h3>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Architecture Components 系列 - Lifecycle]]></title>
      <url>/2018/03/29/Lifecycle/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><strong> 这几个月总被项目耽搁，很久没学过什么东西了，文章也没怎么写，翻翻博客，前面的几篇文章都太监了，再早一点的连链接都挂了。感觉很羞愧，赶紧开几个系列文章压压惊。</strong></p>
<p><strong> Architecture Components 是安卓官方推出的数据驱动组件全家桶，包括 Lifecycle，LiveData，ViewModel，Room，Paging等，使用该全家桶最直观的效果就是，你更新数据库的时候，UI可以自动更新并且再也不用担心复杂的生命周期对app产生的负面影响。另外 LiveData是目前MVVM架构的核心依赖库，如果你想学习MVVM架构，也应该将Architecture Components作为入门基础</strong></p>
<p><strong>在入门之前，推荐先观看官方的<a href="https://www.youtube.com/watch?v=vOJCrbr144o" target="_blank" rel="external">介绍视频</a></strong></p>
<p><br></p>
<h2 id="啥是Lifecycle啊"><a href="#啥是Lifecycle啊" class="headerlink" title="啥是Lifecycle啊"></a>啥是Lifecycle啊</h2><ul>
<li>Lifecycle是 Architecture Components 组件的基础，它允许我们使用观察者模式监听Activity和Fragment的生命周期，LiveData的生命周期感知能力实际上就来自Lifecycle</li>
</ul>
<ul>
<li>熟悉MVP模式的开发者肯定都有一套MVP基类的封装，其中的Activity和Fragment完成了与presenter的生命周期绑定，这是很自然的</li>
</ul>
<pre><code>@Override
@CallSuper
protected void onResume() {
    super.onResume();
    if (mPresenter != null)
        mPresenter.onResume();
}

@Override
@CallSuper
protected void onStop() {
    super.onStop();
    if (mPresenter != null)
        mPresenter.onStop();
}
</code></pre><ul>
<li>而Lifecycle为我们提供了继承以外的切入点，我们先来看看怎么使用它们</li>
</ul>
<pre><code>//实现一个LifecycleObserver
//使用注解监听生命周期时间，这有点像eventbus
public class MyObserver implements LifecycleObserver {
    private static final String TAG = &quot;MyObserver&quot;;

    @OnLifecycleEvent(Lifecycle.Event.ON_CREATE)
    public void onCreate() {
        Log.d(TAG, &quot;onCreate: &quot;);
    }

    … 

    //在Activity或Fragmet中
    getLifecycle().addObserver(new MyObserver())；

    //启动Activity，LifecycleObserver被注解的方法被执行了
    //logcat中
    D/MyObserver: onCreate: 
</code></pre><p><br></p>
<h2 id="为啥要Lifecycle啊"><a href="#为啥要Lifecycle啊" class="headerlink" title="为啥要Lifecycle啊"></a>为啥要Lifecycle啊</h2><ul>
<li>确实可以感觉到Lifecycle的用法非常简洁，但是既然我们都已经封装好了自己的库，还有必要使用LifeCycle吗。实际上是有的，我们这样实现的生命周期感知实际上是被动的，试问你怎么知道当前的view处于什么周期呢，写在onCreate中的代码一定在onCreate中执行吗，如果我在其中执行异步操作呢？为了这个解决这个问题，你可以添加一个标记，然后在不同的回调方法中维护它，但是Lifecycle提供了更好的解决方案，让我们主动查询生命周期</li>
</ul>
<pre><code>if(getLifecycle().getCurrentState() == Lifecycle.State.STARTED){
        //do something
    }

if(getLifecycle().getCurrentState().isAtLeast(Lifecycle.State.RESUMED)){
        //do something
    }
</code></pre><ul>
<li>使用Lifecycle也可以使得代码更加解耦，比如说我们的项目中有一个监听遥感的模块，那么我们可以在onResume和onDestroy中开始和解除监听，假如我们现在又要加入一个监听地理位置的功能呢，这些模块都是独立的但是目前它们的生命周期都落在负责这个界面的人的手上，由那个人去调用，而使用Lifecycle之后，你只需要像下面这样就可以分离职责，一个LifeCycle可以有多个Observer</li>
</ul>
<pre><code>getLifecycle().addObserver(new MyObserver());
getLifecycle().addObserver(new YourObserver());
getLifecycle().addObserver(new HisObserver());
getLifecycle().addObserver(new HerObserver());
</code></pre><ul>
<li>学过一点设计模式应该都清楚，组合优先于继承，下面是一个我参与的项目中十分常见的Fragment的继承关系,每当添加一个新特性都有可能需要加一层继承关系，而java又不支持多继承，引入Lifecycle之后功能特性可以写到Observer当中，如果某个组件需要这个特性只需要调用addObserver即可完成绑定工作，逻辑也就更加清晰了</li>
</ul>
<pre><code>public class DeviceDetailFragment extends BaseMvpFragment\&lt;DeviceDetailContract.Presenter\&gt; implements DeviceDetailContract.View

public abstract class BaseMvpFragment\&lt;P extends MSBaseContract.BasePresenter\&gt; extends MSBaseMvpFragment&lt;P&gt;

public abstract class MSBaseMvpFragment\&lt;P extends MSBaseContract.BasePresenter\&gt; extends MSBaseFragment

public abstract class MSBaseFragment extends MSLazyFragment

public class MSLazyFragment extends MSBaseLazyFragment 

public class MSBaseLazyFragment extends Fragment
</code></pre><ul>
<li>其实我觉得最重要的理由其实是官方已经把LifeCycle植入到SupportActivity等组件当中了，只要你的support库在26以上，那么你就已经依赖了Lifecycle，不管你如何强调不要重复造轮子，既然官方强制导入了Lifecycle，那么现在重复的就是你的轮子</li>
</ul>
<pre><code>public class SupportActivity extends Activity implements LifecycleOwner
</code></pre><p><br></p>
<h2 id="在support-26以下使用Lifecycle"><a href="#在support-26以下使用Lifecycle" class="headerlink" title="在support 26以下使用Lifecycle"></a>在support 26以下使用Lifecycle</h2><ul>
<li>之前提到，对于活动而言 Lifecycle是在SupportActivity当中实现的，那么看一下我们怎么让Activity也支持Lifecycle，我们只需要让其实现LifecycleOwner接口，这个接口只有一个getLifecycle方法，返回一个生命周期的提供者</li>
</ul>
<pre><code>public interface LifecycleOwner {
    /**
     * Returns the Lifecycle of the provider.
     *
     * @return The lifecycle of the provider.
     */
    Lifecycle getLifecycle();
}
</code></pre><ul>
<li>这个get方法实现起来也很简单，只要返回LifecycleRegistry即可</li>
</ul>
<pre><code>@NonNull
@Override
public Lifecycle getLifecycle() {
    if(lifecycle == null)lifecycle = new LifecycleRegistry(this);
    return new LifecycleRegistry(this);
}
</code></pre><ul>
<li>在support 26以下，情况则有小小的不同，首先你需要依赖Lifecycle，注意Lifecycle版本不能太高，否则会与support库冲突</li>
</ul>
<pre><code>    compile &quot;android.arch.lifecycle:runtime:1.0.0-alpha1&quot;
compile &quot;android.arch.lifecycle:extensions:1.0.0-alpha1&quot;
    annotationProcessor &quot;android.arch.lifecycle:compiler:1.0.0-alpha1&quot;
</code></pre><ul>
<li>然后让Activity或Fragment实现 LifecycleRegistryOwner 接口，该接口同样只有一个getLifecycle方法,但返回的是LifecycleRegistry</li>
</ul>
<pre><code>@NonNull
@Override
public LifecycleRegistry getLifecycle() {
    if(lifecycle == null)lifecycle = new LifecycleRegistry(this);
    return new LifecycleRegistry(this);
}
</code></pre><p><br></p>
<h2 id="Lifecycle-实现细节"><a href="#Lifecycle-实现细节" class="headerlink" title="Lifecycle 实现细节"></a>Lifecycle 实现细节</h2><p><br></p>
<h3 id="透明初始化"><a href="#透明初始化" class="headerlink" title="透明初始化"></a>透明初始化</h3><ul>
<li>Lifecycle中非常值得学习的一点就是它的透明初始化，什么是透明呢，不妨从反面说起，我们在使用第三方库时常常要手动调用初始化操作，最常见的做法是在Application的onCreate中调用各种init，而Lifecycle巧用provider，将初始化操作交给了android框架和库本身</li>
</ul>
<ul>
<li>Lifecycle注册了一个专门用于初始化的provider，称其为木马</li>
</ul>
<pre><code>\&lt;provider
        android:name=&quot;android.arch.lifecycle.LifecycleRuntimeTrojanProvider&quot;
        android:authorities=&quot;${applicationId}.lifecycle-trojan&quot;
        android:exported=&quot;false&quot;
        android:multiprocess=&quot;true&quot; /&gt;
</code></pre><ul>
<li>这个provider中只有onCreate是有实际意义的，它从getContext中获得了Application的Context并调用需要context的初始化方法，由于provider的onCreate总是早于Activity的onCreate执行，所以这个方法是可行的</li>
</ul>
<pre><code>public class LifecycleRuntimeTrojanProvider extends ContentProvider {
    @Override
    public boolean onCreate() {
        LifecycleDispatcher.init(getContext());
        ProcessLifecycleOwner.init(getContext());
        return true;
    }

    @Nullable
    @Override
    public Cursor query(@NonNull Uri uri, String[] strings, String s, String[] strings1,
            String s1) {
        return null;
    }

    @Nullable
    @Override
    public String getType(@NonNull Uri uri) {
        return null;
    }

    @Nullable
    @Override
    public Uri insert(@NonNull Uri uri, ContentValues contentValues) {
        return null;
    }

    @Override
    public int delete(@NonNull Uri uri, String s, String[] strings) {
        return 0;
    }

    @Override
    public int update(@NonNull Uri uri, ContentValues contentValues, String s, String[] strings) {
        return 0;
    }
}
</code></pre><p><br><br><br><br><strong>全文完</strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HTTP权威指南 笔记]]></title>
      <url>/2018/03/04/httpGuide/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><br></p>
<h2 id="第一章-http概述"><a href="#第一章-http概述" class="headerlink" title="第一章 http概述"></a>第一章 http概述</h2><p><strong>略</strong></p>
<p><br></p>
<h2 id="第二章-URL与资源"><a href="#第二章-URL与资源" class="headerlink" title="第二章 URL与资源"></a>第二章 URL与资源</h2><p><br></p>
<h3 id="URL概述"><a href="#URL概述" class="headerlink" title="URL概述"></a>URL概述</h3><ul>
<li>URL是浏览寻找信息时所属的资源位置</li>
<li>URL提供了一种统一的资源命名方式和定位因特网上任意资源的手段</li>
</ul>
<p><br></p>
<h3 id="URI，URL-与-URN"><a href="#URI，URL-与-URN" class="headerlink" title="URI，URL 与 URN"></a>URI，URL 与 URN</h3><ul>
<li>URI是一种更通用的资源标识符，URL实际上是它的一个子集</li>
<li>URI主要包括URL和URN。URL通过描述资源的位置来标识资源。而URN通过名字来识别资源，与位置无关</li>
</ul>
<p><br></p>
<h3 id="URL语法"><a href="#URL语法" class="headerlink" title="URL语法"></a>URL语法</h3><ul>
<li><p>资源可以通过不同的方案进行访问，因此URL的语法会随着方案的不同而不同</p>
</li>
<li><p>大多数URL方案的语法都建立在由9个组件构成的通用格式上，注意几乎没有哪个URL包含了所有的组件，这些组件当中最重要的是方案scheme、主机host、路径path</p>
</li>
</ul>
<pre><code>&lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;\\#&lt;frag&gt;
</code></pre><ul>
<li>通用组件如下</li>
</ul>
<table>
<thead>
<tr>
<th>组件</th>
<th style="text-align:center">描述</th>
<th style="text-align:right">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>方案</td>
<td style="text-align:center">访问服务器以获取资源时要使用哪种协议</td>
<td style="text-align:right">无</td>
</tr>
<tr>
<td>用户</td>
<td style="text-align:center">某些方案访问资源时需要的用户名</td>
<td style="text-align:right">匿名</td>
</tr>
<tr>
<td>密码</td>
<td style="text-align:center">用户名后面可能包含的密码，中间由冒号分割</td>
<td style="text-align:right">E-mail地址</td>
</tr>
<tr>
<td>主机</td>
<td style="text-align:center">资源宿主服务器的主机名或点分IP地址</td>
<td style="text-align:right">无</td>
</tr>
<tr>
<td>端口</td>
<td style="text-align:center">资源宿主服务器正在监听的端口号。很多方案都有默认端口号（http的默认端口号为80）</td>
<td style="text-align:right">每个方案特有</td>
</tr>
<tr>
<td>路径</td>
<td style="text-align:center">服务器上资源的本地名，有一个斜杠（/）将其与前面的URL组件分隔开。路径组件的语法是与服务器和方案有关的，URL路径可以分成若干段，每段都可以有其特有的组件</td>
<td style="text-align:right">无</td>
</tr>
<tr>
<td>参数</td>
<td style="text-align:center">某些方案侯勇这个组件来指定输入参数，参数为名值对。URL中可以包含多个参数字段，它们互相之间以及与路径之间的其余部分之间用分号（;）分隔</td>
<td style="text-align:right">无</td>
</tr>
<tr>
<td>查询</td>
<td style="text-align:center">某些方案会用这个组件传递参数以激活应用程序（数据库，公告板，搜索引擎等）。查询组件的内容没用通用哪个格式，用问号（?）将其与URL的其余部分分隔开来</td>
<td style="text-align:right">无</td>
</tr>
<tr>
<td>片段</td>
<td style="text-align:center">一小片或者一部分资源的名字，引用对象时，不会将frag字段穿给服务器，这个字段是在客户端内部使用的，因此服务器会请求整个资源</td>
<td style="text-align:right">无</td>
</tr>
</tbody>
</table>
<p><br></p>
<h3 id="URL字符"><a href="#URL字符" class="headerlink" title="URL字符"></a>URL字符</h3><p><br></p>
<h4 id="URL字符集"><a href="#URL字符集" class="headerlink" title="URL字符集"></a>URL字符集</h4><ul>
<li><p>安全传输意味着URL的传输不能丢失信息，有些协议，比如传输电子邮件的协议会剥去一些特定的字符，因此URL只能使用一些相对较小的，通用的，安全字母表中的文字</p>
</li>
<li><p>设计者还希望URL可供人阅读，因此不可见字符不能在URL中使用</p>
</li>
</ul>
<ul>
<li>URL还得是完整的，有时人们会希望URL能够包含通用的安全字母表之外的二进制数据或字符。因此需要一种将不安全的字符转义为安全字符的机制，这种转义方法包含一个百分号（%）和后面两个表示ASCII码的十六进制</li>
</ul>
<p><br></p>
<h4 id="字符限制"><a href="#字符限制" class="headerlink" title="字符限制"></a>字符限制</h4><ul>
<li><p>在URL中有几个字符被保留起来，有着特殊的含义。有些字符不在定义的US-ASCII可打印字符中，有些字符会与某些因特网网关和协议产生混淆，因此不赞成使用</p>
</li>
<li><p>客户端在向其他应用程序发送任意URL之前，最好把所有不安全或者受限的字符进行转换</p>
</li>
<li><p>常见的保留及受限的字符如下</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>字符</th>
<th>保留/受限</th>
</tr>
</thead>
<tbody>
<tr>
<td>%</td>
<td>保留为编码字符的转移标志</td>
</tr>
<tr>
<td>/</td>
<td>保留作为路径组件中分隔路径段的定界符</td>
</tr>
<tr>
<td>.</td>
<td>保留在路径组件中使用</td>
</tr>
<tr>
<td>..</td>
<td>保留在路径组件中使用</td>
</tr>
<tr>
<td>#</td>
<td>保留作为分段定界符使用</td>
</tr>
<tr>
<td>?</td>
<td>保留作为查询字符串定界符使用</td>
</tr>
<tr>
<td>;</td>
<td>保留作为参数定界符使用</td>
</tr>
<tr>
<td>:</td>
<td>保留作为方案，用户/口令，以及主机/端口组件的定界符使用</td>
</tr>
<tr>
<td>$,+</td>
<td>保留</td>
</tr>
<tr>
<td>@ &amp; =</td>
<td>在某些方案的上下文中有特殊意义，保留</td>
</tr>
<tr>
<td>{}  ^ [ ] ’</td>
<td>由于各种传输Agent代理，比如网关的不安全处理，使用受限</td>
</tr>
<tr>
<td>\&lt;> “</td>
<td>不安全，这些字符在URL范围之外通常是有意义的，比如在文档中对URL自身进行定界，所以应该对其进行编码</td>
</tr>
<tr>
<td>0x00-0x1f，0x7f</td>
<td>受限，这些十六进制范围内的字符都在US-ASCII字符集的不可打印区间内</td>
</tr>
<tr>
<td>>0x7F</td>
<td>受限，十六进制值在此范围内的字符都不在US-ASCII字符集的7比特范围内</td>
</tr>
</tbody>
</table>
<p><br></p>
<h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><ul>
<li>常见方案如下</li>
</ul>
<table>
<thead>
<tr>
<th>方案</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>http</td>
<td>超文本传输协议，除了没有用户名和密码之外，与通用的URL格式相符，如果省略了端口，就默认为80，基本格式 <a href="http://host:port/path?query#frag" target="_blank" rel="external">http://host:port/path?query#frag</a></td>
</tr>
<tr>
<td>https</td>
<td>方案https与http是一对，唯一区别在于方案https使用了网景的SSL，SSL为HTTP连接提供了端到端的加密机制，其语法与HTTP的语法相同，默认端口为443</td>
</tr>
<tr>
<td>mailto</td>
<td>Mailto URL指向的是E-Mail地址，由于E-mail的行为与其他方案都有所不同（它并不指向任何可以直接访问的对象），所以mailto URL的格式与标准URL的格式也有所不同，基本格式 mailto:addr-spec 如 mailto:joe@joes-hardware.com</td>
</tr>
<tr>
<td>ftp</td>
<td>文件传输URL可以用来从FTP服务器上下载或者向其上载文件，并获取FTP服务器上的目录结构内容的列表，基本格式 ftp:user:passwird@host:port/path;params</td>
</tr>
<tr>
<td>file</td>
<td>表示一台指定的主机上可以直接访问的文件，如果省略了主机名就默认为正在使用URL的本地主机，基本格式 file:host/path</td>
</tr>
<tr>
<td>telnet</td>
<td>用于访问交互式业务，它表示的不是对象自身，而是可通过telnet协议访问的交互式应用程序</td>
</tr>
</tbody>
</table>
<p><br></p>
<h2 id="第二章-HTTP报文"><a href="#第二章-HTTP报文" class="headerlink" title="第二章 HTTP报文"></a>第二章 HTTP报文</h2><p><br></p>
<h3 id="报文流"><a href="#报文流" class="headerlink" title="报文流"></a>报文流</h3><p><br></p>
<h3 id="报文组成"><a href="#报文组成" class="headerlink" title="报文组成"></a>报文组成</h3><p><br></p>
<h3 id="报文语法"><a href="#报文语法" class="headerlink" title="报文语法"></a>报文语法</h3>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux命令行与shell脚本编程大全 笔记]]></title>
      <url>/2018/03/04/CommandLineAndShellScriptNote/</url>
      <content type="html"><![CDATA[<ul>
<li>英文书名 Linux Command Line and Shell Scripting Bible</li>
</ul>
<a id="more"></a>
<ul>
<li>慢更，非手打，直接copy电子版</li>
<li>每天记录一个Linux知识点</li>
<li>太监</li>
</ul>
<p><br></p>
<h1 id="初识-LInux-Shell"><a href="#初识-LInux-Shell" class="headerlink" title="初识 LInux Shell"></a>初识 LInux Shell</h1><p><strong>2017.11.15</strong></p>
<p><br></p>
<h2 id="深入理解LInux内核"><a href="#深入理解LInux内核" class="headerlink" title="深入理解LInux内核"></a>深入理解LInux内核</h2><p><br></p>
<h3 id="内核的功能概括"><a href="#内核的功能概括" class="headerlink" title="内核的功能概括"></a>内核的功能概括</h3><ul>
<li>内核主要负责以下四种功能</li>
</ul>
<pre><code> 系统内存管理
 软件程序管理
 硬件设备管理
 文件系统管理
</code></pre><p><br></p>
<h3 id="系统内存管理"><a href="#系统内存管理" class="headerlink" title="系统内存管理"></a>系统内存管理</h3><p> <em>内核不仅管理可用物理内存,还可以创建和管理虚拟内存</em> </p>
<h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><h5 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h5><ul>
<li>交换空间(swap space) ，内核通过硬盘上的存储空间来实现虚拟内存,这块区域称为交换空间</li>
</ul>
<ul>
<li>页面(page) ，内存存储单元按组划分成很多块,这些块称作页面</li>
</ul>
<ul>
<li>分页表，每个内存页面被放在物理内存或交换空间。然后,内核会维护一个分页表,保存分页到物理内存或交换空间的映射</li>
</ul>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><ul>
<li>换出(swapping out),内核会记录正在使用的页面,并自动把一段时间未访问的页面复制到交换空间，这个过程称为换出，</li>
</ul>
<ul>
<li>换入(swapped in)，当要访问一个被换出的页面时,内核必须从物理内存换出另外一个页面给它让出空间,然后把它从交换空间放到物理内存，这个过程称为换入</li>
</ul>
<ul>
<li>只要Linux系统在运行，换入换出内存页面的过程就不会停歇</li>
</ul>
<p><br></p>
<h3 id="软件程序管理"><a href="#软件程序管理" class="headerlink" title="软件程序管理"></a>软件程序管理</h3><p><em>进程(process),操作系统中正在运行的程序</em><br><em>内核控制着Linux系统如何管理运行在系统上的所有进程</em></p>
<h4 id="进程的启动"><a href="#进程的启动" class="headerlink" title="进程的启动"></a>进程的启动</h4><h5 id="init进程"><a href="#init进程" class="headerlink" title="init进程"></a>init进程</h5><ul>
<li>内核创建了第一个进程(称为init进程)并将其加载到虚拟内存中来启动系统上所有其他进程</li>
</ul>
<ul>
<li>内核启动任何其他进程时,都会在虚拟内存中给新进程分配一块专有区域来存储该进程用到的数据和代码</li>
</ul>
<h5 id="运行级"><a href="#运行级" class="headerlink" title="运行级"></a>运行级</h5><ul>
<li>Linux的init系统采用运行级。运行级决定init进程运行/etc/inittab文件或 /etc/rcX.d目录中定义好的特定类型的进程</li>
</ul>
<ul>
<li>运行级为1只启动基本的系统进程和一个控制台终端进程，仅有一人能登录系统,通常用来进行紧急的文件系统维护</li>
</ul>
<ul>
<li>运行级为3会启动大多数应用软件，但不会启动图形化桌面窗口</li>
</ul>
<ul>
<li>运行级为5会启动图形化的X Window，允许用户通过图形化桌面窗口登录</li>
</ul>
<p><br></p>
<h3 id="硬件设备管理"><a href="#硬件设备管理" class="headerlink" title="硬件设备管理"></a>硬件设备管理</h3><h4 id="驱动程序"><a href="#驱动程序" class="headerlink" title="驱动程序"></a>驱动程序</h4><p><em>任何Linux系统需要与之通信的设备,都需要在内核代码中加入其驱动程序代码</em><br><em>驱动程序代码相当于应用程序和硬件设备的中间人,允许内核与设备之间交换数据</em></p>
<h5 id="插入设备驱动代码"><a href="#插入设备驱动代码" class="headerlink" title="插入设备驱动代码"></a>插入设备驱动代码</h5><ul>
<li>Linux内核中有两种方法用于插入设备驱动代码</li>
</ul>
<pre><code> 编译进内核的设备驱动代码 
# 每次都要重新编译内核，十分低效的
 可插入内核的设备驱动模块
# 允许向运行中的内核插入或移除设备驱动代码，无需重新编译内核
</code></pre><h5 id="设备文件"><a href="#设备文件" class="headerlink" title="设备文件"></a>设备文件</h5><p><em>一切皆文件，Linux系统将硬件设备当成特殊的文件,称为设备文件</em></p>
<ul>
<li>设备文件分为3类</li>
</ul>
<pre><code> 字符型设备文件
# 一次只能处理一个字符的设备，如调制解调器和终端
 块设备文件
# 一次能处理大块数据的设备，比如硬盘
 网络设备文件
# 采用数据包发送和接收数据的设备，包括各种网卡和一个特殊的回环设备
# 这个回环设备允许Linux系统使用常见的网络编程协议同自身通信。
</code></pre><ul>
<li>Linux 为每个设备创建称为节点的特殊文件，与设备的所有通信通过设备节点完成。每个节点有唯一数值对(主设备号/次设备号)供Linux内核标识</li>
</ul>
<ul>
<li>类似的设备被划分到同样的主设备号下，次设备号用于标识主设备组下的某个特定设备。</li>
</ul>
<p><br></p>
<h3 id="文件系统管理"><a href="#文件系统管理" class="headerlink" title="文件系统管理"></a>文件系统管理</h3><ul>
<li>Linux内核支持通过不同类型的文件系统从硬盘中读写数据。除了自有的诸多文件系统外,还支持从其他操作系统(比如Microsoft Windows)采用的文件系统中读写数据</li>
</ul>
<ul>
<li>内核必须在编译时就加入对所有可能用到的文件系统的支持</li>
</ul>
<ul>
<li>Linux内核采用虚拟文件系统(Virtual File System,VFS)为和每个文件系统的交互提供一个标准接口</li>
</ul>
<p><br></p>
<h3 id="桌面环境"><a href="#桌面环境" class="headerlink" title="桌面环境"></a>桌面环境</h3><p><strong>2017.11.16</strong></p>
<h4 id="X-Window-系统"><a href="#X-Window-系统" class="headerlink" title="X Window 系统"></a>X Window 系统</h4><ul>
<li>X Window软件是直接和PC上的显卡及显示器打交道的底层程序，针对不同操作系统的版本有不同的实现，如Fedora的Wayland，Ubuntu的Mir</li>
</ul>
<ul>
<li>核心的X Window软件可以产生图形化显示环境，但仅此而已，它没有桌面环境供用户操作文件或是开启程序</li>
</ul>
<h4 id="图形桌面"><a href="#图形桌面" class="headerlink" title="图形桌面"></a>图形桌面</h4><ul>
<li>桌面环境都建立在X Window系统软件之上的，比较流行的有KDE，GNOME，Unity等</li>
</ul>
<ul>
<li>图形化桌面环境的弊端在于它们要占用相当一部分的系统资源来保证正常运行</li>
</ul>
<p><br></p>
<h1 id="bash-shell"><a href="#bash-shell" class="headerlink" title="bash shell"></a>bash shell</h1><p><br></p>
<h2 id="基本的shell命令"><a href="#基本的shell命令" class="headerlink" title="基本的shell命令"></a>基本的shell命令</h2><p><br></p>
<h3 id="启动shell"><a href="#启动shell" class="headerlink" title="启动shell"></a>启动shell</h3><ul>
<li>shell通常在用于登录终端时自启动</li>
</ul>
<ul>
<li>/etc/passwd文件包含了所有系统用户账户列表以及每个用户的基本配置信息，最后一个条目是用户使用的shell</li>
</ul>
<pre><code>parallels:x:1000:1000:Parallels,,,:/home/parallels:/bin/zsh
</code></pre><p><br></p>
<h3 id="浏览文件系统"><a href="#浏览文件系统" class="headerlink" title="浏览文件系统"></a>浏览文件系统</h3><h4 id="Linux-文件系统"><a href="#Linux-文件系统" class="headerlink" title="Linux 文件系统"></a>Linux 文件系统</h4><ul>
<li>虚拟目录 ，Linux在路径名中不使用驱动器盘符，文件都存储在单个目录结构中,这个目录被称为虚拟目录，它只包含一个称为根(root)目录的基础目录</li>
</ul>
<ul>
<li>根驱动器，PC上安装的第一块硬盘称为根驱动器，包含虚拟目录的核心，其他目录从那里构建，通常系统文件会存储在根驱动器，用户文件存储在另一驱动器</li>
</ul>
<ul>
<li>挂载点(mount point) ，Linux在根驱动器上创建称为挂载点的特别目录 ，让文件和目录出现在挂载点中,然而它们实际上存储在另外一个驱动器</li>
</ul>
<ul>
<li>通用的目录名用于表示一些常见的功能，常见目录名如下，它们基于文件系统层级标准(filesystem hierarchy standard,FHS)，很多Linux发行版都遵循FHS </li>
</ul>
<pre><code>/ 
# 虚拟目录的根目录。通常不会在这里存储文件
/bin 
# 二进制目录,存放许多用户级的GNU工具
/boot 
# 启动目录,存放启动文件
/dev 
# 设备目录,Linux在这里创建设备节点
/etc 
# 系统配置文件目录
/home 
# 主目录,Linux在这里创建用户目录
/lib 
# 库目录,存放系统和应用程序的库文件
/media 
# 媒体目录,可移动媒体设备的常用挂载点
/mnt 
# 挂载目录,另一个可移动媒体设备的常用挂载点
/opt 
# 可选目录,常用于存放第三方软件包和数据文件
/proc 
# 进程目录,存放现有硬件及当前进程的相关信息
/root 
# root用户的主目录
/sbin 
# 系统二进制目录,存放许多GNU管理员级工具
/run 
# 运行目录,存放系统运作时的运行时数据
/srv 
# 服务目录,存放本地服务的相关文件
/sys 
# 系统目录,存放系统硬件信息的相关文件
/tmp 
# 临时目录,可以在该目录中创建和删除临时工作文件
/usr
# 用户二进制目录,大量用户级的GNU工具和数据文件都存储在这里
/var 
# 可变目录,用以存放经常变化的文件,比如日志文件
</code></pre><h4 id="遍历目录"><a href="#遍历目录" class="headerlink" title="遍历目录"></a>遍历目录</h4><h5 id="绝对文件路径"><a href="#绝对文件路径" class="headerlink" title="绝对文件路径"></a>绝对文件路径</h5><ul>
<li>绝对文件路径定义了虚拟目录中的确切位置,以根目录开始,相当于目录全名</li>
</ul>
<ul>
<li>cd将shell会话切换到另一个目录 </li>
</ul>
<pre><code>➜  cd /usr/bin
</code></pre><ul>
<li>pwd命令可以显示出shell会话的当前目录 </li>
</ul>
<pre><code>➜  pwd
/usr/bin
</code></pre><h5 id="相对文件路径"><a href="#相对文件路径" class="headerlink" title="相对文件路径"></a>相对文件路径</h5><ul>
<li>相对文件路径允许用户指定一个基于当前位置的目标文件路径</li>
</ul>
<ul>
<li>有两个特殊字符可用于相对文件路径中</li>
</ul>
<pre><code> 单点符(.),表示当前目录;
 双点符(..),表示当前目录的父目录。
</code></pre><h4 id="文件和目录列表"><a href="#文件和目录列表" class="headerlink" title="文件和目录列表"></a>文件和目录列表</h4><h5 id="基本列表功能"><a href="#基本列表功能" class="headerlink" title="基本列表功能"></a>基本列表功能</h5><ul>
<li>ls ，最基本的形式会显示当前目录下的文件和目录 </li>
</ul>
<pre><code>➜  ls
Desktop    Downloads         Home   Pictures  Templates  vim
Documents  examples.desktop  Music  Public    Videos
</code></pre><ul>
<li>ls -a ，Linux经常采用点号开始的名称隐藏文件来保存配置信息 , -a 参数显示隐藏文件和普通文件 </li>
</ul>
<pre><code>➜  ls -a
.              Downloads         .oh-my-zsh                 .vim\_back
..             examples.desktop  .parallels                 .viminfo
.bash\_history  .fzf              Pictures                   .wget-hsts
</code></pre><h5 id="显示长列表"><a href="#显示长列表" class="headerlink" title="显示长列表"></a>显示长列表</h5><ul>
<li>ls -l ,长列表格式的输出</li>
</ul>
<ul>
<li>长列表格式的输出在每一行中列出了单个文件或目录。除了文件名,输出中还有其他有用信息</li>
</ul>
<pre><code>➜  \~ ls -l
total 48
drwxr-xr-x  2 parallels parallels 4096 Nov 25 19:11 Desktop
drwxr-xr-x  2 parallels parallels 4096 Aug 10 19:15 Documents
drwxr-xr-x  2 parallels parallels 4096 Aug 10 19:15 Downloads
</code></pre><ul>
<li>输出的第一行显示了在目录中包含的总块数。在此之后,每一行都包含了关于文件(或 目录)的下述信息</li>
</ul>
<pre><code> 文件类型,比如目录(d)、文件(-)、字符型文件(c)或块设备(b); 
 文件的权限(参见第6章);
 文件的硬链接总数;
 文件属主的用户名;
 文件属组的组名;
 文件的大小(以字节为单位); 
 文件的上次修改时间;
 文件名或目录名。
</code></pre><p><br></p>
<h3 id="处理文件"><a href="#处理文件" class="headerlink" title="处理文件"></a>处理文件</h3><h4 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h4><ul>
<li>touch，创建空文件</li>
</ul>
<pre><code>➜  touch test
➜  ls -l test  
-rw-rw-r-- 1 parallels parallels 0 Nov 26 22:42 test
</code></pre><ul>
<li>touch -l , 改变修改时间</li>
</ul>
<ul>
<li>touch -a ，改变访问时间</li>
</ul>
<h4 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h4><ul>
<li>cp source destination ，将文件复制到另一个位置 ，当两个参数都是文件名时将源文件复制成一个新文件</li>
</ul>
<ul>
<li>cp -R ，递归地复制整个目录的内容</li>
</ul>
<h4 id="重命名文件"><a href="#重命名文件" class="headerlink" title="重命名文件"></a>重命名文件</h4><p><strong>2017.11.17</strong></p>
<p><strong>在Linux中, 重命名文件为移动(moving)</strong></p>
<ul>
<li>mv source new_name将文件和目录移动到另一个位置或者重命名</li>
</ul>
<pre><code>➜  mv data\_dir new\_data\_dir
</code></pre><ul>
<li>文件的时间戳和inode编号不会改变，改变的只有名称和位置</li>
</ul>
<h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><ul>
<li>rm source ,删除文件</li>
</ul>
<pre><code>➜  \~ rm data\_file 
</code></pre><h4 id="链接文件"><a href="#链接文件" class="headerlink" title="链接文件"></a>链接文件</h4><p><strong>2017.11.18</strong></p>
<ul>
<li>在Linux中有两种 不同类型的文件链接</li>
</ul>
<pre><code> 符号链接 
 硬链接
</code></pre><h5 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h5><ul>
<li>ln -s source link_name ,创建符号链接</li>
</ul>
<pre><code>➜  ln -s data\_file sl\_data\_file
➜  ls -l \*data\_file
-rw-rw-r-- 1 parallels parallels 7 Nov 27 22:00 data\_file
lrwxrwxrwx 1 parallels parallels 9 Nov 27 22:01 sl\_data\_file -\&gt; data\_file
</code></pre><ul>
<li>readlink sl_file ，获取原文件绝对路径</li>
</ul>
<pre><code>➜  readlink sl\_data\_file 
data\_file
</code></pre><ul>
<li>符号链接就是一个实实在在的文件,它指向存放在虚拟目录结构中某个地方的另一个文件</li>
</ul>
<ul>
<li>注意不要创建软连接的软连接，这会让链接十分混乱，不便于管理</li>
</ul>
<h5 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h5><ul>
<li>ln source link_name 创建硬链接</li>
</ul>
<pre><code>➜  ln data\_file hl\_data\_file
➜  ls -l \*data\_file  
-rw-rw-r-- 2 parallels parallels 13 Nov 27 22:02 data\_file
-rw-rw-r-- 2 parallels parallels 13 Nov 27 22:02 hl\_data\_file
lrwxrwxrwx 1 parallels parallels  9 Nov 27 22:01 sl\_data\_file -\&gt; data\_file
</code></pre><ul>
<li>索引节点号(Inode Index)，在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号</li>
</ul>
<ul>
<li>只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放，硬链接有防止误删的功能</li>
</ul>
<ul>
<li>cp 硬链接会得到原文件的副本，一般不用复制链接文件，而是创建新的链接即可</li>
</ul>
<p><br></p>
<h3 id="处理目录"><a href="#处理目录" class="headerlink" title="处理目录"></a>处理目录</h3><h4 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h4><ul>
<li>mkdir dir_name，创建新目录</li>
</ul>
<pre><code>➜  mkdir dir  
➜  ls -ld dir  
drwxrwxr-x 2 parallels parallels 4096 Nov 28 21:21 dir
</code></pre><ul>
<li>mkdir -p dir1/dir2/dir3/dir4，同时根据需要创建目录和子目录</li>
</ul>
<pre><code>➜  mkdir -p dir1/dir2/dir3/dir4 
➜  ls -R dir1
dir1:
dir2
dir1/dir2:
dir3
dir1/dir2/dir3:
dir4
dir1/dir2/dir3/dir4:
</code></pre><h4 id="删除目录"><a href="#删除目录" class="headerlink" title="删除目录"></a>删除目录</h4><p><br></p>
<h3 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件"></a>查看文件</h3><h4 id="查看文件类型"><a href="#查看文件类型" class="headerlink" title="查看文件类型"></a>查看文件类型</h4><ul>
<li>随手打开一个二进制文件可能导致终端挂起</li>
<li>file file_name ,返回文件类型</li>
</ul>
<pre><code>➜  file libatomic.a 
libatomic.a: current ar archive
➜  file scan-view 
scan-view: Python script, ASCII text executable
</code></pre><h4 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h4><ul>
<li>cat file_name , 显示文本文件内容</li>
</ul>
<h2 id="更多的-bash-shell-命令"><a href="#更多的-bash-shell-命令" class="headerlink" title="更多的 bash shell 命令"></a>更多的 bash shell 命令</h2><h3 id="检测程序"><a href="#检测程序" class="headerlink" title="检测程序"></a>检测程序</h3><h4 id="探查进程"><a href="#探查进程" class="headerlink" title="探查进程"></a>探查进程</h4><p><br></p>
<h1 id="理解-shell"><a href="#理解-shell" class="headerlink" title="理解 shell"></a>理解 shell</h1>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[译文：对匈牙利命名法说不]]></title>
      <url>/2017/12/30/Hungarian-translate/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><br></p>
<pre><code>译者：

本文来自 Android 大神 Jake Wharton,他是 ButerKnife 和 RxBinding 的开发者,
OkHttp，RxJava，Retrofit 等流行的 Android 开发库的重要贡献者，对安卓编程风格的演进具有不可磨灭的影响
</code></pre><ul>
<li><a href="http://jakewharton.com/just-say-no-to-hungarian-notation/" target="_blank" rel="external">原文博客地址</a></li>
<li><a href="https://alberthumbert.github.io/2017/12/30/Hungarian-translate/">译文地址</a></li>
<li><a href="https://www.jianshu.com/p/3dcc81d3e937" target="_blank" rel="external">简书地址</a></li>
</ul>
<p><br></p>
<p><strong>每一天都会有为安卓应用和库编写的java代码携带着一种传染病诞生，这种传染病的名字就叫做匈牙利命名法。</strong><br><strong>匈牙利命名法在安卓领域的推广纯粹是个意外，然而它依然受到错误的辩护。让我们先来推垮几个常见的主张：</strong></p>
<p><br></p>
<ul>
<li><strong>“《安卓 java 代码风格指南》推荐使用匈牙利命名法”</strong></li>
</ul>
<p>根本就不存在所谓指导程序员如何编写java代码的《安卓java代码风格指南》，绝大部分人口中子虚乌有的编码风格指南来自于 <a href="https://source.android.com/source/code-style#follow-field-naming-conventions" title="面向贡献者的 AOSP 代码样式指南&gt;" target="_blank" rel="external"> 《面向贡献者的 AOSP 代码样式指南》 </a></p>
<p>你可不是在为AOSP项目编写代码，因此你并不需要遵循他们的指南。</p>
<p>即便你正在编写未来可能纳入AOSP的代码，你也不需要遵循这份指南,<br>几乎所有AOSP所导入的java库都没有遵循它，甚至AOSP项目中的一部分开发人员都没有这么做</p>
<p><br></p>
<ul>
<li><strong>“Android 样例使用匈牙利命名法”</strong></li>
</ul>
<p>一些样例诞生于AOSP项目的开发平台所以它们奉行AOSP的风格。而那些不来自AOSP的样例，它们的作者要么错误地相信了别的主张，要么只是单纯地忘了纠正编写这些样例时所使用的风格</p>
<p><br></p>
<ul>
<li><strong>“那些额外的信息为 code review 提供了帮助”</strong></li>
</ul>
<p>使用变量名前缀m和s分别可以声明变量是private/package的非静态成员或静态成员①，不然进行code review时将无法得知这些信息。这种方式能够推断那些代码改动②中不可见的变量。从而，不管怎样，一个变量的可见性都可以被显而易见地得知。</p>
<p>在我反驳这种观点之前，我们先来定义一下匈牙利命名法。根据维基百科，匈牙利命名法有两种：</p>
<ul>
<li><p>1.</p>
<pre><code>系统命名法将变量的数据类型加入到变量名当中。
一个long类型的用户id在java中将被一个名为lUser的变量代表，以此来表示它的用途和数据类型
</code></pre></li>
<li><p>2.</p>
<pre><code>应用命名法将变量在语义上的用途而不是逻辑上的用途或目的加入到变量名中。
保存私有信息的变量带有某种前缀（如mUserId）而保存公有信息的变量则有另一种前缀，或者压根没有前缀
</code></pre></li>
</ul>
<p>那么当你看见一个成员变量被使用时，究竟哪一种信息对code review来说更重要，是它的可见性还是数据类型？</p>
<p>可见性在code review当中是一种无需关注的属性。成员变量已经出现并且能够被使用，而且它的可见性大概也已经在上一个改动中被审阅过了<br>然而，成员变量的类型对于其在代码改动中如何被使用有更加直接的影响。被正确调用的方法名，参数的位置，可以被调用的方法，这些全都与变量的类型直接相关。</p>
<p>因此提出应用匈牙利命名法是错误的不单只是因为它没有用处，还因为系统匈牙利命名法能提供更多有关的信息。这可不是在说你应该使用系统匈牙利命名法，数据类型和可见性时常改动，而你将会忘记修改它们的名字。毕竟并不难发现静态的mContext成员变量</p>
<p><br></p>
<ul>
<li><strong>“额外的信息有助于开发”</strong></li>
</ul>
<p>Android Studio和IntelliJ IDEA会根据成员身份（静态或非静态）在视觉上区分非成员变量</p>
<p>IDE默认强制使用正确的可见性和数据类型，所以一个命名规定不会带来任何东西。简单敲击键盘，就会有弹窗显示变量的那三种（以及更多）属性。</p>
<p><img src="http://jakewharton.com/static/post-image/hungarian-idea.png" alt=""></p>
<p><br></p>
<ul>
<li><strong>“我想像谷歌官方一样编写java代码”</strong></li>
</ul>
<p>尽管安卓和AOSP都是该公司的一部分，谷歌在他们的<a href="https://google.github.io/styleguide/javaguide.html#s5.1-identifier-names" target="_blank" rel="external">编码风格指南</a>中积极明确地禁止了匈牙利命名法的使用。公开的java风格指南是AOSP经年累月的内部习惯固化的产物。</p>
<p>安卓起源于谷歌之外，AOSP团队早已染上了匈牙利命名的顽疾。现在对其进行修改将是一种无用的扰乱并且会给分支和第三方合作者带来冲突。</p>
<p>但你对下面这个观点的持续支持与实践能够让我们在人生中根除这种疾病</p>
<p><strong>朋友就不该再让朋友使用匈牙利命名法③</strong></p>
<p><br></p>
<p><strong>— Jake Wharton</strong></p>
<p><br><br><br></p>
<pre><code>译者注：

① field(成员): 根据oracle提供的文档，field这个词在未特指的情况下指的是非静态的成员变量，
    而在本文单纯指成员变量，没有额外的限定

② change(代码改动)：在该文中应指git等svn中的提交差异

③ 该文中标题中的“不”以及结尾处的两个“朋友”在原文中使用的分别是 mNo,mFriends,sFriends,
    这里直接舍弃了匈牙利命名法的前缀来翻译，至于作者使用这些前缀的意图，感兴趣的读者可以自行借助原文进行思考
</code></pre><ul>
<li><a href="http://jakewharton.com/just-say-no-to-hungarian-notation/" target="_blank" rel="external">原文博客地址</a></li>
<li><a href="https://github.com/JakeWharton/" target="_blank" rel="external">作者GitHub地址</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/information/glossary.html" target="_blank" rel="external">翻译参考资料</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 交叉编译 Shape/KML/GeoJSON 文件读写库 Gdal 注意事项]]></title>
      <url>/2017/12/09/makeFuckingGdalSo/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><br></p>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><ul>
<li>目前编译出来的so包只能兼容 Android 5.0 及以上的系统</li>
</ul>
<ul>
<li>网络上有编译好并且兼容Android 4.4的so包可以直接拿来用，这些so包都是armeabi-v7a的，目前绝大部分手机都是ARMv7架构，当前项目使用的设备也是ARMv7的，因此暂时没有问题</li>
</ul>
<ul>
<li>由于pc端一般是x86或x86_64架构的处理器，因此虚拟机也是x86或x86_64架构，因此调试阶段先加入x86的so，正式版本中会移除</li>
</ul>
<p><br></p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><br></p>
<h3 id="为什么使用Gdal"><a href="#为什么使用Gdal" class="headerlink" title="为什么使用Gdal"></a>为什么使用Gdal</h3><ul>
<li>就目前所知Java平台的地理数据文件的处理工具主要有GeoTools，ArcGIS Runtime SDK 以及 Gdal</li>
</ul>
<ul>
<li>GeoTools的jar文件至少有70mb，虽然可以精简，但核心部分依赖了Java的awt库，awt库无法再Android上使用直接导致crash</li>
</ul>
<ul>
<li>ArcGIS Runtime SDK 的大小没有了解过，估计也小不到哪里去，ArcGIS 可以读取shp文件，但是不能直接修改和创建shp，而且ArcGIS 读取shp也是通过Gdal实现的</li>
</ul>
<ul>
<li>Gdal 精简并且支持多种地理数据文件的操作，社区活跃度也很高，就在写这篇文章的上个月还发布了新的稳定版，但是和其他工具一样，Gdal并不针对 Android开发，因此为了能够在Android平台上使用，编译过程比较复杂</li>
</ul>
<p><br></p>
<h3 id="关于Shape"><a href="#关于Shape" class="headerlink" title="关于Shape"></a>关于Shape</h3><ul>
<li>Shape文件至少包含三个后缀不同的文件，.shp .dbf .shx</li>
</ul>
<ul>
<li>类似 Gdal和GeoTools等工具可以只读取其中一个文件，如shp和dbf，但是导入文件的时候注意全部导入，否则某些数据将会缺失</li>
</ul>
<ul>
<li>Gdal 支持 shp 和 KML，GeoJson 直接互换，KML实际上是一种专门的XML规范，GeoJson则是Json的规范，如果自行解析，可以直接将其视为XML和Json</li>
</ul>
<p><br></p>
<h3 id="关于编译"><a href="#关于编译" class="headerlink" title="关于编译"></a>关于编译</h3><ul>
<li>请在Linux上按照<a href="http://www.jianshu.com/p/b6899345d18e" title="这篇文章" target="_blank" rel="external">这篇文章</a>的流程进行编译，作者写得十分详细</li>
</ul>
<ul>
<li>x86 交叉编译的配置参考如下,其他abi请自行推断CC 和CXX参数</li>
</ul>
<pre><code>export NDK\_HOME=/home/parallels/albert/Android/android-ndk-r14b
 export PATH=$NDK\_HOME:$PATH
 export TOOLCHAIN\_HOME=/home/parallels/Android/android-toolchain/x86
 export PATH=$TOOLCHAIN\_HOME/bin:$PATH
 export LIBS=&quot;-lstdc++ -lgnustl\_shared&quot;
 export CC=/home/parallels/Android/android-toolchain/x86/bin/i686-linux-android-gcc-4.9
 export CXX=/home/parallels/Android/android-toolchain/x86/bin/i686-linux-android-g++
 export CXXFLAGS=&quot;-march=i686&quot;
 export CFLAGS=&quot;-march=i686&quot;
 export LDFLAGS=&quot;-march=i686&quot;
</code></pre><ul>
<li>./configure 阶段如果报错，务必在configure.log中查看详细的错误信息</li>
</ul>
<ul>
<li>在 gdal 2.0.3版本以下会出现  x86_64-unknown-linux-gnu 错误，无法检测到编译平台，这里需要更新 gdal源文件的config.guess和config.sub文件，可以在<a href="http://git.savannah.gnu.org/gitweb/?p=config.git;a=tree" title="这里" target="_blank" rel="external">这里</a>获取</li>
</ul>
<ul>
<li>使用APP_PLATFORM = 19 编译无法通过，这是由于signal和atof等库或函数在21以下不存在，将APP_PLATFORM下调至8可以通过，但是运行时可能出现链接错误，暂时没有找到解决办法</li>
</ul>
<ul>
<li>其中由于库或函数不存在而出错的源文件如下,可以考虑直接修改源文件，如atof可以修改strtod(nptr, NULL)</li>
</ul>
<pre><code>gxf\_ogcwkt.c

hf2dataset.cpp

tif\_luv.c

cpl\_strtod.cpp

gdalwarper.cpp

gdalnodatamaskband.cpp

ilwisdataset.cpp

cpl\_spawn.cpp
</code></pre><ul>
<li>使用低版本源码有时在swig目录中make出错，本人是直接忽略的，gdal社区中有人给出的建议是调低swig版本，实际使用发现一般swig正常生成jar包可以通用，可能是由于绝大部分接口的定义都是一致的</li>
</ul>
<ul>
<li>正式发版时记得将x86的so文件移除</li>
</ul>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Jni ，从入门到入坟]]></title>
      <url>/2017/11/17/Jni/</url>
      <content type="html"><![CDATA[<a id="more"></a>
<p><br></p>
<h2 id="如何使用jni进行开发"><a href="#如何使用jni进行开发" class="headerlink" title="如何使用jni进行开发"></a>如何使用jni进行开发</h2><p><strong>本文主要针对Android环境进行NDK\Native\Jni开发进行介绍</strong></p>
<p><strong>使用2.2版本之前的Android Studio进行ndk开发是比较繁琐的，如果你还在使用旧版本的Android Studio，那么建议更新到3.0，现阶段3.0已经比较稳定了(虽然旧项目的gradle升级可能需要折腾一下)。下面介绍旧版本的开发流程只是为了能够更加详细地介绍jni。</strong></p>
<p><strong>jni并不是android框架内的概念，所以也会提及其他环境使用jni开发的方法，基本上大同小异，不过你可能还需要查阅其他文章来处理一些细节问题（如Windows下生成dll文件）</strong></p>
<p><br></p>
<h3 id="AS-2-2之前的做法"><a href="#AS-2-2之前的做法" class="headerlink" title="AS 2.2之前的做法"></a>AS 2.2之前的做法</h3><p><br></p>
<h4 id="1-编写C-C"><a href="#1-编写C-C" class="headerlink" title="1.编写C/C++"></a>1.编写C/C++</h4><ul>
<li>首先创建一个java文件，声明一个自定义的native方法，对我们来说，这个方法就是java层到native层的入口，另外，还需要使用静态域将so包加载进来</li>
</ul>
<pre><code>package com.linjiamin.jnishare;

/**
* Created by Albert on 17/11/16.
*/

public class JniUtil {

    static {
        System.loadLibrary(&quot;sotest&quot;);
    }

    public static native int sum(int num1,int num2);
}
</code></pre><ul>
<li>开始编写 C/C++代码之前我们需要两个头文件。其中一个是 jni.h，该头文件包含了对jni数据类型和接口的定义（之后还会介绍），现在开始你所编写的所有C/C++代码都需要引入这个头文件。另外你还需要一个根据刚刚编写的native方法签名及类信息生成的头文件。对前者，简单地include进来即可，而对于后者，可以使用javah命令生成，当然你也可以选择亲自编写，使用命令生成的方法如下</li>
</ul>
<pre><code>//在终端中
cd app/src/main/java
javac com/linjiamin/jnishare/JniUtil.java
javah com.linjiamin.jnishare.JniUtil

//生成的头文件如下

/* DO NOT EDIT THIS FILE - it is machine generated */
#include &lt;jni.h&gt;
/* Header for class com_linjiamin_jnishare_JniUtil */

#ifndef _Included_com_linjiamin_jnishare_JniUtil
#define _Included_com_linjiamin_jnishare_JniUtil
#ifdef __cplusplus
extern &quot;C&quot; {
#endif
/*
* Class:     com_linjiamin_jnishare_JniUtil
* Method:    sum
* Signature: (II)I
*/
JNIEXPORT jint JNICALL Java_com_linjiamin_jnishare_JniUtil_sum 
(JNIEnv *, jclass, jint, jint);

#ifdef __cplusplus
}
#endif
#endif
</code></pre><ul>
<li>简单说一下如何手写这个头文件，预处理指令的写法都是相同的，将完整类名替换进去即可，对于函数签名，从左到右按以下顺序编写，当然还是使用javah方法生成更好</li>
</ul>
<pre><code>JNIEXPORT： 在android和linux中是空定义的宏，而在windows下被定义为__declspec(dllexport)，具体的作用我们不需要关心

jni数据类型：如jint，jboolean，jstring，它们对应于本地方法的返回类型（int，boolean，String）之后会进一步介绍、

JNICALL ： 这是__stdcall等函数调用约定（calling conventions）的宏，这些宏用于提示编译器该函数的参数如何入栈（从左到右，从右到左），以及清理堆栈的方式等

方法名： Java + 完整类名 + 方法名

参数列表：JNIEnv * + jclass\jobject + 所有你定义的参数所对应的jni数据类型 ，JNIEnv*是指向jvm函数表的指针，如果该方法为静态方法则第二个参数为class否则为jobject，它是含有该方法的class对象或实例

注意JNIEXPORT和JNICALL是固定的
</code></pre><ul>
<li>函数具体实现如下，相信大家都能看懂</li>
</ul>
<pre><code>#include &quot;jni.h&quot;
#include &quot;com_linjiamin_jnishare_JniUtil.h&quot;
//
// Created by Albert Humbert on 17/11/17.
//

JNIEXPORT jint JNICALL Java_com_linjiamin_jnishare_JniUtil_sum
(JNIEnv * env, jclass obj, jint num1, jint num2){
  return num1 + num2;
}
</code></pre><p><br>       </p>
<h4 id="2-使用ndk编译so包"><a href="#2-使用ndk编译so包" class="headerlink" title="2.使用ndk编译so包"></a>2.使用ndk编译so包</h4><p><br>   </p>
<h5 id="包结构"><a href="#包结构" class="headerlink" title="包结构"></a>包结构</h5><ul>
<li>现在在main包下创建一个jni包，将你的头文件和c/c++文件放进去，然后，你还需要两份mk文件，mk文件是makefile文件的一部分，makefile包含c/c++编译器的编译命令、顺序和规则，如果你不了解makefile是什么，那也没什么关系，后面会讲解Android.mk和Application.mk文件的书写规范</li>
</ul>
<ul>
<li>注意请在Android Library中进行ndk开发，不要使用Java Library，前者会生成aar包，可以包含so以及其他资源文件，后者会生成jar，jar通常只能调用外部so包，网上也有文章将jar当中的so包用文件流写到本地调用的，建议不要尝试这种骚操作</li>
</ul>
<p><br>       </p>
<h5 id="编写Android-mk"><a href="#编写Android-mk" class="headerlink" title="编写Android.mk"></a>编写Android.mk</h5><ul>
<li>你可以直接登录 <a href="http://android.mk" target="_blank" rel="external">http://android.mk</a> ，查看相关文档</li>
</ul>
<ul>
<li>一个最基本的Android.mk如下</li>
</ul>
<pre><code>LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)
LOCAL_MODULE := libsotest
LOCAL_SRC_FILES := com_linjiamin_jnishare_JniUtil.cpp
include $(BUILD_SHARED_LIBRARY)
</code></pre><ul>
<li>LOCAL_PATH := $(call my-dir)，Android.mk必须以该属性开头，它用于指定源文件的路径，my-dir是一个返回Android.mk文件所在目录的宏</li>
</ul>
<ul>
<li>include $(CLEAR_VARS) ，指定负责文件的清理的makefile文件，一般固定这么写就好</li>
</ul>
<ul>
<li>LOCAL_SRC_FILES，需要编译的c/c++文件，如无后缀则默认为cpp文件</li>
</ul>
<ul>
<li>include $(BUILD_SHARED_LIBRARY) ，收集上次清理后的源文件信息，并决定如何编译</li>
</ul>
<ul>
<li>LOCAL_C_INCLUDES，头文件的搜索路径</li>
</ul>
<ul>
<li>TARGET_ARCH，指定CPU，如armeabi，armeabi-v7a</li>
</ul>
<p><br>       </p>
<h5 id="编写Application-mk"><a href="#编写Application-mk" class="headerlink" title="编写Application.mk"></a>编写Application.mk</h5><ul>
<li>一个典型的Application.mk文件如下</li>
</ul>
<pre><code>APP_PLATFORM = android-24
APP_ABI := armeabi,armeabi-v7a,x86_64,arm64-v8a
APP_STL := stlport_static
APP_OPTIM := debug
</code></pre><ul>
<li>APP_PLATFORM，ndk版本号，你可以在ndk-bundle文件夹中查看所本地ndk版本</li>
</ul>
<pre><code># for mac
/Users/alberthumbert/Library/Android/sdk/ndk-bundle/platforms
</code></pre><ul>
<li>APP_ABI，指定APP_ABI版本，这会决定ndk编译出的so包数量，关于ABI的介绍见下文，推荐至少包含armeabi或armeabi-v7a</li>
</ul>
<ul>
<li>APP_STL 如何连接c++标准库 ，包括 stlport_static ，stlport_shared ，system，分别表示静态，动态，系统默认</li>
</ul>
<ul>
<li>APP_OPTIM，包括debug，和release，这会决定so中是否包含调试信息</li>
</ul>
<ul>
<li>APP_MODULES，填写so包的名字，如果没有这个属性，则按照Android.mk中的进行命名，注意如果文件中含有多个该属性，则会按照先后顺序为你编译出来的so文件命名</li>
</ul>
<ul>
<li>填写完这两个mk文件之后，需要在gradle中指定so库的路径，gradle会自动将so文件打包进来，在andorid闭包中添加</li>
</ul>
<pre><code>sourceSets.main {
jniLibs.srcDir &apos;src/main/libs&apos;
jni.srcDirs = []
}
</code></pre><ul>
<li>如无意外这个时候我们的项目就可以运行起来了，打印log如下</li>
</ul>
<pre><code>11-17 16:33:37.563 3824-3824/? D/JniUtil: test: 2
</code></pre><p><br></p>
<h3 id="人生苦短，我用AS-3-0"><a href="#人生苦短，我用AS-3-0" class="headerlink" title="人生苦短，我用AS 3.0"></a>人生苦短，我用AS 3.0</h3><p><br></p>
<h4 id="自动生成函数"><a href="#自动生成函数" class="headerlink" title="自动生成函数"></a>自动生成函数</h4><ul>
<li>如果出于不幸、粗心、经验不足等原因，你的项目无法运行，请不要怀疑你的智商，下面为你带来傻瓜式的ndk开发流程</li>
</ul>
<ul>
<li>最新版的AS，可以为你使用ndk开发提供很大的方便，请确保你在SDK Tools中下载了CMake、LLDB、NDK</li>
</ul>
<ul>
<li>首先创建一个新项目，并勾选Include C++ support</li>
</ul>
<ul>
<li>C++ Standard中可以选择使用的C++标准，默认是CMake所使用的标准，Exceptions Support可以启用C++异常处理，一般这些选项使用默认的就可以了</li>
</ul>
<ul>
<li>项目创建完毕之后你可以看见官方已经为你做好了很多工作，并且带了一个c++的hello world示例，你需要关注的主要有cpp和External Build Files 两个目录，前者用于放置你的C++源文件，后者根据不同的ABI版本放置了CMake脚本</li>
</ul>
<ul>
<li>接着我们直接在MainActivity中添加一个native方法，然后选中该方法，按下alt+enter，让IDE为我们自动生成C++函数</li>
</ul>
<pre><code>public native boolean booleanFromJNI();
</code></pre><ul>
<li>在native-lib.cpp中可以看见自动生成的函数，我们只需要实现该函数即可</li>
</ul>
<pre><code>JNIEXPORT jboolean JNICALL
Java_com_linjiamin_myapplication_MainActivity_booleanFromJNI(JNIEnv *env, jobject instance) {

    // TODO

}
</code></pre><ul>
<li>注意使用上面的方法你可以在任意一个java文件中声明native方法，IDE会自动在native-lib.cpp中为你生成对应的函数签名，当然，你也不是非要把所有的C/C++代码都写在一个文件里，下面来讲解一下CMakeList的基本写法</li>
</ul>
<p><br></p>
<h4 id="编写CMakeList"><a href="#编写CMakeList" class="headerlink" title="编写CMakeList"></a>编写CMakeList</h4><ul>
<li>下面是一份官方写好的CMakeList.txt，这个文件可以在你当前项目的app目录下看到</li>
</ul>
<pre><code>add_library( # 设置编译出来的so包的名字. 不需要添加lib前缀
             native-lib

             # 设置为共享链接库. 有SHARED，STATIC两种可选
             SHARED

             # 设置源文件的相对路径，可将多个源文件进行编译
             src/main/cpp/native-lib.cpp )

# Searches for a specified prebuilt library and stores the path as a
# variable. Because CMake includes system libraries in the search path by
# default, you only need to specify the name of the public NDK library
# you want to add. CMake verifies that the library exists before
# completing its build.

find_library( # 设置外部引用库.这个库支持你在c/c++中打印log，具体请见  android/log.h
            log-lib
            # 外部引用库的名称
            log )

# Specifies libraries CMake should link to your target library. You
# can link multiple libraries, such as libraries you define in this
# build script, prebuilt third-party libraries, or system libraries.

target_link_libraries( # 指定被链接的库.
                    native-lib

                    # 链接log-lib到native-lib
                    ${log-lib} )
</code></pre><ul>
<li>现在我们想要将不同的源文件编译成多份so包，例如我在cpp目录下添加一份test-lib.cpp文件，代码如下</li>
</ul>
<pre><code>extern &quot;C&quot;
JNIEXPORT jboolean JNICALL
Java_com_linjiamin_myapplication_JniUtil_booleanFromJNI(JNIEnv *env, jobject instance) {

//上面提到的log库可以这么使用，而且你应该使用宏让它好看些
__android_log_print(ANDROID_LOG_DEBUG,&quot;stringFromJNI&quot;,&quot;%d&quot;,0);
return (jboolean) true;

}
</code></pre><ul>
<li>那么可以在刚刚的CMakeList中设定我们的so包，在最后加上</li>
</ul>
<pre><code>add_library( test-lib SHARED src/main/cpp/test-lib.cpp )
</code></pre><ul>
<li>编译之后 可以看到 build/intermediates/cmake/debug/obj/ 路径下不同的ABI目录中都有了两份so文件，分别是libnative-lib.so，libtest-lib.so</li>
</ul>
<ul>
<li>如果你在不同的路径下放置了源文件，并且希望对于每一个特定的路径都有一份自己特定的CMakeList文件来描述这些源文件的打包规则（这看起来是个好习惯），可以使用add_subdirectory(“目录名”)方法指定子路径，子路径当中的放置CMakeList会被执行</li>
</ul>
<p><br></p>
<h3 id="使用g-编译so包"><a href="#使用g-编译so包" class="headerlink" title="使用g++编译so包"></a>使用g++编译so包</h3><ul>
<li>对于非安卓开发者，这里再简单介绍一个使用g++编译so包的方法，使用这种方法你无需ndk环境，也不用编写mk、CMakeList文件，完全使用命令行进行编译，当然我更推荐你去学习cmake</li>
</ul>
<ul>
<li>编写java文件并用javah指令生成头文件，再编写cpp文件，这个流程对于不同平台的jni开发都是相同的（虽然Intelligent Idea这种IDE可以为你自动生成头文件），那么现在需要一份对应平台下的jni.h文件，可以在你的jdk当中查找，编译器可能还会提示你需要一份jni_md.h文件，它也在jdk当中</li>
</ul>
<pre><code>$ cd /Library/Java/JavaVirtualMachines/jdk1.7.0_71.jdk
$ find . -iname jni.h
./Contents/Home/include/jni.h
</code></pre><ul>
<li>我这里用的是ndk当中的jni.h文件，下载ndk之后在sdk当中可以找到</li>
</ul>
<pre><code>$ cd /Users/alberthumbert/Library/Android/sdk/ndk-bundle
$ find . -iname jni.h
./sysroot/usr/include/jni.h
</code></pre><ul>
<li>现在假定你以及有了一份java文件，两份头文件，一份cpp或c文件，那么可以使用如下命令将他们编译成so文件，注意最后的参数不一定是必要的，如果你想编译安卓平台可用的so包那么建议加上</li>
</ul>
<pre><code>g++ com_linjiamin_jnishare_JniUtil.cpp -fPIC -shared -o libsotest.so -Wl,--hash-style=sysv
</code></pre><p>*<em>注意，</em>nix平台使用lib表示一个so库，所以so文件必须以lib开头，但加载时请将lib前缀去掉**</p>
<ul>
<li>你可以用绝对路径加载一个so文件</li>
</ul>
<pre><code>System.load(&quot;\***\***\***.so&quot;)
</code></pre><ul>
<li>你也可以将so文件放入系统加载路径当中，调用  System.getProperty(“java.library.path”)方法得到系统加载路径，想要修改这个路径，可以在修改.bashrc（或者当前使用的其他shell）中添加</li>
</ul>
<pre><code>export PATH=PATH:/XXX
</code></pre><ul>
<li>运行jar时动态指定路径也是可以的，这样会暂时覆盖上面写入的属性</li>
</ul>
<pre><code>java -jar -Djava.library.path=/**/**   **.jar
</code></pre><ul>
<li>重新在java代码中加载so文件，*nix平台注意去掉lib前缀</li>
</ul>
<pre><code>System.loadLibrary (&quot;***&quot;);
</code></pre><p><br></p>
<h3 id="ABI与so"><a href="#ABI与so" class="headerlink" title="ABI与so"></a>ABI与so</h3><ul>
<li>这里再啰嗦一下别的东西，可以先跳过，之后再倒回来看</li>
</ul>
<ul>
<li>由于目前我们的项目很简单，没有用到第三方so库和也没有去除多余so库为apk瘦身，因此不用考虑兼容问题，但实际开发项目时通常没这么简单。我们知道，编译出来的so是二进制文件，由于不同的CPU支持不同的指令集，所以我们需要考虑兼容性的问题。一个包含多种指令集及其相关约定的实现被称之为ABI，一个CPU架构支持一种到多种ABI。安卓平台就是针对ABI进行编译和打包的。</li>
</ul>
<ul>
<li>可能看了上面这一段会比较晕，那么我就举一个例子来说明，比如ARMv7架构的CUP，支持 armeabi和armeabi-v7a两种ABI，而armeabi这种ABI支持Thumb-1，ARMV5TE等指令集，armeabi-v7a这种ABI又支持Thumb-2和VFPv3-D16等指令集，也就是说，一种CPU架构对应多种ABI类型，一种ABI类型对于多种指令集</li>
<li>一个so文件只支持一种ABI，因此你会发现在lib下每一个包都是以ABI来命名的，同名的so文件被按照其支持的ABI进行分类</li>
<li>目前ABI一共有七种，那么是不是意味者我们的每一个so都需要编译成七种，然后全都打包进apk当中呢，答案是否定的。目前CUP流行的架构主要有ARM系列，x86，x86_64，而这些架构全部都支持armeabi这种ABI，因此类似淘宝、微信、饿了么的国内大厂通常只使用armeabi一种ABI，Facebook，Twitter等外国大厂则是只保留了armeabi-v7a，这是十分合理的，apk只保留一种通用的ABI，而最适应的so可以在外部去下载</li>
</ul>
<ul>
<li>那么是不是只要编译一种so文件就可以了呢？不完全正确，如果你引用了第三方的ndk，而第三方在兼容性做得比较好的情况下适配了多种ABI，又或者目前你的lib下so包的数量参差不齐。当一个apk安装时就有可能查找到了最适用的ABI的路径存在，但里面又没有想要的so，这时它不会自动去查找其他ABI版本的so，而是会crash，为了解决这个问题，请在lib包下只保留一个包（通常是armeabi或者armeabi-v7a），或者每个名字的so在不同包下都存在对应版本，并且在app的gradle的defaultConfig闭包中添加你所适配好的ABI，这样安装时只会从你所指定的ABI中查找so包</li>
</ul>
<pre><code>ndk{
    abiFilters  &quot;armeabi-v7a&quot;, &quot;x86&quot;, &quot;armeabi&quot;
}
</code></pre><p><br></p>
<h2 id="什么是jni"><a href="#什么是jni" class="headerlink" title="什么是jni"></a>什么是jni</h2><p><strong>现在我们已经可以进行简单的ndk开发了，但为了加深理解认识，让我再来啰嗦一下jni</strong></p>
<p><strong>看过这一部分之后你对jni应该会有更近一步的感性认识</strong></p>
<p><br></p>
<h2 id="jni-h"><a href="#jni-h" class="headerlink" title="jni.h"></a>jni.h</h2><p><br></p>
<h3 id="jni数据类型"><a href="#jni数据类型" class="headerlink" title="jni数据类型"></a>jni数据类型</h3><ul>
<li>现在来看看c/c++层的数据类型是怎么对应到java层的</li>
</ul>
<ul>
<li>首先是基本类型，根据java中的定义定义了j*类型</li>
</ul>
<pre><code>/* Primitive types that match up with Java equivalents. */
typedef uint8_t  jboolean; /* unsigned 8 bits */
typedef int8_t   jbyte;    /* signed 8 bits */
typedef uint16_t jchar;    /* unsigned 16 bits */
typedef int16_t  jshort;   /* signed 16 bits */
typedef int32_t  jint;     /* signed 32 bits */
typedef int64_t  jlong;    /* signed 64 bits */
typedef float    jfloat;   /* 32-bit IEEE 754 */
typedef double   jdouble;  /* 64-bit IEEE 754 */
</code></pre><ul>
<li>对于引用类型，c和c++有区别，在c++中 jobject是类，而jstring和各种类型的数组都是jobject的子类的指针，在c中jobject是一个void*指针，而其他引用类型其实都是jobject</li>
</ul>
<pre><code>class _jobject {};
class _jclass : public _jobject {};
class _jstring : public _jobject {};
class _jarray : public _jobject {};
class _jobjectArray : public _jarray {};
class _jbooleanArray : public _jarray {};
class _jbyteArray : public _jarray {};
class _jcharArray : public _jarray {};
class _jshortArray : public _jarray {};
class _jintArray : public _jarray {};
class _jlongArray : public _jarray {};
class _jfloatArray : public _jarray {};
class _jdoubleArray : public _jarray {};
class _jthrowable : public _jobject {};

typedef _jobject*       jobject;
typedef _jclass*        jclass;
typedef _jstring*       jstring;
typedef _jarray*        jarray;
typedef _jobjectArray*  jobjectArray;
typedef _jbooleanArray* jbooleanArray;
typedef _jbyteArray*    jbyteArray;
typedef _jcharArray*    jcharArray;
typedef _jshortArray*   jshortArray;
typedef _jintArray*     jintArray;
typedef _jlongArray*    jlongArray;
typedef _jfloatArray*   jfloatArray;
typedef _jdoubleArray*  jdoubleArray;
typedef _jthrowable*    jthrowable;
typedef _jobject*       jweak;


/*
 * Reference types, in C.
 */
typedef void*           jobject;
typedef jobject         jclass;
typedef jobject         jstring;
typedef jobject         jarray;
typedef jarray          jobjectArray;
typedef jarray          jbooleanArray;
typedef jarray          jbyteArray;
typedef jarray          jcharArray;
typedef jarray          jshortArray;
typedef jarray          jintArray;
typedef jarray          jlongArray;
typedef jarray          jfloatArray;
typedef jarray          jdoubleArray;
typedef jobject         jthrowable;
typedef jobject         jweak;
</code></pre><ul>
<li>jvalue是一个比较特殊的联合体，一般在需要调用java层方法时做为方法参数传入，如 void CallVoidMethodA(jobject obj, jmethodID methodID, jvalue* args) ，通过jobject和表示其方法的jmethodID即可特定一个具体的方法，然后将我们的jvalue作为函数列表传入</li>
</ul>
<pre><code>typedef union jvalue {
        jboolean    z;
        jbyte       b;
        jchar       c;
        jshort      s;
        jint        i;
        jlong       j;
        jfloat      f;
        jdouble     d;
        jobject     l;
    } jvalue;
</code></pre><ul>
<li>在这一方面我们可以讨论的内容比较少，总的来说，由于C/C++ 中基本类型的字节数依赖与实现，所以在native层转换到java层是不能直接使用原本的int，long等类型而是根据java中的约定使用jni.h指定了相同长度与有符号的类型，而java中的类则可以使用类或结构体的指针来解决</li>
</ul>
<p><br></p>
<h3 id="常用的接口"><a href="#常用的接口" class="headerlink" title="常用的接口"></a>常用的接口</h3><p><strong>在讲解JNIEnv和JavaVM之前先来尝试一下各种jni的基本操作，版本较新的AS已经支持了对C/C++ 的智能提示和代码补全功能，你可以很方便地试用JNIEnv提供的接口</strong></p>
<p><strong>这里只介绍几个例子，以后有时间我会另写文章介绍这些接口，强烈推荐你使用AS把可调用的函数浏览并选择性地使用一遍</strong></p>
<p><br></p>
<h4 id="修改成员变量"><a href="#修改成员变量" class="headerlink" title="修改成员变量"></a>修改成员变量</h4><ul>
<li>通过之前的例子你应该已经知道怎么从native层中获取一个变量了，现在再进一步，我们使用native方法直接改变成员变量的值，在MainActivity中定义一个native方法</li>
</ul>
<pre><code>public class MainActivity extends AppCompatActivity {

    public String mString = null;

static {
        System.loadLibrary(&quot;native-lib&quot;);
    }

    private static final String TAG = &quot;MainActivity&quot;;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        Log.d(TAG, &quot;onCreate: &quot;+mString);
        getFieldFromJNI();
        Log.d(TAG, &quot;onCreate: &quot;+ mString);
    }

    public native String getFieldFromJNI();

}
</code></pre><ul>
<li>在来看C++实现，注意你可能在阅览其他文章时发现调用jni函数时有两种不同的写法 env-> 和 (*env)->，这是由于C与C++的实现有所差异，不影响我们使用。如果你使用过反射改变成员变量的值，应该可以毫不费力地理解下面这段代码</li>
</ul>
<pre><code>extern &quot;C&quot;
JNIEXPORT jstring JNICALL
Java_com_linjiamin_jnilearning_MainActivity_getFieldFromJNI(JNIEnv *env, jobject instance) {

    jclass clazz = env-&gt;GetObjectClass(instance);
    //获取调用者的class对象
    jfieldID  jfID = env -&gt;GetFieldID(clazz,&quot;mString&quot;,&quot;Ljava/lang/String;&quot;);
    //获取成员变量的键
    jstring strValue = (jstring) env-&gt;GetObjectField(instance, jfID);
    //获取成员变量的值，不做操作
    char chars[10] = &quot;whatever&quot;；
    jstring newValue = env-&gt;NewStringUTF(chars);
    //创建一个String对象
    env-&gt;SetObjectField(instance,jfID,newValue);
    //设置新的值
    return strValue;
}
</code></pre><p><br></p>
<h4 id="创建引用"><a href="#创建引用" class="headerlink" title="创建引用"></a>创建引用</h4><p><br></p>
<h5 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h5><ul>
<li>了解jni中的引用类型，有助于你编写高效的代码并且解决内存泄漏等问题，jni中的引用类型可以分为三种，局部引用，全局引用，弱（全局）引用，通常jvm会在函数返回后自动为你释放局部引用，但你需要自行管理全局引用的生命周期</li>
</ul>
<p><br></p>
<h5 id="局部引用"><a href="#局部引用" class="headerlink" title="局部引用"></a>局部引用</h5><ul>
<li>其实我们之前已经接触过局部引用了，调用jni函数通常会创建新对象的实例并返回一个局部引用，局部引用只在一次native函数的调用周期中存在，在函数结束时被释放</li>
</ul>
<ul>
<li>通常我们需要避免返回全局引用，而是返回创建出来的局部引用，例如这样</li>
</ul>
<pre><code>return (jstring) env-&gt;NewLocalRef(someValue);
</code></pre><ul>
<li>我们刚刚说过，局部引用在函数的调用过程中存在，也就是说如果不进行人为的销毁操作，它将一直存在，在任意native函数中执行下面这段代码，你将接受到一个异常，跟java不同，gc不会及时回收通过这种方法创建出来的变量</li>
</ul>
<pre><code>for(int i = 0;i&lt;1000000000;i++){
    jstring newValue = env-&gt;NewStringUTF(chars);
}
</code></pre><ul>
<li>你可以调用 DeleteLocalRef函数销毁一个局部引用，这个函数现在就可以执行了，不过他会比一般函数耗时些</li>
</ul>
<pre><code>for(int i = 0;i&lt;1000000000;i++){
    jstring newValue = env-&gt;NewStringUTF(chars);
    env-&gt;DeleteLocalRef(newValue);
}
</code></pre><p><br></p>
<h5 id="全局引用"><a href="#全局引用" class="headerlink" title="全局引用"></a>全局引用</h5><ul>
<li>之前说过局部引用在函数的调用过程中存在，我们不能直接使用显式赋值的方式将局部引用强行将其缓存起来</li>
</ul>
<pre><code>jobject gInstance;

…

extern &quot;C&quot; JNIEXPORT void JNICALL 
Java_com_linjiamin_jnilearning_MainActivity_useCPlusThread(JNIEnv *env, jobject instance) {
methodID = env-&gt;GetMethodID(clazz,&quot;sayHello&quot;,&quot;()V&quot;);
gInstance = instance;
...
}
</code></pre><ul>
<li>上面的例子将会报错，不过对于jni开发，你可能常常只能收到含糊的报错信息，甚至收不到报错信息</li>
</ul>
<pre><code>JNI DETECTED ERROR IN APPLICATION: native code passing in reference to invalid stack indirect reference table or invalid reference: 0x7fff871642e0
</code></pre><ul>
<li>我们可以使用 NewGlobalRef 函数来创建一个全局引用，但是注意，你需要对自己的行为负责，全局引用只有在你的手动调用 DeleteGlobalRef 函数之后才会被释放，你可以在JNI_OnLoad 中进行缓存工作，在JNI_OnUnload函数中进行缓存的清除</li>
</ul>
<pre><code>jobject gInstance;

…
extern &quot;C&quot; JNIEXPORT void JNICALL 
Java_com_linjiamin_jnilearning_MainActivity_useCPlusThread(JNIEnv *env, jobject instance) {

methodID = env-&gt;GetMethodID(clazz,&quot;sayHello&quot;,&quot;()V&quot;);
gInstance = env-&gt;NewGlobalRef(instance);
...
}

…

void fun() {
...
...
env-&gt;DeleteGlobalRef(gInstance);
}
</code></pre><p><br></p>
<h5 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h5><ul>
<li>弱引用和全局引用大体上类似，但是当内存不足时它会被GC回收，通过 NewWeakGlobalRef 函数可以创建一个弱引用，和Java层的弱引用一致，它不会阻止自己所指向的对象被GC回收</li>
</ul>
<pre><code>gInstance = env-&gt;NewWeakGlobalRef(instance);
</code></pre><ul>
<li>但是这不意味着你可以不用管理弱引用的生命周期，在不需要它时请主动释放弱引用，注意，弱引用的释放不会导致它所指向的对象被GC回收</li>
</ul>
<pre><code>env-&gt;DeleteWeakGlobalRef(gInstance)
</code></pre><ul>
<li>最好在使用弱引用时判断它的对象是否已被释放，你可能会理所当然地使用 == 进行判断，这种方法是错误的，除非这个引用从来就没有被初始化过，不然表达式将永远为真，解决方案是使用jni提供的接口进行比较，有的文章也推荐再次使用NewWeakGlobalRef来达到这样的效果，个人认为这两种方案除了在可读性上的区别外没什么不同</li>
</ul>
<pre><code>if (env-&gt;IsSameObject(gInstance,NULL)) {
    __android_log_print(ANDROID_LOG_DEBUG,&quot;fun&quot;,&quot;%s&quot;,&quot;instance is NULL&quot;);
}

    //或者

if (!gInstance || !env-&gt;NewWeakGlobalRef(gInstance)) {
    __android_log_print(ANDROID_LOG_DEBUG,&quot;fun&quot;,&quot;%s&quot;,&quot;instance is NULL&quot;);
}
</code></pre><p><br></p>
<h4 id="JNIEnv，JavaVM-以及多线程"><a href="#JNIEnv，JavaVM-以及多线程" class="headerlink" title="JNIEnv，JavaVM 以及多线程"></a>JNIEnv，JavaVM 以及多线程</h4><ul>
<li>你可能已经意识到，目前为止我们都是通过JNIEnv来使用jni的，实际上JNIEnv提供了Native函数的基础环境，具体来说，它包含了一个指向函数表的指针，这也就是为什么我们需要通过JNIEnv才能调用native方法，JNIEnv也代表了具体的进程环境，因此不允许跨进程调用，最好的做法是永远不要缓存JNIEnv，你可以通过JavaVM来创造它的实例</li>
</ul>
<p><img src="https://s1.ax1x.com/2017/11/22/2xj2T.png" alt="" title="JNIEnv"></p>
<ul>
<li>JavaVM是java虚拟机的代表，它可以跨线程调用，它是一个全局对象，典型的jni环境中一个进程可以有多个JavaVM,但是在安卓环境当中他在每个进程中只有一个实例，通常你可以在JNI_OnLoad 函数，或其可以获取JNIEnv的地方得到它_</li>
</ul>
<pre><code>env-&gt;GetJavaVM(&amp;gVm);
</code></pre><ul>
<li>下面在C++线程中模仿耗时操作，并调用Java层方法传回数据，首先定义接受数据的方法和一个native方法，这里的参数列表稍微定义得复杂一点，方便之后演示jvalue的使用方法</li>
</ul>
<pre><code>public void resultCallback(boolean isSuccess,int result,String data){
    Log.d(TAG, &quot;resultCallback: &quot;+ isSuccess + &quot; &quot;+result + &quot; &quot; +data);
}

public native void useCPlusThread();
</code></pre><ul>
<li>native方法的实现如下,这里我们通过GetJavaVM方法得到了JavaVM对象，JavaVM用于我们之后获取JNIEnv，同时我们把调用者通过全局引用缓存起来，注意这里的methodID不需要使用NewGlobalRef，它是一个结构体，直接赋值即可，由于java支持重载，需要输入方法函数列表的标识才可以特定一个方法，每个基本类型都有其对应的缩写，而对于类我们需要通过包名和类名来指定。然后我们开启五个线程进行耗时操作</li>
</ul>
<pre><code>extern &quot;C&quot;
JNIEXPORT void JNICALL
Java_com_linjiamin_jnilearning_MainActivity_useCPlusThread(JNIEnv *env, jobject instance) {

env-&gt;GetJavaVM(&amp;gVm);
jclass clazz = env-&gt;GetObjectClass(instance);


methodID = env-&gt;GetMethodID(clazz, &quot;resultCallback&quot;, &quot;(ZILjava/lang/String;)V&quot;);
gInstance = env-&gt;NewGlobalRef(instance);

pthread_t pthread[5];

for(int i = 0;i&lt;5;i++){
    pthread_create(&amp;pthread[i], NULL, &amp;fun, NULL);
}
}
</code></pre><ul>
<li>线程方法的实现如下,linux系统的sleep函数定义在unistd.h文件中，我们使用它来模仿耗时操作，像刚刚说过的一样JNIEnv不能跨进程调用，那么这里使用AttachCurrentThread函数得到实例，这个函数同时也会将当前线程绑定到JavaVM上，然后我们使用CallVoidMethodA来调用刚刚缓存起来的实例的方法，也就是java层的resultCallback方法，jvalue数组可以作为参数列表传入，另外你也可以使用更为简便的CallVoidMethod函数，最后记得使用DetachCurrentThread函数解绑，除非你使用DeleteLocalRef函数释放引用，不然你通过JNIEnv获取的局部引用在你调用DetachCurrentThread之前都不会被销毁，并且在函数结束后造成内存泄漏</li>
</ul>
<pre><code>void *fun(void *arg) {
sleep(3);

JNIEnv *env;
if (gVm-&gt;AttachCurrentThread(&amp;env, NULL) != JNI_OK) {
    __android_log_print(ANDROID_LOG_DEBUG, &quot;callJniInDifferentThread&quot;, &quot;%s&quot;, &quot;attach failed&quot;);
    return NULL;
}

jvalue * args = new jvalue[3];
args[0].z = (jboolean) true;
args[1].i = 1000;
args[2].l = env-&gt;NewStringUTF(&quot;some data&quot;);

env-&gt;CallVoidMethodA(gInstance, methodID, args);

if (gVm-&gt;DetachCurrentThread() != JNI_OK) {
    __android_log_print(ANDROID_LOG_DEBUG, &quot;callJniInDifferentThread&quot;, &quot;%s&quot;, &quot;detach failed&quot;);
}

return NULL;

}
</code></pre><ul>
<li>注，各种类型对应的缩写如下，请使用一下的缩写特定具体的方法</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>缩写       </th>
</tr>
</thead>
<tbody>
<tr>
<td>Boolean</td>
<td>Z</td>
</tr>
<tr>
<td>Byte</td>
<td>B</td>
</tr>
<tr>
<td>Char</td>
<td>C</td>
</tr>
<tr>
<td>Short</td>
<td>S</td>
</tr>
<tr>
<td>Int</td>
<td>I</td>
</tr>
<tr>
<td>Long</td>
<td>L</td>
</tr>
<tr>
<td>Float</td>
<td>F</td>
</tr>
<tr>
<td>Double</td>
<td>D</td>
</tr>
<tr>
<td>Void</td>
<td>V</td>
</tr>
<tr>
<td>Object</td>
<td>以”L”开头，以”;”结尾，中间是用”/“ 隔开的包及类名。比如：Ljava/lang/String;如果是嵌套类，则用$来表示嵌套。例如 “(Ljava/lang/String;Landroid/os/FileUtils$FileStatus;)Z”</td>
</tr>
<tr>
<td>返回值与参数</td>
<td>例 (IB)L 表示返回类型为long，参数为int和byte的函数</td>
</tr>
</tbody>
</table>
<p><br></p>
<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p><br></p>
<h3 id="局部引用的内存模型"><a href="#局部引用的内存模型" class="headerlink" title="局部引用的内存模型"></a>局部引用的内存模型</h3><ul>
<li>刚刚提到JVM在一定程度上会为你管理局部引用的生命周期，但这不意味着局部引用等于局部变量。每当线程从Java层切换到native层时，JVM会创建局部引用表，它们维系了你的C/C++变量和Java层变量。</li>
</ul>
<ul>
<li>下图中出现的本地方法栈是和虚拟机栈类似的一种概念，但它用于运行native方法，注意，规范只约定了jni的操作和使用方法，对实现没有明确的要求，有些虚拟机会将虚拟机栈与本地方法栈合并实现，这里只大致地描绘本地方法栈的结构。当java层切入到native层（以下简称J2N过程，反之为N2J），或者在native函数中调用了jni接口时会导致本地方法栈的入栈操作，本地引用表在J2N时创建，并在N2J时销毁，在这个过程中，每当局部引用被合法创建，该局部引用都会被添加到表中并映射到java堆中的一个对象</li>
</ul>
<p><img src="https://s1.ax1x.com/2017/11/22/2zSr4.png" alt="" title="NativeMethodStack"></p>
<ul>
<li>看回前面这个例子，我们在循环中不断创建新的局部引用，并且赋值给变量newValue，这些不断创建的引用并不会立即释放，并且我们之后也无法获取到这些还留在表中的引用，所以他们都导致了内存泄漏。一般情况下局部引用表分配到的内存空间很小，这种内存泄漏很容易就会导致内存溢出，虚拟机崩溃。为了编写更加安全流畅的代码，我建议你遵循下面几个规范</li>
</ul>
<pre><code>for(int i = 0;i&lt;1000000000;i++){
    jstring newValue = env-&gt;NewStringUTF(chars);
}
</code></pre><p><br></p>
<h3 id="引用的使用规范"><a href="#引用的使用规范" class="headerlink" title="引用的使用规范"></a>引用的使用规范</h3><ul>
<li>native编程首先需要遵循C/C++自身的内存管理机制，除了局部引用以外，JVM不会为你做更多的内存释放工作，所以当你使用malloc函数分配内存空间后必须使用free函数进行释放，这和其他平台上的C/C++编程没什么不同</li>
</ul>
<ul>
<li>全局变量对java层对象的引用一直有效，请在不用时进行删除，否它所指向的对象将一直留在堆中</li>
</ul>
<ul>
<li>和刚刚介绍局部引用时说的一样，在函数返回之前，局部引用不会自动释放，如果创建过多的引用将会导致内存溢出的风险，如果你的函数只会创建为数不多的局部引用，那么完全可以将删除引用的操作交给JVM去处理，但如果你的函数会创建大量的引用，特别是在开启循环的请况下，请自行调用DeleteLocalRef函数</li>
</ul>
<p><br></p>
<h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul>
<li><a href="https://www.ibm.com/Search/?q=jni&amp;v=18&amp;en=utf&amp;lang=zh&amp;cc=cn&amp;sn=dw&amp;dws=cndw&amp;hpp=20" target="_blank" rel="external">IBM developerWorks 相关文章</a></li>
<li><a href="https://www.zybuluo.com/cxm-2016/note/563686" target="_blank" rel="external">JNI 完全指南</a></li>
<li><a href="http://blog.csdn.net/a345017062/article/details/8068928" target="_blank" rel="external">JNI 官方规范中文版</a></li>
<li><a href="http://blog.csdn.net/guojin08/article/details/9964579" target="_blank" rel="external">Android JNI 编程提高篇</a></li>
<li><a href="http://blog.guorongfei.com/2017/01/24/android-jni-tips-md/" target="_blank" rel="external">Android JNI 使用总结</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RxJava 与 Retrofit]]></title>
      <url>/2017/10/23/RxJava/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><strong>太监</strong></p>
<p><br></p>
<h3 id="什么是-RxJava-？-为什么使用RxJava"><a href="#什么是-RxJava-？-为什么使用RxJava" class="headerlink" title="什么是 RxJava ？ 为什么使用RxJava"></a>什么是 RxJava ？ 为什么使用RxJava</h3><ul>
<li>Rx ，ReactiveX ，Reactive Extensions，最早是<a href="http://www.yiibai.com/linq/" target="_blank" rel="external">LINQ</a>的一种扩展，Rx定义了一种语言模型，使得编程者通过基于事件的方式来编写由可观察的序列组成的异步的代码，是不是看不懂，没关系，我也不懂</li>
<li>RxJava 是Rx在Java VM上的实现，RxJava最大的特点就是异步，链式</li>
<li>RxJava 易于编写可读性强的代码，个人认为RxJava为编程者提供了一套规范，RxJava让我们编写代码时可以十分清晰的把业务逻辑写在一起，不用因为线程的切换和复杂的请求而创建大量的接口，不管是对于编写还是阅读代码的人都很方便</li>
</ul>
<p><br></p>
<h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><ul>
<li>RxJava采用观察者模式，Observer、 Consumer 对于观察者，Observable、 Single、 Completable 对应被观察者</li>
<li>上游的被观察者可以向下游的观察者发送事件，一个下游可以对应多个上游</li>
<li>在RxJava的实现中，链式操作的每一个节点往往都会创建新的被观察者来包裹下层的被观察者，当调用subscribe时，又会逐级地创建观察者，最上层的被观察者发送的事件将会在这条链上传递，我们可以自由设定事件产生和消费时的线程</li>
</ul>
<p><br></p>
<h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p><br></p>
<h3 id="RxJava-上手"><a href="#RxJava-上手" class="headerlink" title="RxJava 上手"></a>RxJava 上手</h3><h4 id="发送事件"><a href="#发送事件" class="headerlink" title="发送事件"></a>发送事件</h4><ul>
<li>简单使用RxJava，调用静态方法create，传入自定义的Observable，subscribe方法的参数emitter主要用于发送事件</li>
<li>emitter的onNext，onError，onComplete方法中传入的参数可以在Observer的对应方法中获取</li>
<li>observeOn和subscribeOn方法用于指定执行onSubscribe和subscribe方法的线程，通常我们会把耗时操作放在上游，再由下游完成UI更新，注意调用observeOn会在下一个操作符开始起作用，这意味着你可以反复切换线程来执行map，filter等操作</li>
</ul>
<pre><code>Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
    @Override
    public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception {
        emitter.onNext(1);
        emitter.onNext(2);
        emitter.onComplete();
        emitter.onNext(3);
    }
}).subscribeOn(Schedulers.io())
        .observeOn(AndroidSchedulers.mainThread())
        .subscribe(new Observer&lt;Integer&gt;() {
            @Override
            public void onSubscribe(@NonNull Disposable d) {
                mDisposable = d;
            }

            @Override
            public void onNext(@NonNull Integer integer) {
                Log.d(TAG, &quot;onNext: &quot; + integer + &quot; &quot; + &quot;thread: &quot; + Thread.currentThread());
            }

            @Override
            public void onError(@NonNull Throwable e) {
                Log.w(TAG, e.toString());
            }

            @Override
            public void onComplete() {
                Log.d(TAG, &quot;onComplete: &quot;);
            }
        });
}
</code></pre><ul>
<li>注意不要反复调用onComplete和onError方法，它们对于下游来说表示着事件队列的结束，之后再调用发射器的onNext，下游不会接受事件</li>
</ul>
<ul>
<li>重复调用onComplete和onError会抛出异常导致crash，这种异常只有在onError的throwable参数无法被下游接受时才会出现，比如说重复调用onError，或者调用onComplete之后再调用onError</li>
</ul>
<p><br></p>
<h4 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h4><p><br>       </p>
<h5 id="map"><a href="#map" class="headerlink" title="- map"></a>- map</h5><p>* map是RxJava中最常用的操作符</p>
<pre><code>Observable&lt;Integer&gt;  observable = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
    @Override
    public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception {

        emitter.onNext(1);            
        emitter.onComplete();
    }
});

observable.map(new Function&lt;Integer, String&gt;() {
    @Override
    public String apply(@NonNull Integer integer) throws Exception {
        return &quot;1&quot;;
    }

}).take(0).subscribe(new Observer&lt;String&gt;() {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;subscribe&quot;);
    }

    @Override
    public void onNext(String string) {
        Log.d(TAG, &quot;&quot; + string);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;error&quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;complete&quot;);
    }
});
</code></pre><ul>
<li>这次我们创建一个泛型为Integer的Observable，和一个泛型参数为String的Observer，显然它们的类型是不对应的，无法直接构成链式。因此这里使用了map操作符，传入的Function是一个函数式接口，apply方法接受上游Observable传来的int对象，返回值为转化后的String对象，简单的说我们要在这个方法中实现具体的转换逻辑，这样下游的Obser类型就变为Observer<string>了</string></li>
</ul>
<p><br>       </p>
<h5 id="concat"><a href="#concat" class="headerlink" title="- concat"></a>- concat</h5><ul>
<li>考虑到获取数据时往往会从多个数据源拉取数据，例如使用典型的本地缓存，内存缓存，网络接口的三级模型。刚刚说过，RxJava中一个下游可以对应多个上游，concat操作符就可以达到这种效果</li>
</ul>
<pre><code>Observable&lt;Integer&gt; observable = Observable.concat(
        Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
            @Override
            public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception {
                emitter.onNext(1);
                emitter.onNext(2);
                emitter.onNext(3);
                emitter.onComplete();
            }
        }),
        Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
            @Override
            public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception {
                emitter.onNext(4);
                emitter.onNext(5);
                emitter.onNext(6);
                emitter.onComplete();
            }
        }));

observable.take(4).subscribe(new Consumer&lt;Integer&gt;() {
    @Override
    public void accept(@NonNull Integer integer) throws Exception {
        Log.d(TAG, &quot;accept: &quot;+integer);
    }
});
}
</code></pre><ul>
<li>这个例子中下游使用的是Consumer，它和Observer类似，只有用来处理Next事件的accept方法，上游虽然可以发送Complete和Error事件，但下游不会接受，为了尽量简洁地给出操作符的用法，之后除特殊情况都将使用Consumer</li>
<li>concat可以将多个Observable合并为一个，使得下游可以接受多个数据源的数据，事件是按照发送顺序被先后接受的</li>
<li>这里还使用了take操作符，take可以指定获事件的数量，但是有一点需要注意，发射器的onComplete和onError方法一定要调用其中一个，否则只有一个Observable的事件会被下游接受，takeLast操作符和take相似，不过会从队列末尾开始拿取事件，2.x中取消了takeFirst操作符，请使用take(0)替代</li>
</ul>
<p><br>       </p>
<h5 id="flatMap"><a href="#flatMap" class="headerlink" title="- flatMap"></a>- flatMap</h5><ul>
<li>flatMap用于将一个Observable转换为多个Observable，也就是说对于发射器的每一次调用onNext方法，下游都会接受到多个事件，至于这些新创造的事件是什么，那就要由你自己来决定了</li>
</ul>
<pre><code>Observable&lt;Integer&gt; observable =
        Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
            @Override
            public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception {
                emitter.onNext(1);
                emitter.onNext(2);
                emitter.onNext(3);
                emitter.onComplete();
            }
        }).flatMap(new Function&lt;Integer, ObservableSource&lt;Integer&gt;&gt;() {
            @Override
            public ObservableSource&lt;Integer&gt; apply(@NonNull Integer integer) throws Exception {
                return Observable.fromArray(integer,integer,integer);
            }
        });

observable.subscribe(new Consumer&lt;Integer&gt;() {
    @Override
    public void accept(@NonNull Integer integer) throws Exception {
        Log.d(TAG, &quot;accept: &quot;+integer);
    }
});
}
</code></pre><ul>
<li>注意，flatMap中事件是无序的，这一点有时可能无法看出来，借用延迟会更为明显</li>
</ul>
<pre><code>observable.flatMap(new Function&lt;Integer, ObservableSource&lt;Integer&gt;&gt;() {
            @Override
            public ObservableSource&lt;Integer&gt; apply(@NonNull Integer integer) throws Exception {
                return Observable.fromArray(integer,integer,integer).delay(2000, TimeUnit.MILLISECONDS);
            }
        });
</code></pre><h5 id="zip"><a href="#zip" class="headerlink" title="- zip"></a>- zip</h5><ul>
<li>有些情况下我们需要访问多个接口才能够获取到完整的数据，使用RxJava，我们再也不用编写嵌套的接口了，RxJava提供了zip操作符，它用于成队地组装事件，只有被组装起来的事件才会被传到下游，保证了数据的完整性</li>
</ul>
<pre><code>Observable&lt;String&gt; observable = Observable.zip(Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
    @Override
    public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception {
        emitter.onNext(1);
        emitter.onNext(2);
        emitter.onNext(3);
        emitter.onNext(3);
        emitter.onComplete();
    }
}), Observable.create(new ObservableOnSubscribe&lt;String&gt;() {
    @Override
    public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception {
        emitter.onNext(&quot;A&quot;);
        emitter.onNext(&quot;B&quot;);
        emitter.onNext(&quot;C&quot;);
        emitter.onComplete();
    }
}), new BiFunction&lt;Integer, String, String&gt;() {
    @Override
    public String apply(@NonNull Integer integer, @NonNull String string) throws Exception {
        return integer + string;
    }
});
</code></pre><p> ##### - distinct &amp; filter </p>
<ul>
<li>RxJava提供了丰富的操作符来过滤事件，这里只简单介绍两个，distinct和filter</li>
</ul>
<ul>
<li>distinct是一种简单的过滤操作符，它会创建一个含有HashSet的Observable，使用这个HashSet来剔除掉重复的事件，因此请严格重写HashCode和equals方法来保证这个特性能正常发挥作用</li>
</ul>
<pre><code> Observable&lt;Integer&gt; observable = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
    @Override
    public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; emitter) throws Exception {
        emitter.onNext(1);
        emitter.onNext(1);
        emitter.onNext(2);
        emitter.onNext(2);
        emitter.onNext(3);
        emitter.onNext(3);
        emitter.onComplete();
    }
});

observable.distinct().subscribe(new Consumer&lt;Integer&gt;() {
    @Override
    public void accept(@NonNull Integer integer) throws Exception {
        Log.d(TAG, &quot;accept: &quot; + integer);
    }
});
</code></pre><ul>
<li>filter允许我们对具体的事件进行判断，可以过滤掉指定的事件  </li>
</ul>
<pre><code> Observable&lt;Integer&gt; observable = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
    @Override
    public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; emitter) throws Exception {
        emitter.onNext(1);
        emitter.onNext(2);
        emitter.onNext(3);
        emitter.onComplete();
    }
});

observable.filter(new Predicate&lt;Integer&gt;() {
    @Override
    public boolean test(@NonNull Integer integer) throws Exception {
        return integer != 1;
    }
}).subscribe(new Consumer&lt;Integer&gt;() {
    @Override
    public void accept(@NonNull Integer integer) throws Exception {
        Log.d(TAG, &quot;accept: &quot; + integer);
    }
});
</code></pre><ul>
<li>关于常用的操作符的介绍就到这里，想要了解更多操作符的用法可以参照<strong><a href="http://reactivex.io/documentation/operators.html" target="_blank" rel="external">官网</a></strong><br><br><h3 id="RxJava-进阶"><a href="#RxJava-进阶" class="headerlink" title="RxJava 进阶"></a>RxJava 进阶</h3></li>
</ul>
<p><br></p>
<h3 id="背压"><a href="#背压" class="headerlink" title="背压"></a>背压</h3><p><br></p>
<h4 id="什么是背压？为什么要有背压？"><a href="#什么是背压？为什么要有背压？" class="headerlink" title="什么是背压？为什么要有背压？"></a>什么是背压？为什么要有背压？</h4><ul>
<li>背压，或称反压，在RxJava中指的是下游对上游高频发送事件时的应对能力或策略，在1.x中，背压由Observable实现，而在2.x中新增了Flowable，理论上你可以不使用Flowable来实现背压，不过本文只介绍什么是背压和如何使用Flowable</li>
</ul>
<ul>
<li>首先我们模拟一个高频发送事件的场景，执行这段代码，相信你很快就会OOM，这就是引入背压的其中一个原因，当然这段代码本身的设计是很不合理的，我们几乎不可能在实际开发中遇到这么狂暴的上游，但我们知道RxJava很重要的一点就是响应式，如果上游可以知道下游的情况，只在下游可以处理的情况下发送消息，显然会更好，RxJava的背压为实现这一点提供了途径，这是引入背压的另一个原因</li>
</ul>
<pre><code>Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
    @Override
    public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception {
        for (int i = 0; ; i++) {
            emitter.onNext(1);
        }
    }

}).subscribeOn(Schedulers.io())
        .observeOn(AndroidSchedulers.mainThread())
        .subscribe(new Consumer&lt;Integer&gt;() {
            @Override
            public void accept(@NonNull Integer integer) throws Exception {
                Thread.sleep(20000);
                Log.d(TAG, &quot;accept: &quot;+integer);
            }
        });
</code></pre><ul>
<li>在继续讲解Flowable之前，我们再来折腾一下这段代码，去掉线程调度的两行（subscribeOn，observeOn。只去掉subscribeOn依然会OOM，原因很简单，请自行思考），一切又正常了，显然完全地同步是不会造成OOM的</li>
</ul>
<ul>
<li>关于造成OOM的原因，很多文章都没有比较清晰的说明，这里结合源码来进行分析，方便之后讲解背压中的request，在ObserveOnObserver类中可以找到下面几个方法，ObserveOnObserver是执行ObserveOn操作时创建的一个新的被观察者ObservableObserveOn的观察者，它用来进线程的调度，onNext就不用说了，schedule方法将会把ObserveOnObserver自己作为Runnable投递给工作线程池，ObserveOnObserver的run方法会执行drainNormal方法</li>
</ul>
<ul>
<li><p>drainNormal方法主要的工作是开启循环，将队列中的事件取出给下层观察者处理，如果下游处理速度赶不上上游发送事件的速度，事件就会一直堆积在队列当中</p>
<pre><code>@Override
public void onNext(T t) {
    if (done) {
        return;
    }

    if (sourceMode != QueueDisposable.ASYNC) {
        queue.offer(t);
    }
    schedule();
}

        void schedule() {
    if (getAndIncrement() == 0) {
        worker.schedule(this);
    }
}

@Override
public void run() {
    if (outputFused) {
        drainFused();
    } else {
        drainNormal();
    }
}

void drainNormal() {
    int missed = 1;

    final SimpleQueue&lt;T&gt; q = queue;
    final Observer&lt;? super T&gt; a = actual;

    for (;;) {
        if (checkTerminated(done, q.isEmpty(), a)) {
            return;
        }

        for (;;) {
            boolean d = done;
            T v;

            try {
                v = q.poll();
            } catch (Throwable ex) {
                Exceptions.throwIfFatal(ex);
                s.dispose();
                q.clear();
                a.onError(ex);
                worker.dispose();
                return;
            }
            boolean empty = v == null;

            if (checkTerminated(d, empty, a)) {
                return;
            }

            if (empty) {
                break;
            }

            a.onNext(v);
        }

        missed = addAndGet(-missed);
        if (missed == 0) {
            break;
        }
    }
}
</code></pre></li>
</ul>
<ul>
<li>从上面我们可以知道，RxJava将事件，或者说发射器的onNext方法接受的参数放入队列当中，链式操作是同步时，下游将上游的事件消耗掉之后，上游才能发送下一个事件，而当操作是异步时，发射器可以不受限制地一直发送事件，最严重的结果就是OOM</li>
</ul>
<p><br></p>
<h5 id="使用Flowable"><a href="#使用Flowable" class="headerlink" title="- 使用Flowable"></a>- 使用Flowable</h5><ul>
<li>下面简单使用Flowable，形式和Observable基本相同，不过这次内存的占用情况很正常，在Flowable.create方法中可以传入 BackpressureStrategy ，这个参数指明了使用何种背压策略，这里使用的是Drop，当缓存不足时会抛弃最近发生的事件，在onSubscribe方法中可以获取到Subscription对象，和Dispose对象基本一致，不过Subscription可以调用request方法向上游反馈下游当前还可处理事件的数量</li>
<li>注意，如果不调用request方法下游将无法接受事件并导致OOM</li>
</ul>
<pre><code>Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() {

    int i;

    @Override
    public void subscribe(@NonNull FlowableEmitter&lt;Integer&gt; emitter) throws Exception {
        for (; ; ) emitter.onNext(++i);
    }
}, BackpressureStrategy.DROP).subscribeOn(Schedulers.io())
        .observeOn(AndroidSchedulers.mainThread())
        .subscribe(new Subscriber&lt;Integer&gt;() {
            @Override
            public void onSubscribe(Subscription s) {
                      s.request(Long.MAX_VALUE);
            }

            @Override
            public void onNext(Integer integer) {
                Thread.sleep(20000);
                Log.d(TAG, &quot;onNext: &quot; + integer);
            }

            @Override
            public void onError(Throwable t) {
                Log.d(TAG, &quot;onError: &quot;);
            }

            @Override
            public void onComplete() {
                Log.d(TAG, &quot;onComplete: &quot;);
            }
        });
}
</code></pre><ul>
<li>RxJava提供了5种背压策略，比较常用的是drop和buffer</li>
</ul>
<pre><code>/**
* Represents the options for applying backpressure to a source sequence.
* （下面的枚举常量）代表着对来源序列采取的背压策略选项
*/
public enum BackpressureStrategy {
    /**
    * OnNext events are written without any buffering or dropping.
    * OnNext事件以无缓冲无弃用的方式编写
    * Downstream has to deal with any overflow.
    * 下游必须自行处理溢出
    * &lt;p&gt;Useful when one applies one of the custom-parameter onBackpressureXXX operators.
    * 在调用了自定义参数的onBackpressureXXX操作符时使用
    */
    MISSING,
    /**
    * Signals a MissingBackpressureException in case the downstream can&apos;t keep up.
    * 如果下游无力处理事件，将抛出MissingBackpressureException异常
    */
    ERROR,
    /**
    * Buffers &lt;em&gt;all&lt;/em&gt; onNext values until the downstream consumes it.
    * 缓存onNext的参数直到下游处理
    */
    BUFFER,
    /**
    * Drops the most recent onNext value if the downstream can&apos;t keep up.
    * 如果下游无力处理事件，将弃用最近的onNext参数
    */
    DROP,
    /**
    * Keeps only the latest onNext value, overwriting any previous value if the
    * downstream can&apos;t keep up
    * 如果下游无力处理事件，将保留最近的onNext参数 ，覆盖任意原来的参数
    */
    LATEST
} 
</code></pre><ul>
<li>前面说过request可以向上游反馈能够处理的事件数量，上游调用FlowableEmitter.requested方法可以得到具体的数值，那么不妨在下游能够处理的情况下才发送事件，并在处理完成后调用requested(1)，让可处理的事件加1</li>
</ul>
<pre><code>Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() {

    int i;

    @Override
    public void subscribe(@NonNull FlowableEmitter&lt;Integer&gt; emitter) throws Exception {
        for (; ; ) {
            if (emitter.requested() != 0) {
                emitter.onNext(++i);
                Log.d(TAG, &quot;subscribe: &quot; + emitter.requested());
            }
        }
    }
}, BackpressureStrategy.DROP).subscribeOn(Schedulers.io())
        .observeOn(AndroidSchedulers.mainThread())
        .onBackpressureBuffer().subscribe(new Subscriber&lt;Integer&gt;() {
    @Override
    public void onSubscribe(Subscription s) {
        mSubscription = s;
        s.request(10);
    }

    @Override
    public void onNext(Integer integer) {

        Log.d(TAG, &quot;onNext: &quot; + integer);
        try {
            Thread.sleep(1000);
             mSubscription.request(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    @Override
    public void onError(Throwable t) {
        Log.d(TAG, &quot;onError: &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;onComplete: &quot;);
    }
});
}
</code></pre><ul>
<li>上面的写法似乎很合理，但实际运行之后会发现，requested从128归0之后每次归0都会返回96，这是由于FlowableObserveOn内部设置了缓存大小，固定为128，Request归零之后重新设定的不是我们定义的值而是强制为96（128的四分之三），换句话说不使用observeOn（也就是让上下游同步）的情况下request方法才会想我们想象的一样发挥作用</li>
</ul>
<pre><code>static final int BUFFER_SIZE;
static {
BUFFER_SIZE = Math.max(16, Integer.getInteger(&quot;rx2.buffer-size&quot;, 128));
}

...
//prefetch大小为BUFFER_SIZE，简单来说相当于 128 - 128/4
      this.limit = prefetch - (prefetch &gt;&gt; 2);
...

//FlowableObserveOn中重设大小
          long p = produced + 1;
        if (p == limit) {
            produced = 0;
            s.request(p);
        } else {
            produced = p;
        }
</code></pre><ul>
<li>同时仔细观察log你会发现在异步的情况下并不是下游调用了request上游的获取到的数值就会马上增加，但下游处理事件的总数量永远不会超过它调用request方法请求的总数，所以如果你需要上游不断发送和处理事件，只需要在onNext方法中提交请求并在上游对requested进行判断即可，当下游的请求处理完毕，上游就不会用发送事件了，总的来说RxJava在Flowable的设计上还是很巧妙的</li>
</ul>
<p><br></p>
<h4 id="LifeCycle"><a href="#LifeCycle" class="headerlink" title="LifeCycle"></a>LifeCycle</h4><p><br></p>
<h3 id="Retrofit-上手"><a href="#Retrofit-上手" class="headerlink" title="Retrofit 上手"></a>Retrofit 上手</h3><p><br></p>
<h3 id="Retrofit-进阶"><a href="#Retrofit-进阶" class="headerlink" title="Retrofit 进阶"></a>Retrofit 进阶</h3><p><br></p>
<h4 id="自定义Coverter"><a href="#自定义Coverter" class="headerlink" title="自定义Coverter"></a>自定义Coverter</h4><p><br></p>
<h4 id="Retrofit-结合-RxJava"><a href="#Retrofit-结合-RxJava" class="headerlink" title="Retrofit 结合 RxJava"></a>Retrofit 结合 RxJava</h4><p><br></p>
<h3 id="RxJava-Retrofit-实战"><a href="#RxJava-Retrofit-实战" class="headerlink" title="RxJava Retrofit 实战"></a>RxJava Retrofit 实战</h3>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RemoteView 使用详解与实现原理]]></title>
      <url>/2017/09/11/RemoteView/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<h2 id="RemoteView-详解"><a href="#RemoteView-详解" class="headerlink" title="RemoteView 详解"></a>RemoteView 详解</h2><ul>
<li>RemoteView，是一种用于跨进程显示View的工具，使用场景一般为显示通知和实现桌面控件</li>
<li>相对于Binder，RemoteView效率更高但限制也更多</li>
<li>下面以桌面控件 AppWidget 为例，讲解RemoteView的使用</li>
</ul>
<h3 id="AppWidget"><a href="#AppWidget" class="headerlink" title="AppWidget"></a>AppWidget</h3><ul>
<li>AppWidget 虽然是一种可选的界面，但是它能够十分方便地为用户提供信息，更重要的是它为整个应用提供了快捷的入口，网上关于AppWidget的文章虽然多但是写得都不是很清晰，忽略了一些需要注意的坑，希望这篇文章能够提供更全面的讲解，写AppWidget主要分为以下几个步骤</li>
</ul>
<pre><code>1.使用XML文件为控件提供元数据（AppWidgetProviderInfo）
2.使用XML文件为控件提供布局信息
3.实现AppWidgetProvider管理控件的生命周期和提供数据
4.使用Service更新界面（可选）
5.实现RemoteViewsService和RemoteViewsFactory为控件提供更复杂的布局及其点击事件的响应（可选）
6.在manifest文件中注册AppWidgetProvider和用到的service 
</code></pre><ul>
<li>我们首先来观察manifest文件，下面是一个简单的例子，从这个例子我们可以知道 AppWidgetProvider 虽然名字比较有误导性，但它其实是一个BroadcastReceiver，标签中的meta-data就是刚刚说的AppWidgetProviderInfo，intent-filter中必须要有android.appwidget.action.APPWIDGET_UPDATE 这个ACTION，如果有其他需求还可以添加自定义的ACTION， \<action android:name="com.linjiamin.UPDATE" \=""> 就是我定义的广播，用于更新这个AppWidget</action></li>
</ul>
<pre><code>&lt;receiver android:name=&quot;.widget.WidgetProvider&quot;&gt;
    &lt;intent-filter&gt;

        &lt;action android:name=&quot;android.appwidget.action.APPWIDGET_UPDATE&quot;/&gt;
        &lt;action android:name=&quot;com.linjiamin.UPDATE&quot;/&gt;
    &lt;/intent-filter&gt;
    &lt;meta-data
        android:name=&quot;android.appwidget.provider&quot;
        android:resource=&quot;@xml/app_widget&quot;/&gt;
&lt;/receiver&gt; 
</code></pre><h4 id="AppWidgetProviderInfo"><a href="#AppWidgetProviderInfo" class="headerlink" title="AppWidgetProviderInfo"></a>AppWidgetProviderInfo</h4><ul>
<li>meta-data中的resource属性指向的布局文件应该写在res的xml包下，如果没有这个包则新建即可，这个xml对应于AppWidgetProviderInfo类的类属性，包含了整个AppWidget的配置信息</li>
</ul>
<pre><code>&lt;!--in app_widget.xml--&gt;
&lt;appwidget-provider xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:initialLayout=&quot;@layout/app_widget&quot;
    android:minHeight=&quot;120dp&quot;
    android:minWidth=&quot;120dp&quot;
    android:previewImage=&quot;@mipmap/ic_launcher&quot;
    android:resizeMode=&quot;horizontal|vertical&quot;
    android:updatePeriodMillis=&quot;3000&quot;
    android:widgetCategory=&quot;home_screen|keyguard&quot;&gt;
&lt;/appwidget-provider&gt;
</code></pre><ul>
<li>AppWidgetProviderInfo 有如下几个属性可供配置</li>
</ul>
<pre><code>minWidth 和 minHeight：AppWidget最小的布局宽高，但不是确切的布局宽高，AppWidget的尺寸的最小单位为桌面每个网格的尺寸，如果不足整数个网格将向上取整，手机上不建议大于4*4个网格

minResizeWidth 和 minResizeHeight ，允许用户重新调整尺寸，minResizeWidth可以小于minWidth，但实际尺寸不能小于minResizeWidth，minResizeHeight同理

updatePeriodMillis ：widget的更新频率，即是更新的回调方法onUpdate粗略的调用频率，在1.6以后，频率不能高于30分钟一次，否则会被设定为30分钟一次，由于更新会唤醒设备所以会有一定的能耗，如果使用 alarm来替代该属性，alarm应设置为 ELAPSED_REALTIME 或 RTC，同时将 updatePeriodMillis 设为 0。

initialLayout : widget 的布局资源文件，只能包含特定的控件

configure：当 widget 创建时，会自动启动填写的Activity，这个Activity应用于进行配置信息

previewImage：预览图，如果没有提供则使用应用图标。

utoAdvanceViewId ：指定一个子view ID，表明该子 view 会自动更新

resizeMode ： horizontal, vertical, none，分别为可拉伸的方向

widgetCategory：home_screen，keyguard，指定widget是否在桌面和锁屏界面上显示

initialKeyguardLayout ： 锁屏界面的布局资源文件
</code></pre><h4 id="主布局"><a href="#主布局" class="headerlink" title="主布局"></a>主布局</h4><ul>
<li>布局，RemoteView只能支持一下几种布局，这个例子中只用到了TextView和ListView，和普通控件的布局没有差别</li>
</ul>
<pre><code>//可供使用的布局
Layout: FrameLayout,LinearLayout,RelativeLayout，GridLayout

View：AnalogClock，Button，Chronometer，ImageButton，ImageView，ProgressBar ，TextView，ViewFlipper，ListView，GridView，StackView，AdapterViewFilter，ViewStub

&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot;
android:gravity=&quot;center_horizontal&quot;
android:orientation=&quot;vertical&quot;&gt;

&lt;TextView
android:id=&quot;@+id/widget_tv&quot;
android:layout_width=&quot;wrap_content&quot;
android:layout_height=&quot;wrap_content&quot;
android:text=&quot;0&quot;
android:textSize=&quot;36sp&quot;
android:textStyle=&quot;bold&quot;/&gt;

&lt;ListView
android:id=&quot;@+id/widget_lv&quot;
android:layout_width=&quot;wrap_content&quot;
android:layout_height=&quot;wrap_content&quot;&gt;
&lt;/ListView&gt;
&lt;/LinearLayout&gt;
</code></pre><h4 id="AppWidgetProvider"><a href="#AppWidgetProvider" class="headerlink" title="AppWidgetProvider"></a>AppWidgetProvider</h4><ul>
<li>AppWidgetProvider，AppWidgetProvider的onReceive中会接收诸如 APPWIDGET_UPDATE，APPWIDGET_DELETED等ACTION，然后调用相应的生命周期方法，如果我们要接收自定义的广播，需要重写onReceive然后调用自己的方法</li>
</ul>
<ul>
<li>onReceive使用的几个回调方法为，onUpdate() ，RemoteView在需要更新数据时调用，onDeleted()，AppWidget被移除时调用  ，onEnabled，AppWidget被实例化时调用，重复实例化时不会反复调用该方法，onDisabled()，AppWidget的最后一个实例被delete时调用</li>
</ul>
<ul>
<li>由于XML中配置的更新频率不能大于30分钟一次，所以这里实现一个Service来更新，在onReceive中接受到自定义的ACTION，然后调用自定义的update方法，在onEnabled中启动发送广播的service，</li>
</ul>
<pre><code>public class WidgetProvider extends AppWidgetProvider {

public static int mIndex = 0;
@Override
public void onReceive(Context context, Intent intent) {
super.onReceive(context, intent);
if(intent.getAction().equals(UpdateService.ACTION_UPDATE)){
    Update(context);
    Log.d(TAG, &quot;onReceive: &quot;);
    }
}

@Override
public void onEnabled(Context context) {

Intent intent = new Intent(context, UpdateService.class);
context.startService(intent);
Log.d(TAG, &quot;onEnabled: &quot;);
super.onEnabled(context);
}

@Override
public void onAppWidgetOptionsChanged(Context context, AppWidgetManager appWidgetManager, int appWidgetId, Bundle
    newOptions) {
super.onAppWidgetOptionsChanged(context, appWidgetManager, appWidgetId, newOptions);
}

@Override
public void onRestored(Context context, int[] oldWidgetIds, int[] newWidgetIds) {
super.onRestored(context, oldWidgetIds, newWidgetIds);
}

@Override
public void onDeleted(Context context, int[] appWidgetIds) {
super.onDeleted(context, appWidgetIds);
}

@Override
public void onDisabled(Context context) {
Intent intent = new Intent(context,UpdateService.class);
context.stopService(intent);
super.onDisabled(context);
}
</code></pre><ul>
<li>更新RemoteView需要获取AppWidgetManager的实例并调用updateAppWidget方法传入包名或id和新的remoteViews</li>
</ul>
<pre><code>private void Update(Context context) {
    RemoteViews remoteViews = new RemoteViews(context.getPackageName(), R.layout.app_widget);
    remoteViews.setTextViewText(R.id.widget_tv, &quot;&quot;+mIndex);
    AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(CurriculumApplication.getContext());
    appWidgetManager.updateAppWidget(new ComponentName(CurriculumApplication.getContext(), WidgetProvider.class), remoteViews);
mIndex ++;
    }
}
</code></pre><ul>
<li>发送广播的service这里用计时器来实现，这里每隔一秒发送一次广播，当然最好是使用AlarmManager的ELAPSED_REALTIME 或 RTC来实现，避免不必要地唤醒设备</li>
</ul>
<pre><code>public class UpdateService extends Service{

private Timer mTimer;
private TimerTask mTimerTask;
public static final int UPDATE_TIME = 1000;
public static final String ACTION_UPDATE = &quot;com.linjiamin.UPDATE&quot;;

@Override
public int onStartCommand(Intent intent, int flags, int startId) {
return super.onStartCommand(intent, flags, startId);
}

@Nullable
@Override
public IBinder onBind(Intent intent) {
return null;
}

@Override
public void onCreate() {
super.onCreate();

Log.d(TAG, &quot;onCreate: &quot;);
mTimer = new Timer();
mTimerTask = new TimerTask() {
    @Override
    public void run() {
        Intent updateIntent = new Intent(ACTION_UPDATE);
        sendBroadcast(updateIntent);
    }
};
mTimer.schedule(mTimerTask, 1000, UPDATE_TIME);
    }

        @Override
    public void onDestroy() {
    super.onDestroy();
    mTimer.cancel();
    }
}
</code></pre><ul>
<li>现在来看回我们的AppWidgetProvider，还有一个很重要的方法没有讲解——onUpdate()，onUpdate()是系统每次决定更新时调用的方法，我们刚刚通过service实现的界面更新是不会调用到这个方法的，如果更新的频率不高于30分钟一次，那么在这个方法中实现更新的逻辑即可，注意对于ListView，StackView这些包含Item的复杂控件需要使用RemoteViewService获取Adapter，这些稍后再讲解</li>
</ul>
<ul>
<li>通常onUpdate()还会做两件事，设置点击事件和PendingIntent的模板，在这里我们为TextView设定了一个启动Activity的PendingIntent，跟Notification类似，没有什么好讲的，接着为ListView设置了适配器和PendingIntent的模板，为ListView的每一个Item设置PendingIntent是很浪费的，为了提高效率，必须在AppWidgetProvider中调用setPendingIntentTemplate，传入的PendingIntent作为模板，之后RemoteViewsFactory可以利用这个模板和新的Intent进行合成</li>
</ul>
<pre><code>@Override
public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {

for(int id:appWidgetIds) {
    Log.d(TAG, &quot;onUpdate: &quot;);

    Intent updateIntent = new Intent(context, RemoteService.class);
    Intent openIntent = new Intent(context,CourseView.class);
    PendingIntent pendingIntent = PendingIntent.getActivity(context, 0, openIntent, PendingIntent.FLAG_UPDATE_CURRENT);

    RemoteViews remoteViews = new RemoteViews(context.getPackageName(), R.layout.app_widget);
    remoteViews.setRemoteAdapter(R.id.widget_lv, updateIntent);
    remoteViews.setOnClickPendingIntent(R.id.widget_tv,pendingIntent);
    remoteViews.setPendingIntentTemplate(R.id.widget_lv,pendingIntent);
    appWidgetManager.updateAppWidget(id, remoteViews);
}
super.onUpdate(context, appWidgetManager, appWidgetIds);
}
</code></pre><h4 id="RemoteViewService-amp-amp-RemoteViewsFactory"><a href="#RemoteViewService-amp-amp-RemoteViewsFactory" class="headerlink" title="RemoteViewService &amp;&amp; RemoteViewsFactory"></a>RemoteViewService &amp;&amp; RemoteViewsFactory</h4><ul>
<li>RemoteViewService用于返回 RemoteViewsFactory，通常RemoteViewsFactory实现在RemoteViewService中即可</li>
</ul>
<ul>
<li>RemoteViewsFactory是ListView和StackView等子View的工厂，从这个角度来说它很像一种适配器，其中getViewAt方法相当于getView，但是需要返回的是一个RemoteView，其他方法可以参考ListView或RecycleView的适配器来写</li>
</ul>
<ul>
<li>可以看到这个例子中调用了RemoteView的setOnClickFillInIntent方法，传入一个新的Intent，由于这里没有什么特殊的需求，所以没有对这个intent进行额外的操作，这个Intent和刚刚的PendingIntent模板组合就能启动Activity了 ，另外如果要实现View的onClickListener的效果则需要使用PendingIntent.getBroadcast来设置模板，并且在getViewAt创建的Intent中传入具体的ACTION，后面就和刚刚的UpdateService是一个套路了</li>
</ul>
<pre><code>public class RemoteService extends RemoteViewsService {


private static final String TAG = &quot;RemoteService&quot;;


@Override
public void onCreate() {
super.onCreate();
Log.d(TAG, &quot;onCreate: &quot;);
}

@Override
public IBinder onBind(Intent intent) {
return super.onBind(intent);
}

@Override
public RemoteViewsFactory onGetViewFactory(Intent intent) {
return new RemoteFactory();
}

public class RemoteFactory implements RemoteViewsService.RemoteViewsFactory {

public List&lt;Integer&gt; mDataList = new ArrayList&lt;&gt;();


public RemoteFactory() {
    for (int i = 0; i &lt; 20; i++) {
        mDataList.add(i);
    }
    Log.d(TAG, &quot;onCreate: &quot;);
}

private static final String TAG = &quot;RemoteFactory&quot;;

@Override
public void onCreate() {

}

@Override
public void onDataSetChanged() {

}

@Override
public void onDestroy() {

}

@Override
public int getCount() {
    return mDataList.size();
}

@Override
public RemoteViews getViewAt(int position) {

    if (position &lt; 0 || position &gt; mDataList.size())
        return null;

    Intent intent = new Intent();
    RemoteViews remoteViews = new RemoteViews(CurriculumApplication.getContext().getPackageName(), R.layout.item_lv_course);
    remoteViews.setTextViewText(R.id.widget_tv_course, mDataList.get(position) + &quot;&quot;);
    remoteViews.setOnClickFillInIntent(R.id.item_lv_course,intent);

    return remoteViews;
}

@Override
public RemoteViews getLoadingView() {
    return null;
}

@Override
public int getViewTypeCount() {
    return 1;
}

@Override
public long getItemId(int position) {
    return position;
}

@Override
public boolean hasStableIds() {
    return true;
}

}
}
</code></pre><ul>
<li>最后注意非常重要的一点，既然RemoteViewService是Service，那么就必须注册，其中permission是一定要设置的，否则这个Service无法启动，这种情况下是不会有异常的，但是ListView等子控件将无法显示</li>
</ul>
<pre><code>&lt;service
    android:name=&quot;.widget.RemoteService&quot;
    android:permission=&quot;android.permission.BIND_REMOTEVIEWS&quot;
    android:enabled=&quot;true&quot;
    android:exported=&quot;true&quot; &gt;
&lt;/service&gt;
</code></pre><h3 id="RemoteViews"><a href="#RemoteViews" class="headerlink" title="RemoteViews"></a>RemoteViews</h3><ul>
<li>现在，我们来研究RemoteView是怎么更新的，我们知道需要更新RemoteViews中的控件时，由于我们获取不到需要的View，所以应该通过RemoteViews的方法来实现更新，比如下面的setImageViewBitmap方法对应的就是ImageView的setBitmap方法</li>
</ul>
<pre><code>remoteViews.setImageViewBitmap()    
</code></pre><ul>
<li>setImageViewBitmap调用setBitmap在第二个参数中传入了方法名，这个方法名是为了后面通过反射调用控件的方法而准备的，RemoteViews的Action表示我们想要对控件进行的操作，RemoteView会通过Binder传到Launcher的线程执行这些操作，从BitmapReflectionAction的名字很容易看出它使用了反射机制</li>
</ul>
<pre><code>public void setImageViewBitmap(int viewId, Bitmap bitmap) {
setBitmap(viewId, &quot;setImageBitmap&quot;, bitmap);
}

public void setBitmap(int viewId, String methodName, Bitmap value) {
addAction(new BitmapReflectionAction(viewId, methodName, value));
}
</code></pre><ul>
<li>接着来看RemoteViews的apply方法，这个方法通过LayoutInflater获取到了我们的AppWidget的布局，有了布局就可以进行更新操作了</li>
</ul>
<pre><code>public View apply(Context context, ViewGroup parent, OnClickHandler handler) {
RemoteViews rvToApply = getRemoteViewsToApply(context);

View result = inflateView(context, rvToApply, parent);
loadTransitionOverride(context, handler);

rvToApply.performApply(result, parent, handler);

return result;
}


private View inflateView(Context context, RemoteViews rv, ViewGroup parent) {
    LayoutInflater inflater = (LayoutInflater)

    ...
        context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);

// Clone inflater so we load resources from correct context and
// we don&apos;t add a filter to the static version returned by getSystemService.
inflater = inflater.cloneInContext(inflationContext);
inflater.setFilter(this);
View v = inflater.inflate(rv.getLayoutId(), parent, false);
v.setTagInternal(R.id.widget_frame, rv.getLayoutId());
return v;
}
</code></pre><ul>
<li>performApply遍历了所有的Action，执行其apply方法，在ReflectionAction中apply方法使用findViewById得到需要更新的布局，findViewById返回的是一个View，这里我们并不知道需要更新的View的具体类型，由于之前传入了方法名所以这里通过反射获取到了需要使用的方法并直接调用，理论上也可以通过使用instanceOf关键字然后再用类型转换来实现，实际setRemoteAdapter的apply方法就是这么做的，但是如果对于所有的View都使用instanceOf，RemoteViews支持的View一共有十几种，相比之下还是使用反射会更加简洁易维护</li>
</ul>
<pre><code>private void performApply(View v, ViewGroup parent, OnClickHandler handler) {
if (mActions != null) {
    handler = handler == null ? DEFAULT_ON_CLICK_HANDLER : handler;
    final int count = mActions.size();
    for (int i = 0; i &lt; count; i++) {
        Action a = mActions.get(i);
        a.apply(v, parent, handler);
    }
}
}   

           @Override
public void apply(View root, ViewGroup rootParent, OnClickHandler handler) {
    final View view = root.findViewById(viewId);
    if (view == null) return;

    Class&lt;?&gt; param = getParameterType();
    if (param == null) {
        throw new ActionException(&quot;bad type: &quot; + this.type);
    }

    try {
        getMethod(view, this.methodName, param).invoke(view, wrapArg(this.value));
    } catch (ActionException e) {
        throw e;
    } catch (Exception ex) {
        throw new ActionException(ex);
    }
}
</code></pre><h3 id="AppWidget-与-binder"><a href="#AppWidget-与-binder" class="headerlink" title="AppWidget 与 binder"></a>AppWidget 与 binder</h3><ul>
<li>AppWidget是利用binder机制实现的，那么就来看看binder接口是怎么实现的，由于部分代码属于internal包，在Android Studio上可能无法查看，可以选择查看<a href="http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/5.1.1_r1/com/android/server/SystemService.java#SystemService.publishBinderService(java.lang.String,android.os.IBinder)" target="_blank" rel="external">这里</a>，如果有更方便的办法，请告诉我</li>
<li>这里先讲解一下Luncher 是什么，为此首先明确一点，Android系统上所谓的桌面本身也是一个应用，这个系统应用我们管他叫启动器或者Luncher，更准确地说Luncher其实是一个Activity，我们的桌面的主视图是一个继承自PagedView的Workspace，每一页就是一个CellLayout，看看下面这一段，是不是觉得很熟悉？</li>
</ul>
<pre><code>public final class Launcher extends Activity implements View.OnClickListener, OnLongClickListener 
</code></pre><ul>
<li>我们知道Activity默认运行在Application指定的进程中，Launcher的Manifest文件我就懒得翻源码了，有需要可以看<a href="http://quanminchaoren.iteye.com/blog/898647" target="_blank" rel="external">这里</a></li>
</ul>
<ul>
<li>刚刚提到 AppWidgetManager 是在SystemServer进程中的，那么加上我们的自己应用的进程和Launcher所在的进程RemoteView就需要在三个进程之间传递，在一个应用中更新另一个应用的Activity，是不是很刺激？</li>
</ul>
<ul>
<li>在需要更新AppWidget时，我们调用了AppWidgetManager.updateAppWidget方法，查看下列源码，调用到了mService的同名方法，而这个mService 的类型是<a href="\* [IAppWidgetService][3]">IAppWidgetService</a>，源码很长，我就不贴出来了，用过AIDL的应该会觉得很熟悉，和我们AS生成的 **AIDL.java的结构是一致的，mServie就是一个binder的代理（Proxy）类，调用它的方法会走Transaction过程，那么我们调用的方法最终就会在AppWidgetManager所在的进程中也就是SystemServer的进程中被调用了</li>
</ul>
<pre><code>public void updateAppWidget(int[] appWidgetIds, RemoteViews views) {
if (mService == null) {
    return;
}
try {
    mService.updateAppWidgetIds(mPackageName, appWidgetIds, views);
} catch (RemoteException e) {
    throw e.rethrowFromSystemServer();
}
}
</code></pre><ul>
<li>看完了Proxy，当然就轮到我们的Binder类了，Binder的实现类为AppWidgetServiceImpl，这里忽略一部分代码，这里主要是通过传入的id拿到了widget对象，widget对象是对每个appWidget的封装，结构很简单</li>
</ul>
<pre><code>private void updateAppWidgetIds(String callingPackage, int[] appWidgetIds,
    RemoteViews views, boolean partially) {
    ...
    synchronized (mLock) {
    ensureGroupStateLoadedLocked(userId);

    final int N = appWidgetIds.length;
    for (int i = 0; i &lt; N; i++) {
        final int appWidgetId = appWidgetIds[i];

        // NOTE: The lookup is enforcing security across users by making
        // sure the caller can only access widgets it hosts or provides.
        Widget widget = lookupWidgetLocked(appWidgetId,
                Binder.getCallingUid(), callingPackage);

        if (widget != null) {
            updateAppWidgetInstanceLocked(widget, views, partially);
        }
    }
}
}


    private static final class Widget {
int appWidgetId;
int restoredId;  // tracking &amp; remapping any restored state
Provider provider;
RemoteViews views;
Bundle options;
Host host;

@Override
public String toString() {
    return &quot;AppWidgetId{&quot; + appWidgetId + &apos;:&apos; + host + &apos;:&apos; + provider + &apos;}&apos;;
}
}
</code></pre><ul>
<li>找到 Widget之后会调用 updateAppWidgetInstanceLocked来进行更新,这里将Widget进行拆解之后使用Handler了回到了主线程</li>
</ul>
<pre><code>    private void updateAppWidgetInstanceLocked(Widget widget, RemoteViews views,
    boolean isPartialUpdate) {
if (widget != null &amp;&amp; widget.provider != null
        &amp;&amp; !widget.provider.zombie &amp;&amp; !widget.host.zombie) {

    if (isPartialUpdate &amp;&amp; widget.views != null) {
        // For a partial update, we merge the new RemoteViews with the old.
        widget.views.mergeRemoteViews(views);
    } else {
        // For a full update we replace the RemoteViews completely.
        widget.views = views;
    }

    scheduleNotifyUpdateAppWidgetLocked(widget, views);
}
}


    private void scheduleNotifyUpdateAppWidgetLocked(Widget widget, RemoteViews updateViews) {
if (widget == null || widget.provider == null || widget.provider.zombie
        || widget.host.callbacks == null || widget.host.zombie) {
    return;
}

SomeArgs args = SomeArgs.obtain();
args.arg1 = widget.host;
args.arg2 = widget.host.callbacks;
args.arg3 = updateViews;
args.argi1 = widget.appWidgetId;

mCallbackHandler.obtainMessage(
        CallbackHandler.MSG_NOTIFY_UPDATE_APP_WIDGET,
        args).sendToTarget();
}
</code></pre><ul>
<li>handleMessage中会调用到了handleNotifyUpdateAppWidget，这个callBack即是IAppWidgetHost，IAppWidgetHost又是一个Proxy类，这里我们就进入了另一个Binder机制了，这一个Binder用于与远程的Launcher进行通讯，同样地我们需要找到Binder的实现类</li>
</ul>
<pre><code>private void handleNotifyUpdateAppWidget(Host host, IAppWidgetHost callbacks,
    int appWidgetId, RemoteViews views) {
try {
    callbacks.updateAppWidget(appWidgetId, views);
} catch (RemoteException re) {
    synchronized (mLock) {
        Slog.e(TAG, &quot;Widget host dead: &quot; + host.id, re);
        host.callbacks = null;
    }
}
}
</code></pre><ul>
<li>Launcher这个Activity中含有LauncherAppWidgetHost对象这个类继承自AppWidgetHost，AppWidgetHost中含有Binder的实现类Callbacks</li>
</ul>
<pre><code>public final class Launcher extends Activity
implements View.OnClickListener, OnLongClickListener, LauncherModel.Callbacks,
           View.OnTouchListener {
           ...
private LauncherAppWidgetHost mAppWidgetHost;
</code></pre><ul>
<li>这里使用Handler回到主线程，接下来自然是Launcher这个Activity要更新界面了</li>
</ul>
<pre><code>static class Callbacks extends IAppWidgetHost.Stub {
private final WeakReference&lt;Handler&gt; mWeakHandler;

public Callbacks(Handler handler) {
    mWeakHandler = new WeakReference&lt;&gt;(handler);
}

public void updateAppWidget(int appWidgetId, RemoteViews views) {
    if (isLocalBinder() &amp;&amp; views != null) {
        views = views.clone();
    }
    Handler handler = mWeakHandler.get();
    if (handler == null) {
        return;
    }
    Message msg = handler.obtainMessage(HANDLE_UPDATE, appWidgetId, 0, views);
    msg.sendToTarget();
}
</code></pre><ul>
<li>updateAppWidgetView中的applyRemoteViews其实就是调用RemoteViews的Apply方法，也就是我们刚刚提到的根据反射去得到View的具体方法然后调用，这样我们的界面就在Launcher上面更新了</li>
</ul>
<pre><code>void updateAppWidgetView(int appWidgetId, RemoteViews views) {
AppWidgetHostView v;
synchronized (mViews) {
    v = mViews.get(appWidgetId);
}
if (v != null) {
    v.updateAppWidget(views);
}
}


public void updateAppWidget(RemoteViews remoteViews) {
applyRemoteViews(remoteViews);
}
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Bug 合集]]></title>
      <url>/2017/09/06/BUG/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><strong>不定期收录自己遇到的一些问题和解决方案，希望不要日更</strong></p>
<h2 id="2017-09-07-Android-Studio-无法添加远程依赖"><a href="#2017-09-07-Android-Studio-无法添加远程依赖" class="headerlink" title="2017.09.07 - Android Studio 无法添加远程依赖"></a>2017.09.07 - Android Studio 无法添加远程依赖</h2><ul>
<li>不知道从什么时候开始无法添加远程依赖，因为之前没有用的新的库所以一直没有察觉，添加远程依赖时会出现如下错误，似乎是下载时出错了，用了梯子也没有解决，并且在Chrome中打开Gradle Console里面的链接发现可以下载到pom文件</li>
</ul>
<pre><code>Error:(50, 17) Failed to resolve: ...
</code></pre><ul>
<li>根据网上的文章在 Android Studio 的HTTP Proxy 中勾选 No Proxy，在Builder Tools -> Gradle 中取消Offline work …然并卵，本来就是这么配置的</li>
</ul>
<ul>
<li>试了很多解决方案后，发现只需要在project的build.gradle 中添加阿里云的maven仓库即可</li>
</ul>
<pre><code>allprojects {
    repositories {
        jcenter()
     maven{ url &apos;http://maven.aliyun.com/nexus/content/groups/public/&apos;}
    }
}
</code></pre><h2 id="2017-09-07-RemoteViewsService-无法启动-amp-amp-RemoteViews-无法定时更新"><a href="#2017-09-07-RemoteViewsService-无法启动-amp-amp-RemoteViews-无法定时更新" class="headerlink" title="2017.09.07 - RemoteViewsService 无法启动 &amp;&amp; RemoteViews 无法定时更新"></a>2017.09.07 - RemoteViewsService 无法启动 &amp;&amp; RemoteViews 无法定时更新</h2><ul>
<li>在manifest文件中需要注明 RemoteViewsService 的权限，缺少 android:permission 属性 该类service将无法启动</li>
</ul>
<pre><code>&lt;service
    android:name=&quot;.widget.RemoteService&quot;
    android:permission=&quot;android.permission.BIND_REMOTEVIEWS&quot;
    android:enabled=&quot;true&quot;
    android:exported=&quot;true&quot; &gt;
&lt;/service&gt;
</code></pre><ul>
<li>1.6以后 updatePeriodMillis 属性少于30分钟时，会被系统直接设定为30分钟，为实现定时效果可以使用计时器</li>
</ul>
<pre><code>public class UpdateService extends Service{

private Timer mTimer;
private TimerTask mTimerTask;
public static final int UPDATE_TIME = 1000;
public static final String ACTION_UPDATE = &quot;com.linjiamin.UPDATE&quot;;

@Override
public int onStartCommand(Intent intent, int flags, int startId) {
return super.onStartCommand(intent, flags, startId);
}

@Nullable
@Override
public IBinder onBind(Intent intent) {
return null;
}

private static final String TAG = &quot;UpdateService&quot;;

@Override
public void onCreate() {
super.onCreate();

Log.d(TAG, &quot;onCreate: &quot;);
mTimer = new Timer();
mTimerTask = new TimerTask() {
    @Override
    public void run() {
        Intent updateIntent = new Intent(ACTION_UPDATE);
        sendBroadcast(updateIntent);
    }
};
//mTimer.schedule(mTimerTask, 1000, UPDATE_TIME);
}
}
</code></pre><ul>
<li>重写 AppWidgetProvider 的 onReceive方法，接受由定时器发来的广播</li>
</ul>
<pre><code>@Override
public void onReceive(Context context, Intent intent) {
super.onReceive(context, intent);
if(intent.getAction().equals(UpdateService.ACTION_UPDATE)){
    Update(context);
    Log.d(TAG, &quot;onReceive: &quot;);
}
}
</code></pre><h2 id="2017-09-08-AIDL-报错-Error-错误-程序包-不存在"><a href="#2017-09-08-AIDL-报错-Error-错误-程序包-不存在" class="headerlink" title="2017.09.08 - AIDL 报错 : Error:(   * , * ) 错误: 程序包 ** 不存在"></a>2017.09.08 - AIDL 报错 : Error:(   * , * ) 错误: 程序包 ** 不存在</h2><ul>
<li>使用自定义类型时，该类型的文件在aidl和java包中的路径必须一致，如果包结构不同，请创建相应的包以补全路径</li>
</ul>
<ul>
<li>注意java文件不能放在aidl包下</li>
</ul>
<h2 id="2017-09-22-ViewPager加载图片缓慢"><a href="#2017-09-22-ViewPager加载图片缓慢" class="headerlink" title="2017.09.22 - ViewPager加载图片缓慢"></a>2017.09.22 - ViewPager加载图片缓慢</h2><ul>
<li><p>使用ViewPager时加载图片速度很慢，原本以为是图片太大，后来发现是解析耗时太多</p>
</li>
<li><p>如果Item是动态创建的，建议设定通过LayoutParams设定的宽度或高度，如果使用布局文件应尽量减少布局层次，可以的情况下请尽量使用 Exactly模式</p>
</li>
<li><p>使用Picasso时发现 ImageView 的 scaleType 属性使用FitXY 时解析耗时远大于 CenterCrop</p>
</li>
</ul>
<h2 id="2017-10-06-Parcelable-包装类-NullPointerException"><a href="#2017-10-06-Parcelable-包装类-NullPointerException" class="headerlink" title="2017.10.06 - Parcelable 包装类 NullPointerException"></a>2017.10.06 - Parcelable 包装类 NullPointerException</h2><ul>
<li>使用快捷键实现Parcelable接口可能会遇上这个坑</li>
<li>自动生成代码可能不会（至少本人使用的AS版本不会，算是个Bug）为包装类生成调用Parcel的read和writer代码，请注意检查</li>
<li>我们知道包装类没有默认的初始值（准确地说，初始值为null），因此writeToParcel可能抛出NullPointerException，一般情况下使用 Long long = 0L 这种形式为类属性赋初值即可</li>
<li>特殊情况下，例如使用Gson这种会修改类属性的工具需要特别注意，在Gson的情况下，没有解析到的类属性为null，请考虑在writeToParcel，构造器或使用Gson的地方进行检查</li>
</ul>
<h2 id="2018-02-XX-横向-RecycleView-高度-wrap-content-时显示空白"><a href="#2018-02-XX-横向-RecycleView-高度-wrap-content-时显示空白" class="headerlink" title="2018.02.XX - 横向 RecycleView 高度 wrap_content 时显示空白"></a>2018.02.XX - 横向 RecycleView 高度 wrap_content 时显示空白</h2><ul>
<li>onBindViewHolder执行但是视图空白</li>
<li>网上出现这种情况一般是RecycleView外套了一层ScrollView，改用NestedScrollView可以解决问题</li>
<li>在其他复杂布局中也可能出现这种情况，具体原因不清楚，但是在RecycleView外再套一层LinearLayout，并将这个LinearLayout的宽高指定得跟RecycleView完全一致，可以解决问题</li>
</ul>
<h2 id="2018-02-XX-GreenDao-获取数据不正常"><a href="#2018-02-XX-GreenDao-获取数据不正常" class="headerlink" title="2018.02.XX - GreenDao 获取数据不正常"></a>2018.02.XX - GreenDao 获取数据不正常</h2><ul>
<li>GreenDao中，对同一个dao进行删除和查询操作，得出结果可能与数据库中的不同，可能是内部缓存的问题，调用XXXdao.detachAll可以清楚缓存</li>
<li>在某种情况下，也可能出现清理缓存后仍然获取不到正确数据的情况，具体原因不清楚</li>
</ul>
<h2 id="2018-02-XX-Intent-隐式跳转系统应用无法识别-mimeType"><a href="#2018-02-XX-Intent-隐式跳转系统应用无法识别-mimeType" class="headerlink" title="2018.02.XX - Intent 隐式跳转系统应用无法识别 mimeType"></a>2018.02.XX - Intent 隐式跳转系统应用无法识别 mimeType</h2><ul>
<li><p>在小米和某些系统的手机下直接使用文件路径作为跳转的data会出现无法弹出匹配的应用供选择的情况，应该是国内厂商改系统造成的</p>
</li>
<li><p>uri类型一般可以正常使用，即content://开头的类型</p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> error </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[volatile 相关概念]]></title>
      <url>/2017/08/16/Volatile/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><br></p>
<h2 id="JMM-Java内存模型"><a href="#JMM-Java内存模型" class="headerlink" title="JMM - Java内存模型"></a>JMM - Java内存模型</h2><ul>
<li>为了理解内存可见性问题和处理Java线程之间的通信，必须对Java内存模型有一定程度的了解</li>
</ul>
<p><br></p>
<h3 id="JMM的组成"><a href="#JMM的组成" class="headerlink" title="JMM的组成"></a>JMM的组成</h3><ul>
<li>共享变量，Java中堆内存对象在线程之间共享，JMM决定一个线程对共享变量的写入何时对另一个线程可见</li>
<li>线程之间的共享变量被存放在主内存当中，每个线程都有一个私有的本地内存，本地内存是一个抽象的概念，由多种途径共同实现，本地内存当中存储了共享变量的副本，相当于高速缓存，为了确保线程之间的正常通信，写入共享变量时必须将共享变量刷新到主内存当中，而读取共享变量时必须从主内存中获取</li>
</ul>
<p><br></p>
<h3 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h3><ul>
<li>编译器和处理器为了提高性能，会对指令进行重排序</li>
<li>重排序包括三种，编译器会在在不改变单线程语义的情况下重新安排语句的执行顺序，处理器在不存在数据依赖性的情况下可以改变语句对应的机器指令的执行顺序，处理器使用缓存和读写缓存区使得加载和储存操作看上去是乱序执行的</li>
<li>JDK5开始Java使用JSR -133内存模型，该模型使用happens-before原则来描述操作的有序性</li>
</ul>
<pre><code>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作
程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作
锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作
传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C
线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作
线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生
线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行
对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始
</code></pre><p><br>       </p>
<h3 id="volatile实现"><a href="#volatile实现" class="headerlink" title="volatile实现"></a>volatile实现</h3><ul>
<li>上面happens-before原则中的第一条，明确了volatile关键字的根本作用</li>
</ul>
<ul>
<li>例如在x86环境下对有volatile修饰的共享变量进行读写操作时会增加一行汇编代码</li>
</ul>
<pre><code>Java代码：   instance = new Singleton();//instance是volatile变量
汇编代码： 0x01a3de1d: movb $0x0,0x1104800(%esi);0x01a3de24: lock addl $0x0,(%esp);
</code></pre><ul>
<li>由于处理器不直接和内存进行通讯，而是将系统内存读取到cache当中，所以当需要读写volatile变量时JVM会想处理器发送一条lock前缀的指令，这条指令主要引发两件事情，前者一般有两种实现方式，一种通过在总线加LOCK#锁阻塞其他CUP的访问，消耗较大，另一种使用缓存一致性协议阻止同时修改被两个以上处理器缓存的内存区域的数据   </li>
</ul>
<pre><code>将当前处理器缓存的数据写回到内存当中
使其他CPU里缓存了该内存地址的数据无效  
</code></pre><ul>
<li>有序性：为了实现volatile内存的语义，JMM会限制刚刚提到的重排序操作：在volatile写之前不管前一个的操作是什么，都不能重排序，保证volatile写先执行完毕；在volatile读之后，不管后一个操作是什么，都不能重排序，保证volatile读先执行完毕，为此编译器会在读写指令的前后插入内存屏障的字节码，这种字节码可以禁止处理器的重排序</li>
</ul>
<ul>
<li>原子性： 注意volatile的实现仅仅保证了单个volatile变量读写的原子性，java虚拟机规范规定了声明为volatile的long和double变量的get和set操作是原子的，对于诸如自增自减等复合操作并不具备原子性，这种复合操作很有可能因为线程的阻塞而产生不可预测的效果</li>
</ul>
<p><br></p>
<h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><ul>
<li>内存屏障分为4类，它们专门用于避免指令重排</li>
</ul>
<pre><code>StoreStore，在Volatile读前
StoreLoad，在Volatile读后
LoadLoad，在Volatile写前
LoadStore，在Volatile写后
</code></pre><ul>
<li>如Volatile写时插入StoreStore后的指令大致如下</li>
</ul>
<pre><code>普通写
StoreStore
Volatile写
StoreLoad
</code></pre><ul>
<li>StoreStore或保证所有普通写操作已经可见了，因为它会将所有普通写的内容刷新到主内存</li>
<li>StoreLoad用于避免Volatile写后面可能有的Volatile读/写重排序，通常编译器无法预测是否真的有这种操</li>
<li>LoadLoad，用于避免处理器将前面的Volatile读与普通读重排序</li>
<li>LoadStore，用于避免处理器将前面的Volatile写与普通读重排序</li>
<li>对于Volatile变量之间，在旧的Java内存模型中其实本来就实现了不可重排的，JSR-133模型增强了volatile的内存语义</li>
</ul>
<p><br></p>
<h2 id="正确使用volatile"><a href="#正确使用volatile" class="headerlink" title="正确使用volatile"></a>正确使用volatile</h2><ul>
<li>上面提到volatile对于复合操作是不具备原子性的，如下面的inc的自增，线程可能在读取Inc的值之后就被阻塞了，这时改线程对inc的修改并没有执行，也就不存在其他线程是否可见的问题，之后该线程继续工作时就会对其他线程的修改进行覆盖</li>
</ul>
<pre><code>public class Test {

        private volatile int inc = 0;

        private void increase(){
            inc++;
        }

        public static void main(String[] args){

        final Test test = new Test();
        for(int i = 0;i&lt;10;i++){
            new Thread(() -&gt; {
                for(int j = 0; j&lt;1000;j++)
                test.increase();
            }).start();
        }

            while (Thread.activeCount()&gt;2)
                Thread.yield();
            System.out.println(test.inc);
        }
    }
</code></pre><ul>
<li>在上述情况下应该放弃使用Volatile，使用锁机制可以解决这种问题</li>
</ul>
<pre><code>public class Test {

    private int inc = 0;

    private synchronized void increase(){
        inc++;
    }

    public static void main(String[] args){

    final Test test = new Test();
    for(int i = 0;i&lt;10;i++){
        new Thread(() -&gt; {
            for(int j = 0; j&lt;1000;j++)
            test.increase();
        }).start();
    }

        while (Thread.activeCount()&gt;2)
            Thread.yield();
        System.out.println(test.inc);
    }
}

//或者

public class Test {

    private int inc = 0;
    Lock lock = new ReentrantLock();

    private void increase(){

        lock.lock();
        try {
            inc++;
        }finally {
            lock.unlock();
        }
    }

    public static void main(String[] args){

    final Test test = new Test();
    for(int i = 0;i&lt;10;i++){
         new Thread(() -&gt; {
            for(int j = 0; j&lt;1000;j++)
            test.increase();
        }).start();
    }

        while (Thread.activeCount()&gt;2)
            Thread.yield();
        System.out.println(test.inc);
    }
}
</code></pre><ul>
<li>也可以使用Java提供的CAS封装</li>
</ul>
<pre><code>public class Test {

    private AtomicInteger inc = new AtomicInteger(0);

    private void increase(){

        inc.getAndIncrement();

    }

    public static void main(String[] args){

    final Test test = new Test();
    for(int i = 0;i&lt;10;i++){
        new Thread(() -&gt; {
            for(int j = 0; j&lt;1000;j++)
            test.increase();
        }).start();
    }

        while (Thread.activeCount()&gt;2)
            Thread.yield();
        System.out.println(test.inc);
    }
}
</code></pre><ul>
<li>volatile可以使用于状态标记</li>
</ul>
<pre><code>volatile boolean flag = false;
while(!flag){
    doSomething();
}

public void setFlag() {
    flag = true;

volatile boolean inited = false;
//线程1:
context = loadContext();  
inited = true;            

//线程2:
while(!inited ){
sleep()
}
doSomethingwithconfig(context);
</code></pre><ul>
<li>Volatile也可用于双重锁，注意初始化对象并不是原子操作，但不会出现上面提到非原子操作带来的错误，因为使用Volatile的原因是禁止指令重排，对于单线程来说，对象的初始化和将栈中引用指向堆内存的空间地址，这两个步骤的先后不会对语义造成影响，所以处理器可能进行指令重排。但对于多线程来说，如果对象未初始化就得到了内存地址，其他线程调用getInstance方法时将会由于instance不为null而得到一个不完整的对象，使用时会抛出异常，因此这里需要用Volatile来避免。</li>
</ul>
<pre><code>    class Singleton{
        private volatile static Singleton instance = null;

        private Singleton() {
        }

        public static Singleton getInstance() {
            if(instance==null) {
                synchronized (Singleton.class) {
                    if(instance==null)
                        instance = new Singleton();
                }

            return instance;
        }
}   
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[GC 基础知识]]></title>
      <url>/2017/08/14/GC/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><br></p>
<h3 id="JVM内存组成"><a href="#JVM内存组成" class="headerlink" title="JVM内存组成"></a>JVM内存组成</h3><ul>
<li>java的内存结构分为三大块，堆空间，方法区，栈</li>
<li>在环境变量或Eclipse等集成环境的设置选项或配置文件中可以设置JVM的内存分配大小</li>
</ul>
<pre><code>-XX:newSize：表示新生代初始内存的大小，应该小于 -Xms的值
-XX:MaxnewSize：表示新生代可被分配的内存的最大上限，应该小于 -Xmx的值
-Xmn：同时配置 -XX:newSize，-XX:MaxnewSize，使-XX:newSize = -XX:MaxnewSize = -Xmn，JDK1.4版本可用
-XX:PermSize：表示非堆区permanent 初始内存分配
-XX:MaxPermSize：表示对非堆区分配的最大内存
</code></pre><p><br></p>
<h3 id="堆区与GC"><a href="#堆区与GC" class="headerlink" title="堆区与GC"></a>堆区与GC</h3><ul>
<li>通常来说，堆Heap是Java虚拟机管理内存中最大的一块，是垃圾回收器管理的主要区域，因此也被称为GC堆</li>
<li>GC机制通常基于以下两个前提实现，Sun推出的HotSpot虚拟机中将堆中的对象分为两类，新生代和老生代，分别对应以下两者</li>
</ul>
<pre><code>大多数对象会很快变得不可达
只有很少的由创建时间较长的对象指向的新对象的引用
</code></pre><ul>
<li>生代仅仅只是一种实现，例如Dalvik使用的是不分代的标记清除算法</li>
</ul>
<p><br>   </p>
<h4 id="新生代-Young-generation"><a href="#新生代-Young-generation" class="headerlink" title="新生代 Young generation"></a>新生代 Young generation</h4><ul>
<li>绝大多数刚创建的对象会被分配到这里，然后变得不可达并被回收，这个区域的垃圾回收称为Minor GC</li>
</ul>
<ul>
<li>新生代又被分为Eden区和Survivor区，Survivor区又由两个相同大小并且不断互换身份的分区组成，在同一时刻将两者称为FromSpace和ToSpace</li>
</ul>
<ul>
<li>当创建对象时 JVM会为对象在Eden区划分内存区域，在初始状态之后，如果Eden空间足够则操作结束，否则触发第一次GC，回收Eden中的不可达对象，并将Eden区中存活的对象放入FromSpace区，操作结束。之后创建对象时如果Eden区再次不足，GC会清空Eden区和FromSpace区的所有不可达对象，并将存活的对象转移到ToSpace区，并且清空FromSpace，分区完成互换</li>
</ul>
<ul>
<li>当Eden区和FromSpace区的存活对象向ToSpace区转移时，存活次数超过一定值的对象会被转移到Old generation，另外如果ToSpace区空间不足，无法存放的对象也会被同时转移</li>
</ul>
<p><br></p>
<h4 id="老生代-Old-generation"><a href="#老生代-Old-generation" class="headerlink" title="老生代 Old generation"></a>老生代 Old generation</h4><ul>
<li>多次存活的对象会被放置到这里，Old generation一般在空间不足时发生GC，只清理该区域的GC被称为Major GC</li>
<li>如果GC之后仍发现空间不足则会出现Out of memory异常</li>
</ul>
<p><br></p>
<h3 id="方法区与GC"><a href="#方法区与GC" class="headerlink" title="方法区与GC"></a>方法区与GC</h3><p><br></p>
<h4 id="告别永久代"><a href="#告别永久代" class="headerlink" title="告别永久代"></a>告别永久代</h4><ul>
<li>方法区常常被称为永久代，但实际上只有HotSpot的虚拟机实现将方法区划入了永久代，并且在很长一段时间内强调永久代的概念，JDK 6开始HotSpot自己也开始计划取消永久代，在JDK 8 中永久代终于被元空间所取代</li>
</ul>
<ul>
<li>方法区用于存放各个线程之间共享的信息，包括被加载的类的信息，final常量，静态变量，编译器即使编译的代码等，方法区不需要时连续的，并且可以设定大小</li>
</ul>
<ul>
<li>方法区之所以被称为永久区是由于方法区可以通过-Xnoclassgc 选择是否进行垃圾收集，而且这种垃圾收集通常由于条件严苛，执行的机会较少</li>
</ul>
<ul>
<li>方法区GC主要回收常量与无用类，包括字面量，类，接口，方法，字段的符号引用等，无用类必须满足三个条件，没有该类的任何实例存在，加载该类的ClassLoader已经被回收，该类的Class对象不可达从而无法在任何地方访问该类的方法</li>
</ul>
<p><br></p>
<h4 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h4><ul>
<li>类所拥有的类信息被称为元数据，包括如类的层级信息，方法数据和方法信息（如字节码，栈和变量大小），运行时常量池，已确定的符号引用和虚方法表</li>
<li>永久代的设计存在一定的缺陷，由于其大小和是否GC都是可选的，这意味着永久代很有可能内存不足抛出OOM异常</li>
<li>每一个类加载器的储存空间都是一个元空间，所有的元空间加在一起就是我们所说的元空间，一个类的元空间的生命周期和它的类加载器的生命周期相同，虚拟机中存在一个全局的空闲组块列表，当类加载器需要空间时会从这个列表中申请用以储存元信息，当类加载器不再存活，将会返回这部分内存给列表 </li>
</ul>
<p><br></p>
<h3 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h3><p><br></p>
<h4 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h4><ul>
<li>标记阶段，从根对象对开始遍历，为所有可以访问的对象打上标记</li>
<li>清除阶段，从堆内存开始线性遍历，回收所有没有被标记的对象</li>
<li>这种算法会产生内存碎片，并且效率不高</li>
</ul>
<p><br></p>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><ul>
<li>新生代采用的算法，只处理正在使用的对象，将其转移到另一区域并将原来的区域清空</li>
<li>不会产生内存碎片，效率较高，但是比较占用内存</li>
</ul>
<p><br></p>
<h4 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h4><ul>
<li>在标记阶段之后不直接对可回收对象进行清理，而是将所有标记对象向一段移动然后清理</li>
</ul>
<p><br></p>
<h3 id="Dalvik-GC"><a href="#Dalvik-GC" class="headerlink" title="Dalvik GC"></a>Dalvik GC</h3><ul>
<li>Dalvik的堆结构不同于常见的JVM的堆结构，Dalvik将堆分为Active堆和Zygote堆，Zygote堆主要保留预加载的类、资源和对象，其余对象都存放在Active堆，Dalvik虚拟机进行部分垃圾收集时，实际上就是只收集在Active堆上分配的对象</li>
<li>Dalvik使用的是标记清除算法，在标记阶段使用两个Bitmap来描述对象，一个为Live Bitmap，另一个为Mark Bitmap，前者标记上一次GC时被引用的对象，后者标记当前GC被引用的对象。被Live Bitmap标记，但不被Mark Bitmap标记的对象会被回收</li>
<li>标记阶段分为两个子阶段，第一个子阶段只负责标记根对象，也就是GC开始瞬间被全局变量，栈变量和寄存器变量引用的对象，这个阶段除了垃圾回收线程之外的线程全部被挂起，第二个子阶段会对所有被根对象直接或间接引用的对象，这个阶段允许其他线程执行</li>
<li>清除Dalvik同样需要挂起所有线程，同时Dalvik的标记清除算法会导致内存碎片化严重，寻址困难，所以GC会带来明显的卡顿</li>
</ul>
<p><br></p>
<h3 id="ART-GC"><a href="#ART-GC" class="headerlink" title="ART GC"></a>ART GC</h3><ul>
<li>ART的堆被分为四个部分Image Space、Zygote Space、Allocation Space和Large Object Space，其中Allocation Space和Large Object Space和Dalvik虚拟机的Zygote堆和Active堆作用是一样的，Large Object Space是离散地址的集合，用来分配大的对象，Image Space永远不需要回收</li>
</ul>
<ul>
<li>ART对Dalvik的GC算法进行了改进，只在回收对象时暂停所有线程一次，并且ART采用力度从小到大的垃圾回收策略，例如Sticky Mark Sweep的垃圾回收只会回收Allocation Stack的垃圾，Partial Mark Sweep只会同时回收Allocation Space和Large Object Space的垃圾</li>
</ul>
<ul>
<li>在垃圾回收之后ART会将不连续的物理内存对齐以解决碎片化的问题</li>
</ul>
<p><br>   </p>
<h3 id="GC-root"><a href="#GC-root" class="headerlink" title="GC root"></a>GC root</h3><ul>
<li>GC root就是所有根对象的引用的集合，GC root是遍历的起点，所有没有被遍历到的对象会被判断为死亡，随后被GC回收</li>
</ul>
<ul>
<li>原本GC root应该包含如下部分</li>
</ul>
<pre><code>Class 由系统类加载器加载的对象，这些类是不能够被回收的，他们可以以静态字段的方式保存持有其它对象
Thread  活着的线程
Stack Local Java方法的local变量或参数
JNI Local JNI方法的local变量或参数
JNI Global 全局JNI引用
Monitor Used 用于同步的监控对象
Held by JVM 用于JVM特殊目的由GC保留的对象
</code></pre><ul>
<li>上面分代式的GC所定义的GC root有部分不同，分代式GC采用部分搜集的做法，并不是完全的遍历，所以分代式GC中非收集部分指向收集部分的引用也应该作为GC root的一部分例如minor GC只收集Young Generation的对象，那么从 Old generation指向Young Generation的引用就属于GC root</li>
</ul>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java泛型 注意事项]]></title>
      <url>/2017/08/14/TypeErasue/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<h2 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h2><p><strong>避免代码膨胀的泛型实现</strong></p>
<ul>
<li>JVM 中不存在泛型，所有的对象都属于普通类，Java通过泛型擦除让泛型实例能够使用一份适应不同类型的字节码，而不需要为每一个泛型实例创建不同的字节码</li>
</ul>
<ul>
<li>泛型擦除的基本逻辑是将类型参数替换为原始类型，例如类Test<t>中类型参数T会被替换为Object，如果泛型中含有限定类型，则会把第一个限定类型作为原始类型，如\<t extends="" comparable="" &="" serializable\=""> 中的类型参数T 会被替换为 Comparable。泛型擦除的各种细节将在下面提及</t></t></li>
</ul>
<ul>
<li>当我们使用泛型方法时，由于类型擦除，编译器会自动为我们进行强制类型转换，确保泛型在一般情况下能达到其设计的初衷</li>
</ul>
<h2 id="桥方法"><a href="#桥方法" class="headerlink" title="桥方法"></a>桥方法</h2><ul>
<li>由于泛型擦除，方法中的类型参数被替换为原始类型，编译器需要避免重写被错误变为重载的问题，例如下面这段代码，子类想要重写父类的test(T t)方法，在当前指明了类型参数的情况下也可以说是test(String str)方法，但是由于这里的父类的T会被替换为Object，因此子类的test(String str)无法重写父类的方法</li>
</ul>
<pre><code>public class Father&lt;T&gt;{

public void test(T t){
//do something
    }
}


public class Son extends  Father&lt;String&gt;{

public void test(String str){
//do something
    }
}
</code></pre><ul>
<li>为了解决这个问题，编译器会自动生成桥方法，当调用test方法时，会调用生成的test(Object t)桥方法，该方法将参数进行强制类型转换后调用我们实现的方法，这样就产生了覆盖的效果</li>
</ul>
<pre><code>public void test(Object t){
    test((String) t)
}  
</code></pre><ul>
<li>不过桥方法会产生一种奇怪的效果，我们知道方法签名由方法名和参数类型组成，不包括返回类型，并且方法签名不能被多个方法共用，也就是说我们不能编写如下的代码，但是如果在父类中含有T get()方法时，编译器为我们自动生成Object get()桥方法却能够通过编译并解决泛型擦除带来的问题。其实这是因为JVM通过参数类型和返回类型确定一个方法，JVM可以处理仅有返回类型不同的方法</li>
</ul>
<pre><code>public String get(){
    //do something
};

public Object get(){
    //do something
};
</code></pre><h2 id="正确使用泛型"><a href="#正确使用泛型" class="headerlink" title="正确使用泛型"></a>正确使用泛型</h2><h3 id="不能使用类型参数实例化类型参数"><a href="#不能使用类型参数实例化类型参数" class="headerlink" title="不能使用类型参数实例化类型参数"></a>不能使用类型参数实例化类型参数</h3><ul>
<li>不能使用 Pair&lt; double &gt; 来实例化类型参数，这是由于泛型擦除后类型参数将变为Object或Object的子类，显然使用基本类型会造成类型不匹配</li>
</ul>
<ul>
<li>这种情况下应该使用包装类型或其它的类</li>
</ul>
<h3 id="运行时类型查询只适用于原始类型"><a href="#运行时类型查询只适用于原始类型" class="headerlink" title="运行时类型查询只适用于原始类型"></a>运行时类型查询只适用于原始类型</h3><ul>
<li>instanceof 只能查询是否为原始类型，若使用instanceof查询某个对象是否为某个泛型类型时编译不会通过</li>
</ul>
<h3 id="不能创建参数化类型的数组"><a href="#不能创建参数化类型的数组" class="headerlink" title="不能创建参数化类型的数组"></a>不能创建参数化类型的数组</h3><ul>
<li>假定参数化类型的数组可以创建，那么 Pair&lt; String &gt;[ ] 在类型擦除后相当于Pair[]，可以将其转换为Objec[]类型，这时数组的类型检查机制将会失效，因为数组只能保证它当中存储的是Pair对象，但是 Pair&lt; String &gt;，Pair&lt; Double &gt;，Pair&lt; Integer &gt;显然是不同的类型，出于这个原因如果new了参数化类型的数组将不能通过编译</li>
</ul>
<ul>
<li>我们应该考虑使用ArrayList等支持泛型的容器来存放参数化类型的对象</li>
</ul>
<h3 id="不能实例化类型变量"><a href="#不能实例化类型变量" class="headerlink" title="不能实例化类型变量"></a>不能实例化类型变量</h3><ul>
<li>不要使用 new T()这样的方法实例化类型变量，这是不能通过编译的，泛型擦除后，它就相当于new Object()，new Object()显然没有什么意义</li>
</ul>
<ul>
<li>在java 8 中可以使用Lambda解决这个问题，Supplier&lt; T &gt;函数式接口返回一个T类型的实例</li>
</ul>
<pre><code>Pair&lt;String&gt; pair = Pair.makePair(String::new);

public class Pair&lt;T&gt;{

        T t1;
        T t2;

public Pair(T t1, T t2){
    this.t1 = t1;
    this.t2 = t2;

}

public static &lt;T&gt;Pair&lt;T&gt; makePair(Supplier&lt;T&gt; constr){

    return new Pair&lt;&gt;(constr.get(),constr.get());

    }
}
</code></pre><ul>
<li>也可以使用反射来实现，注意不能直接使用 T.class.newInstance，这也相当于new一个原始类型，我们应该从外部传入Class对象</li>
</ul>
<pre><code>public static &lt;T&gt;Pair&lt;T&gt; makePair(Class&lt;T&gt; cl){

    try {
        return new Pair&lt;&gt;(cl.newInstance(),cl.newInstance());
    } catch (InstantiationException | IllegalAccessException e) {
        e.printStackTrace();
    }
    return null;
}   
</code></pre><h3 id="不要使用带有类型变量的静态域和方法"><a href="#不要使用带有类型变量的静态域和方法" class="headerlink" title="不要使用带有类型变量的静态域和方法"></a>不要使用带有类型变量的静态域和方法</h3><ul>
<li>由于类型擦除，所有传入的类型变量实际上只相当于原始类型，所有的静态变量都是共享的</li>
</ul>
<pre><code>public class Singleton&lt;T&gt;{
    private static T singleInstance;
    public static  T getSingleInstance(){
        if(singleInstance == null)
                construct new instanceof T

        return singleInstance;
    }
</code></pre><h3 id="不能抛出或者捕获泛型类的实例"><a href="#不能抛出或者捕获泛型类的实例" class="headerlink" title="不能抛出或者捕获泛型类的实例"></a>不能抛出或者捕获泛型类的实例</h3><ul>
<li>不能抛出或者捕获泛型类的实例，也不能使用泛型扩展Throwable，由于泛型擦拭，这里的T替换为Throwable，实际上失去了泛型的作用，因此编译不通过，另外通常来说处理异常需要有足够的运行时信息，因此也没有理由catch泛型的异常</li>
</ul>
<pre><code>    public static &lt;T extends Throwable&gt; void dowork(Class&lt;T&gt; t){
...
    catch(T e)
    }
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Loader 机制详解]]></title>
      <url>/2017/08/13/Loader/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<h2 id="什么是Loader"><a href="#什么是Loader" class="headerlink" title="什么是Loader"></a>什么是Loader</h2><p><img src="https://ws1.sinaimg.cn/large/987832a0gy1fiiicfa8ehj21fe0mstgh.jpg" alt=""></p>
<ul>
<li>写app最重要的一个部分就是与数据打交道，回顾我们平时处理数据的套路，通常我们在Activity启动或响应用户触摸事件时开启线程获取数据，然后通过Handler切换到主线程中更新UI，在这过程中还需要通过onSaveInstanceState保留数据，有时甚至还需要实时监控数据源更新数据</li>
<li>使用AsyncTask或者Thread + Handler 完全可以实现我们的需求，但是随着Task的增多，我们可能发现自己管理线程，UI，回调接口比较繁琐，而且不同的Task当中又有很多相似的操作</li>
<li>为了满足和解决以上的需求和问题，在Android 3.0中加入了LoaderManager，统一管理异步任务</li>
<li>学习如何使用Loader其实不是很重要的，一般我们只会在使用ContentProvider时用到Loader，最重要的是学习官方如何根据Activity和Fragment的生命周期管理数据，以及使用统一的接口传递数据</li>
</ul>
<h2 id="简单使用Loader"><a href="#简单使用Loader" class="headerlink" title="简单使用Loader"></a>简单使用Loader</h2><h3 id="AsyncTaskLoader"><a href="#AsyncTaskLoader" class="headerlink" title="AsyncTaskLoader"></a>AsyncTaskLoader</h3><ul>
<li>AsyncTaskLoader是一个对AsyncTask的封装，我们可以实现这个抽象类自定义Loader，它需要实现下面五个方法</li>
<li>public void deliverResult(D data)</li>
<li>protected D doInBackground(Void… params)    </li>
<li>protected void onStartLoading()</li>
<li>protected void onStopLoading()</li>
<li>protected void onReset()</li>
<li>通常我们不应该主动调用这几个方法以免扰乱Loader的生命周期</li>
</ul>
<h3 id="LoaderCallbacks"><a href="#LoaderCallbacks" class="headerlink" title="LoaderCallbacks"></a>LoaderCallbacks</h3><ul>
<li>LoaderCallbacks，这是与LoaderManager进行交互的接口，需要实现以下三个方法</li>
<li>public Loader<d> onCreateLoader(int id, Bundle args)</d></li>
<li>public void onLoadFinished(Loader<d> loader, D data)</d></li>
<li>public void onLoaderReset(Loader<d> loader)</d></li>
</ul>
<h3 id="使用自定义Loader"><a href="#使用自定义Loader" class="headerlink" title="使用自定义Loader"></a>使用自定义Loader</h3><ul>
<li>下面通过 AsyncTaskLoader 简单过一遍使用Loader的流程，将我们的数据类型定义为 List<dirinfo>，它是一个手机中所有含有图片的文件夹的信息的列表</dirinfo></li>
</ul>
<pre><code>public class MyLoader extends AsyncTaskLoader&lt;List&lt;DirInfo&gt;&gt; 
</code></pre><ul>
<li>onStartLoading，这个方法在主线程被调用，在这里开始获取我们的数据，通常来说有两种情况，如果我们的数据可缓存并且已经缓存，使用deliverResult()方法直接投递数据即可，如果需要开启线程异步加载数据则调用forceLoad()方法</li>
</ul>
<pre><code>protected void onStartLoading() {
if(mData != null)
    deliverResult(mData);
else 
    forceLoad();
}
</code></pre><ul>
<li>loadInBackground，相当于AsyncTask中的doInBackground，在这里进行耗时操作并返回所需的数据，具体的过程和主题无关就不讲解了</li>
</ul>
<pre><code> @Override
 public List&lt;DirInfo&gt; loadInBackground() {

 SparseArray&lt;DirInfo&gt; array = new SparseArray&lt;&gt;();

 ContentResolver resolver = mContext.getContentResolver();
 Cursor cursor;
 try{

     cursor = resolver.query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,new String[]{&quot;_id&quot;,&quot;_data&quot;,&quot;_display_name&quot;,&quot;bucket_id&quot;,&quot;bucket_display_name&quot;},null,null,&quot;_id desc&quot;);
     if(cursor!=null){

         DirInfo allPic = new DirInfo(ALL_PIC_ID,&quot;全部图片&quot;);
         array.put(ALL_PIC_ID,allPic);

         while (cursor.moveToNext()) {

             //图片对象
             int imageId = cursor.getInt(cursor.getColumnIndex(&quot;_id&quot;));
             String imageUrl = cursor.getString(cursor.getColumnIndex(&quot;_data&quot;));
             String imageName = cursor.getString(cursor.getColumnIndex(&quot;_display_name&quot;));
             ImageInfo imageInfo = new ImageInfo(imageId,imageName,imageUrl);
             allPic.addImageInfo(imageInfo);

             //文件夹对象
             DirInfo dirInfo;
             int dirId = cursor.getInt(cursor.getColumnIndex(&quot;bucket_id&quot;));
             String dirName = cursor.getString(cursor.getColumnIndex(&quot;bucket_display_name&quot;));

             if((dirInfo = array.get(dirId))==null) {

                 dirInfo = new DirInfo(dirId,dirName);
                 dirInfo.addImageInfo(imageInfo);
                 array.put(dirId,dirInfo);

             }else dirInfo.addImageInfo(imageInfo); //如果文件夹对象已创建，直接加入图片对象
         }
     }

     if(cursor!=null) cursor.close();

 }catch (Exception e){
     e.printStackTrace();
 }

 ArrayList&lt;DirInfo&gt; list = new ArrayList&lt;&gt;();
 list.add(array.get(ALL_PIC_ID));
 Log.d(TAG, &quot;loadInBackground: &quot;+array.get(ALL_PIC_ID).getImageList().size());
 array.remove(ALL_PIC_ID);

 //转换容器类型
 for(int i = 0;i&lt;array.size();i++){
     DirInfo dirInfo = array.get(array.keyAt(i));
     list.add(dirInfo);
 }

 return list;
}
</code></pre><ul>
<li>deliverResult，通过这个方法可以得到我们刚刚返回给LoaderManager的数据，根据实际需求在这里缓存我们的数据，之后如果没有必要，就无需重复加载了，可以参考一下<a href="https://stackoverflow.com/questions/25234581/what-does-asynctaskloader-deliverresult-actually-do" target="_blank" rel="external">StackOverflow</a>上面的建议</li>
</ul>
<pre><code>@Override
public void deliverResult(List&lt;DirInfo&gt; data) {
super.deliverResult(data);
mData = data;
}
</code></pre><ul>
<li>onStopLoading，当Activity或Fragment处于stop状态时会调用这个方法，通常在这个方法中使用 cancelLoad 终止正在执行的任务，注意这里只关乎当前的任务，当数据源变化时还是会再次加载数据的</li>
</ul>
<pre><code>@Override
protected void onStopLoading() {
cancelLoad();
} 
</code></pre><ul>
<li>onReset，执行这个方法之后LoaderManager会重新初始化Loader的所有标志位，通常在这里进行资源的释放</li>
</ul>
<pre><code>@Override
protected void onReset() {
super.onReset();
mData = null;
}
</code></pre><h3 id="实现-LoaderCallbacks"><a href="#实现-LoaderCallbacks" class="headerlink" title="实现 LoaderCallbacks"></a>实现 LoaderCallbacks</h3><ul>
<li>为了处理数据，需要实现LoaderCallbacks，下面在Activity中实现这个接口</li>
</ul>
<ul>
<li>onCreateLoader，该方法用于根据id返回我们的需要用到的Loader，args是在调用initLoader时我们传入的参数，可以用于存放一些必要的信息</li>
</ul>
<pre><code>@Override
public Loader&lt;List&lt;DirInfo&gt;&gt; onCreateLoader(int id, Bundle args) {
return new MyLoader(this);
}
</code></pre><ul>
<li>onLoadFinished，当数据加载完后会调用onLoadFinished方法，在这里可以更新UI</li>
</ul>
<pre><code>@Override
public void onLoadFinished(Loader&lt;List&lt;DirInfo&gt;&gt; loader, List&lt;DirInfo&gt; dataList) {

mPicAdapter.setDataList((dataList.get(0)).getImageList());
Log.d(TAG, &quot;onLoadFinished: &quot;+dataList.size());

}
</code></pre><ul>
<li>onLoaderReset，之前提到Loader的onReset方法会初始化Loader，这时onLoaderReset就会被调用，通常可以在该方法中将Activity，Fragment或Adapter中的数据置为null，如果使用了CursorLoader，这一步非常重要，Cursor被close之后会调用该方法，所以要确保在这里将数据置空，避免出现异常</li>
</ul>
<pre><code>@Override
public void onLoaderReset(Loader&lt;List&lt;DirInfo&gt;&gt; loader) {

}    
</code></pre><ul>
<li>在onCreate方法中调用initLoader开始获取数据            </li>
</ul>
<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);

initView();
getLoaderManager().initLoader(111,null,this);

}

public void initView() {

mRvPic = (RecyclerView)findViewById(R.id.rv_image);
mPicAdapter = new PicAdapter(mImageInfoList, this);
mRvPic.setLayoutManager(new LinearLayoutManager(this,LinearLayoutManager.VERTICAL,false));
mRvPic.addItemDecoration(new DividerItemDecoration(this,DividerItemDecoration.VERTICAL));
mRvPic.setAdapter(mPicAdapter);
mRvPic.setItemAnimator(new DefaultItemAnimator());

}       
</code></pre><h3 id="使用CursorLoader"><a href="#使用CursorLoader" class="headerlink" title="使用CursorLoader"></a>使用CursorLoader</h3><ul>
<li>Loader被用得最多的情况就是从ContentProvider中获取数据，如联系人列表，手机图片等等，Android提供了CursorLoader，顾名思义是对cursor和loader的封装，如果只需要得到手机中的数据，用CursorLoader来实现是非常方便的</li>
</ul>
<ul>
<li>在onCreateLoader方法中，根据不同的id调用CursorLoader的构造器得到Loader</li>
</ul>
<pre><code>@Override
public Loader&lt;Cursor&gt; onCreateLoader(int id, Bundle args) {

Log.d(TAG, &quot;onCreateLoader: &quot;);

switch (id){

    case IMAGE:
        return new CursorLoader(this, MediaStore.Images.Media.EXTERNAL_CONTENT_URI,new String[]{&quot;_id&quot;,&quot;_data&quot;},null,null,&quot;_id desc&quot;);

    case RESET_IMAGE:
        return new CursorLoader(this, MediaStore.Images.Media.EXTERNAL_CONTENT_URI,new String[]{&quot;_id&quot;,&quot;_data&quot;},null,null,&quot;_id asc&quot;);

    default:
        return null;
    }
} 
</code></pre><ul>
<li>每次数据源发生改变时就会重新获取cursor，在这个例子当中，我们在手机图库中删除一张图片然后回到这个应用时onLoadFinish就会被调用，说明我们自行处理数据源的变化</li>
</ul>
<pre><code>    @Override
    public void onLoadFinished(Loader&lt;Cursor&gt; loader, Cursor cursor) {

    switch (loader.getId()){

        case IMAGE:
        case RESET_IMAGE:

            mPicAdapter.swapCursor(cursor);
            break;

        default:
            Log.d(TAG, &quot;onLoadFinished: a Loader might be ignored&quot;);
            break;
    }
}

    @Override
    public void onLoaderReset(Loader&lt;Cursor&gt; loader) {
        mPicAdapter.swapCursor(null);
    } 
</code></pre><ul>
<li>如果我们使用的是自定义的Loader，需要如下注册观察者。如果不使用cursor的话，Loader能够帮助我们的地方不多，需要利用广播监听数据源并使用Loader的onContentChanged()方法更新数据</li>
</ul>
<pre><code>private ForceLoadContentObserver mObserver = new ForceLoadContentObserver();
...

   cursor.registerContentObserver(mObserver);
   cursor.setNotificationUri(resolver,MediaStore.Images.Media.EXTERNAL_CONTENT_URI);
</code></pre><h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><ul>
<li>首先找到我们分析的入口，我们最初调用的getLoaderManager()方法，每一个Activity或Fragment都有一个LoaderManager，LoaderManager用于同一管理不同Loader的生命周期</li>
</ul>
<ul>
<li>Activity和Fragment的getLoaderManager最终调用到Activity->FragmentController->FragmentHostCallback类的下面这个方法。所有的LoaderManager都保存在mAllLoaderManagers当中，它是一个ArrayMap，ArrayMap和SparseArray一样是官方推荐用于替代HashMap的数据结构，实际上在更早期的实现中mAllLoaderManagers用的就是HashMap。当没有获取到需要的LoaderManager时就会创建LoaderManagerImpl实例</li>
</ul>
<pre><code>LoaderManagerImpl getLoaderManager(String who, boolean started, boolean create) {
if (mAllLoaderManagers == null) {
    mAllLoaderManagers = new ArrayMap&lt;String, LoaderManager&gt;();
}
LoaderManagerImpl lm = (LoaderManagerImpl) mAllLoaderManagers.get(who);
if (lm == null) {
    if (create) {
        lm = new LoaderManagerImpl(who, this, started);
        mAllLoaderManagers.put(who, lm);
    }
} else {
    lm.updateHostController(this);
}
return lm;
}
</code></pre><ul>
<li>LoaderManagerImpl中我们可以看到initLoader方法的实现，同样是从集合中获取实例，mLoaders是一个LoaderInfo<br>类型的稀疏数组，LoaderInfo是对Loader的一层封装，它是一个非常重要的类，不仅仅包含了单独的Loader和这个Loader相关的信息，还会调用Loader和LoaderCallbacks中onLoaderFinish等回调方法，这些会在后面提到</li>
</ul>
<pre><code>@Override
@SuppressWarnings(&quot;unchecked&quot;)
public &lt;D&gt; Loader&lt;D&gt; initLoader(int id, Bundle args, LoaderManager.LoaderCallbacks&lt;D&gt; callback) {
    if (mCreatingLoader) {
        throw new IllegalStateException(&quot;Called while creating a loader&quot;);
    }

LoaderInfo info = mLoaders.get(id);

if (DEBUG) Log.v(TAG, &quot;initLoader in &quot; + this + &quot;: args=&quot; + args);

if (info == null) {
    // Loader doesn&apos;t already exist; create.
    info = createAndInstallLoader(id, args,  (LoaderManager.LoaderCallbacks&lt;Object&gt;)callback);
    if (DEBUG) Log.v(TAG, &quot;  Created new loader &quot; + info);
} else {
    if (DEBUG) Log.v(TAG, &quot;  Re-using existing loader &quot; + info);
    info.mCallbacks = (LoaderManager.LoaderCallbacks&lt;Object&gt;)callback;
}

if (info.mHaveData &amp;&amp; mStarted) {
    // If the loader has already generated its data, report it now.
    info.callOnLoadFinished(info.mLoader, info.mData);
}

return (Loader&lt;D&gt;)info.mLoader;
}
</code></pre><ul>
<li>从上面可以看出，当没有指定的LoaderInfo可以复用时就会调用createAndInstallLoader方法创建实例，再看下面，获取封装的Loader时最终会调用我们实现的onCreateLoader方法以及一个installLoader方法</li>
</ul>
<pre><code>private LoaderInfo createAndInstallLoader(int id, Bundle args,
    LoaderManager.LoaderCallbacks&lt;Object&gt; callback) {
try {
    mCreatingLoader = true;
    LoaderInfo info = createLoader(id, args, callback);
    installLoader(info);
    return info;
} finally {
    mCreatingLoader = false;
}
}

    private LoaderInfo createLoader(int id, Bundle args,
    LoaderManager.LoaderCallbacks&lt;Object&gt; callback) {
LoaderInfo info = new LoaderInfo(id, args,  callback);
Loader&lt;Object&gt; loader = callback.onCreateLoader(id, args);
info.mLoader = loader;
return info;
}
</code></pre><ul>
<li>在installLoader方法中调用了info.start方法，显然这里启动了Loader，但是根据注释我们知道，Activity的onStart方法会启动所有已存在的Loader，这里启动的只是后面创建的Loader，可能是数据源发生了变化，或者主动调用了restartLoader</li>
</ul>
<pre><code>void installLoader(LoaderInfo info) {
mLoaders.put(info.mId, info);
if (mStarted) {
    // The activity will start all existing loaders in it&apos;s onStart(),
    // so only start them here if we&apos;re past that point of the activity&apos;s
    // life cycle
    info.start();
}
}

//Activity的onStart方法最终会调用这个doStart方法
//与installLoader方法不同，doStart会启动所有未启动的Loader

void doStart() {
if (DEBUG) Log.v(TAG, &quot;Starting in &quot; + this);
if (mStarted) {
    RuntimeException e = new RuntimeException(&quot;here&quot;);
    e.fillInStackTrace();
    Log.w(TAG, &quot;Called doStart when already started: &quot; + this, e);
    return;
}

mStarted = true;

// Call out to sub classes so they can start their loaders
// Let the existing loaders know that we want to be notified when a load is complete
for (int i = mLoaders.size()-1; i &gt;= 0; i--) {
    mLoaders.valueAt(i).start();
}
}
</code></pre><ul>
<li>接着来看LoaderInfo的start方法，下面省略了一些条件判断，可以看到这里注册了两个监听器，一个用于接受加载完的数据，另一个用于接受被取消加载的Loader，注册完监听器后调用了Loader的onStartLoading方法，onStartLoading是我们实现Loader时需要实现的方法，还记得刚刚说的在onStartLoading中需要使用forceLoad方法来开始加载吗，Loader基类中这个方法调用了onForceLoad方法，而onForceLoad是一个空实现，所以接下来就要到子类AsyncTaskLoader登场了</li>
</ul>
<pre><code>        void start() {

...

    mStarted = true;

    if (DEBUG) Log.v(TAG, &quot;  Starting: &quot; + this);
    if (mLoader == null &amp;&amp; mCallbacks != null) {
       mLoader = mCallbacks.onCreateLoader(mId, mArgs);
    }

    if (mLoader != null) {

...

        if (!mListenerRegistered) {
            mLoader.registerListener(mId, this);
            mLoader.registerOnLoadCanceledListener(this);
            mListenerRegistered = true;
        }
        mLoader.startLoading();
    }
}

    public interface OnLoadCompleteListener&lt;D&gt; {
/**
 * Called on the thread that created the Loader when the load is complete.
 *
 * @param loader the loader that completed the load
 * @param data the result of the load
 */
public void onLoadComplete(Loader&lt;D&gt; loader, D data);
}

    public interface OnLoadCanceledListener&lt;D&gt; {
/**
 * Called on the thread that created the Loader when the load is canceled.
 *
 * @param loader the loader that canceled the load
 */
public void onLoadCanceled(Loader&lt;D&gt; loader);
}
</code></pre><ul>
<li>AsyncTaskLoader是对AsyncTask的抽象封装，包含一个AsyncTask内部类，这个AsyncTask同时也是一个Runnable，在onForceLoad方法中调用了executePendingTask方法，executePendingTask中需要关心的只有executeOnExecutor这个步骤，这是AsyncTask新增的接口，允许开发者提供线程池并行的处理Task，而我们用的比较多的Excute方法是串行的</li>
</ul>
<pre><code>@Override
protected void onForceLoad() {
    super.onForceLoad();
    cancelLoad();
    mTask = new LoadTask();
    if (DEBUG) Log.v(TAG, &quot;Preparing load: mTask=&quot; + mTask);
    executePendingTask();
}

void executePendingTask() {
    ...
    mTask.executeOnExecutor(mExecutor, (Void[]) null);
    }
}
</code></pre><ul>
<li>既然是AsyncTask，那么就先来看doInBackground，这里一大串注释想表达的是任务被LoaderManger以外的对象取消时需要抛出异常，毕竟所有Task应该由LoaderManager来管理，故手动调用AsyncTask的cancel方法是不应该的，正常情况下这里会调用我们实现的onLoadInBackground方法来获取数据</li>
</ul>
<pre><code>final class LoadTask extends AsyncTask&lt;Void, Void, D&gt; implements Runnable {
private final CountDownLatch mDone = new CountDownLatch(1);

// Set to true to indicate that the task has been posted to a handler for
// execution at a later time.  Used to throttle updates.
boolean waiting;

/* Runs on a worker thread */
@Override
protected D doInBackground(Void... params) {
    if (DEBUG) Log.v(TAG, this + &quot; &gt;&gt;&gt; doInBackground&quot;);
    try {
        D data = AsyncTaskLoader.this.onLoadInBackground();
        if (DEBUG) Log.v(TAG, this + &quot;  &lt;&lt;&lt; doInBackground&quot;);
        return data;
    } catch (OperationCanceledException ex) {
        if (!isCancelled()) {
            // onLoadInBackground threw a canceled exception spuriously.
            // This is problematic because it means that the LoaderManager did not
            // cancel the Loader itself and still expects to receive a result.
            // Additionally, the Loader&apos;s own state will not have been updated to
            // reflect the fact that the task was being canceled.
            // So we treat this case as an unhandled exception.
            throw ex;
        }
        if (DEBUG) Log.v(TAG, this + &quot;  &lt;&lt;&lt; doInBackground (was canceled)&quot;, ex);
        return null;
    }
}

    protected D onLoadInBackground() {
return loadInBackground();
}
</code></pre><ul>
<li>在onPostExecute我们进入到了数据的分发阶段，如果任务没有被取消，那么调用deliverResult方法获取数据，通常我们可以重写这个方法来实现数据缓存，而deliverResult调用了OnLoadCompleteListener.onLoadComplete方法，这个监听器就是我们先前提到的LoaderInfo实现的接口</li>
</ul>
<pre><code>    /* Runs on the UI thread */
    @Override
    protected void onPostExecute(D data) {
        if (DEBUG) Log.v(TAG, this + &quot; onPostExecute&quot;);
        try {
            AsyncTaskLoader.this.dispatchOnLoadComplete(this, data);
        } finally {
            mDone.countDown();
        }
    }

        void dispatchOnLoadComplete(LoadTask task, D data) {
    if (mTask != task) {
        if (DEBUG) Log.v(TAG, &quot;Load complete of old task, trying to cancel&quot;);
        dispatchOnCancelled(task, data);
    } else {
        if (isAbandoned()) {
            // This cursor has been abandoned; just cancel the new data.
            onCanceled(data);
        } else {
            commitContentChanged();
            mLastLoadCompleteTime = SystemClock.uptimeMillis();
            mTask = null;
            if (DEBUG) Log.v(TAG, &quot;Delivering result&quot;);
            deliverResult(data);
        }
    }
}
    public void deliverResult(D data) {
    if (mListener != null) {
        mListener.onLoadComplete(this, data);
    }
}
</code></pre><ul>
<li>onLoadComplete主要有三个步骤</li>
</ul>
<ul>
<li>一，处理新请求：当我们调用restartLoader方法时，为了避免启动过多的Task或是新Task的数据被旧的Task返回的数据覆盖，这里采用的做法是让LoaderInfo持有一个mPendingLoader，在旧的Loader执行完后让这个mPendingLoader启动</li>
</ul>
<pre><code>...
    LoaderInfo pending = mPendingLoader;
    if (pending != null) {
        // There is a new request pending and we were just
        // waiting for the old one to complete before starting
        // it.  So now it is time, switch over to the new loader.
        if (DEBUG) Log.v(TAG, &quot;  Switching to pending loader: &quot; + pending);
        mPendingLoader = null;
        mLoaders.put(mId, null);
        destroy();
        installLoader(pending);
        return;
    }
</code></pre><ul>
<li>二，当没有等待的请求，调用callOnLoadFinished，这个方法会调用到我们实现的onLoadFinished，这样就可以更新UI了</li>
</ul>
<pre><code>// Notify of the new data so the app can switch out the old data before
// we try to destroy it.
if (mData != data || !mHaveData) {
    mData = data;
    mHaveData = true;
    if (mStarted) {
        callOnLoadFinished(loader, data);
    }
}
</code></pre><ul>
<li>三，restartLoader时会把旧Loader放入mInactiveLoaders当中，现在可以清除旧的Loader了</li>
</ul>
<pre><code>    //if (DEBUG) Log.v(TAG, &quot;  onLoadFinished returned: &quot; + this);

    // We have now given the application the new loader with its
    // loaded data, so it should have stopped using the previous
    // loader.  If there is a previous loader on the inactive list,
    // clean it up.
    LoaderInfo info = mInactiveLoaders.get(mId);
    if (info != null &amp;&amp; info != this) {
        info.mDeliveredData = false;
        info.destroy();
        mInactiveLoaders.remove(mId);
    }

    if (mHost != null &amp;&amp; !hasRunningLoaders()) {
        mHost.mFragmentManager.startPendingDeferredFragments();
    }
}
</code></pre><ul>
<li>到目前为止我们从获取LoaderManager，启动Loader，数据传递都已经分析完了，但是还有很关键的一点，就是监听数据源，自动启动任务。在Loader基类中我们可以找到这个内部类</li>
</ul>
<pre><code>/**
* An implementation of a ContentObserver that takes care of connecting
* it to the Loader to have the loader re-load its data when the observer
* is told it has changed.  You do not normally need to use this yourself;
* it is used for you by {@link CursorLoader} to take care of executing
* an update when the cursor&apos;s backing data changes.
*/
    public final class ForceLoadContentObserver extends ContentObserver {

    public ForceLoadContentObserver() {
    super(new Handler());
    }

    @Override
    public boolean deliverSelfNotifications() {
    return true;
    }

    @Override
    public void onChange(boolean selfChange) {
    onContentChanged();
    }
}

public void onContentChanged() {
if (mStarted) {
    forceLoad();
} else {
    // This loader has been stopped, so we don&apos;t want to load
    // new data right now...  but keep track of it changing to
    // refresh later if we start again.
    mContentChanged = true;
}
}
</code></pre><ul>
<li>在CursorLoader的实现中loadInBackground方法为cursor注册了观察者当数据发送变化时ContentResolver会调用观察者的onChange方法，而onChange会onContentChanged方法最终重新加载数据，至于ContentResolver如何实现监听则涉及较多系统层的问题，有兴趣可以看<a href="http://www.cnblogs.com/bastard/archive/2012/06/02/2531663.html" target="_blank" rel="external">这篇文章</a>，这里就不再深入地谈四大组件方面的内容了</li>
</ul>
<pre><code>    @Override
public Cursor loadInBackground() {
synchronized (this) {
    if (isLoadInBackgroundCanceled()) {
        throw new OperationCanceledException();
    }
    mCancellationSignal = new CancellationSignal();
}
try {
    Cursor cursor = ContentResolverCompat.query(getContext().getContentResolver(),
            mUri, mProjection, mSelection, mSelectionArgs, mSortOrder,
            mCancellationSignal);
    if (cursor != null) {
        try {
            // Ensure the cursor window is filled.
            cursor.getCount();
            cursor.registerContentObserver(mObserver);
        } catch (RuntimeException ex) {
            cursor.close();
            throw ex;
        }
    }
    return cursor;
} finally {
    synchronized (this) {
        mCancellationSignal = null;
    }
}
}
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Volley 事件派发机制]]></title>
      <url>/2017/08/09/VolleyDispatcher/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<ul>
<li>之前大致浏<a href="https://alberthumbert.github.io/2017/07/19/aboutVolley/">览过</a>一遍Volley的源码，对事件派发的部分有不少缺漏，下面进行补充</li>
</ul>
<h2 id="请求容器"><a href="#请求容器" class="headerlink" title="请求容器"></a>请求容器</h2><ul>
<li>我们知道，Volley将所有请求都存放在RequestQueue当中，虽然叫做Queue但实际上RequestQueue并不是collection类，Volley暂存请求的容器有四个，mCacheQueue 用于存放可以访问缓存的请求，mNetworkQueue用于存放需要访问网络的请求，mWaitingRequests用于存放等待的处理的请求，mCurrentRequests用于存放正在处理的请求，之前对mWaitingRequests的存在意义不是很理解，后来发现它的设计还是很巧妙的，下面会进行详细的分析</li>
</ul>
<pre><code>private final Map&lt;String, Queue&lt;Request&lt;?&gt;&gt;&gt; mWaitingRequests =
    new HashMap&lt;String, Queue&lt;Request&lt;?&gt;&gt;&gt;();

    private final Set&lt;Request&lt;?&gt;&gt; mCurrentRequests = new HashSet&lt;Request&lt;?&gt;&gt;();            

    private final PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mCacheQueue =
new PriorityBlockingQueue&lt;Request&lt;?&gt;&gt;();

    private final PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mNetworkQueue =
new PriorityBlockingQueue&lt;Request&lt;?&gt;&gt;();
</code></pre><ul>
<li>来看RequestQueue的add方法，首先是调用request的setRequestQueue将请求与RequestQueue绑定。然后将请求放入mCurrentRequests，正在处理的请求的容器当中，mCurrentRequests是一个HashSet，线程不安全，所以使用了锁</li>
</ul>
<pre><code>public &lt;T&gt; Request&lt;T&gt; add(Request&lt;T&gt; request) {
    // Tag the request as belonging to this queue and add it to the set of current requests.
    request.setRequestQueue(this);
    synchronized (mCurrentRequests) {
        mCurrentRequests.add(request);
    }

    // Process requests in the order they are added.
    request.setSequence(getSequenceNumber());
    request.addMarker(&quot;add-to-queue&quot;);
</code></pre><ul>
<li>如果请求不能缓存，直接放入mNetworkQueue网络队列</li>
</ul>
<pre><code>// If the request is uncacheable, skip the cache queue and go straight to the network.
if (!request.shouldCache()) {
    mNetworkQueue.add(request);
    return request;
}
</code></pre><ul>
<li>接着对mWaitingRequests的操作是关键，我们先看看文档中对mWaitingRequests的描述。mWaitingRequests是一个HashMap，这个HashMap的每个value值都是一个队列，每个队列当中都是相同的请求，这是因为mWaitingRequests是专门用于存放重复的请求的<pre><code>/**
* Staging area for requests that already have a duplicate request in flight.
*
* &lt;ul&gt;
*     &lt;li&gt;containsKey(cacheKey) indicates that there is a request in flight for the given cache
*          key.&lt;/li&gt;
*     &lt;li&gt;get(cacheKey) returns waiting requests for the given cache key. The in flight request
*          is &lt;em&gt;not&lt;/em&gt; contained in that list. Is null if no requests are staged.&lt;/li&gt;
* &lt;/ul&gt;
*/
    private final Map&lt;String, Queue&lt;Request&lt;?&gt;&gt;&gt; mWaitingRequests =
    new HashMap&lt;String, Queue&lt;Request&lt;?&gt;&gt;&gt;();
</code></pre></li>
</ul>
<ul>
<li>继续看add方法，HashMap线程不安全所以也开启了锁，我们发现这里检查mWaitingRequests中是否存在给定的key，如果存在则说明先前已有相同的请求被提交了，但是最初已被提交的请求并不会创建队列，而是放入一个null值，当下一个相同的请求到来，发现Map中有了这个Key值，才会创建队列并且将请求放进队列之后就暂时再不处理，Volley就是利用这种方法避免请求被重复执行的</li>
</ul>
<pre><code>    // Insert request into stage if there&apos;s already a request with the same cache key in flight.
    synchronized (mWaitingRequests) {
        String cacheKey = request.getCacheKey();
        if (mWaitingRequests.containsKey(cacheKey)) {
            // There is already a request in flight. Queue up.
            Queue&lt;Request&lt;?&gt;&gt; stagedRequests = mWaitingRequests.get(cacheKey);
            if (stagedRequests == null) {
                stagedRequests = new LinkedList&lt;Request&lt;?&gt;&gt;();
            }
            stagedRequests.add(request);
            mWaitingRequests.put(cacheKey, stagedRequests);
            if (VolleyLog.DEBUG) {
                VolleyLog.v(&quot;Request for cacheKey=%s is in flight, putting on hold.&quot;, cacheKey);
            }
        } else {
            // Insert &apos;null&apos; queue for this cacheKey, indicating there is now a request in
            // flight.
            mWaitingRequests.put(cacheKey, null);
            mCacheQueue.add(request);
        }
        return request;
    }
}
</code></pre><ul>
<li>进过一段时间，当一个Request被处理完毕时，它的finish方法会被执行，之前Volley将Request与RequestQueue进行了绑定，在这里回调RequestQueue的finish()方法并传入自身</li>
</ul>
<pre><code> void finish(final String tag) {
if (mRequestQueue != null) {
    mRequestQueue.finish(this);
    onFinish();
}
if (MarkerLog.ENABLED) {
    final long threadId = Thread.currentThread().getId();
    if (Looper.myLooper() != Looper.getMainLooper()) {
        // If we finish marking off of the main thread, we need to
        // actually do it on the main thread to ensure correct ordering.
        Handler mainThread = new Handler(Looper.getMainLooper());
        mainThread.post(new Runnable() {
            @Override
            public void run() {
                mEventLog.add(tag, threadId);
                mEventLog.finish(this.toString());
            }
        });
        return;
    }

    mEventLog.add(tag, threadId);
    mEventLog.finish(this.toString());
    }
}    
</code></pre><ul>
<li>下面来看RequestQueue的finish方法，一开始在mCurrentRequests移除了Request，这里比较好理解，接着在等待队列waitingRequests中取出了所有相同的请求，并把这些请求全部加入到mCacheQueue当中，这样做是因为刚刚只是把这些相同的Request放入waitingRequests而没有去处理，现在最初的Request对象被处理完毕了，所有与它相同的请求都可以保证能从缓存中拿到结果了，故将其加入到缓存队列当中。通过这个机制，相同的请求同时进入到RequestQueue中时，只会从网络获取一次（假设Response不需要更新），很好地节约了时间</li>
</ul>
<pre><code>    /**
    * Called from {@link Request#finish(String)}, indicating that processing of the given request
    * has finished.
    *
    * &lt;p&gt;Releases waiting requests for &lt;code&gt;request.getCacheKey()&lt;/code&gt; if
    *      &lt;code&gt;request.shouldCache()&lt;/code&gt;.&lt;/p&gt;
    */
    &lt;T&gt; void finish(Request&lt;T&gt; request) {
// Remove from the set of requests currently being processed.
synchronized (mCurrentRequests) {
    mCurrentRequests.remove(request);
}
synchronized (mFinishedListeners) {
  for (RequestFinishedListener&lt;T&gt; listener : mFinishedListeners) {
    listener.onRequestFinished(request);
    }
    }

if (request.shouldCache()) {
    synchronized (mWaitingRequests) {
        String cacheKey = request.getCacheKey();
        Queue&lt;Request&lt;?&gt;&gt; waitingRequests = mWaitingRequests.remove(cacheKey);
        if (waitingRequests != null) {
            if (VolleyLog.DEBUG) {
                VolleyLog.v(&quot;Releasing %d waiting requests for cacheKey=%s.&quot;,
                        waitingRequests.size(), cacheKey);
            }
            // Process all queued up requests. They won&apos;t be considered as in flight, but
            // that&apos;s not a problem as the cache has been primed by &apos;request&apos;.
            mCacheQueue.addAll(waitingRequests);
        }
    }
}
} 
</code></pre><h2 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h2><ul>
<li>再来看start方法，这里开启了处理和分发请求的线程，网上普遍说这里处理网络请求的线程<strong>默认</strong>是四个，但实际上由于外部调用RequestQueue的构造方法没有意义，所以定死了就是四个</li>
</ul>
<pre><code>    public void start() {
    stop();  // Make sure any currently running dispatchers are stopped.
    // Create the cache dispatcher and start it.
    mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);
    mCacheDispatcher.start();

    // Create network dispatchers (and corresponding threads) up to the pool size.
    for (int i = 0; i &lt; mDispatchers.length; i++) {
        NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork,
                mCache, mDelivery);
        mDispatchers[i] = networkDispatcher;
        networkDispatcher.start();
    }
}

    ...

    RequestQueue queue;
    if (maxDiskCacheBytes &lt;= -1)
            {
        // No maximum size specified
        queue = new RequestQueue(new DiskBasedCache(cacheDir), network);
    }
    else
        {
            // Disk cache size specified
            queue = new RequestQueue(new DiskBasedCache(cacheDir, maxDiskCacheBytes), network);
        }

    ...

    public RequestQueue(Cache cache, Network network) {
            this(cache, network, DEFAULT_NETWORK_THREAD_POOL_SIZE);
        }

    ...

    public RequestQueue(Cache cache, Network network, int threadPoolSize,
        ResponseDelivery delivery) {
    mCache = cache;
    mNetwork = network;
    mDispatchers = new NetworkDispatcher[threadPoolSize];
    mDelivery = delivery;
    }

    ...
</code></pre><ul>
<li>我们来看处理缓存请求的CacheDispatcher线程的run方法，具体的分析写在注释里</li>
</ul>
<pre><code>    @Override
    public void run() {
if (DEBUG) VolleyLog.v(&quot;start new dispatcher&quot;);
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);

// Make a blocking call to initialize the cache.
mCache.initialize();
//初始化缓存

Request&lt;?&gt; request;
while (true) {
//开启一个死循环处理请求
    // release previous request object to avoid leaking request object when mQueue is drained.
    request = null;
    try {
        // Take a request from the queue.
        request = mCacheQueue.take();
        //重置请求，BlockingQueue的take()方法会阻塞线程直到有一个元素被拿出为止

    } catch (InterruptedException e) {
        // We may have been interrupted because it was time to quit.
        if (mQuit) {
            return;
            //当关闭线程时会在这里抛出异常，检查是否需要停止
        }
        continue;
    }
    try {
        request.addMarker(&quot;cache-queue-take&quot;);

        // If the request has been canceled, don&apos;t bother dispatching it.
        if (request.isCanceled()) {
            request.finish(&quot;cache-discard-canceled&quot;);
            continue;
            //如果请求被取消，直接放过
        }

        // Attempt to retrieve this item from cache.
        Cache.Entry entry = mCache.get(request.getCacheKey());
        if (entry == null) {
            request.addMarker(&quot;cache-miss&quot;);
            // Cache miss; send off to the network dispatcher.
            mNetworkQueue.put(request);
            //拿不到缓存，放入网络队列
            continue;
        }

        // If it is completely expired, just send it to the network.
        if (entry.isExpired()) {
            request.addMarker(&quot;cache-hit-expired&quot;);
            request.setCacheEntry(entry);
            mNetworkQueue.put(request);
            //请求过期，也放入网络队列
            continue;
        }

        // We have a cache hit; parse its data for delivery back to the request.
        request.addMarker(&quot;cache-hit&quot;);
        Response&lt;?&gt; response = request.parseNetworkResponse(
                new NetworkResponse(entry.data, entry.responseHeaders));
        request.addMarker(&quot;cache-hit-parsed&quot;);

        if (!entry.refreshNeeded()) {
            // Completely unexpired cache hit. Just deliver the response.
            mDelivery.postResponse(request, response);
            //从缓存中拿到了结果，如果不需要更新内容，则直接投递结果
        } else {
            // Soft-expired cache hit. We can deliver the cached response,
            // but we need to also send the request to the network for
            // refreshing.
            request.addMarker(&quot;cache-hit-refresh-needed&quot;);
            request.setCacheEntry(entry);

            // Mark the response as intermediate.
            response.intermediate = true;

            // Post the intermediate response back to the user and have
            // the delivery then forward the request along to the network.
            final Request&lt;?&gt; finalRequest = request;

           //如果内容需要更新，也同样会投递结果，不同的是之后这里的run方法会执行，进行更新
            mDelivery.postResponse(request, response, new Runnable() {
                @Override
                public void run() {
                    try {
                        mNetworkQueue.put(finalRequest);
                    } catch (InterruptedException e) {
                        // Not much we can do about this.
                    }
                }
            });
        }
    } catch (Exception e) {
        VolleyLog.e(e, &quot;Unhandled exception %s&quot;, e.toString());
            }
        }
    }
}
</code></pre><ul>
<li>接着再看NetworkDispatcher的run方法，逻辑是差不多的</li>
</ul>
<pre><code>@Override
    public void run() {
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
Request&lt;?&gt; request;
while (true) {
//开启死循环处理请求
    long startTimeMs = SystemClock.elapsedRealtime();
    // release previous request object to avoid leaking request object when mQueue is drained.
    request = null;
    try {
        // Take a request from the queue.
        request = mQueue.take();
        //阻塞直到获得对象
    } catch (InterruptedException e) {
        // We may have been interrupted because it was time to quit.
        if (mQuit) {
            return;
        }
        continue;
    }

    try {
        request.addMarker(&quot;network-queue-take&quot;);

        // If the request was cancelled already, do not perform the
        // network request.
        if (request.isCanceled()) {
            request.finish(&quot;network-discard-cancelled&quot;);
            continue;
        }

        addTrafficStatsTag(request);

        // Perform the network request.
        NetworkResponse networkResponse = mNetwork.performRequest(request);
        //从网络获取Response
        request.addMarker(&quot;network-http-complete&quot;);

        // If the server returned 304 AND we delivered a response already,
        // we&apos;re done -- don&apos;t deliver a second identical response.
        if (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) {
            request.finish(&quot;not-modified&quot;);
            continue;
        }

        // Parse the response here on the worker thread.
        Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse);
        request.addMarker(&quot;network-parse-complete&quot;);

        // Write to cache if applicable.
        // TODO: Only update cache metadata instead of entire record for 304s.
        if (request.shouldCache() &amp;&amp; response.cacheEntry != null) {
            mCache.put(request.getCacheKey(), response.cacheEntry);
            //将结果放入缓存
            request.addMarker(&quot;network-cache-written&quot;);
        }

        // Post the response back.
        request.markDelivered();
        mDelivery.postResponse(request, response);
        //投递结果
    } catch (VolleyError volleyError) {
        volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);
        parseAndDeliverNetworkError(request, volleyError);
    } catch (Exception e) {
        VolleyLog.e(e, &quot;Unhandled exception %s&quot;, e.toString());
        VolleyError volleyError = new VolleyError(e);
        volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);
        mDelivery.postError(request, volleyError);
    }
}
} 
</code></pre><h2 id="ExecutorDelivery"><a href="#ExecutorDelivery" class="headerlink" title="ExecutorDelivery"></a>ExecutorDelivery</h2><ul>
<li>mDelivery是真正用于投递结果的对象，是ExecutorDelivery的实例，持有一个主线程的handler</li>
</ul>
<pre><code>    public RequestQueue(Cache cache, Network network, int threadPoolSize) {
this(cache, network, threadPoolSize,
        new ExecutorDelivery(new Handler(Looper.getMainLooper())));
    }

    public ExecutorDelivery(final Handler handler) {                // Make an Executor that just wraps the handler.
    mResponsePoster = new Executor() {
        @Override
        public void execute(Runnable command) {
            handler.post(command);
        }
    };
}
</code></pre><ul>
<li>ExecutorDelivery内部有一个实现了Runnable接口的类，它用于将请求结构返回给我们实现的监听器，这样我们就能接收到数据了，注意这里还调用到了Request的finish方法，这之后就回到刚刚讲到的RequestQueue的finish方法了</li>
</ul>
<pre><code>        /**
        * A Runnable used for delivering network responses to a listener on the
        * main thread.
        */
        @SuppressWarnings(&quot;rawtypes&quot;)
        private class ResponseDeliveryRunnable implements Runnable {
            private final Request mRequest;
            private final Response mResponse;
            private final Runnable mRunnable;

    public ResponseDeliveryRunnable(Request request, Response response, Runnable runnable) {
        mRequest = request;
        mResponse = response;
        mRunnable = runnable;
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public void run() {
        // If this request has canceled, finish it and don&apos;t deliver.
        if (mRequest.isCanceled()) {
            mRequest.finish(&quot;canceled-at-delivery&quot;);
            return;
        }

        // Deliver a normal response or error, depending.
        if (mResponse.isSuccess()) {
            mRequest.deliverResponse(mResponse.result);
        } else {
            mRequest.deliverError(mResponse.error);
        }

        // If this is an intermediate response, add a marker, otherwise we&apos;re done
        // and the request can be finished.
        if (mResponse.intermediate) {
            mRequest.addMarker(&quot;intermediate-response&quot;);
        } else {
            mRequest.finish(&quot;done&quot;);
        }

        // If we have been provided a post-delivery runnable, run it.
        if (mRunnable != null) {
            mRunnable.run();
        }
   }
}
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Picasso 源码分析]]></title>
      <url>/2017/08/08/Picasso/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<ul>
<li>使用<a href="https://github.com/square/picasso" target="_blank" rel="external">Picasso</a>主要包括四步，创建单例（with / Builder），传入链接（load），配置属性（centerCrop，resize … ），加载图片（into），下面就大致按照这个顺序来解析Picasso的源码</li>
</ul>
<pre><code>Picasso.with(context)
        .load(uri)
        .centerCrop()
        .into(imageView);
</code></pre><h2 id="with"><a href="#with" class="headerlink" title="with"></a>with</h2><ul>
<li>with方法是一种全部使用内部默认组件进行初始化的方法，所以并不会很复杂，这里主要用到了单例模式，通过Builder对象创建Picasso的单例，注意这里的Builder对象在创建出来之后直接调用了build()方法，其实相当于没有使用到建造者模式</li>
</ul>
<pre><code>public static Picasso with(Context context) {
    if (singleton == null) {
    synchronized (Picasso.class) {
        if (singleton == null) {
        singleton = new Builder(context).build();
        }
    }
    }
    return singleton;
}
</code></pre><ul>
<li>再来看build()方法，这里包含了Picasso中几个至关重要的成员的初始化，Downloader、Cache、ExecutorService、RequestTransformer、Stats和Dispatcher</li>
</ul>
<pre><code>    public Picasso build() {
    Context context = this.context;

    if (downloader == null) {
        downloader = Utils.createDefaultDownloader(context);
    }
    if (cache == null) {
        cache = new LruCache(context);
    }
    if (service == null) {
        service = new PicassoExecutorService();
    }
    if (transformer == null) {
        transformer = RequestTransformer.IDENTITY;
    }

    Stats stats = new Stats(cache);

    Dispatcher dispatcher = new Dispatcher(context, service, HANDLER, downloader, cache, stats);

    return new Picasso(context, dispatcher, cache, listener, transformer, requestHandlers, stats,
        defaultBitmapConfig, indicatorsEnabled, loggingEnabled);
    }
} 
</code></pre><ul>
<li>默认的downloader使用的是OkHttpClient或者UrlConnection，一般情况下会是OkHttpClient，它们是用于处理图片的网络请求工具类，如有需要我们可以进行自定义，只需实现Downloader接口即可，但一般没有这个必要</li>
</ul>
<pre><code>static Downloader createDefaultDownloader(Context context) {
    try {
    Class.forName(&quot;com.squareup.okhttp.OkHttpClient&quot;);
    //如果加载类时抛出异常，将使用UrlConnectionDownloader
    return OkHttpLoaderCreator.create(context);
    } catch (ClassNotFoundException ignored) {
    }
    return new UrlConnectionDownloader(context);
}

...
public class OkHttpDownloader implements Downloader {
private static OkHttpClient defaultOkHttpClient() {
    OkHttpClient client = new OkHttpClient();
    client.setConnectTimeout(Utils.DEFAULT_CONNECT_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
    client.setReadTimeout(Utils.DEFAULT_READ_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
    client.setWriteTimeout(Utils.DEFAULT_WRITE_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
    return client;
} 

...
public class UrlConnectionDownloader implements Downloader {
static final String RESPONSE_SOURCE = &quot;X-Android-Response-Source&quot;;
static volatile Object cache;

private static final Object lock = new Object();
private static final String FORCE_CACHE = &quot;only-if-cached,max-age=2147483647&quot;;
private static final ThreadLocal&lt;StringBuilder&gt; CACHE_HEADER_BUILDER =
new ThreadLocal&lt;StringBuilder&gt;() {
        @Override protected StringBuilder initialValue() {
        return new StringBuilder();
        }
    };

private final Context context;

public UrlConnectionDownloader(Context context) {
    this.context = context.getApplicationContext();
}       
</code></pre><ul>
<li>cache，默认LruCache，没什么好讲的，一般自定义也是封装LruCache</li>
</ul>
<ul>
<li>service，Picasso使用ThreadPoolExecutor配置的线程池，内部根据手机使用的通信标准进行了优化，核心线程数与最大线程数一致，根据网络条件优劣(wifi,4g,3g,2g)进行配置</li>
</ul>
<pre><code>private void setThreadCount(int threadCount) {
    setCorePoolSize(threadCount);
    setMaximumPoolSize(threadCount);
}
</code></pre><ul>
<li>PicassoExecutorService维护一个优先级队列，质量高的图片优先加载，质量相同的图片先进先出</li>
</ul>
<pre><code>public enum Priority {
      LOW,
      NORMAL,
      HIGH
  }

 @Override
  public int compareTo(PicassoFutureTask other) {
  Picasso.Priority p1 = hunter.getPriority();
  Picasso.Priority p2 = other.hunter.getPriority();

  // High-priority requests are &quot;lesser&quot; so they are sorted to the front.
  // Equal priorities are sorted by sequence number to provide FIFO ordering.
  return (p1 == p2 ? hunter.sequence - other.hunter.sequence : p2.ordinal() - p1.ordinal());
  }
</code></pre><ul>
<li>RequestTransformer，对Request进行转换的接口，内部提供一个空实现，一般也不做处理</li>
</ul>
<pre><code>public interface RequestTransformer {

    Request transformRequest(Request request);

    RequestTransformer IDENTITY = new RequestTransformer() {
    @Override public Request transformRequest(Request request) {
        return request;
    }
    };
}
</code></pre><ul>
<li>stats，记录图片状态，dispatcher，用于分发任务，之后会详细分析</li>
</ul>
<ul>
<li>使用Builder可以进行一些自定义配置，注意不要漏了设置单例</li>
</ul>
<pre><code>Picasso picasso = new Picasso.Builder(this)  
        .downloader(...) 
        .addRequestHandler(...)
        .build();  
        Picasso.setSingletonInstance(picasso);  
</code></pre><h2 id="load"><a href="#load" class="headerlink" title="load"></a>load</h2><ul>
<li>load用于传入的链接并创建RequestCreator对象，提供四个重载，但最终都将参数转换为uri处理，RequestCreator实际上也是一个builder模式</li>
</ul>
<pre><code>  public RequestCreator load(Uri uri) {
    return new RequestCreator(this, uri, 0);
}

  public RequestCreator load(String path) {
    if (path == null) {
    return new RequestCreator(this, null, 0);
    }
    if (path.trim().length() == 0) {
    throw new IllegalArgumentException(&quot;Path must not be empty.&quot;);
    }
    return load(Uri.parse(path));
}

  public RequestCreator load(File file) {
    if (file == null) {
    return new RequestCreator(this, null, 0);
    }
    return load(Uri.fromFile(file));
}

  public RequestCreator load(int resourceId) {
    if (resourceId == 0) {
    throw new IllegalArgumentException(&quot;Resource ID must not be zero.&quot;);
    }
    return new RequestCreator(this, null, resourceId);
}
</code></pre><ul>
<li>通过RequestCreator，我们可以对加载的图片进行一些设定，传入的参数一般保留在RequestCreator的成员变量data当中</li>
</ul>
<pre><code>public RequestCreator resize(int targetWidth, int targetHeight) {
    data.resize(targetWidth, targetHeight);
    return this;
}

public RequestCreator centerCrop() {
    data.centerCrop();
    return this;
}

    public RequestCreator rotate(float degrees) {
    data.rotate(degrees);
    return this;
}
</code></pre><h2 id="into"><a href="#into" class="headerlink" title="into"></a>into</h2><ul>
<li>into是真正加载图片的方法，这个方法中首先对刚刚传入的参数进行检查和应用，这部分不是重点</li>
</ul>
<pre><code>if (!data.hasImage()) { 
...
}

if (data.hasSize()) {
...
}

if (setPlaceholder) {
...
}
</code></pre><ul>
<li>在这之后会判断是否从内存缓存读取图片，拿到图片则关闭请求设置图片，拿不到再去加载图片</li>
</ul>
<pre><code>if (shouldReadFromMemoryCache(memoryPolicy)) {
    Bitmap bitmap = picasso.quickMemoryCacheCheck(requestKey);
    //从缓存中读取
    if (bitmap != null) {
        picasso.cancelRequest(target);
        //关闭请求
        setBitmap(target, picasso.context, bitmap, MEMORY, noFade, picasso.indicatorsEnabled);
        //设置图片
        if (picasso.loggingEnabled) {
            log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), &quot;from &quot; + MEMORY);
        //如果需要，将图片信息用log打出    
        }
        if (callback != null) {
        callback.onSuccess();
        //加载图片的监听器
        }
        return;
    }
    }

    //如果拿不到图片，则从本地或网络加载
    if (setPlaceholder) {
    setPlaceholder(target, getPlaceholderDrawable());
    //如果需要，设置占位图
    }

    Action action =
new ImageViewAction(picasso, target, request, memoryPolicy, networkPolicy, errorResId,
    errorDrawable, requestKey, tag, callback, noFade);
    //创建action对象
    picasso.enqueueAndSubmit(action);
    //投递action对象
}
</code></pre><ul>
<li>可以看到action对象几乎包含了图片的所有信息，这之后action会交由Dispatcher的dispatchSubmit方法处理，这个handler来自于HandlerThread</li>
</ul>
<pre><code>this.dispatcherThread = new DispatcherThread();  
this.handler = new DispatcherHandler(dispatcherThread.getLooper(), this);

static class DispatcherThread extends HandlerThread {
    DispatcherThread() {
    super(Utils.THREAD_PREFIX + DISPATCHER_THREAD_NAME, THREAD_PRIORITY_BACKGROUND);
    }
}

void dispatchSubmit(Action action) {
            handler.sendMessage(handler.obtainMessage(REQUEST_S     UBMIT, action));
        }
</code></pre><ul>
<li><p>如无意外现在action对象会在Dispatcher对象的performSubmit方法中被处理，</p>
<pre><code>@Override public void handleMessage(final Message msg) {
switch (msg.what) {
    case REQUEST_SUBMIT: {
    Action action = (Action) msg.obj;
    dispatcher.performSubmit(action);
    break;
    } 

... 
</code></pre></li>
</ul>
<h2 id="BitmapHunter"><a href="#BitmapHunter" class="headerlink" title="BitmapHunter"></a>BitmapHunter</h2><ul>
<li>BitmaHunter是一个Runnable对象，内部最多可持有三个Action对象</li>
</ul>
<ul>
<li>performSubmit的主要步骤是，判断请求是否被停止，判断Action是否已分配BitmapHunter，判断线程池是否被关闭，以上三个条件只要一个成立都会直接返回，如果都不成立则创建BitmapHunter，投递BimapHunter给线程池</li>
</ul>
<pre><code>    void performSubmit(Action action, boolean dismissFailed) {
        if (pausedTags.contains(action.getTag())) {
        pausedActions.put(action.getTarget(), action);
        if (action.getPicasso().loggingEnabled) {
            log(OWNER_DISPATCHER, VERB_PAUSED, action.request.logId(),
        &quot;because tag &apos;&quot; + action.getTag() + &quot;&apos; is paused&quot;);
        }
        return;
        }

        BitmapHunter hunter = hunterMap.get(action.getKey());
        if (hunter != null) {
        hunter.attach(action);
        return;
        }

        if (service.isShutdown()) {
        if (action.getPicasso().loggingEnabled) {
            log(OWNER_DISPATCHER, VERB_IGNORED, action.request.logId(), &quot;because shut down&quot;);
        }
        return;
        }

        hunter = forRequest(action.getPicasso(), this, cache, stats, action);
        hunter.future = service.submit(hunter);
        hunterMap.put(action.getKey(), hunter);
        if (dismissFailed) {
        failedActions.remove(action.getTarget());
        }

        if (action.getPicasso().loggingEnabled) {
        log(OWNER_DISPATCHER, VERB_ENQUEUED, action.request.logId());
        }
}
</code></pre><ul>
<li>创建BitmapHunter中使用到了责任链模式，在Picasso的构造函数中，初始化了一条责任链，这是一条不可变的RequestHandler的ArrayList，RequestHandler对象在BitmapHunter中用于获取Bitmap对象，RequestHandler是一个抽象类其中包含判断是否可以处理某个请求的canHandleRequest方法，图片对象的构造器，压缩图片的calculateInSampleSize方法</li>
</ul>
<pre><code>allRequestHandlers.add(new ContactsPhotoRequestHandler(context));
allRequestHandlers.add(new MediaStoreRequestHandler(context));
allRequestHandlers.add(new ContentStreamRequestHandler(context));
allRequestHandlers.add(new AssetRequestHandler(context));
allRequestHandlers.add(new FileRequestHandler(context));
allRequestHandlers.add(new NetworkRequestHandler(dispatcher.downloader, stats));
requestHandlers = Collections.unmodifiableList(allRequestHandlers);
</code></pre><ul>
<li>创建BitmapHunter时，遍历RequestHandler链表，查找可以处理Request的对象</li>
</ul>
<pre><code>  static BitmapHunter forRequest(Picasso picasso, Dispatcher dispatcher, Cache cache, Stats stats,
Action action) {
      Request request = action.getRequest();
      List&lt;RequestHandler&gt; requestHandlers = picasso.getRequestHandlers();

      // Index-based loop to avoid allocating an iterator.
      //noinspection ForLoopReplaceableByForEach
      for (int i = 0, count = requestHandlers.size(); i &lt; count; i++) {
      RequestHandler requestHandler = requestHandlers.get(i);
      if (requestHandler.canHandleRequest(request)) {
          return new BitmapHunter(picasso, dispatcher, cache, stats, action, requestHandler);
      }
      }

      return new BitmapHunter(picasso, dispatcher, cache,         stats, action, ERRORING_HANDLER);
  } 
</code></pre><ul>
<li>在BitmapHunter的run方法中执行了hunt方法，hunt方法使用requestHandler的load方法得到需要的bitmap，之后使用dispatcher来传递bitmap</li>
</ul>
<pre><code>Bitmap hunt() throws IOException {
    ...
    data.networkPolicy = retryCount == 0 ? NetworkPolicy.OFFLINE.index : networkPolicy;
    RequestHandler.Result result = requestHandler.load(data, networkPolicy);
    if (result != null) {
    loadedFrom = result.getLoadedFrom();
    exifRotation = result.getExifOrientation();

    bitmap = result.getBitmap();
    ...

    }


Run(){
    ...
    result = hunt();

    if (result == null) {
        dispatcher.dispatchFailed(this);
    } else {
        dispatcher.dispatchComplete(this);
    ...
     }
}           
</code></pre><ul>
<li>最终bitmap被传递到performBatchComplete当中，使用主线程的handler来发送信息，在handlerMessage方法中调用到了picasso对象的complete方法，这个方法最终调用到了action的complete方法</li>
</ul>
<pre><code>void performBatchComplete() {
    List&lt;BitmapHunter&gt; copy = new ArrayList&lt;BitmapHunter&gt;(batch);
    batch.clear();
    mainThreadHandler.sendMessage(mainThreadHandler.obtainMessage(HUNTER_BATCH_COMPLETE, copy));
    logBatch(copy);
} 
</code></pre><ul>
<li>在ImageViewAction的complete方法中我们可以看到bitmap已经被设置了，这样就完成了一个完整的图片加载过程</li>
</ul>
<pre><code>@Override public void complete(Bitmap result,       Picasso.LoadedFrom from) {
    if (result == null) {
    throw new AssertionError(
        String.format(&quot;Attempted to complete action with no result!\n%s&quot;, this));
 }

    ImageView target = this.target.get();
    if (target == null) {
    return;
    }

    Context context = picasso.context;
    boolean indicatorsEnabled = picasso.indicatorsEnabled;
PicassoDrawable.setBitmap(target, context, result, from, noFade, indicatorsEnabled);

    if (callback != null) {
    callback.onSuccess();
    }
} 
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Matisse 源码分析]]></title>
      <url>/2017/08/07/Matisse/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<ul>
<li>首先还是从最初使用的地方开始一步步分析，很明显这里用到了builder模式，我们在启动Activity之前进行一些基本的配置，这里主要关心的方法有三个from，choose和forResult</li>
</ul>
<pre><code>Matisse.from(SampleActivity.this)
        .choose(MimeType.ofAll(), false)
        .countable(true)
        // 是否在图片右上角显示选中的数目
        .capture(true)
        //是否开启照相功能
        .captureStrategy(new CaptureStrategy(true, &quot;com.zhihu.matisse.sample.fileprovider&quot;)) 
        .maxSelectable(9)
        //设置最大可选数量
        .addFilter(new GifSizeFilter(320, 320, 5 * Filter.K * Filter.K))
        //添加过滤器,可自定义
        .gridExpectedSize(getResources().getDimensionPixelSize(R.dimen.grid_expected_size))
        //设置期待的尺寸
        .restrictOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT)
        //设置布局的水平或垂直属性
        .thumbnailScale(0.85f)
        //缩略图的缩放尺寸，默认为0.5
        .imageEngine(new GlideEngine())
        //设置图片加载库，Matisse对Glide和Picasso做了一层封装，也可以自定义，后面会提到
        .forResult(REQUEST_CODE_CHOOSE);
        //启动选择图片的Activity
</code></pre><ul>
<li>查看from方法，这里利用重载一个静态构造方法，既可以利用Activity也可以通过Fragment来创建Matisse对象</li>
</ul>
<pre><code>public static Matisse from(Activity activity) {
    return new Matisse(activity);
}

public static Matisse from(Fragment fragment) {
    return new Matisse(fragment);
}
</code></pre><ul>
<li>查看choose方法，这里我们定义了可以获取的媒体类型，构造并返回SelectionCreator对象，SelectionCreator类是Matisse中一个类似Builder的类型，从这里开始所有的配置方法都返回这个SelectionCreator</li>
</ul>
<pre><code>    public SelectionCreator choose(Set&lt;MimeType&gt; mimeTypes) {
        return this.choose(mimeTypes, true);
    }

    public SelectionCreator choose(Set&lt;MimeType&gt; mimeTypes, boolean mediaTypeExclusive) {
return new SelectionCreator(this, mimeTypes, mediaTypeExclusive);
}
</code></pre><ul>
<li>查看SelectionCreator对象的构造器和类结构，它只持有刚刚创建的Matisse对象和SelectionSpec对象，SelectionSpec对象保存调用countable，capture等方法时传入的参数，也就是保存了我们对matisse的配置属性</li>
</ul>
<pre><code>SelectionCreator(Matisse matisse, @NonNull Set&lt;MimeType&gt; mimeTypes, boolean mediaTypeExclusive) {
mMatisse = matisse;
mSelectionSpec = SelectionSpec.getCleanInstance();
mSelectionSpec.mimeTypeSet = mimeTypes;
mSelectionSpec.mediaTypeExclusive = mediaTypeExclusive;
mSelectionSpec.orientation = SCREEN_ORIENTATION_UNSPECIFIED;
}
</code></pre><ul>
<li>mSelectionSpec是一个懒汉式单例，当被初次调用<br>时InstanceHolder才会被加载进来，同时完成INSTANCE的初始化</li>
</ul>
<pre><code>private static final class InstanceHolder {
private static final SelectionSpec INSTANCE = new SelectionSpec();
} 
</code></pre><ul>
<li>mSelectionSpec 持有了这些配置属性，作为一个第三方库，我们使用的时候只需要进行这些配置，而不需要关系Matisse的内部实现</li>
</ul>
<pre><code>public Set&lt;MimeType&gt; mimeTypeSet;
    public boolean mediaTypeExclusive;
    public boolean showSingleMediaType;
    public int themeId;
    public int orientation;
    public boolean countable;
    public int maxSelectable;
    public List&lt;Filter&gt; filters;
    public boolean capture;
    public CaptureStrategy captureStrategy;
    public int spanCount;
    public int gridExpectedSize;
    public float thumbnailScale;
    public ImageEngine imageEngine; 
</code></pre><ul>
<li>再来看看forResult方法，如果我们之前传入的是activity就会调用activity的startActivityForResult，如果传入的是fragment那就调用fragment的startActivityForResult方法，所以重写onActivityResult方法获取返回的数据即可</li>
</ul>
<pre><code>    public void forResult(int requestCode) {
Activity activity = mMatisse.getActivity();
if (activity == null) {
    return;
}

Intent intent = new Intent(activity, MatisseActivity.class);

Fragment fragment = mMatisse.getFragment();
if (fragment != null) {
    fragment.startActivityForResult(intent, requestCode);
} else {
    activity.startActivityForResult(intent, requestCode);
}
} 

...

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
super.onActivityResult(requestCode, resultCode, data);
if (requestCode == REQUEST_CODE_CHOOSE &amp;&amp; resultCode == RESULT_OK) {
    mAdapter.setData(Matisse.obtainResult(data), Matisse.obtainPathResult(data));
}
}
</code></pre><ul>
<li>刚才使用startActivityForResult启动了MatisseActivity，那么首先查看MatisseActivity的onCreate方法，这里获取到了刚刚的SelectionSpec静态常量进行初始化</li>
</ul>
<pre><code>mSpec = SelectionSpec.getInstance();
setTheme(mSpec.themeId);

...

mButtonPreview = (TextView) findViewById(R.id.button_preview);
mButtonApply = (TextView) findViewById(R.id.button_apply);

...

mAlbumsSpinner = new AlbumsSpinner(this);
mAlbumCollection.onCreate(this, this);
</code></pre><ul>
<li>比较值得学习的一点是这里的AlbumsSpinner类，它其实是将Activity左上角的一组控件进行了封装，主要包括显示文件夹名称的TextView，ListPopupWindow，Adapter等等，相当于把一个相对完整的功能抽取出来，把逻辑操作写在里面，在Activity中当做一种控件来使用，有点类似自定义View。观察整个MatisseActivity，发现内部基本只有回调方法，逻辑还是挺清晰的。</li>
</ul>
<pre><code>public class AlbumsSpinner {

private static final int MAX_SHOWN_COUNT = 6;
private CursorAdapter mAdapter;
private TextView mSelected;
private ListPopupWindow mListPopupWindow;
private AdapterView.OnItemSelectedListener mOnItemSelectedListener;
...
</code></pre><ul>
<li>Matisse的数据加载使用 <a href="http://www.jianshu.com/p/385327e35711" target="_blank" rel="external">Loader机制</a>，AlbumCollection是一个LoaderCallbacks的实现，同时提供一个接口给Activity在数据加载时更新UI</li>
</ul>
<pre><code>public interface AlbumCallbacks {
void onAlbumLoad(Cursor cursor);

void onAlbumReset();
}
</code></pre><ul>
<li>当选中文件夹时，调用Activity中的回调方法，如果没有图片就加载一个简单的布局提示用户，有图片就加载一个Fragment，并传入一个Album文件夹对象</li>
</ul>
<pre><code>    @Override
    public void onItemSelected(AdapterView&lt;?&gt; parent, View view, int position, long id) {
mAlbumCollection.setStateCurrentSelection(position);
mAlbumsAdapter.getCursor().moveToPosition(position);
Album album = Album.valueOf(mAlbumsAdapter.getCursor());
if (album.isAll() &amp;&amp; SelectionSpec.getInstance().capture) {
    album.addCaptureCount();
}
onAlbumSelected(album);
    }

    private void onAlbumSelected(Album album) {
if (album.isAll() &amp;&amp; album.isEmpty()) {
    mContainer.setVisibility(View.GONE);
    mEmptyView.setVisibility(View.VISIBLE);
} else {
    mContainer.setVisibility(View.VISIBLE);
    mEmptyView.setVisibility(View.GONE);
    Fragment fragment = MediaSelectionFragment.newInstance(album);
    getSupportFragmentManager()
            .beginTransaction()
            .replace(R.id.container, fragment, MediaSelectionFragment.class.getSimpleName())
            .commitAllowingStateLoss();
    }
} 
</code></pre><ul>
<li>进入到MediaSelectionFragment，在onAttach方法中将Activity作为监听器传来进来</li>
</ul>
<pre><code>    @Override
    public void onAttach(Context context) {
super.onAttach(context);
if (context instanceof SelectionProvider) {
    mSelectionProvider = (SelectionProvider) context;
} else {
    throw new IllegalStateException(&quot;Context must implement SelectionProvider.&quot;);
}
if (context instanceof AlbumMediaAdapter.CheckStateListener) {
    mCheckStateListener = (AlbumMediaAdapter.CheckStateListener) context;
}
if (context instanceof AlbumMediaAdapter.OnMediaClickListener) {
    mOnMediaClickListener = (AlbumMediaAdapter.OnMediaClickListener) context;
}
    }
</code></pre><ul>
<li>各种初始化的操作主要在onActivityCreated当中，比较重要的步骤是通过在Activity中传入的Album对象初始化Loader</li>
</ul>
<pre><code>mAlbumMediaCollection.onCreate(getActivity(), this);
mAlbumMediaCollection.load(album, selectionSpec.capture);

    public void load(@Nullable Album target, boolean enableCapture) {
Bundle args = new Bundle();
args.putParcelable(ARGS_ALBUM, target);
args.putBoolean(ARGS_ENABLE_CAPTURE, enableCapture);
mLoaderManager.initLoader(LOADER_ID, args, this);
}

@Override
    public void onMediaClick(Album album, Item item, int adapterPosition) {
Intent intent = new Intent(this, AlbumPreviewActivity.class);
intent.putExtra(AlbumPreviewActivity.EXTRA_ALBUM, album);
intent.putExtra(AlbumPreviewActivity.EXTRA_ITEM, item);
intent.putExtra(BasePreviewActivity.EXTRA_DEFAULT_BUNDLE, mSelectedCollection.getDataWithBundle());
startActivityForResult(intent, REQUEST_CODE_PREVIEW);
    }
</code></pre><ul>
<li>Fragment图片Item的监听器最终调用到，Activity中的方法，启动预览Activity，这后面就没什么好说的了</li>
</ul>
<pre><code>    @Override
    public void onMediaClick(Album album, Item item, int adapterPosition) {
Intent intent = new Intent(this, AlbumPreviewActivity.class);
intent.putExtra(AlbumPreviewActivity.EXTRA_ALBUM, album);
intent.putExtra(AlbumPreviewActivity.EXTRA_ITEM, item);
intent.putExtra(BasePreviewActivity.EXTRA_DEFAULT_BUNDLE, mSelectedCollection.getDataWithBundle());
startActivityForResult(intent, REQUEST_CODE_PREVIEW);
    }
</code></pre><ul>
<li>另外在RecycleView的AlbumMediaAdapter的onBindViewHolder中，可以发现Matisse将ViewHolder抽取出来，通过preBindMedia和bindMedia来设定Item信息</li>
</ul>
<pre><code>mediaViewHolder.mMediaGrid.preBindMedia(new MediaGrid.PreBindInfo(
        getImageResize(mediaViewHolder.mMediaGrid.getContext()),
        mPlaceholder,
        mSelectionSpec.countable,
        holder
));
mediaViewHolder.mMediaGrid.bindMedia(item);
</code></pre><ul>
<li>ViewHolder中只有一个MediaGrid对象，它是一个正方形的FrameLayout</li>
</ul>
<pre><code>public class MediaGrid extends SquareFrameLayout implements View.OnClickListener {

private ImageView mThumbnail;
private CheckView mCheckView;
private ImageView mGifTag;
private TextView mVideoDuration;

private Item mMedia;
private PreBindInfo mPreBindInfo;
private OnMediaGridClickListener mListener; 
</code></pre><ul>
<li>在MediaGrid中我们可以找到设定图片的方法，engine包下是真正的图片加载工具，包括了默认的GlideEngine和PicassoEngine</li>
</ul>
<pre><code>    private void setImage() {
if (mMedia.isGif()) {
    SelectionSpec.getInstance().imageEngine.loadGifThumbnail(getContext(), mPreBindInfo.mResize,
            mPreBindInfo.mPlaceholder, mThumbnail, mMedia.getContentUri());
} else {
    SelectionSpec.getInstance().imageEngine.loadThumbnail(getContext(), mPreBindInfo.mResize,
            mPreBindInfo.mPlaceholder, mThumbnail, mMedia.getContentUri());
    }
}
</code></pre><ul>
<li>GlideEngine，PicassoEngine是对两个第三方库的封装，实现了ImageEngine接口，ImageEngine中只有几个加载图片的方法，如果要使用自定义的图片加载工具，只需实现这个接口即可，可见使用接口大大地提高了可扩展性</li>
</ul>
<pre><code>    public interface ImageEngine {

    void loadThumbnail(Context context, int resize, Drawable placeholder, ImageView imageView, Uri uri);

    void loadGifThumbnail(Context context, int resize, Drawable placeholder, ImageView imageView, Uri uri);


    void loadImage(Context context, int resizeX, int resizeY, ImageView imageView, Uri uri);

    void loadGifImage(Context context, int resizeX, int resizeY, ImageView imageView, Uri uri);

    boolean supportAnimatedGif();
} 
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java 四类线程池与自定义线程池]]></title>
      <url>/2017/07/28/ThreadPool/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<h2 id="关于线程池"><a href="#关于线程池" class="headerlink" title="关于线程池"></a>关于线程池</h2><ul>
<li>当我们异步处理请求时，如果每一个请求都去创建一个线程，那么请求和销毁线程所消耗的时间和空间上的资源可能比时间处理请求的销毁的资源更多，为了解决线程开销的问题，需要使用线程池统一管理和复用线程</li>
</ul>
<ul>
<li>任何的多线程操作都有死锁的风险。如果线程池太大，系统资源会被长期占用影响程序的性能。</li>
</ul>
<ul>
<li>线程池最严重的风险是线程泄漏，当线程抛出运行时异常或Error时如果没有被捕捉，线程意外死亡，那么池的大小就永远减小一个，最终很有可能导致线程池为空的情况，另外如果某个线程被一个任务永久消耗，那么实际上它相当于被从线程池中移除了</li>
</ul>
<h2 id="Java自带线程池"><a href="#Java自带线程池" class="headerlink" title="Java自带线程池"></a>Java自带线程池</h2><h3 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h3><ul>
<li>java.util.concurrent包中提供了进行后台操作的接口ExecutorService，这个接口继承了Executor接口，Executor中只有一个Execute方法，ExecutorService主要有两个实现ThreadPoolExecutor和ScheduledThreadPoolExecutor，这两个类为我们提供了各种各样的线程池</li>
</ul>
<pre><code>public interface Executor {

/**
* Executes the given command at some time in the future.  The command
* may execute in a new thread, in a pooled thread, or in the calling
* thread, at the discretion of the {@code Executor} implementation.
*
* @param command the runnable task
* @throws RejectedExecutionException if this task can   not be
* accepted for execution
* @throws NullPointerException if command is null
*/
void execute(Runnable command);
}
</code></pre><ul>
<li><p>ExecutorService有一个工厂类Executors，Executors可以创建下面四类线程池</p>
<pre><code>newCachedThreadPool
newFixedThreadPool
newScheduledThreadPoo
newSingleThreadExecutor
</code></pre></li>
</ul>
<ul>
<li><p>ExecutorService有五个执行方法</p>
<pre><code>execute(Runnable)
submit(Runnable)
submit(Callable)
invokeAny()
invokeAll()
</code></pre></li>
<li><p>execute方法不能得到返回值而submit方法可以得到返回值的Future对象，使用submit(Runnable)得到的Future对象调用get()方法会阻塞当前线程，并最终得到一个null值，但是submit(Callable)得到Future对象的get()方法可以获取结果</p>
</li>
<li><p>invokeAny方法接受一个Callable，但是执行这个方法不会返回Future，而是可以得到其中一个Callable的结果，但无法保证是哪一个Callable的结果，使用invokeAll可以返回一个Future对象的list使用future.get()可以得到对应结果</p>
</li>
</ul>
<h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><ul>
<li><p>这种线程池对线程创建的数量几乎没有要求，查看内部的构造器发现它传递的是Integer.MAX_VALUE，它会根据需要回收线程，如果没有线程可回收就新开线程，当某线程空闲时间超过60秒时，该线程会被回收</p>
<pre><code>    public static ExecutorService newCachedThreadPool() {
return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                              60L, TimeUnit.SECONDS,
                              new SynchronousQueue&lt;Runnable&gt;());
    }
</code></pre></li>
<li><p>开启线程池使用Executors的静态方法</p>
</li>
</ul>
<pre><code>ExecutorService cachedThreadPool = Executors.newCachedThreadPool(); 
</code></pre><ul>
<li>发送请求，投递Runnable或Thread</li>
</ul>
<pre><code>cachedThreadPool.execute(new Runnable() {
        @Override
        public void run() {
        //do something
        }
    }); 
</code></pre><ul>
<li>使用shutdown和shutdownNow方法可以终止线程池，shutdown会等待队列中的任务执行完毕才去终止线程池，shutdownNow或尝试打断正在执行的任务</li>
</ul>
<ul>
<li>这种线程一般用在请求的速度小于处理请求的速度的情况下，也就是说任务的耗时比较短，注意一点要控制任务的数量不然相当于没有使用线程池管理线程，并清空任务队列</li>
</ul>
<h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><ul>
<li>这种线程池可以规定池的大小，每提交一个任务就开启一个线程，直到线程数量达到最大值为止</li>
</ul>
<pre><code>ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3);
</code></pre><ul>
<li>可以看到当任务数量超过池的大小，多出来的任务需要等待空闲的线程</li>
</ul>
<pre><code>fixedThreadPool.execute(new Runnable() {
            @Override
            public void run() {

                try {

                    Thread.sleep(3000);
                    Log.d(TAG, &quot;run: &quot;+index+&quot; &quot;+ Thread.currentThread());

                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

            }
        });


    07-28 15:10:50.137 24819-24849/com.linjiamin.threadtest D/MainActivity: run: 1 Thread[pool-1-thread-2,5,main]
    07-28 15:10:50.137 24819-24850/com.linjiamin.threadtest D/MainActivity: run: 2 Thread[pool-1-thread-3,5,main]
    07-28 15:10:50.157 24819-24848/com.linjiamin.threadtest D/MainActivity: run: 0 Thread[pool-1-thread-1,5,main]
    07-28 15:10:53.138 24819-24849/com.linjiamin.threadtest D/MainActivity: run: 3 Thread[pool-1-thread-2,5,main]
    07-28 15:10:53.138 24819-24850/com.linjiamin.threadtest D/MainActivity: run: 4 Thread[pool-1-thread-3,5,main]
    07-28 15:10:53.158 24819-24848/com.linjiamin.threadtest D/MainActivity: run: 5 Thread[pool-1-thread-1,5,main]
</code></pre><ul>
<li>FixedThreadPool一般用在耗时较长的任务上，对于一些需要马上执行的任务可能要考虑另外执行</li>
</ul>
<h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><ul>
<li>创建一个单线程的Executor，所有任务都在一个线程中执行，并且保证了任务的优先级，当线程发生异常时，会有新的线程被创造，以保证任务的正常进行</li>
</ul>
<pre><code>ExecutorService fixedThreadPool = Executors.newSingleThreadExecutor();  
</code></pre><ul>
<li>适用于需要串行的任务，如数据库，文件的读写等</li>
</ul>
<h3 id="newScheduleThreadPool"><a href="#newScheduleThreadPool" class="headerlink" title="newScheduleThreadPool"></a>newScheduleThreadPool</h3><ul>
<li>一种定长的线程池，支持定时和周期性的执行任务</li>
</ul>
<pre><code>ExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(3);
</code></pre><ul>
<li>使用schedule方法可以重复执行任务</li>
</ul>
<pre><code>public ScheduledFuture&lt;?&gt; schedule(Runnable command,
                               long delay, TimeUnit unit);
</code></pre><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><ul>
<li>上述的四种线程池都调用了ThreadPoolExecutor这个构造方法，ThreadPoolExecutor一般用来定义新的线程池</li>
<li>ThreadPoolExecutor的构造器如下，corePoolSize表示核心池的大小，当线程池中的线程数目大于该值时会把任务放到缓存队列当中</li>
</ul>
<ul>
<li>maximumPoolSize，最大线程数，表示一个线程池最多能创建多少线程</li>
</ul>
<ul>
<li>keepAliveTime，当线程池的大小超过corePoolSize且线程的空闲时间超过该值，该线程就会终止</li>
</ul>
<ul>
<li>unit时间单位，包括DAYS，HOURS，MINUTES，SECONDS，MILLISECONDS，MICROSECONDS，NANOSECONDS</li>
</ul>
<ul>
<li>workQueue，阻塞队列，用来储存待执行的任务，一般有三个可能的类型，ArrayBlockingQueue，先进先出队列，必须指定大小，LinkedBlockingQueue，先进先出队列，可不指定大小，SynchronousQueue，直接新建一个线程来执行新来的任务，不缓存任务，ThreadFactory用于创建线程，RejectedExecutionHandler用于处理当线程池拒绝任务时的策略</li>
</ul>
<pre><code>public ThreadPoolExecutor(int corePoolSize,
                      int maximumPoolSize,
                      long keepAliveTime,
                      TimeUnit unit,
                      BlockingQueue&lt;Runnable&gt; workQueue,
                      ThreadFactory threadFactory,
                      RejectedExecutionHandler handler) {   
</code></pre><ul>
<li>下面来实现一个后进先出的线程池，首先需要实现它的构造函数，一般外界只需要决定池的大小即可，这里创建了一个PriorityBlockingQueue并传入了自定义的comparator，PriorityBlockingQueue需要comparator来决定优先顺序，那么我们可以利用comparator来实现后进先出</li>
</ul>
<pre><code>    public static LIFOThreadExecutor newLIFOExecutor(int size){

return new LIFOThreadExecutor(size,MAX_SIZE,ALIVE_TIME,TimeUnit.SECONDS,new PriorityBlockingQueue&lt;&gt;(MAX_SIZE,comparator));
    }


    private LIFOThreadExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) {
super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);
    }
</code></pre><ul>
<li>这里我们获取execute方法传入的Runnable对象，并为其加上一个标记</li>
</ul>
<pre><code>class RunnabalbeWithTag implements Runnable{

private final Runnable runnable;
private final long tag;

RunnabalbeWithTag(Runnable runnable) {
    this.runnable = runnable;
    this.tag = LIFOThreadExecutor.this.tag.getAndIncrement();
}

@Override
public void run() {
    runnable.run();
    }
}

@Override
public void execute(Runnable command) {

super.execute(new RunnabalbeWithTag(command));

}
</code></pre><ul>
<li>在compare方法中利用标记决定优先顺序</li>
</ul>
<pre><code>private static final Comparator&lt;Runnable&gt; comparator = new Comparator&lt;Runnable&gt;() {
@Override
public int compare(Runnable o1, Runnable o2) {

    return ((RunnabalbeWithTag)o1).tag&lt;((RunnabalbeWithTag)o2).tag ?
            1: ((RunnabalbeWithTag)o1).tag&gt;((RunnabalbeWithTag)o2).tag? -1:0;
    }
};  
</code></pre><ul>
<li>接着使用这个线程池，可以看到已经实现了后进先出的效果</li>
</ul>
<pre><code>LIFOThreadExecutor executor =  LIFOThreadExecutor.newLIFOExecutor(1);
for(int i = 0 ;i&lt;10;i++){

        final int index = i;
        executor.execute(new Runnable() {
            @Override
            public void run() {
                try {
                    Thread.sleep(3000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                Log.d(TAG, &quot;run: &quot;+ index +&quot; &quot;+Thread.currentThread());
            }
        });
    }
}   

    ...
MainActivity: run: 6 Thread[pool-1-thread-1,5,main]
MainActivity: run: 5 Thread[pool-1-thread-1,5,main]
MainActivity: run: 4 Thread[pool-1-thread-1,5,main]
MainActivity: run: 3 Thread[pool-1-thread-1,5,main]
MainActivity: run: 2 Thread[pool-1-thread-1,5,main]
MainActivity: run: 1 Thread[pool-1-thread-1,5,main]
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[GestureDetector 使用详解]]></title>
      <url>/2017/07/27/Gesture/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<h2 id="GestureDetector"><a href="#GestureDetector" class="headerlink" title="GestureDetector"></a>GestureDetector</h2><ul>
<li>GestureDetector用于识别不同的手势，Down，ShowPress，SingleTapUp，Scroll，LongPress，Fling<pre><code>Down，点击屏幕
ShowPress，短时间内点击屏幕且不抬起或拖动
SingleTapUp，轻击屏幕立即抬起
Scroll，拖动
LongPress，长按屏幕
Fling，滑屏，屏幕上的每次拖动手势最终都会触发Fling，期间Scroll可能会被调用多次，但Fling只被调用一次
</code></pre></li>
</ul>
<ul>
<li>GestureDetector只负责识别手势，创建GestureDetector需要传入监听器以实现手势的反馈</li>
</ul>
<h2 id="OnGestureListener"><a href="#OnGestureListener" class="headerlink" title="OnGestureListener"></a>OnGestureListener</h2><ul>
<li>GestureDetector包含两个接口和一个内部类，OnGestureListener是其中一个接口，有六个回调方法需要实现</li>
</ul>
<pre><code>private class GestureListener implements GestureDetector.OnGestureListener{


@Override
public boolean onDown(MotionEvent e) {

    Log.d(TAG, &quot;onDown: &quot;);
    return false;
}

@Override
public void onShowPress(MotionEvent e) {
    Log.d(TAG, &quot;onShowPress: &quot;);

}

@Override
public boolean onSingleTapUp(MotionEvent e) {
    Log.d(TAG, &quot;onSingleTapUp: &quot;);
    return false;
}

@Override
public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {
    Log.d(TAG, &quot;onScroll: &quot;);
    return false;
}

@Override
public void onLongPress(MotionEvent e) {
    Log.d(TAG, &quot;onLongPress: &quot;);

}

@Override
public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
    Log.d(TAG, &quot;onFling: &quot;);

    return false;
}

}
</code></pre><ul>
<li>构造GestureDetector，传入listener实例</li>
</ul>
<pre><code>GestureDetector detector = new GestureDetector(getContext(),new GestureListener());
</code></pre><ul>
<li>重写onTouchEvent，将事件传递给GestureDetector</li>
</ul>
<pre><code>@Override
public boolean onTouchEvent(MotionEvent event) {

detector.onTouchEvent(event);
return true;
}
</code></pre><ul>
<li>也可以使用setOnTouchListener方法传递Event</li>
</ul>
<pre><code>setOnTouchListener(new OnTouchListener() {
    @Override
    public boolean onTouch(View v, MotionEvent event) {
        return detector.onTouchEvent(event);
    }
});
</code></pre><ul>
<li>在onFling中，我们可以进行一些条件判断</li>
</ul>
<pre><code>@Override
public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
    Log.d(TAG, &quot;onFling: &quot;);
    if(e2.getX()-e1.getX()&gt;0) Log.d(TAG, &quot;onFling: right&quot;);
    if(e2.getX()-e1.getX()&lt;0) Log.d(TAG, &quot;onFling: lift&quot;);
    return false;
}
</code></pre><h2 id="OnDoubleTapListener"><a href="#OnDoubleTapListener" class="headerlink" title="OnDoubleTapListener"></a>OnDoubleTapListener</h2><ul>
<li>OnGestureListener 只能监听单次的点击事件，为了能够监听双击事件还需要OnDoubleTapListener，用法与前者类似</li>
</ul>
<pre><code>    class DoubleListener implements GestureDetector.OnDoubleTapListener{

    @Override
    public boolean onSingleTapConfirmed(MotionEvent e) {
        Log.d(TAG, &quot;onSingleTapConfirmed: &quot;);
        return false;
    }

    @Override
    public boolean onDoubleTap(MotionEvent e) {
        Log.d(TAG, &quot;onDoubleTap: &quot;);
        return false;
    }

    @Override
    public boolean onDoubleTapEvent(MotionEvent e) {
        Log.d(TAG, &quot;onDoubleTapEvent: &quot;);
        return false;
    }
}
</code></pre><ul>
<li>onSingleTapConfirmed只会在单击时被调用</li>
</ul>
<pre><code>onDown -&gt;
onSingleTapUp -&gt;
onSingleTapConfirmed
</code></pre><ul>
<li>onDoubleTap和onDoubleTapEvent会在双击的时候被调用，这里onDoubleTapEvent被调用了两次，第一次event的ACTION为ACTION_DOWN，第二次为ACTION_UP</li>
</ul>
<pre><code>onDown: 
onSingleTapUp: 
onDoubleTap: 
onDoubleTapEvent: 0
onDown: 
onDoubleTapEvent: 1
</code></pre><h2 id="SimpleOnGestureListener"><a href="#SimpleOnGestureListener" class="headerlink" title="SimpleOnGestureListener"></a>SimpleOnGestureListener</h2><ul>
<li>SimpleOnGestureListener是GestureDetector的一个内部类，它实现了前两个接口的所有方法，只不过里面都是空白，通常我们只需要使用到一两个回调方法，这时候使用SimpleOnGestureListener即可</li>
</ul>
<pre><code>    class GestureListener extends GestureDetector.SimpleOnGestureListener{

    @Override
    public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
        Log.d(TAG, &quot;onFling: &quot;);
        return super.onFling(e1, e2, velocityX, velocityY);
    }


    @Override
    public boolean onDoubleTap(MotionEvent e) {
        Log.d(TAG, &quot;onDoubleTap: &quot;);
        return super.onDoubleTap(e);
    }
}
</code></pre><h2 id="Matrix"><a href="#Matrix" class="headerlink" title="Matrix"></a>Matrix</h2><ul>
<li>matrix用于修改图片的各种属性，使用matrix可以对图片进行伸缩，旋转，倾斜，平移等操作<pre><code>Matrix matrix = new Matrix();
setScaleType(ScaleType.MATRIX);
matrix.setScale(10,10);//伸缩变换
matrix.postTranslate(0,100);//平移变换
matrix.postRotate(10);//旋转变换
matrix.postSkew(2,2);//扭曲变换
this.setImageMatrix(matrix);
</code></pre></li>
</ul>
<ul>
<li>Matrix对矩阵的处理分为pre和post两种，前者是矩阵前乘后者是矩阵后乘，但实际使用来说只需要将所有操作过程理解为一组队列，pre先执行post后执行，另外使用set方法会清空之前添加的所有操作</li>
</ul>
<h2 id="ScaleGestureDetector"><a href="#ScaleGestureDetector" class="headerlink" title="ScaleGestureDetector"></a>ScaleGestureDetector</h2><ul>
<li>ScaleGestureDetector专门用于实现放大和缩小的手势操作 </li>
</ul>
<pre><code>ScaleGestureDetector scaleGestureDetector = new ScaleGestureDetector(getContext(), new ScaleListener());
</code></pre><ul>
<li>使用ScaleGestureDetector，需要传入OnScaleGestureListener的实现类，其中有三个方法需要实现，onScaleBegin在开始缩放时调用，也就是使用了两个触控点的时候，onScaleEnd在结束缩放的时候调用，一般可以在两个方法里设置标记。onScale在期间会不断地被调用，可以在其中实现缩放的逻辑</li>
</ul>
<pre><code>@Override
 public boolean onScale(ScaleGestureDetector detector) {
        return true;
    }


@Override
public boolean onScaleBegin(ScaleGestureDetector detector) {

    return true;
}

@Override
public void onScaleEnd(ScaleGestureDetector detector) {


}
</code></pre><ul>
<li>下面来简单实现手势缩放的效果，在onScale中通过ScaleGestureDetector得到ScaleFactor缩放因子，它是ScaleGestureDetector通过当前的手势得到的Scale值，getFocusX和getFocusY是两触点之间的焦点，将这几个参数传入即可，另外可以在这之前获取当前的Scale值进行检查</li>
</ul>
<pre><code>@Override
    public boolean onScale(ScaleGestureDetector detector) {

    if(getScaleSize()&gt;2&amp;&amp;detector.getScaleFactor()&gt;1
            ||getScaleSize()&lt;0.5&amp;&amp;detector.getScaleFactor()&lt;1){
        return true;
    }

    mCurrentMatrix.postScale(detector.getScaleFactor(),detector.getScaleFactor(),detector.getFocusX(),detector.getFocusY());
    setImageMatrix(mCurrentMatrix);


    return true;
}

public float getScaleSize(){

    float[] value = new float[9];
    mCurrentMatrix.getValues(value);

    return value[Matrix.MSCALE_X];
}
</code></pre><ul>
<li>在onScaleBegin和onScaleEnd方法中简单地设置标记，提供给外界判断当前状态</li>
</ul>
<pre><code>@Override
public boolean onScaleBegin(ScaleGestureDetector detector) {

    isScaling = true;
    return true;
}

@Override
public void onScaleEnd(ScaleGestureDetector detector) {
    isScaling = false;

}   
</code></pre><h2 id="ActionEvent"><a href="#ActionEvent" class="headerlink" title="ActionEvent"></a>ActionEvent</h2><ul>
<li>在onTouch方法中我们可以通过获取Event的getAction方法得到触摸的事件类型， 事件类型代表了一系列的动作，系统不断地传进Event对象为我们动态地响应操作提供了可能，下面是主要的动作类型</li>
</ul>
<pre><code>/**
* A pressed gesture has started
* 表示用户开始触碰
*/
public static final int ACTION_DOWN             = 0;

/**
* A pressed gesture has finished
*表示用户抬起了手指
*/
public static final int ACTION_UP               = 1;

/**
* A change has happened during a
* press gesture (between {@link #ACTION_DOWN} and {@link #ACTION_UP}).
* 表示手指在移动
*/

public static final int ACTION_MOVE             = 2;

/**
* The current gesture has been aborted.
* You will not receive any more points in it.  You should treat this as
* an up event, but not perform any action that you normally would.
* 手势被取消，类似ACTION_UP但是后续的操作并不会被执行
*/

public static final int ACTION_CANCEL           = 3;

/**
* A movement has happened outside of the
* normal bounds of the UI element.
* 用户的手指超过了UI边界
*/
public static final int ACTION_OUTSIDE          = 4;

/**
* A non-primary pointer has gone down.
* 用户按下了另一只手指
*/
public static final int ACTION_POINTER_DOWN     = 5;

/**
* A non-primary pointer has gone up.
* 用户抬起了一只手指
* 
*/
public static final int ACTION_POINTER_UP       = 6; 
</code></pre><h2 id="TouchListener"><a href="#TouchListener" class="headerlink" title="TouchListener"></a>TouchListener</h2><ul>
<li>使用TouchListener，我们可以利用 ActionEvent的ACTION类型进行一些其他的操作，只有一个onTouch方法需要重写</li>
</ul>
<ul>
<li>下面实现一个拖拽图片的手势效果，首先需要将Event传递给其他监听器，接着获取ACTION类型当用户点击时记录下点击的坐标然后在移动时不断更新坐标并根据位移移动我们的图片，注意此时会和刚刚实现的缩放操作产生冲突，使用标记为进行判断，另外还可以使用控件的宽和高进行边界的设定</li>
</ul>
<pre><code>   private class TouchListener implements OnTouchListener {

   @Override
   public boolean onTouch(View v, MotionEvent event) {

       scaleGestureDetector.onTouchEvent(event);
       gestureDetector.onTouchEvent(event);

       switch (event.getAction()){
           case MotionEvent.ACTION_DOWN:

               mCurrentMatrix.set(getImageMatrix());
               moveY = event.getY();
               moveX = event.getX();

               break;
           case MotionEvent.ACTION_MOVE:

               float x = event.getX();
               float y = event.getY();

               if(!isScaling&amp;&amp;(getWidth()/5&lt;x&amp;&amp;x&lt;getWidth()*4/5
                       ||getHeight()/5&lt;y&amp;&amp;y&lt;getHeight()*4/5)) {

                   mCurrentMatrix.postTranslate(x - moveX, y - moveY);
                   setImageMatrix(mCurrentMatrix);

               }
               moveX = x;
               moveY = y;

               break;

           default:
               break;
       }
       return true;
   }
} 
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Bitmap 获取与处理]]></title>
      <url>/2017/07/26/Bitmap/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<h2 id="Bitmap属性"><a href="#Bitmap属性" class="headerlink" title="Bitmap属性"></a>Bitmap属性</h2><ul>
<li>Bitmap主要的属性有三个，width，height，config，可以直接通过get方法获得</li>
<li>config 是bitmap的像素类型，有四种可能的值，config后面的数字表明了每个像素占用的位数，如 ALPHA_8 为8位，RGB_565为16位，ARGB_8888为32位，ARGB_8888模式的Bitmap是最清晰的，这也是默认的模式</li>
</ul>
<pre><code>ALPHA_8 
RGB_565 
ARGB_4444 
ARGB_8888 
</code></pre><h2 id="获取Bitmap"><a href="#获取Bitmap" class="headerlink" title="获取Bitmap"></a>获取Bitmap</h2><h3 id="获取Bitmap对象"><a href="#获取Bitmap对象" class="headerlink" title="获取Bitmap对象"></a>获取Bitmap对象</h3><ul>
<li>Drawable -> Bitmap </li>
</ul>
<pre><code>//BitmapDrawable
Bitmap bitmap = drawable.getBitmap();

//Drawable
int w = drawable.getIntrinsicWidth();
int h = drawable.getIntrinsicHeight();
Bitmap bitmap = Bitmap.createBitmap(w,h, drawable.getOpacity()!= PixelFormat.OPAQUE?Bitmap.Config.ARGB_8888:Bitmap.Config.RGB_565);
Canvas canvas = new Canvas(bitmap);
drawable.setBounds(0, 0, w, h);
drawable.draw(canvas);
</code></pre><ul>
<li>BitmapFactory.decodeResource，从资源获取</li>
</ul>
<pre><code>Bitmap bitmap = BitmapFactory.decodeResource(getResources(),R.mipmap.ic_launcher);
</code></pre><ul>
<li><p>BitmapFactory.decodeFile ，从文件获取      </p>
<pre><code>//需要加入权限
//WRITE_EXTERNAL_STORAGE
//MOUNT_UNMOUNT_FILESYSTEMS

String path = Environment.getExternalStorageDirectory().getPath()+&quot;/bitmap/bitmaptest.jpg&quot;;
Bitmap bitmap = BitmapFactory.decodeFile(path);
imageView.setImageBitmap(bitmap);
</code></pre></li>
</ul>
<ul>
<li><p>BitmapFactory.decodeByteArray</p>
<pre><code>Bitmap bitmap = BitmapFactory.decodeByteArray(bitmap,0,bitmap);
</code></pre></li>
<li><p>BitmapFactory.decodeStream，从流获取, decodeFile和decodeResource内部都调用这个方法  </p>
</li>
</ul>
<pre><code>Bitmap bitmap = BitmapFactory.decodeStream(inputStream);
</code></pre><h3 id="获取所有本地图片"><a href="#获取所有本地图片" class="headerlink" title="获取所有本地图片"></a>获取所有本地图片</h3><ul>
<li><p>android的媒体文件数据信息主要存储在 /data/data/com.android.providers.media/databases目录中，其中有两个db文件，external.db和internal.db 前者是储存卡数据库，后者是内部存储的数据库，两者中包含的表和表结构是一致的</p>
</li>
<li><p>数据库中和图片相关的主要有两张表iamges 和 thumbnails，表结构如下，后者是缩略图的信息</p>
</li>
</ul>
<pre><code>CREATE TABLE images (
_id INTEGER PRIMARY KEY,
_data TEXT,
_size INTEGER,
_display_name TEXT,
mime_type TEXT,
title TEXT,
date_added INTEGER,
date_modified INTEGER,
description TEXT,
picasa_id TEXT,
isprivate INTEGER,
latitude DOUBLE,
longitude DOUBLE,
datetaken INTEGER,
orientation INTEGER,
mini_thumb_magic INTEGER,
bucket_id TEXT,
bucket_display_name TEXT);          

CREATE TABLE thumbnails (
_id INTEGER PRIMARY KEY,
_data TEXT,
image_id INTEGER,
kind INTEGER,
width INTEGER,height INTEGER);
</code></pre><ul>
<li>获取所有包含图片的文件夹名称和文件夹id</li>
</ul>
<pre><code>select DISTINCT bucket_display_name from images;
select DISTINCT bucket_id from images;
</code></pre><ul>
<li>获取所有缩略图bitmap</li>
</ul>
<pre><code>public List&lt;ImageInfo&gt; getImage(Context context){

List&lt;ImageInfo&gt; list = new ArrayList&lt;&gt;();

ContentResolver resolver = context.getContentResolver();
Cursor cursor = null;
try{
    cursor = resolver.query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,null,null,null,null);
    int i = 0;
    if(cursor!=null){
        while (cursor.moveToFirst()) {
            Log.d(TAG, &quot;getImage: got &quot;+i++);
            final ImageInfo imageInfo = new ImageInfo();
            imageInfo.id = cursor.getInt(cursor.getColumnIndex(MediaStore.Images.Media._ID));
            imageInfo.path = cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media.DATA));
            Log.d(TAG, &quot;getImage: &quot;+imageInfo.path);
            imageInfo.name = cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media.DISPLAY_NAME));
            imageInfo.bitmap = MediaStore.Images.Thumbnails.getThumbnail(resolver, imageInfo.id, MediaStore.Images.Thumbnails.MICRO_KIND, null);
            list.add(imageInfo);

        }
    }

}catch (Exception e){
    e.printStackTrace();
}

return list;
}

class ImageInfo{

int id ;
String path;
String name;
Bitmap bitmap;
}
</code></pre><h2 id="处理Bitmap"><a href="#处理Bitmap" class="headerlink" title="处理Bitmap"></a>处理Bitmap</h2><h3 id="compress"><a href="#compress" class="headerlink" title="compress"></a>compress</h3><ul>
<li>compress为质量压缩，不会丢失像素，只会降低图片的存储大小，而不会改变Bitmap的内存大小</li>
</ul>
<pre><code>OutputStream outputStream = new FileOutputStream(picFile);
bitmap.compress(Bitmap.CompressFormat.JPEG,50,outputStream);
outputStream.close();
</code></pre><ul>
<li>compress方法接受三个参数,图片类型，压缩比例，流对象，注意压缩比例是从最小质量到最大质量算起的，如果使用PNG格式，这个参数貌似是没有意义的</li>
</ul>
<pre><code>* @param format   The format of the compressed image
* @param quality  Hint to the compressor, 0-100. 0 meaning compress for
*                 small size, 100 meaning compress for max quality. Some
*                 formats, like PNG which is lossless, will ignore the
*                 quality setting
* @param stream   The outputstream to write the compressed data.
* @return true if successfully compressed to the specified stream.
*/
public boolean compress(CompressFormat format, int quality, OutputStream stream)
</code></pre><h3 id="inSampleSize"><a href="#inSampleSize" class="headerlink" title="inSampleSize"></a>inSampleSize</h3><ul>
<li><p>inSampleSize表示加载的图片的宽高相对于原始图片的比例，例如当这个值为2时，图片宽和高就为原始图片的1/2，因此内存占用降到里1/4，还是比较高效的一种方式</p>
</li>
<li><p>最简单的用法，创建一个option对象，设定它的inSampleSize值并传入BitmapFactory.decodeFile方法即可，inSampleSize最小值为1，且当其大于1时且不为偶数时会自动向下取偶然</p>
</li>
</ul>
<pre><code>BitmapFactory.Options options = new BitmapFactory.Options();
options.inSampleSize = 2;
Bitmap bitmap = BitmapFactory.decodeFile(path, options);
</code></pre><ul>
<li><p>但是我们在加载图片时常常不知道图片的尺寸大小，也就不知道是否需要压缩与压缩比例应该为多少，而将Bitmap加载进来再压缩又将毫无意义，好在Option提供了一个只加载宽和高的方法，获得宽高之后可以和我们需要的尺寸进行比较调整缩放比例</p>
<pre><code>BitmapFactory.Options options = new BitmapFactory.Options();
options.inSampleSize = 2;
options.inJustDecodeBounds =true;
Bitmap bitmap = BitmapFactory.decodeFile(path, options);
Log.d(TAG, &quot;onCreate: &quot;+options.outHeight+options.outWidth);
</code></pre></li>
<li><p>下面是一个Android提供的计算缩放比例的方法</p>
</li>
</ul>
<pre><code>int calculateInSampleSize(BitmapFactory.Options options,  int reqWidth, int reqHeight){

final int height = options.outHeight;

final int width  = options.outWidth;

int inSampleSize = 1 ;

if(reqWidth &lt; width || reqHeight &lt;height){

final int halfWidth = width / 2;

final int halfHeight = height / 2;

   // Calculate the largest inSampleSize value that is a power of 2 and keeps both        // height and width larger than the requested height and width.   

while( (halfWidth / inSampleSize &gt; reqWidth &amp;&amp; halfHeight / inSampleSize &gt; reqHeight){

    inSampleSize *= 2;

    }

    }

}
</code></pre><ul>
<li>除了通过压缩Bitmap减少内存占用以外，bitmap使用完之后最好进行回收，注意不要频繁进行gc，这样可能造成卡顿</li>
</ul>
<pre><code>if(bitmap != null &amp;&amp; !bitmap.isRecycled()){   
        bitmap.recycle();   
        bitmap = null;   
}   
System.gc();  
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HandlerThread 基本用法]]></title>
      <url>/2017/07/25/HandlerThread/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><ul>
<li><p>子线程不能直接创建Handler，所以当我们需要使用handler时必须先创建Looper</p>
<pre><code>Can&apos;t create handler inside thread that has not called Looper.prepare()
</code></pre></li>
</ul>
<ul>
<li>使用Looper.prepare之后创建Handler，这个handler可以处理其他线程中发送的消息，但是Looper.loop()之后的操作不会执行，因为looper开启了一个无限循环，它是一个阻塞操作</li>
</ul>
<pre><code>public void run(){
    super.run();
    Looper.prepare();
    mHandler = new Handler(){
        @Override
        public void handleMessage(Message msg) {
            super.handleMessage(msg);

            Log.d(TAG, &quot;handleMessage: &quot;+Thread.currentThread().getName()+&quot; &quot;+msg.what);
        }
    };
    Looper.loop();
    Log.d(TAG, &quot;behind loop&quot;);
}   
</code></pre><ul>
<li><p>要在子线程使用Handler，还有更方便的方法，使用HandlerThread，获取它的Looper</p>
<pre><code>HandlerThread  handlerThread = new HandlerThread(&quot;test thread&quot;);
        handlerThread.start();
        Handler handler = new Handler(handlerThread.getLooper()){

    @Override
    public void handleMessage(Message msg) {
        super.handleMessage(msg);
        Log.d(TAG, &quot;handleMessage: &quot;+Thread.currentThread());
        Log.d(TAG, &quot;handleMessage: &quot;+msg.what);
    }
};

handler.sendEmptyMessage(0);    

...
</code></pre></li>
</ul>
<pre><code>handlerThread.quit();
...

D/MainActivity: handleMessage: Thread[test thread,5,main]
D/MainActivity: handleMessage: 0
</code></pre><ul>
<li>我们可以把耗时操作放在handleMessage方法中执行，以分担主线程的工作</li>
</ul>
<pre><code>handler.post(new Runnable() {
    @Override
    public void run() {
        Log.d(TAG, &quot;run: -------------&quot;+Thread.currentThread());
    }
});
</code></pre><ul>
<li>在handlerMessage中发送延迟消息，可以实现定时操作的功能</li>
</ul>
<pre><code>public void handleMessage(Message msg)
    {
        doSomething();
        if (!stop)
        {
            handler.sendEmptyMessageDelayed(DO_SOMETHING, 1000);
        }
</code></pre><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><ul>
<li>HandlerThread的源码比较简短，HandlerThread有两个 构造方法，在不传入优先级的情况下会使用默认的优先级5</li>
</ul>
<pre><code>public class HandlerThread extends Thread {
    int mPriority;
    int mTid = -1;
    Looper mLooper;

    public HandlerThread(String name) {
        super(name);
        mPriority = Process.THREAD_PRIORITY_DEFAULT;
    }

 /**
    * Constructs a HandlerThread.
    * @param name
    * @param priority The priority to run the thread at. The value supplied must be from 
    * {@link android.os.Process} and not from java.lang.Thread.
    */
    public HandlerThread(String name, int priority) {
        super(name);
        mPriority = priority;
    }
</code></pre><ul>
<li>查看run方法，发现这里调用了Looper.prepare()和Looper.loop()方法创建了looper，这就是使用HandlerThread只需要调用start方法就可以获得Looper的原因</li>
</ul>
<pre><code>@Override
public void run() {
    mTid = Process.myTid();
    Looper.prepare();
    synchronized (this) {
        mLooper = Looper.myLooper();
        notifyAll();
    }
    Process.setThreadPriority(mPriority);
    onLooperPrepared();
    Looper.loop();
    mTid = -1;
}
</code></pre><ul>
<li>在创建Looper时会创建一个消息队列，Looper.loop则会开启循环处理消息，这部分之前了解过不再重复了</li>
</ul>
<pre><code>    private Looper(boolean quitAllowed) {
mQueue = new MessageQueue(quitAllowed);
mThread = Thread.currentThread();
    }
</code></pre><ul>
<li>在我们用来获得looper的方法getLooper中，为了保证Looper已经创建完毕，会调用wait()进行等待</li>
</ul>
<pre><code> public Looper getLooper() {
     if (!isAlive()) {
         return null;
        }

// If the thread has been started, wait until the looper has been created.
synchronized (this) {
    while (isAlive() &amp;&amp; mLooper == null) {
        try {
            wait();
        } catch (InterruptedException e) {
        }
    }
}
return mLooper;
}
</code></pre><ul>
<li><p>停止消息循环，有两个方法quit和quitSafely，它们分别调用了looper的同名方法，而这两个方法都调用到了MessageQueue中的quit方法，只是传入的参数不同而已</p>
<pre><code>//in HandlerThread
    public boolean quit() {
        Looper looper = getLooper();
        if (looper != null) {
            looper.quit();
            return true;
        }
        return false;
    }
</code></pre></li>
</ul>
<pre><code>        public boolean quitSafely() {
            Looper looper = getLooper();
            if (looper != null) {
                looper.quitSafely();
                return true;
            }
            return false;
        } 

        //in MessageQueue
            void quit(boolean safe) {
    if (!mQuitAllowed) {
        throw new IllegalStateException(&quot;Main thread not allowed to quit.&quot;);
    }

    synchronized (this) {
        if (mQuitting) {
            return;
        }
        mQuitting = true;

        if (safe) {
            removeAllFutureMessagesLocked();
        } else {
            removeAllMessagesLocked();
        }

        // We can assume mPtr != 0 because mQuitting was previously false.
        nativeWake(mPtr);
    }
}
</code></pre><ul>
<li><p>可以看到quit和quitSafely最终的区别在于MessageQueue调用removeAllFutureMessagesLocked方法还是removeAllMessagesLocked方法，在removeAllMessagesLocked中只是简单地遍历单链表并回收消息结点而已，而removeAllFutureMessagesLocked中使用判断条件n.when > now 跳过了所有非延迟的消息，也就是说不管是使用quit还是quitSafely，队列中都不会再添加消息，但是quitSafely处理完队列中的非延迟消息，到这里就过完HandlerThread的源码了</p>
<pre><code> private void removeAllMessagesLocked() {
Message p = mMessages;
while (p != null) {
    Message n = p.next;
    p.recycleUnchecked();
    p = n;
}
mMessages = null;
}

    private void removeAllFutureMessagesLocked() {
final long now = SystemClock.uptimeMillis();
Message p = mMessages;
if (p != null) {
    if (p.when &gt; now) {
        removeAllMessagesLocked();
    } else {
        Message n;
        for (;;) {
            n = p.next;
            if (n == null) {
                return;
            }
            if (n.when &gt; now) {
                break;
            }
            p = n;
        }
        p.next = null;
        do {
            p = n;
            n = p.next;
            p.recycleUnchecked();
        } while (n != null);
    }
}
    }
</code></pre></li>
</ul>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Animation 的三种实现方法]]></title>
      <url>/2017/07/25/Animation/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<h2 id="属性动画"><a href="#属性动画" class="headerlink" title="属性动画"></a>属性动画</h2><ul>
<li>补间动画只能改变View的显示效果，并不会改变View的属性，View的形状位置发生改变，点击事件的响应区域并不会跟着变化</li>
</ul>
<ul>
<li>ValueAnimator是属性动画中最核心的类，它提供了两个比较重要的监听器，其中AnimatorListener中的四个方法分别会在动画开始，结束，循环，取消时被调用，而AnimatorUpdateListener的onAnimationUpdate方法会在动画的每一帧被调用，想要实现动画效果，必须实现onAnimationUpdate方法</li>
</ul>
<pre><code>new Animator.AnimatorListener() {
    @Override
    public void onAnimationStart(Animator animation) {

    }

    @Override
    public void onAnimationEnd(Animator animation) {

    }

    @Override
    public void onAnimationCancel(Animator animation) {

    }

    @Override
    public void onAnimationRepeat(Animator animation) {

    }
};

new ValueAnimator.AnimatorUpdateListener() {
    @Override
    public void onAnimationUpdate(ValueAnimator animation) {

    }
};
</code></pre><ul>
<li>ValueAnimator能够在一段时间中为我们提供渐变的值，这些值本身不会对控件造成任何影响，不过我们能够使用这些值和监听器去改变控件的属性从而实现动画效果，下面实现一个位移动画。要点在于使用ofInt方法获得animator对象，在onAnimationUpdate使用它的getAnimatedValue得到不断改变的值去设定layout属性。</li>
</ul>
<pre><code>final ValueAnimator animator = ValueAnimator.ofInt(0,200);
animator.setDuration(3000);
animator.setRepeatCount(3);
animator.setRepeatMode(ValueAnimator.REVERSE);

animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
    @Override
    public void onAnimationUpdate(ValueAnimator animation) {
        int value = (int)animator.getAnimatedValue();
        ViewGroup.MarginLayoutParams marginLayoutParams = (ViewGroup.MarginLayoutParams) imageView.getLayoutParams();
        marginLayoutParams.leftMargin = value;
        imageView.setLayoutParams(marginLayoutParams);
    }
});
animator.setTarget(imageView);
animator.start();
</code></pre><ul>
<li>接着实现一个响应按钮点击事件弹出或关闭ListView的方法</li>
</ul>
<pre><code>    button.setOnClickListener(new View.OnClickListener(){
        @Override
        public void onClick(View v) {
            hideOrShowListView();
        }
    });
}
</code></pre><ul>
<li>逻辑和前者基本一致，不过在方法里进行了关于ListView高度状态的判断，注意如果使用LinearLayout，由于布局的特性，ListView弹出之后其他控件的位置会跟着改动，使用FrameLayout和RelativeLayout可以实现”覆盖”的效果，并且指定了layout_alignParentBottom属性的情况下可以让ListView从下往上弹出，另外ListView的背景最好不要透明</li>
</ul>
<pre><code>public static final int LIST_HEIGHT = 300;
public void hideOrShowListView(){

final ValueAnimator mAnimator;

if(listView.getHeight()==LIST_HEIGHT) {
    mAnimator = ValueAnimator.ofInt(LIST_HEIGHT, 0);
}else {
    mAnimator = ValueAnimator.ofInt(0, LIST_HEIGHT);
}

mAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
    @Override
    public void onAnimationUpdate(ValueAnimator animation) {

        listView.getLayoutParams().height = (int)animation.getAnimatedValue();
        listView.setLayoutParams(listView.getLayoutParams());
        Log.d(TAG, &quot;onAnimationUpdate: &quot; +listView.getHeight());

    }
});
mAnimator.start();
}
</code></pre><h2 id="ObjectAnimator"><a href="#ObjectAnimator" class="headerlink" title="ObjectAnimator"></a>ObjectAnimator</h2><ul>
<li>ObjectAnimator对ValueAnimator进行了封装，使用更加方便</li>
</ul>
<ul>
<li>这里使用到了PropertyName，它指定了控件需要改变的属性，包括alpha，scaleX等</li>
</ul>
<ul>
<li>使用插值器Interpolator可以改变数值变化的效果，官方提供了多种插值器，实现插值器涉及较多数学方面的内容，需要时再<a href="http://blog.csdn.net/xiaochuanding/article/details/73200149" target="_blank" rel="external">查找</a>即可</li>
</ul>
<pre><code>ObjectAnimator animator = ObjectAnimator.ofInt(button,
           &quot;backgroundColor&quot;, Color.RED, Color.GREEN, Color.BLUE,
           Color.GREEN);
   animator.setDuration(300);
   animator.setRepeatCount(3);
   animator.setInterpolator(new DecelerateInterpolator());
   animator.setRepeatMode(ValueAnimator.REVERSE);
   animator.start();
</code></pre><h2 id="补间动画"><a href="#补间动画" class="headerlink" title="补间动画"></a>补间动画</h2><ul>
<li>AlphaAnimation，渐变动画，四种补间动画的设置方法基本一致</li>
</ul>
<pre><code>Animation alphaAnimation = new AlphaAnimation(0, 1); //传入开始和结束时的透明度，0~1
alphaAnimation.setDuration(3000);//持续时间
alphaAnimation.setFillAfter(true);//是否停留在执行完的状态
alphaAnimation.setRepeatCount(2);//重复次数
alphaAnimation.setStartOffset(1000);//执行前的等待时间
imageView.startAnimation(alphaAnimation);
</code></pre><ul>
<li>RotateAnimation，旋转动画</li>
</ul>
<pre><code>Animation rotateAnimation = new RotateAnimation(0,45);//传入开始和结束时的角度
rotateAnimation.setDuration(3000);
imageView.startAnimation(rotateAnimation);   
</code></pre><ul>
<li>ScaleAnimation，伸缩动画</li>
</ul>
<pre><code>ScaleAnimation scaleAnimation = new ScaleAnimation(0.5f,1.0f,1.0f,1.0f);//传入开始和结束时的伸缩比例
    scaleAnimation.setDuration(3000);
    imageView.startAnimation(scaleAnimation);
</code></pre><ul>
<li>TranslateAnimation，位移动画</li>
</ul>
<pre><code>TranslateAnimation translateAnimation = new TranslateAnimation(0,100,0,0);//传入开始和结束时的位置
translateAnimation.setDuration(3000);
imageView.startAnimation(translateAnimation);
</code></pre><ul>
<li>AnimationSet，混合动画，同时执行一系列的动画</li>
</ul>
<pre><code>AnimationSet animationSet = new AnimationSet(true);
animationSet.addAnimation(scaleAnimation);
  animationSet.addAnimation(rotateAnimation);
  animationSet.addAnimation(scaleAnimation);
  imageView.startAnimation(animationSet);
</code></pre><ul>
<li>也可以在XML中设置动画属性， 创建anim文件夹添加XML文件，使用AnimationUtils.loadAnimation获取实例即可</li>
</ul>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;alpha xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:duration=&quot;500&quot;
    android:fillAfter=&quot;false&quot;
    android:fromAlpha=&quot;1.0&quot;
    android:toAlpha=&quot;0.0&quot; /&gt;
    Animation alphaAnimation = AnimationUtils.loadAnimation(this,R.anim.animation);
</code></pre><h2 id="帧动画"><a href="#帧动画" class="headerlink" title="帧动画"></a>帧动画</h2><ul>
<li>逐帧动画用于一张张地播放图片，一般用于实现较简单的动画效果，不建议设置帧数过多的逐帧动画</li>
</ul>
<ul>
<li>在drawable文件夹中</li>
</ul>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
android:oneshot=&quot;false&quot;&gt;

&lt;item
android:drawable=&quot;@drawable/img_1&quot;
android:duration=&quot;200&quot; /&gt;
&lt;item
android:drawable=&quot;@drawable/img_2&quot;
android:duration=&quot;200&quot; /&gt;
&lt;item
android:drawable=&quot;@drawable/img_3&quot;
android:duration=&quot;200&quot; /&gt;

&lt;/animation-list&gt;
</code></pre><ul>
<li>在java代码中，注意不要直接在onCreate中开启动画，Window初始化完毕时动画才可能播放，因此可以在onWindowFocusChanged中开启</li>
</ul>
<pre><code>imageView.setImageResource(R.drawable.animation);
AnimationDrawable animationDrawable = (AnimationDrawable) imageView.getDrawable();
animationDrawable.start();
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 控件架构与自定义View]]></title>
      <url>/2017/07/24/View/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<h2 id="android-控件架构"><a href="#android-控件架构" class="headerlink" title="android 控件架构"></a>android 控件架构</h2><ul>
<li>每一个Activity包含一个PhoneWindow对象，它是Window抽象类的唯一实现，PhoneWindow将DectorView作为整个窗口的根View，DectoView只含有一个LinearLayout，其中包含了两个子View，分别是TitleView和ContentView，ContentView为一个FrameLayout，onCreate方法中的setContentView就是把我们的布局添加到ContentView上</li>
</ul>
<p><img src="http://img.mukewang.com/568b5f2d0001c42a11300576.png" alt=""></p>
<h3 id="MeasureSpec"><a href="#MeasureSpec" class="headerlink" title="MeasureSpec"></a>MeasureSpec</h3><ul>
<li>MeasureSpec是一个32位int值，高二位用来表示SpecMode，低30位用来表示SpecSize，SpecMode有三个可能的值UNSPECIFIED，EXACTLY，AT_MOST，view的大小由父布局的属性和MeasureSpec共同决定</li>
</ul>
<pre><code>/**
 * Measure specification mode: The parent has not imposed any constraint
 * on the child. It can be whatever size it wants.
 */
public static final int UNSPECIFIED = 0 &lt;&lt; MODE_SHIFT;

/**
 * Measure specification mode: The parent has determined an exact size
 * for the child. The child is going to be given those bounds regardless
 * of how big it wants to be.
 */
public static final int EXACTLY     = 1 &lt;&lt; MODE_SHIFT;

/**
 * Measure specification mode: The child can be as large as it wants up
 * to the specified size.
 */
public static final int AT_MOST     = 2 &lt;&lt; MODE_SHIFT;
</code></pre><ul>
<li><p>UNSPECIFIED，view的大小不受父布局的限制，view想要多大就多大</p>
</li>
<li><p>EXACTLY，对应match_parent和精确数字的布局大小，是父布局测量出来的SpecSize值</p>
</li>
<li><p>AT_MOST，父布局指定SpecSize，view不能超过SpecSize规定的大小</p>
</li>
</ul>
<h3 id="View的工作流程"><a href="#View的工作流程" class="headerlink" title="View的工作流程"></a>View的工作流程</h3><ul>
<li><p>measure，测量View的尺寸,一个ViewGroup会遍历调用子View的测量方法，子View再递归地去执行测量，最终的到所有元素的大小</p>
<pre><code>protected void measureChild(View child, int parentWidthMeasureSpec,

...

child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
}
</code></pre></li>
</ul>
<ul>
<li>layout，确定子View的位置，layout()会确定View本身的位置而onLayout会确定所有子View的位置，和measure的逻辑类似。onLayout，方法由具体的布局去实现，所有ViewGroup的子类都必须去重写这个方法。在layout中可以发现view的位置由四种属性构成，它们分别表示view相对于父布局的位置，left是左上角的横坐标，top是左上角的纵坐标，right是右下角的横坐标，bottom是右下角的纵坐标，x和y轴的的正方向为右和下</li>
</ul>
<pre><code>* @param l Left position, relative to parent
* @param t Top position, relative to parent
* @param r Right position, relative to parent
* @param b Bottom position, relative to parent

int oldL = mLeft;
int oldT = mTop;
int oldB = mBottom;
int oldR = mRight;
boolean changed = setFrame(l, t, r, b);  
</code></pre><ul>
<li>draw，view的绘制 ，主要包括绘制背景，View本身，子View，装饰四个步骤，其中dispatchDraw用于遍历所有子View并绘制</li>
</ul>
<pre><code>/*
    * Draw traversal performs several drawing steps which must be executed
    * in the appropriate order:
    *
    *      1. Draw the background
    *      2. If necessary, save the canvas&apos; layers to prepare for fading
    *      3. Draw view&apos;s content
    *      4. Draw children
    *      5. If necessary, draw the fading edges and restore layers
    *      6. Draw decorations (scrollbars for instance)
    *   /

// Step 1, draw the background, if needed
int saveCount;
if (!dirtyOpaque) {
    drawBackground(canvas);
}

// skip step 2 &amp; 5 if possible (common case)
final int viewFlags = mViewFlags;
boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0;
boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0;
if (!verticalEdges &amp;&amp; !horizontalEdges) {

    // Step 3, draw the content
    if (!dirtyOpaque) onDraw(canvas);

    // Step 4, draw the children
    dispatchDraw(canvas);

    // Overlay is part of the content and draws beneath Foreground
    if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) {
        mOverlay.getOverlayView().dispatchDraw(canvas);
    }

    // Step 6, draw decorations (foreground, scrollbars)
    onDrawForeground(canvas);
</code></pre><ul>
<li>自定义布局，需要实现onMeasure方法和onLayout方法，在onMeasure方法中需要测量出子View的大小，在onLayout中可以通过子View的getMeasuredWidth方法和getMeasuredHeighet方法得到在onMeasure中测量出来的大小。调用子View的layout方法我们可以设定它在这个父布局中的位置，注意如果四个点之间的相对位置和原来子View不同，它就会被拉伸</li>
</ul>
<pre><code>public class MyLayout extends ViewGroup {

public MyLayout(Context context, AttributeSet attrs) {
    super(context, attrs);
}

@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
        if(getChildCount()&gt;0){
        View child = getChildAt(0);
        measureChild(child,widthMeasureSpec,heightMeasureSpec);
    }
}

@Override
protected void onLayout(boolean changed, int l, int t, int r, int b) {

    if(getChildCount()&gt;0){
        View child = getChildAt(0);
        child.layout(0,0,child.getMeasuredWidth(),child.getMeasuredHeight());
    }
}
}
</code></pre><ul>
<li>重写onDraw，通过Paint和Canvas对象绘制图像，在onLayout方法执行之后可以通过getWidth方法和getHeigh方法得到View的实际显示的宽和高</li>
</ul>
<pre><code>@Override
protected void onDraw(Canvas canvas){

mPaint.setColor(Color.GREEN);
canvas.drawRect(0,0,getWidth(),getHeight(),mPaint);

mPaint.setColor(Color.YELLOW);
canvas.drawOval(20,20,getWidth()/2,getHeight()/2,mPaint);

}
</code></pre><h2 id="自定义View"><a href="#自定义View" class="headerlink" title="自定义View"></a>自定义View</h2><h3 id="attrs-属性"><a href="#attrs-属性" class="headerlink" title="attrs 属性"></a>attrs 属性</h3><ul>
<li>当使用控件时我们可以设定系统提供的layout_width等属性值，为了能够使用自定义的属性，需要在values文件中加入attrs.xml文件</li>
</ul>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;resources&gt;
    &lt;declare-styleable name=&quot;test_attrs&quot;&gt;
        &lt;attr name=&quot;myColor&quot; format=&quot;color&quot;/&gt;
        &lt;attr name=&quot;mySize&quot; format=&quot;dimension&quot;/&gt;
        &lt;attr name=&quot;myFlag&quot; format=&quot;boolean&quot;/&gt;
    &lt;/declare-styleable&gt;
&lt;/resources&gt;    
</code></pre><ul>
<li>在布局文件中声明名称空间</li>
</ul>
<pre><code>xmlns:test_view = &quot;http://schemas.android.com/apk/res-auto&quot;
</code></pre><ul>
<li>在控件属性中设置变量值，注意名称空间不需要与attrs中的name属性相同，但是变量的名称一定要能够与attrs中的匹配</li>
</ul>
<pre><code>&lt;com.linjiamin.viewtest.MyView
    android:layout_width=&quot;200dp&quot;
    android:layout_height=&quot;200dp&quot;
    test_view:myColor=&quot;#000000&quot;&gt;
</code></pre><ul>
<li><p>在java文件中，使用context的obtainStyledAttributes方法获取TypedArray对象，再将属性值在typedArray当中取出，注意typedArray对象使用完之后必须回收</p>
<pre><code>    public MyView(Context context, @Nullable AttributeSet attrs) {
        super(context, attrs);
        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
        mContext = context;
        TypedArray typedArray = mContext.obtainStyledAttributes(attrs,R.styleable.test_attrs2);
    mColor = typedArray.getColor(R.styleable.test_attrs2_myColor2,Color.BLUE);
    typedArray.recycle();
}
</code></pre></li>
</ul>
<h3 id="继承View"><a href="#继承View" class="headerlink" title="继承View"></a>继承View</h3><ul>
<li>重写构造方法，获取XML中的属性值</li>
</ul>
<pre><code>public MyTextView(Context context, @Nullable AttributeSet attrs) {
super(context, attrs);
TypedArray typedArray = context.obtainStyledAttributes(attrs,R.styleable.my_text_view);
mColor = typedArray.getColor(R.styleable.my_text_view_text_color, Color.BLUE);
mbackColor = typedArray.getInteger(R.styleable.my_text_view_background_color,Color.BLUE);
mSize = typedArray.getInteger(R.styleable.my_text_view_text_size,10);
mContent = typedArray.getString(R.styleable.my_text_view_text_content);
mPaint = new Paint();
mPaint.setTextSize(mSize);
typedArray.recycle();

}
</code></pre><ul>
<li><p>重写onMeasure，当长宽属性为wrap_content及AT_MOST时，我们需要自己实现测量的逻辑</p>
<pre><code>@Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    int widthMode = MeasureSpec.getMode(widthMeasureSpec);
        int heightMode = MeasureSpec.getMode(heightMeasureSpec);
        int width = MeasureSpec.getSize(widthMeasureSpec);
    int heigeht = MeasureSpec.getSize(heightMeasureSpec);

if(widthMode == MeasureSpec.AT_MOST){

    mPaint.setTextSize(mSize);
    mPaint.getTextBounds(mContent,0,mContent.length(),mBound);
    width = getPaddingLeft()+ getPaddingEnd() +mBound.width();

}

if(heightMode == MeasureSpec.AT_MOST){

    mPaint.setTextSize(mSize);
    mPaint.getTextBounds(mContent,0,mContent.length(),mBound);
    heigeht = getPaddingTop()+ getPaddingBottom() +mBound.height();
}

setMeasuredDimension(width,heigeht);
</code></pre><p>  }</p>
</li>
<li>重写onDraw，使canvas和paint对象绘制<br>  @Override<br>  protected void onDraw(Canvas canvas) {<pre><code>mPaint.setColor(mbackColor);
canvas.drawRect(0,0,getWidth(),getHeight(),mPaint);
mPaint.setColor(mColor);
canvas.drawText(mContent,getWidth()/2-mBound.width()/2,getHeight()/2,mPaint);
}
</code></pre>  }</li>
</ul>
<h2 id="继承特定的View"><a href="#继承特定的View" class="headerlink" title="继承特定的View"></a>继承特定的View</h2><ul>
<li><p>我们想为已有的View类添加新特性的时候，可以继承这个view类，下面实现一个右上角带有选择框的ImageView</p>
<pre><code>private boolean checked = false;
private Bitmap mCheckedImage;
private Bitmap mUncheckImage;
private Paint mPaint;
private Rect mRect;
private static final String TAG = &quot;CheckableImageView&quot;;

public CheckableImageView(Context context, AttributeSet attrs) {
super(context, attrs);

mCheckedImage = BitmapFactory.decodeResource(getResources(),R.drawable.checked);
mUncheckImage = BitmapFactory.decodeResource(getResources(),R.drawable.uncheck);

mPaint = new Paint();
mRect = new Rect();
}
</code></pre></li>
<li><p>在onDraw方法中添加需要绘制的内容，其余操作交回给父类去处理</p>
<pre><code>public void onDraw(Canvas canvas){

super.onDraw(canvas);
mRect.left = getWidth()-mUncheckImage.getWidth();
mRect.right = getWidth();
mRect.top = 0;
mRect.bottom = mUncheckImage.getHeight();

if(checked)
    canvas.drawBitmap(mCheckedImage,null, mRect, mPaint);

else canvas.drawBitmap(mUncheckImage,null, mRect, mPaint);
}
</code></pre></li>
<li><p>处理点击事件，注意最好不要直接使用setOnClickListener方法，而是在onTouchEvent中处理点击事件，需要调用父类的方法并返回true，返回false时onTouchEvent中的操作不会执行</p>
<pre><code>@Override
public boolean onTouchEvent(MotionEvent event) {

int action = event.getAction();

super.onTouchEvent(event);
switch (action) {

    case MotionEvent.ACTION_DOWN:
        break;
    case MotionEvent.ACTION_MOVE:
        break;
    case MotionEvent.ACTION_UP:

        checked = !checked;
        invalidate();
        Log.d(TAG, &quot;onTouchEvent: &quot;);

        break;
    }
return true;
}
</code></pre></li>
<li><p>另外还可以创建一个listener,并提供一个set方法，在onTouchEvent中调用listener的方法</p>
<pre><code>private OnCheckListener listener;

    public CheckableImageView(Context context, AttributeSet attrs) {
super(context, attrs);

...

setOnCheckedListener(new OnCheckListener() {
    @Override
    public void onCheck() {
        Log.d(TAG, &quot;onCheck: &quot;);
    }
}); 
}

public interface OnCheckListener{
void onCheck();
}
</code></pre></li>
</ul>
<ul>
<li><p>最后像原本的view一样去使用它即可</p>
<pre><code>&lt;com.linjiamin.CheckableImageView
 android:id=&quot;@+id/item_image&quot;
 android:layout_alignParentEnd=&quot;true&quot;
 android:layout_width=&quot;100dp&quot;
 android:layout_height=&quot;100dp&quot;
 android:padding=&quot;8dp&quot;
 android:contentDescription=&quot;@string/desc&quot;/&gt;
</code></pre></li>
<li><p><img src="http://i2.kiimg.com/1949/599504b74c0fd397.png" alt=""></p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[工厂模式与单例模式]]></title>
      <url>/2017/07/20/Pattern/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><br></p>
<h2 id="静态工厂方法"><a href="#静态工厂方法" class="headerlink" title="静态工厂方法"></a>静态工厂方法</h2><p><br></p>
<h3 id="使用静态工厂方法代替构造器"><a href="#使用静态工厂方法代替构造器" class="headerlink" title="使用静态工厂方法代替构造器"></a>使用静态工厂方法代替构造器</h3><p><strong>对于类而言，获取实例的手段无非两个，构造器和静态工厂方法</strong></p>
<ul>
<li>静态工厂方法的优点在于它是有名字的，一个签名只能对应一个构造器，对于相同参数的构造器我们只能通过修改参数列表的位置进行扩展，而且构造器较多时往往会造成混乱</li>
<li>静态工厂方法不必每次都创造对象，可以使用预先构建好的实例</li>
<li>静态工厂方法可以返回任何子类型的对象</li>
</ul>
<p><br></p>
<h3 id="静态工厂模式"><a href="#静态工厂模式" class="headerlink" title="静态工厂模式"></a>静态工厂模式</h3><ul>
<li>静态工厂模式包含一个具体的工厂类，一个抽象的产品类，不限数量的具体产品类</li>
<li>当我们有较多的产品类时，通常的这些产品会是一个树形结构，但是这时相同的逻辑很难复用，所有静态工厂方法模式有时并不理想</li>
</ul>
<p><br></p>
<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><ul>
<li>工厂方法模式是对静态工厂模式的扩展，它包含一个抽象工厂类，一个抽象象产品类，不限数量的具体产品类和具体工厂类</li>
<li>抽象的工厂类定义了规范，每一个具体的产品对应一个具体的工厂类，这样使得需求增加时只要再实现工厂类即可</li>
<li>这种方法通常只针对的单一产品结构，当我们需要多种差别较大的实例时会导致具体工厂的数量非常多，这时回使用抽象工厂方法</li>
</ul>
<p><br></p>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><ul>
<li>抽象工厂模式与工厂方法模式的不同在于它有多个抽象产品类而且每个具体的工厂类可以产生多个具体产品类的实例</li>
<li>这种模式是高度解耦的，但是当抽象产品类的数量较少时它实际上回退化为工厂方法模式，所以实际上并不是越抽象就越好，而要看实际的情况来使用</li>
</ul>
<p><br></p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p><strong>单例模式指的时同一时刻一个类最多只存在一个实例，并且这个唯一实例由类自己创建并提供给其他对象</strong></p>
<p><br></p>
<h3 id="懒汉式单例"><a href="#懒汉式单例" class="headerlink" title="懒汉式单例"></a>懒汉式单例</h3><ul>
<li>懒汉式单例指的是一个类只有到有需要时才去创建单例，在这之前让它一直为null，这里使用了私有的构造器，并让这个类持有自己的实例，只有这个引用为null且外界调用了静态工厂方法时才去创建实例</li>
</ul>
<pre><code>public class Singleton {  
    private static Singleton singleton=null;

    private Singleton() {
        }  

    public static Singleton getInstance() {  
        if (singleton == null) {    
        singleton = new Singleton();  
        }    
        return singleton;  
    }  
}  
</code></pre><ul>
<li>考虑到线程安全的问题，为这个方法加上锁，这样每次获取对象时都会受到同步锁的影响</li>
</ul>
<pre><code>public static synchronized Singleton getInstance() {  
    if (singleton == null) {    
    single = new Singleton();  
    }    
    return singleton;  
}  
</code></pre><ul>
<li>synchronized(ClassName.class)这种写法可以时同一时刻只有一个线程可以访问这个类的实例，但是这样又产生了问题如果两个线程同时进行了判空，这时就会产生两个实例</li>
</ul>
<pre><code>Public static Singleton getInstance(){
    If(singleton == null){
        Synchronized(singleton.class){
                    Singleton = new Singleton();
            }
        return singleton;  
    }
}   
</code></pre><ul>
<li>因此这里再检查一遍防止有多余的实例产生</li>
</ul>
<pre><code>public static Singleton getInstance() {  
        if (singleton == null) {    
            synchronized (Singleton.class) {    
            if (singleton == null) {    
                singleton = new Singleton();   
            }    
        }    
    }    
    return singleton;   
}  
</code></pre><ul>
<li>还有另一种懒汉式的单例，它使用了利用了类加载机制的特点，对应JVM来说外部类和内部类是同等的类，类加载时方法不会被调用，当我们调用getInstance时内部类才会加载进来，这时才会去初始化，而类加载只进行一次，所以它是懒汉式单例</li>
</ul>
<pre><code>public class Singleton {  
    private static class SingletonHolder {  
    private static final Singleton INSTANCE = new   Singleton();  
    }  
    private Singleton (){}  
    public static final Singleton getInstance() {  
    return SingletonHolder.INSTANCE;  
    }  
}  
</code></pre><p><br></p>
<h3 id="饿汉式单例"><a href="#饿汉式单例" class="headerlink" title="饿汉式单例"></a>饿汉式单例</h3><ul>
<li>饿汉式单例指的是类的实例在获取之前就初始化，根据类加载的机制在类创建时创建实例，由于类只会加载一次，所以只会有一个实例</li>
</ul>
<pre><code>public class Singleton {  
    private static Singleton singleton = new Singleton();  
    private Singleton (){}  
    public static Singleton getInstance() {  
    return singleton;  
    }  
}  
</code></pre><ul>
<li>下面这种方式使用了静态域，本质上和上一种没有区别</li>
</ul>
<pre><code>public class Singleton {  
    private Singleton instance = null;  
    static {  
    instance = new Singleton();  
    }  
    private Singleton (){}  
    public static Singleton getInstance() {  
    return this.instance;  
    }  
}   
</code></pre><ul>
<li>通过枚举来实现单例是最简洁的，枚举可以含有私有的构造器，同时枚举有保证了内部只会有一个实例</li>
</ul>
<pre><code>private static enum Singleton{
    INSTANCE;

    private EnumSingleton singleton;

    private Singleton(){
        singleton = new EnumSingleton();
    }
    public EnumSingleton getInstance(){
    return singleton;
    }
}           
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java 注解入门]]></title>
      <url>/2017/07/20/Annotation/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<h2 id="元数据与注解"><a href="#元数据与注解" class="headerlink" title="元数据与注解"></a>元数据与注解</h2><ul>
<li>元数据用来描述代码之间以及代码与所使用的资源之间的关系</li>
<li>从JDK 5.0之后java 有了四种类型，class，enum，interface，@interface，@interface就是注解，java通过注解来表示元数据</li>
<li>元数据只是一种描述数据的数据，所以注解本身除了定义信息外其实什么都没做，它和业务逻辑没有关系，当我们使用@Override却没有重写父类的方法，编译器会报错，当我们使用<a href="http://blog.csdn.net/zcxwww/article/details/52205832" target="_blank" rel="external">ButterKnife</a>这种工具时会有类文件被自动生成…这些都不是注解负责的，它们主要交由<a href="http://blog.csdn.net/u013045971/article/details/53509237" target="_blank" rel="external">解析工具</a>或者是编译工具等消费器来处理</li>
</ul>
<h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><ul>
<li>元注解是描述其他注解的注解，元注解本身也由元注解描述</li>
</ul>
<pre><code>@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.ANNOTATION_TYPE})
public @interface Inherited {
}

@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.ANNOTATION_TYPE})
public @interface Retention {
    RetentionPolicy value();
}
...
</code></pre><ul>
<li>@Retention，描述了注解的生命周期长度，可能的值有：</li>
</ul>
<pre><code>SOURCE：只会保留在源代码中
CLASS: 驻留在CLASS文件中，但会被JVM在运行时忽略，运行时不可见
RUNTIME：可以在运行时通过反射获取
</code></pre><ul>
<li>@Target，注解可以用在代码的任何地方，使用@Target可以进行限制，约束使用的范围</li>
</ul>
<pre><code>ElementType.TYPE:只能描述类、接口或enum
ElementType.FIELD:只能描述实例变量
ElementType.METHOD:只能描述方法
ElementType.PARAMETER:只能描述方法的参数
ElementType.CONSTRUCTOR:只能描述构造器
ElementType.LOCAL_VARIABLE:只能描述局部变量
ElementType.ANNOTATION_TYPE:只能描述另一个注释
ElementType.PACKAGE: 只能描述包名 
</code></pre><ul>
<li>@Documented，表示在生成JavaDoc文档时，注解也会出现在文档当中</li>
<li>@Inherited ，使注解的信息会被标注了这个注解的类的子类继承</li>
</ul>
<h2 id="內建注解"><a href="#內建注解" class="headerlink" title="內建注解"></a>內建注解</h2><ul>
<li>java提供了三种内建注解</li>
<li>@Override，告诉编译器该方法重写了父类方法</li>
</ul>
<pre><code>@Target({ElementType.METHOD})
@Retention(RetentionPolicy.SOURCE)
public @interface Override {
}
</code></pre><ul>
<li><p>Deprecated，告诉编译器该方法不推荐使用，使用它时应该提供充分的说明和替代方案</p>
</li>
<li><p>SuppressWarnings，用于忽略警告信息，需要提供一个字符串值进行说明</p>
</li>
</ul>
<pre><code>@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.CONSTRUCTOR, ElementType.FIELD, ElementType.LOCAL_VARIABLE, ElementType.METHOD, ElementType.PACKAGE, ElementType.PARAMETER, ElementType.TYPE})
public @interface Deprecated {
}
</code></pre><h2 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h2><ul>
<li>注解需要用@interface指示，内部属性只支持基本类型，String类型、枚举类型、Class类型，Annotation和这些类型的数组，所有这些属性都使用方法来定义，并且可以提供一个默认值 </li>
</ul>
<pre><code>@Inherited
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Hello {
    String author() default &quot;Albert&quot;;
    public enum Priority {ONE, TOW, THREE}
    Hello.Priority priority() default Hello.Priority.ONE;
    String[] strs() default {&quot;1&quot;,&quot;2&quot;,&quot;3&quot;};
    int i() default 1;
    float f() default (float)2.0;
    double d() default 3.0;
    boolean b() default false;
    Class  c() default Void.class;
    AnnotationTest a();
}
</code></pre><ul>
<li>使用注解，注解只能标注于Target指定的类型之前，在括号中为属性赋值，如果某个属性没有默认值，则它必须被赋值，如果注解只有一个属性，那么使用时赋值可以不用指定属名称，但内部必须将它的名称指定为value</li>
</ul>
<pre><code>@Hello(d = 2.0)
    public static String helloWorld(){

    }
...

public @interface Hello2 {

    double value() default 3.0;

}

@Hello2(2.0)
public static String helloWorld2(){

}
</code></pre><h2 id="获取注解属性"><a href="#获取注解属性" class="headerlink" title="获取注解属性"></a>获取注解属性</h2><ul>
<li>使用反射我们可以得到一个类中所有注解的属性值，这里随便找了一个类进行测试</li>
</ul>
<pre><code>public static void getInfo() {

Class&lt;GetDate&gt; annotationDemoClass = GetDate.class;
for (Method method : annotationDemoClass.getMethods()) {
    Hello hello = (Hello) method.getAnnotation(Hello.class);
    if (hello != null) {
        Log.d(TAG, &quot;getInfo: &quot;+method.getName());
        Log.d(TAG, &quot;getInfo: &quot;+hello.b());
        Log.d(TAG, &quot;getInfo: &quot;+hello.c());
        }
    }
} 
</code></pre><ul>
<li>输出为</li>
</ul>
<pre><code>getInfo: formatDate
getInfo: false
getInfo: class java.lang.Void 
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ButterKnife 快速绑定控件]]></title>
      <url>/2017/07/20/ButterKnife/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><ul>
<li>鉴于ButterKnife更新较快，添加依赖的方法以GitHub上的为准</li>
</ul>
<pre><code>https://github.com/JakeWharton/butterknife
</code></pre><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><ul>
<li>ButterKnife最初和最常见的用途就是绑定View类，使我们不用去打findViewById</li>
</ul>
<ul>
<li>首先必须在setContentView之后调用ButterKnife.bind()方法，这样BindView方法才有效 </li>
</ul>
<pre><code>setContentView(R.layout.activity_home);
ButterKnife.bind(this); 
</code></pre><ul>
<li>声明一个View引用时使用BindView方法，这样我们在使用这些变量的时候就不用去初始化了</li>
</ul>
<pre><code>@BindView(R.id.home_srl_update)SwipeRefreshLayout mSrUpdate;
@BindView(R.id.home_tb_title)Toolbar toolbar;
@BindView(R.id.drawer_layout)DrawerLayout mHomeLayout;
@BindView(R.id.home_rv_news)RecyclerView rvNews;
@BindView(R.id.home_lv_types)ListView lvTypes;
@BindView(R.id.download) Button download;
</code></pre><ul>
<li>ButterKnife生成的代码长这个样子</li>
</ul>
<pre><code>target.rvNews = finder.findRequiredViewAsType(source, R.id.home_rv_news, &quot;field &apos;rvNews&apos;&quot;, RecyclerView.class);
target.lvTypes = finder.findRequiredViewAsType(source, R.id.home_lv_types, &quot;field &apos;lvTypes&apos;&quot;, ListView.class); 
</code></pre><ul>
<li>绑定Fragment的方式基本相同，但是要注意解绑  </li>
</ul>
<pre><code>ButterKnife.bind(this,mRootView)    

...

public void onDestroyView() {  
super.onDestroyView();  
ButterKnife.unbind(this);//解绑  
}       
</code></pre><ul>
<li>ButterKnife还可以绑定其他资源</li>
</ul>
<pre><code>@BindDrawable(R.drawable.ic_comment)Drawable drawable;
@BindColor(R.color.dark)  
</code></pre><ul>
<li><p>还可以绑定监听事件</p>
<pre><code>@OnClick(R.id.download)
public void download() {
    ...
}

@OnItemClick({R.id.item_lv_news,R.id.item_lv_types})
itemClick(){

}
</code></pre></li>
</ul>
<ul>
<li>也可以在ViewHolder中使用</li>
</ul>
<pre><code>static class ViewHolder extends RecyclerView.ViewHolder {

@BindView(R.id.item_image) ImageView imageView;
public ViewHolder(View itemView) {

    super(itemView);
    ButterKnife.bind(this, itemView);       
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[WebView 基础知识]]></title>
      <url>/2017/07/19/WebView/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><ul>
<li>第一步当然是添加权限和在xml中写入我们的控件了</li>
</ul>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;  
...

&lt;WebView
android:id=&quot;@+id/wv_article&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;wrap_content&quot;&gt;
&lt;/WebView&gt;
</code></pre><ul>
<li>使用loadUrl方法可以打开网页，注意WebView没有自动补全协议的功能，另外我们会发现现在网页实际上是由浏览器browser打开的，为了真正使用到我们WebView，需要设置WebViewClient</li>
</ul>
<pre><code>webView.loadUrl(&quot;http://www.baidu.com&quot;); 
</code></pre><ul>
<li><p>还可以使用本地Url显示页面，这些链接通常放置在assets文件夹中，assets文件夹可以在AS中通过选项直接创建，我们可以使用Context.getAssets().open() 方法获取到这个文件夹里的输入流，不过使用WebView可以直接访问，这时候并不会开启browser</p>
<pre><code>webView.loadUrl(“file:///android_asset/ahtml.html);
</code></pre></li>
<li><p>对于获取到的html字符串，我们有两种方法来显示，loadDataWithBaseURL和loadData，一般使用前者，它的第一个参数可以用来指定相对路径的起点，有时html中的元素会使用相对路径的超链接，不设定这个参数可以造成图片无法显示页面无法跳转的问题，注意loadData的html字符串中不能出现 ‘#’, ‘%’, ‘\’, ‘?’四种字符，以及当使用loadDataWithBaseURL时最后一个参数history url一定要设置，否则可能导致回退到空白页面的问题</p>
</li>
<li><p>WebView还提供了很多可自由设定的<a href="http://www.cnblogs.com/yume2015/archive/2013/05/27/3101947.html" target="_blank" rel="external">属性</a>，获取WebSettings后调用相关方法即可,比较常用的有setJavaScriptEnabled，setUseWideViewPort，requestFocusFromTouch等</p>
</li>
</ul>
<pre><code>WebSettings webSettings = webView.getSettings(); webSettings.setLayoutAlgorithm((WebSettings.LayoutAlgorithm.SINGLE_COLUMN));
    webSettings.setUseWideViewPort(true);
    webSettings.setLoadWithOverviewMode(true);
    webSettings.setDomStorageEnabled(true);
</code></pre><ul>
<li>当点击back键时，会直接退出Activity，为了实现页面的回退功能，需要重写onKeyDown回调方法</li>
</ul>
<pre><code>@Override
public boolean onKeyDown(int keyCode, KeyEvent event) {


if (keyCode == KeyEvent.KEYCODE_BACK &amp;&amp; mWebView.canGoBack()) {
    mWebView.goBack();
    return true;
}
return super.onKeyDown(keyCode, event);
} 
</code></pre><h1 id="WebViewClient"><a href="#WebViewClient" class="headerlink" title="WebViewClient"></a>WebViewClient</h1><ul>
<li><p>和普通控件一样，我们可以设定各种事件的回调方法，这时需要 WebViewClient</p>
</li>
<li><p>onPageStarted和onPageFinished    分别在加载开始和完毕的时候调用，可以在这两个方法中设定和关闭正在加载的提示</p>
</li>
</ul>
<pre><code>webView.setWebViewClient(new WebViewClient(){
    @Override
    public void onPageStarted(WebView view, String url, Bitmap favicon) {
        super.onPageStarted(view, url, favicon);
        Log.d(TAG,&quot;onPageStarted&quot;);
    }

    @Override
    public void onPageFinished(WebView view, String url) {
        super.onPageFinished(view, url);
        Log.d(TAG,&quot;onPageFinished&quot;);
    }
</code></pre><ul>
<li>shouldOverrideUrlLoading方法可以用于进行页面的跳转，它在超链接被加载之前被调用，所有我们还可以在这个方法中实现链接的拦截，这个方法一般返回false</li>
</ul>
<pre><code>@Override
public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) {

    return false;
}
</code></pre><ul>
<li>在onReceivedError，onReceivedSslError可以处理访问错误的情况</li>
</ul>
<h2 id="WebView内存泄漏"><a href="#WebView内存泄漏" class="headerlink" title="WebView内存泄漏"></a>WebView内存泄漏</h2><ul>
<li><p>避免内存泄漏 WebView要动态创建而不是直接写在XML里面，注意要使用ApplicationContext</p>
<pre><code>mWebView = new WebView(getApplicationContext());
LinearLayout linearLayout = (LinearLayout) findViewById(R.id.wv_article);
linearLayout.addView(mWebView); 
</code></pre></li>
<li><p>在ondestroy中销毁WebView</p>
<pre><code>@Override
protected void onDestroy() {
super.onDestroy();
mWebView.removeAllViews();
mWebView.destroy();
mWebView = null;
}
</code></pre></li>
</ul>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Volley 基本用法和源码分析]]></title>
      <url>/2017/07/19/Volley/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><strong>Volley是一套比较完善的网络框架，它可以自动调度网络请求，实现并发的网络连接，并且可以很方便的更新UI</strong></p>
<ul>
<li>添加依赖</li>
</ul>
<pre><code>compile &apos;com.mcxiaoke.volley:library:1.0.19&apos;
</code></pre><h2 id="StringRequest，JsonRequest"><a href="#StringRequest，JsonRequest" class="headerlink" title="StringRequest，JsonRequest"></a>StringRequest，JsonRequest</h2><ul>
<li>一般使用Volley会包括三个部分，创建requestQueue对象，创建request对象，将request对象添加到requestQueue对象当中</li>
<li>requestQueue对象不需要每次都创建，它是一个请求队列</li>
</ul>
<pre><code>mQueue = Volley.newRequestQueue(NewsApplication.getNewsContext());
</code></pre><ul>
<li>创建request对象，我们需要服务器地址和两个监听器，然后将其添加到队列即可</li>
</ul>
<pre><code>public static void  getString(String url,   Response.Listener&lt;String&gt; listener,Response.ErrorListener errorListener){

    StringRequest stringRequest = new StringRequest(url,listener,errorListener);
    mQueue.add(stringRequest);

} 
</code></pre><ul>
<li>Response.Listener 和 Response.ErrorListener 中我们需要分别实现成功加载时和加载失败时的回调方法</li>
</ul>
<pre><code>    @Override
public void onErrorResponse(VolleyError error) {
Log.d(TAG, &quot;onErrorResponse: &quot;);

}

...
public void onResponse(String response) {
Log.d(TAG, &quot;onResponse:&quot;);

}
</code></pre><ul>
<li>Volley 没有提供默认的post方法，但是我们可以重写getParams方法，将POST参数放入一个map容器中返回即可</li>
</ul>
<pre><code>        protected Map&lt;String, String&gt; getParams() throws AuthFailureError {
    Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
    map.put(&quot;params1&quot;, &quot;value1&quot;);
    map.put(&quot;params2&quot;, &quot;value2&quot;);
    return map;
}
</code></pre><h2 id="ImageRequest"><a href="#ImageRequest" class="headerlink" title="ImageRequest"></a>ImageRequest</h2><ul>
<li><p>ImageRequest专门用于加载网络图片，使用方法和StringRequest和JsonRequest有小小的差别</p>
</li>
<li><p>ImageRequest的构造方法有七个参数，分别为链接，含有加载成功时的回调方法的监听器，最大的长和宽，缩放模式，颜色属性，加载失败的监听器，当不需要限制长宽时可以将参数设置为0，图片参数一般设置为 Config.RGB_565 即可</p>
</li>
</ul>
<pre><code>public ImageRequest(String url, Response.Listener&lt;Bitmap&gt; listener, int maxWidth, int maxHeight,
    ScaleType scaleType, Config decodeConfig, Response.ErrorListener errorListener)
...

ImageRequest imageRequest = new ImageRequest(url,

        new Response.Listener&lt;Bitmap&gt;() {
    @Override
    public void onResponse(Bitmap response) {
        imageView.setImageBitmap(response);
    }

}, 0,0, ImageView.ScaleType.CENTER_INSIDE, Bitmap.Config.RGB_565,

        new Response.ErrorListener() {
    @Override
    public void onErrorResponse(VolleyError error) {

    }

});
</code></pre><h2 id="ImageLoader"><a href="#ImageLoader" class="headerlink" title="ImageLoader"></a>ImageLoader</h2><ul>
<li>ImageRequest 使用起来还是比较麻烦的，使用ImageLoader会比较简洁而且它支持了缓存功能</li>
<li>创建ImageLoader对象需要请求队列和缓存对象，Imageloader为回调方法做了封装，我们只需要提供ImageView和成功及失败时使用的资源图片即可</li>
</ul>
<pre><code>public static void getImage(String url, ImageLoader.ImageCache cache, ImageView imageView){

setQueue();
ImageLoader imageLoad = new ImageLoader(mQueue,cache);
ImageLoader.ImageListener listener = ImageLoader.getImageListener(imageView, R.drawable.downing,R.drawable.failed);
imageLoad.get(url,listener);

}
</code></pre><ul>
<li>一般使用LruCache来缓存，让它实现ImageCache接口即可，这个接口只需实现将Bitmap加入缓存和取出缓存的方法</li>
</ul>
<pre><code>@Override
public Bitmap getBitmap(String url) {
return mCache.get(url);
}

@Override
public void putBitmap(String url, Bitmap bitmap) {

mCache.put(url,bitmap);
}
</code></pre><h2 id="NetworkImageView"><a href="#NetworkImageView" class="headerlink" title="NetworkImageView"></a>NetworkImageView</h2><ul>
<li>NetworkImageView是一个封装了请求操作的图片控件，我们只需要提供一个imageLoad对象和url即可</li>
</ul>
<pre><code>&lt;com.android.volley.toolbox.NetworkImageView
android:id=&quot;@+id/theme_iv_header&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;360dp&quot; /&gt;

...  
ivHeader.setImageUrl(imageUrl,new ImageLoader(DataFromVolley.getQueue(),new BitmapCache(BitmapCache.MAX_MEMORY /8)));
</code></pre><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><ul>
<li>我们使用Volley的第一步，是调用newRequestQueue方法创建请求队列，那么先来查看这个方法，它的内部经过了几次直接的return，之后我们来到这里</li>
</ul>
<pre><code>    public static RequestQueue newRequestQueue(Context context, HttpStack stack, int maxDiskCacheBytes) {


    ... 

    if (stack == null) {
        if (Build.VERSION.SDK_INT &gt;= 9) {
            stack = new HurlStack();
        } else {
            // Prior to Gingerbread, HttpUrlConnection was unreliable.
            // See: http://android-developers.blogspot.com/2011/09/androids-http-clients.html
            stack = new HttpClientStack(AndroidHttpClient.newInstance(userAgent));
        }
    }

    Network network = new BasicNetwork(stack);

    RequestQueue queue;
    if (maxDiskCacheBytes &lt;= -1)
    {
        // No maximum size specified
        queue = new RequestQueue(new DiskBasedCache(cacheDir), network);
    }
    else
    {
        // Disk cache size specified
        queue = new RequestQueue(new DiskBasedCache(cacheDir, maxDiskCacheBytes), network);
    }

    queue.start();

    return queue;
}   
</code></pre><ul>
<li>我们看到这里判断了 Build.VERSION.SDK_INT ，以此根据不同的安卓版本创建了两个Stack类的实例，查看注释这两个类分别是基于HttpURLConnection和HttpClient来实现的，在较新的版本上使用的是 HttpURLConnection。所以我们可以知道Volley真正的网络操作实际交由这两者来执行的。</li>
</ul>
<pre><code>/**
* An {@link HttpStack} based on {@link      HttpURLConnection}.
*/ 

/**
* An HttpStack that performs request over an {@link         HttpClient}.
*/
</code></pre><ul>
<li>创建完stack对象，networ对象和请求队列queue之后，queue的start方法执行了，查看这个方法的内部</li>
</ul>
<pre><code>public void start() {
stop();  // Make sure any currently running dispatchers are stopped.
// Create the cache dispatcher and start it.
mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);
mCacheDispatcher.start();

// Create network dispatchers (and corresponding threads) up to the pool size.
for (int i = 0; i &lt; mDispatchers.length; i++) {
    NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork,
            mCache, mDelivery);
    mDispatchers[i] = networkDispatcher;
    networkDispatcher.start();
}
}
</code></pre><ul>
<li>start 方法中主要有两个对象 mCacheDispatcher和networkDispatcher，查看继承关系，得知他们是 Thread 子类的实例，同一时刻会有一个CacheDispatcher线程和多个NetworkDispatcher线程在执行，从名字就可以看出CacheDispatcher用来执行缓存操作而NetworkDispatcher用来执行网络操作，找到前者的run方法</li>
</ul>
<pre><code>public void run() {
if (DEBUG) VolleyLog.v(&quot;start new dispatcher&quot;);
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);

// Make a blocking call to initialize the cache.
mCache.initialize();

Request&lt;?&gt; request;
while (true) {
    // release previous request object to avoid leaking request object when mQueue is drained.
    request = null;
    try {
        //这里从请求队列拿出了请求
        // Take a request from the queue.
        request = mCacheQueue.take();
    }

    ....

        // Attempt to retrieve this item from cache.
        Cache.Entry entry = mCache.get(request.getCacheKey());

        //查看是否有缓存，没有则交给网络队列
        if (entry == null) {
            request.addMarker(&quot;cache-miss&quot;);
            // Cache miss; send off to the network dispatcher.
            mNetworkQueue.put(request);
            continue;
        }

        // If it is completely expired, just send it to the network.
        if (entry.isExpired()) {
            request.addMarker(&quot;cache-hit-expired&quot;);
            request.setCacheEntry(entry);
            mNetworkQueue.put(request);
            continue;
        }

        // We have a cache hit; parse its data for delivery back to the request.

            // Post the intermediate response back to the user and have
            // the delivery then forward the request along to the network.
            final Request&lt;?&gt; finalRequest = request;
            mDelivery.postResponse(request, response, new Runnable() {
                @Override
                public void run() {
                    try {
                        mNetworkQueue.put(finalRequest);
                    } catch (InterruptedException e) {
                        // Not much we can do about this.
                    }
                }
            });
        }
    }
</code></pre><ul>
<li><p>可以看到CacheDispatcher缓存线程会先检查它的请求队列mCacheQueue中各个请求的数据是否在缓存中，如果缓存中没有就加入到NetworkDispatcher网络线程处理的队列mNetworkQueue，让NetworkDispatcher去处理。注意这里的循环是while (true)，所以我们调用newRequestQueue最后就是为了开启了这几个无限循环处理请求的线程，注意这里的队列都是PriorityBlockingQueue，也就是优先级队列</p>
</li>
<li><p>线程已经打开了但是这时还没有请求，那么再来看看我们调用的add方法，终于看到比较短的代码了…</p>
</li>
</ul>
<pre><code>public &lt;T&gt; Request&lt;T&gt; add(Request&lt;T&gt; request) {
// Tag the request as belonging to this queue and add it to the set of current requests.
request.setRequestQueue(this);
synchronized (mCurrentRequests) {
    mCurrentRequests.add(request);
}

// Process requests in the order they are added.
request.setSequence(getSequenceNumber());
request.addMarker(&quot;add-to-queue&quot;);

// If the request is uncacheable, skip the cache queue and go straight to the network.
if (!request.shouldCache()) {
    mNetworkQueue.add(request);
    return request;
}

// Insert request into stage if there&apos;s already a request with the same cache key in flight.
synchronized (mWaitingRequests) {
    String cacheKey = request.getCacheKey();
    if (mWaitingRequests.containsKey(cacheKey)) {
        // There is already a request in flight. Queue up.
        Queue&lt;Request&lt;?&gt;&gt; stagedRequests = mWaitingRequests.get(cacheKey);
        if (stagedRequests == null) {
            stagedRequests = new LinkedList&lt;Request&lt;?&gt;&gt;();
        }
        stagedRequests.add(request);
        mWaitingRequests.put(cacheKey, stagedRequests);
        if (VolleyLog.DEBUG) {
            VolleyLog.v(&quot;Request for cacheKey=%s is in flight, putting on hold.&quot;, cacheKey);
        }
    } else {
        // Insert &apos;null&apos; queue for this cacheKey, indicating there is now a request in
        // flight.
        mWaitingRequests.put(cacheKey, null);
        mCacheQueue.add(request);
    }
    return request;
}
} 
</code></pre><ul>
<li>add方法几乎每一步都加了注释，还是很好解读的，去掉一些判断逻辑，发现add方法其实是先检查我们传进来的请求是否需要缓存，如果不需要就直接加入上NetworkDispatcher处理的队列否则就加入CacheDispatcher的队列，一般请求都是默认可以缓存的，到了这里队列就有请求了</li>
</ul>
<ul>
<li>现在再来看看请求得到的response是怎么回到主线程处理的，reponse是由之前提到的NetWork对象操作stack对象（HttpURLConnection或者HttpClient）得到的，置于怎么操作不是很重要，不去研究。我们看到NetworkDispatcher的run方法最后使用ResponseDelivery mDelivery的一个post方法，顾名思义，response被传递了，点进去发现ResponseDelivery是一个接口，所以还得去找找他是在哪创建的</li>
</ul>
<pre><code>mDelivery.postResponse(request, response);
</code></pre><ul>
<li>找了半天发现它是在RequestQueue被创建时调用的，也就是在newRequestQueue方法的过程中，它的实现类是ExecutorDelivery，这里我们看到它持有了一个MainLooper，已经大概可以猜到内部实现了</li>
</ul>
<pre><code>public RequestQueue(Cache cache, Network network, int threadPoolSize) {
this(cache, network, threadPoolSize,
        new ExecutorDelivery(new Handler(Looper.getMainLooper())));
}
</code></pre><ul>
<li>找到之前 postResponse 方法的具体实现， 它调用了mResponsePoster 的 execute方法             <pre><code>              @Override
public void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable) {
request.markDelivered();
request.addMarker(&quot;post-response&quot;);
mResponsePoster.execute(new ResponseDeliveryRunnable(request, response, runnable));
}
</code></pre></li>
</ul>
<ul>
<li>execute其实就是handler的post方法，由于已经知道handler持有的是mainLooper，因此response可以在主线程处理了</li>
</ul>
<pre><code>mResponsePoster = new Executor() {
    @Override
    public void execute(Runnable command) {
        handler.post(command);
    }
};
</code></pre><ul>
<li>那么这里post的Runnable又是什么呢，查看ExecutorDelivery，也就是之前接受了MainLooper的那个类，看来这个Runnable是它的内部类，当请求成功时调用deliverResponse，不成功时调用deliverError，在进去阅读文档得知这两个方法最终会调用Listener的回调方法，也就是我们熟悉的onResponse方法了，值得注意的是这个Runnable的run方法里面又执行了另一个Runnable的run方法，在NetworkDispatcher中这个传入的Runnable是null，这个Runnable是用于CacheDispatcher得到缓存后可以直接回到主线程而存在的</li>
</ul>
<pre><code>    @Override
    public void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response) {
    postResponse(request, response, null);
    }

    @Override
    public void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable) {
    request.markDelivered();
    request.addMarker(&quot;post-response&quot;);
    mResponsePoster.execute(new ResponseDeliveryRunnable(request, response, runnable));
    }


    /**
    * A Runnable used for delivering network responses to a listener on the
    * main thread.
    */
@SuppressWarnings(&quot;rawtypes&quot;)
private class ResponseDeliveryRunnable implements Runnable {
    private final Request mRequest;
    private final Response mResponse;
    private final Runnable mRunnable; 
    ...
            public void run() {
                        if (mResponse.isSuccess()) {
        mRequest.deliverResponse(mResponse.result);
    } else {
        mRequest.deliverError(mResponse.error);
    }
    ...
                if (mRunnable != null) {
        mRunnable.run();
    }
    ...
</code></pre><p>*  </p>
<ul>
<li>这样我们就把Volley的机制大致过了一遍，我们发现Volley实现了并发的异步请求，数据缓存，优先级，同时有一个RequestQueue来同一存放请求，相对于我们单独地使用HttpURLConnection，它减少了大量线程开启和销毁带来的消耗，还是有比较多的优点的，另外使用它的时候要特别注意不要多次创建RequestQueue队列，否则会开启很多长期运行的线程</li>
</ul>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RecycleView 基本用法]]></title>
      <url>/2017/07/18/RecycleView/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><strong>RecycleView不但能提供比ListView更多的显示效果，还提供了较高的解耦性，可定制性，另外，它封装了我们常用的ViewHolder机制，使得代码更加清晰</strong></p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><ul>
<li>recycleView 相比于ListView除了设置适配器以外还必须设置布局管理器，LayoutManager是一个抽象类，它有三个子类LinearLayoutManager、GridLayoutManager和StaggeredGridLayoutManager分别支持线性布局、表格布局和瀑布流布局的属性设置，线性布局通常用来实现与ListView相似的效果</li>
<li>通过addItemDecoration方法和setItemAnimator方法我们可以设分割线和添加和删除的动画,但是分割线的参数类型ItemDecoration需要重写</li>
</ul>
<pre><code>List&lt;NewsBase&gt; commentDataList = new ArrayList&lt;&gt;();
RecyclerView rvComment = (RecyclerView) findViewById(R.id.comment_lv_content);
rvComment.setLayoutManager(new LinearLayoutManager(this,LinearLayoutManager.VERTICAL,false));
UserAdapter commentAdapter = new UserAdapter(commentDataList,apiType);
rvComment.setAdapter(commentAdapter);
CommentHandler handler = new CommentHandler(commentAdapter);
</code></pre><ul>
<li>在XML中设置属性，和ListView大同小异，但注意设置divider属性是不起作用的</li>
</ul>
<pre><code>&lt;android.support.v7.widget.RecyclerView
    android:id=&quot;@+id/home_lv_news&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:scrollbars=&quot;vertical&quot;
    android:scrollbarStyle=&quot;insideOverlay&quot;/&gt;
</code></pre><ul>
<li>接着我们需要重写Adapter，注意要在其中实现ViewHolder的子类</li>
</ul>
<pre><code>static class ViewHolder extends RecyclerView.ViewHolder{

ImageView itemIvAvatar;
TextView itemTvAuthor;
TextView itemTvContent;
TextView itemTvLikes;
TextView itemTvTime;

public ViewHolder(View itemView) {

    super(itemView);
    itemIvAvatar = (ImageView)itemView.findViewById(R.id.item_iv_avatar);
    itemTvAuthor =  (TextView)itemView.findViewById(R.id.item_tv_author);
    itemTvContent = (TextView)itemView.findViewById(R.id.item_tv_content);
    itemTvLikes = (TextView)itemView.findViewById(R.id.item_tv_likes);
    itemTvTime = (TextView)itemView.findViewById(R.id.item_tv_time);
    }

}
</code></pre><ul>
<li>在onCreateViewHolder中返回我们的item布局</li>
</ul>
<pre><code>public UserAdapter.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_rc_news,parent,false);
ViewHolder viewHolder = new ViewHolder(v);
return viewHolder;
} 
</code></pre><ul>
<li>在onBindViewHolder中设置控件的相关信息，这个步骤和listView的getView是相似的只不过Recycle将ViewHolder机制包装起来了</li>
</ul>
<pre><code>@Override
public void onBindViewHolder(ViewHolder viewHolder, int position) {

NewsUser user = (NewsUser)mDataList.get(position);
viewHolder.itemTvContent.setText(user.getContent());
viewHolder.itemTvAuthor.setText(user.getAuthor());
}
</code></pre><ul>
<li>在getItemCount中返回Item的数目</li>
</ul>
<pre><code>@Override
public int getItemCount() {
return mDataList.size();
}
</code></pre><ul>
<li>对于Recycle我们需要自己创建和实现接口，已响应点击时间</li>
</ul>
<pre><code>public interface OnItemClickListener{
void onClick(int positon);
}
</code></pre><ul>
<li><p>对于表格布局和瀑布流布局，使用其他管理器</p>
<pre><code>new StaggeredGridLayoutManager(3,StaggeredGridLayoutManager.VERTICAL);
</code></pre></li>
</ul>
<h2 id="添加HeaderView"><a href="#添加HeaderView" class="headerlink" title="添加HeaderView"></a>添加HeaderView</h2><ul>
<li>在ListView中有 getItemViewType方法，但并不怎么常用，而在扩展性较强的Recycle中就十分常用了</li>
<li>ListView中可以通过调用addHeader方法添加一个顶部布局，但RecycleView中不提供这种方法，需要自己动手写的代码比较多</li>
</ul>
<ul>
<li>首先我们需要让Adapter持有Header同时需要调用notifyItemInserted方法来告诉Adapter我们在顶部插入了一个子View</li>
</ul>
<pre><code>public void setHeaderView(View mHeaderView) {
this.mHeaderView = mHeaderView;
notifyItemInserted(0);
}
</code></pre><ul>
<li>对于header与普通的子View应划分成两种类型，通过getItemViewType得到具体位置的类型，注意我们需要检查是否有加入header，以便进行不同的处理以提高复用性</li>
</ul>
<pre><code>@Override
public int getItemViewType(int position) {

if(mHeaderView == null)return TYPE_NORMAL;
if(position == 0)return TYPE_HEADER;
return TYPE_NORMAL;
}
</code></pre><ul>
<li>在ListView中添加了header之后，通常要将在onClick方法中的position参数减一来使用，对于RecycleView，插入header同样使得显示列表的position和我们数据中的position不一致，需要处理这部分逻辑，创建一个方法返回一个ViewHolder的数据在集合中的正确位置</li>
</ul>
<pre><code>public int getItemPosition(NewsAdapter.ViewHolder viewHolder){
int position =  viewHolder.getLayoutPosition();
    return mHeaderView == null ? position : position-1;
}

@Override
public int getItemCount() {
return mHeaderView == null ? mDataList.size() : mDataList.size()+1;
}
</code></pre><ul>
<li>对于header和普通子View的ViewHolder需要分别处理</li>
</ul>
<pre><code>public NewsAdapter.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {

if(mHeaderView != null &amp;&amp; viewType == TYPE_HEADER) return  new ViewHolder(mHeaderView);
View v = LayoutInflater.from(parent.getContext()).inflate(mResourceId,parent,false);
return new ViewHolder(v);
}

@Override
public void onBindViewHolder(NewsAdapter.ViewHolder viewHolder, int forePosition) {


    if(getItemViewType(forePosition)==TYPE_HEADER)return;

    final int position = getItemPosition(viewHolder);
    ....
</code></pre><ul>
<li>这样一个支持Header的Recycle就完成了，理论上套用这个方式可以添加各种不同的布局到Recycle的各个位置</li>
</ul>
<h2 id="上拉加载"><a href="#上拉加载" class="headerlink" title="上拉加载"></a>上拉加载</h2><ul>
<li><p>使用上面的方式添加footer功能，可以提供点击加载的效果，但现在的应用还是以上拉自动加载居多</p>
</li>
<li><p>Recycle提供了addOnScrollListener方法，但是它只能响应滚动状态，具体什么时候去加载需要我们自己去实现</p>
</li>
<li><p>对于一个滚动列表，当我们滑动到底部时，可见的item数量加上上方所有的item数量就是item的总数量，LayoutManager的ChildCount，FirstVisibleItemPosition，ItemCount，分别就当别这三个数量，还是比较好实现的</p>
</li>
</ul>
<pre><code>rvNews.addOnScrollListener(new RecyclerView.OnScrollListener() {
     int pastCount, visibleCount, totalCount;
     @Override
     public void onScrolled(RecyclerView recyclerView, int dx, int dy) {

         visibleCount = mLayoutManager.getChildCount();
         totalCount = mLayoutManager.getItemCount();
         pastCount = mLayoutManager.findFirstVisibleItemPosition();

             if ( (visibleCount + pastCount) &gt;= totalCount) {
                 String date = mNewsDataList.get(mNewsDataList.size() - 1).getDate();
                 Log.d(TAG, &quot;onClick: &quot;+mNewsDataList.get(mNewsDataList.size() - 1).getDate()+mNewsDataList.get(mNewsDataList.size() - 1).getTitle());
                 dataTask.execute(mNewsDataList,new Api(Api.BEFORE,date,0,0));

             }
         }
 });
</code></pre><h2 id="绘制分割线"><a href="#绘制分割线" class="headerlink" title="绘制分割线"></a>绘制分割线</h2><ul>
<li><p>ItemDecoration主要有三个绘制方法可以重写，都可以实现绘制分割线的功能，选一种即可</p>
</li>
<li><p>首先创建布局文件</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
 android:shape=&quot;rectangle&quot;&gt;
    &lt;size
    android:width=&quot;1dp&quot;
    android:height=&quot;1dp&quot; /&gt;
    &lt;solid android:color=&quot;@color/colorPrimary&quot; /&gt;

&lt;/shape&gt;
</code></pre></li>
</ul>
<ul>
<li><p>在Style的AppTheme中添加属性</p>
<pre><code>&lt;item name=&quot;android:listDivider&quot;&gt;@drawable/divider&lt;/item&gt;
</code></pre></li>
<li>使用 getResources().getDrawable即可获取到我们定义的divider，对于一个垂直的Recycle，我们可以通过父布局的padding属性得到，但上下的偏移量需要通过每个子View得到，这部分涉及较多View绘制的内容，暂时不去深究  </li>
</ul>
<pre><code>public class Decoration extends RecyclerView.ItemDecoration {



public Drawable mDivider;

public Decoration(Context context){
mDivider =context.getResources().getDrawable(R.drawable.divider,null);

}

@Override
public void onDrawOver(Canvas c, RecyclerView parent, RecyclerView.State state) {
int left = parent.getPaddingLeft();
int right = parent.getWidth()-parent.getPaddingRight();

int count = parent.getChildCount();
for (int i=0;i&lt;count;i++){
    View child = parent.getChildAt(i);

    RecyclerView.LayoutParams params = (RecyclerView.LayoutParams)child.getLayoutParams();

    int top = child.getBottom()+params.bottomMargin;
    int bottom = top + mDivider.getIntrinsicWidth();

    mDivider.setBounds(left,top,right,bottom);
    mDivider.draw(c);

}
}
}
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ViewPager+TabLayout+Fragment 实现懒加载]]></title>
      <url>/2017/07/17/ViewPagerTabFragments/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><strong>本篇乙烷</strong></p>
<h2 id="TabLayout"><a href="#TabLayout" class="headerlink" title="TabLayout"></a>TabLayout</h2><p><strong>水平展示标签的布局，在Google推出TabLayout之前，一般使用TabActivity或者ViewPageIndicator等第三方库实现这种功能</strong></p>
<ul>
<li>使用之前需要先添加支持库</li>
</ul>
<pre><code>compile &apos;com.android.support:design:24.2.1&apos;
</code></pre><ul>
<li>像普通控件一样，在需要的地方设置XML属性，注意app:tabMode属性一般设置为滚动，因为当标签数目较少时scrollable默认是静止的，而当标签数目较多时如果没有设置这个属性时，Tab不能滚动，文字会显示不全</li>
</ul>
<pre><code>&lt;android.support.design.widget.TabLayout
android:id=&quot;@+id/tab&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;wrap_content&quot;
app:tabMode=&quot;scrollable&quot;/&gt;
</code></pre><ul>
<li>动态添加Tab，使用addTag方法和newTab方法</li>
</ul>
<pre><code>for(int i = 0;i&lt;10;i++){
    tabLayout.addTab(tabLayout.newTab().setText(&quot;NO: &quot;+i));
}
</code></pre><ul>
<li>这时一个TabLayout已经可以正常显示了，但是它并没有什么作用，TabLayout一般与ViewPager相结合，实现翻页的功能</li>
</ul>
<h2 id="FragmentPagerAdapter"><a href="#FragmentPagerAdapter" class="headerlink" title="FragmentPagerAdapter"></a>FragmentPagerAdapter</h2><p>** 用于显示一组Fragment的ViewPager的Adapter**</p>
<ul>
<li>必须实现的方法有两个，和pagerAdapter的含义基本一致，在getItem中根据位置返回Fragment，getcount中返回item总数量</li>
</ul>
<pre><code>public FragmentAdapter(FragmentManager fm,List&lt;Fragment&gt; list) {
super(fm);
this.list = list;

}

@Override
public Fragment getItem(int position) {
return list.get(position);
}

@Override
public int getCount() {
return list.size();
}
</code></pre><ul>
<li>为Fragment设定Adapter之后调用tabLayout的setupWithViewPager方法即可将TabLayout和ViewPager关联起来</li>
</ul>
<pre><code>FragmentAdapter fragmentAdapter = new FragmentAdapter(getSupportFragmentManager(),fragments);
viewPager.setAdapter(fragmentAdapter);
tabLayout.setupWithViewPager(viewPager); 
</code></pre><ul>
<li>注意如果在之前设置了文字，这些文字会被<a href="http://blog.csdn.net/u013233097/article/details/54708202" target="_blank" rel="external">清除</a>，将这个步骤放在这之后即可</li>
</ul>
<pre><code>for(int i = 0;i\&lt;10;i++){
        tabLayout.getTabAt(i).setText(&quot;No：&quot;+i);
    }
</code></pre><ul>
<li>显示效果是这样的</li>
</ul>
<ul>
<li><img src="http://i1.buimg.com/1949/3df635474afa9281.png" alt=""></li>
</ul>
<h2 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h2><ul>
<li>ViewPager默认会缓存三页数据，这个属性是由DEFAULT_OFFSCREEN_PAGES决定的，可以使用setOffscreenPageLimit方法设定预加载的页数，但是没有办法设定为0</li>
<li>如果预加载的每个Fragment都去加载数据，Activity的创建时会造成卡顿，所以我们需要在页面切换到可见时再去加载数据</li>
<li>为了解决这个问题，必须从Fragment中入手，Fragment中含有setUserVisibleHint方法，它会在onCreateView之前被调用一次出入false参数，表示Fragment不可见，之后在每次Fragment变为可见时传入true，不可见时传入false</li>
<li>首先需要创建Fragment的子类作为我们使用Fragment的基类，设定三个标记，分别表示当前Fragment是否可见，布局是否已经加载，Fragment是否为第一次可见</li>
</ul>
<pre><code>    private boolean isVisible;
private boolean isPrepared;
private boolean isFirst; 
</code></pre><ul>
<li>在setUserVisibleHint方法中设置isVisible标记，注意必须调用父类的方法，否则在需要使用getUserVisibleHint时可能得到错误的返回值</li>
</ul>
<pre><code>@Override
public void setUserVisibleHint(boolean isVisibleToUser) {
    if(isVisibleToUser){
        isVisible = true;
        Log.d(TAG, &quot;setUserVisibleHint: fragment NO: &quot;+getArguments().getInt(&quot;name&quot;,0)+&quot; true&quot;);
        loadData();

    }else {
        isVisible = false;
        Log.d(TAG, &quot;setUserVisibleHint: fragment NO: &quot;+getArguments().getInt(&quot;name&quot;,0)+&quot; false&quot;);

    }
    super.setUserVisibleHint(isVisibleToUser);
}
</code></pre><ul>
<li>在onCreateView中返回RootView，注意判空，并设置isPrepared标记，当然，直接判断RootView是否为空也能起到isPrepared标记的作用</li>
</ul>
<pre><code>@Override
public View onCreateView(LayoutInflater inflater, ViewGroup container,
                     Bundle savedInstanceState) {

if(mRoot ==null){
    mRoot = initView(inflater,container);
    Log.d(TAG, &quot;onCreateView: &quot;);
}            
    isPrepared = true;
return mRoot;
}
</code></pre><ul>
<li>在setUserVisibleHint中调用了loadData方法，它大致上是这样的，在加载数据之前先检查一下三个标记</li>
</ul>
<pre><code>void loadData(){
if(isFirst&amp;&amp;isPrepared&amp;&amp;isVisible) {
    Log.d(TAG, &quot;loadData: --------------&quot;);
    Log.d(TAG, &quot;loadData: &quot;+ getArguments().getInt(&quot;name&quot;,0));
    isFirst = false;
   return;
}
    ...
}
</code></pre><ul>
<li>注意在onActivityCreated中也要调用一次loadData方法这是因为当ViewPager第一次加载两个Fragment时，setUserVisibleHint 在 onCreateView之前调用了，这时 isPrepared是false，当然无法加载数据。如果不在onActivityCreated中调用loadData方法，第一页的数据将无法在第一次显示时初始化</li>
</ul>
<pre><code>@Override
public void onActivityCreated(@Nullable Bundle savedInstanceState) {
super.onActivityCreated(savedInstanceState);

Log.d(TAG, &quot;onActivityCreated: &quot;+ getArguments().getInt(&quot;name&quot;,0));
loadData();

}
</code></pre><ul>
<li>下面滑动页面进行测试，可以看到进入Activity和翻页时虽然各个Fragment都有回应ViewPager的缓存机制，但是只有到它们被显示时才会去加载数据，懒加载的目的达成了，当需要使用这个Fragment时重写loadData方法和initView方法即可  </li>
</ul>
<pre><code>onActivityCreated: 0
loadData: --------------
loadData: 0
initView: 
onCreateView: 
onActivityCreated: 1

setUserVisibleHint: fragment NO: 2 false
setUserVisibleHint: fragment NO: 0 false
setUserVisibleHint: fragment NO: 1 true

loadData: 1
initView: 
onCreateView: 
onActivityCreated: 2
setUserVisibleHint: fragment NO: 3 false
setUserVisibleHint: fragment NO: 1 false
setUserVisibleHint: fragment NO: 2 true
loadData: --------------
loadData: 2
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Fragment 基础知识]]></title>
      <url>/2017/07/17/Fragment/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<h2 id="Fragment-生命周期"><a href="#Fragment-生命周期" class="headerlink" title="Fragment 生命周期"></a>Fragment 生命周期</h2><ul>
<li>Fragment的生命周期简单来说是这样的</li>
</ul>
<ul>
<li><img src="http://img.blog.csdn.net/20140719225005356?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbG1qNjIzNTY1Nzkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></li>
</ul>
<ul>
<li>但实际上是这样的</li>
</ul>
<p><img src="http://www.jcodecraeer.com/uploads/20150605/1433435656859602.png" alt=""></p>
<ul>
<li>Fragment 依赖于Activity而存在，相对于Activity它还多了几个回调方法</li>
<li>onAttach（Activity） 当Fragment和Activity发生关联的时候调用</li>
<li>onCreateView（Bundle）创建Fragment视图时调用，需要返回Fragment的布局视图，注意查找控件时要先判断是否为null避免重复加载</li>
<li>onActivityCreate（Bundle）当Activity的onCreate方法返回时调用，到了调用这个方法的时候才可以和Activity中的控件进行交互的UI操作，因为这个此时Activity的onCreate方法才调用完毕</li>
<li>onDestroyView（）当Fragment的视图被移除时调用</li>
<li>onDetach（）当Fragment与Activity关联被取消时调用</li>
<li>如果Activity处于暂停状态时其中所有的Fragment都是暂停状态，如果Activity处于stopped状态，其中所有Fragment都不能启动，如果Activity被销毁，所有Fragment都会被销毁</li>
<li>在onCreate中应该初始化除了view类之外的东西，在onCreateView中应该创建Fragment自己的视图并且返回</li>
</ul>
<h2 id="静态使用Fragment"><a href="#静态使用Fragment" class="headerlink" title="静态使用Fragment"></a>静态使用Fragment</h2><ul>
<li>创建Fragment子类和它的布局文件，在onCreateView中初始化控件并返回Fragment的布局</li>
</ul>
<pre><code>@Nullable
@Override
public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {


View view = inflater.inflate(R.layout.fragment_content,container,false);

Button button = (Button)view.findViewById(R.id.button);
...

return view;

}
</code></pre><ul>
<li>在Activity的XML文件中使用Fragment的布局</li>
</ul>
<pre><code>&lt;fragment
android:id=&quot;@+id/title&quot;
android:name = &quot;com.linjiamin.aboutfragment.TitleFragment&quot;
android:layout_width=&quot;wrap_content&quot;
android:layout_height=&quot;wrap_content&quot;/&gt;

&lt;fragment
android:id=&quot;@+id/content&quot;
android:name=&quot;com.linjiamin.aboutfragment.ContentFragment&quot;
android:layout_width=&quot;wrap_content&quot;
android:layout_height=&quot;wrap_content&quot;/&gt;
</code></pre><h2 id="动态使用Fragment-及常见问题"><a href="#动态使用Fragment-及常见问题" class="headerlink" title="动态使用Fragment 及常见问题"></a>动态使用Fragment 及常见问题</h2><ul>
<li>管理Fragment Transaction 需要获取FragmentManage，注意调用getSupportFragmentManager而不是getFragmentManager，我们需要获取support-v4包中的FragmentManager</li>
</ul>
<ul>
<li>动态使用Fragment时，可以使用findFragmentByTag方法，Tag为使用add和replace方法时添加的第三个参数</li>
</ul>
<ul>
<li>动态使用Fragment时调用FragmentManage的findFragmentById方法会返回null值，因为这个方法通过在Activity的布局文件中查找Fragment的id，因为通常只有静态使用Fragment时我们才会在Activity的布局中添加Fragment标签</li>
</ul>
<pre><code>FragmentManager fragmentManager = getSupportFragmentManager();
FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();
fragmentOne = new FragmentOne();
fragmentTransaction.replace(R.id.content,fragmentOne);
fragmentTransaction.commit(); 
</code></pre><ul>
<li>FragmentTransaction用于对Fragment进行添加，替换，移除等操作，一个完整的事务可以设定一系列的变化， 但只有提交之后这些变化才会执行</li>
</ul>
<ul>
<li>add、hide、show方法避免了重复加载数据的问题，但是可能会导致视图的重叠，需要合理地配合replace</li>
</ul>
<ul>
<li>当使用add方法在同一显示位置反复添加一个Fragment时会抛出异常，通常进行检查已避免这个问题：if(fragmentTwo.isAdded())</li>
</ul>
<pre><code>java.lang.IllegalStateException: Fragment already added: FragmentTwo
</code></pre><ul>
<li>若不调用 addToBackStack(String)方法，被移除的Fragment会被销毁，addToBackStack通过模拟返回栈可以实现回退的功能，该方法接受一个参数，它仅作为标记，可以为null</li>
</ul>
<pre><code>fragmentTransaction.addToBackStack(null);
    fragmentTransaction.replace(R.id.content,fragmentTwo);
</code></pre><ul>
<li>使用addToBackStack和replace时，Fragment的实例虽然不会被销毁，但是视图层依然会被销毁，为了避免这种状况，可以使用hide()方法将Fragment隐藏</li>
</ul>
<ul>
<li>Activity重启时可能会造成Fragment重叠的问题，解决方案可以参考<a href="http://www.jianshu.com/p/c12a98a36b2b" target="_blank" rel="external">这里</a></li>
</ul>
<h2 id="Fragment-与-Activity-进行通信"><a href="#Fragment-与-Activity-进行通信" class="headerlink" title="Fragment 与 Activity 进行通信"></a>Fragment 与 Activity 进行通信</h2><ul>
<li>通过Fragment通过getActivity可以活动Activity的实例，Activity通过findFragment*方法可以获得Fragment的实例</li>
<li>通常情况下Fragment不应该和具体的Activity耦合，这样会降低Fragment的重用性，通常使用接口回调的方法实现Activity和Fragment之间的通信</li>
</ul>
<pre><code>    private FragmentButtonListener mListener;

public void setListener(FragmentButtonListener mListener) {
this.mListener = mListener;
}

public interface FragmentButtonListener{
void onFragmentButtonClick();
}

@Override
public void onClick(View v) {

if(mListener!= null){
    mListener.onFragmentButtonClick();
}
}
</code></pre><ul>
<li>下面这种方法也是可行的</li>
</ul>
<pre><code>@Override
public void onClick(View v) {

    if(getActivity() instanceof FragmentButtonListener){
    (FragmentButtonListener) getActivity()).onFragmentButtonClick();
    }
}
</code></pre><ul>
<li>注意通常不要让Fragment直接与其他Fragment进行消息传递，这样会使不同的Fragment耦合，应当让Activity充当总线去接受和发送消息给各个Fragment</li>
</ul>
<h2 id="DialogFragment"><a href="#DialogFragment" class="headerlink" title="DialogFragment"></a>DialogFragment</h2><p>** DialogFragment 首先是一种Fragment，Google官方不推荐直接使用Dialog，Dialog在屏幕旋转和按下后退键时有更好管理的生命周期，它与Fragment基本一致，并且可以在不同尺寸的屏幕上显示不同的效果**</p>
<h3 id="onCreatDialog"><a href="#onCreatDialog" class="headerlink" title="onCreatDialog"></a>onCreatDialog</h3><p><strong>使用DialogFragment有两种途径，重写onCreateView和onCreateDialog，不能同时使用两者</strong></p>
<ul>
<li>重写该方法，返回一个AlertDialog对象，注意需要实现监听器，在需要的地方调用dismiss()方法即可</li>
</ul>
<pre><code>@Override
public Dialog onCreateDialog(Bundle savedInstanceState) {

AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
builder.setTitle(&quot;title&quot;)
        .setPositiveButton(&quot;yes&quot;,this)
        .setNegativeButton(&quot;no&quot;,this)
        .setCancelable(true);

return builder.create();
}
</code></pre><ul>
<li>实例化DialogFragment传入FragmentManger和tag即可</li>
</ul>
<pre><code>new TestDialog().show(getFragmentManager(),null);
</code></pre><h3 id="onCreateView"><a href="#onCreateView" class="headerlink" title="onCreateView"></a>onCreateView</h3><ul>
<li>首先自定义布局</li>
</ul>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout
xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
android:orientation=&quot;horizontal&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot;
android:id=&quot;@+id/dialog&quot;&gt;

&lt;Button
android:id=&quot;@+id/positive&quot;
android:text=&quot;yes&quot;
android:layout_width=&quot;wrap_content&quot;
android:layout_height=&quot;wrap_content&quot; /&gt;

&lt;Button
android:id=&quot;@+id/negative&quot;
android:text=&quot;no&quot;
android:layout_width=&quot;wrap_content&quot;
android:layout_height=&quot;wrap_content&quot; /&gt;

&lt;Button
android:text=&quot;help&quot;
android:id=&quot;@+id/help&quot;
android:layout_width=&quot;wrap_content&quot;
android:layout_height=&quot;wrap_content&quot; /&gt;

&lt;/LinearLayout&gt;
</code></pre><ul>
<li>继承DialogFragment，重写onCreateView，设定控件的监听器，返回自定义的view</li>
</ul>
<pre><code>    @Nullable
    @Override
public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, Bundle savedInstanceState) {

View view = inflater.inflate(R.layout.test_dialog, container, false);
Button posivitive = (Button)view.findViewById(R.id.positive);
Button negative = (Button)view.findViewById(R.id.negative);
Button help = (Button)view.findViewById(R.id.help);

posivitive.setOnClickListener(this);
help.setOnClickListener(this);
negative.setOnClickListener(this);

return view;
}
</code></pre><ul>
<li>二次弹窗需要开启事务，操作和普通Fragment是相似的，之后开启新的弹窗即可</li>
</ul>
<pre><code>FragmentTransaction fragmentTransaction = getActivity().getSupportFragmentManager().beginTransaction();
fragmentTransaction.remove(this);
fragmentTransaction.addToBackStack(null);
fragmentTransaction.commit();
new AnotherDialog().show(getFragmentManager(),null); 
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Handler 详解]]></title>
      <url>/2017/07/13/Handler/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<h2 id="ANR"><a href="#ANR" class="headerlink" title="ANR"></a>ANR</h2><ul>
<li>application not responding，当线程阻塞超过5秒时会弹出无响应的Dialog</li>
</ul>
<pre><code>       button.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {

        Thread thread = Thread.currentThread();
        try {
            thread.sleep(6000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
});
</code></pre><ul>
<li><img src="http://i2.kiimg.com/1949/7d8478d22d279b6a.png" alt=""></li>
<li>所以我们需要在子线程中进行耗时操作，但是子线程是不可以更新UI的，这就意味着我们需要一种机制，使子线程中加载完数据可以马上切换到主线程</li>
</ul>
<h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><h3 id="post"><a href="#post" class="headerlink" title="post"></a>post</h3><p><strong>发送线程</strong></p>
<ul>
<li>post用于投递Runnable，通常被投递的Runnable的run方法会在UI线程中执行，可以更新UI，尝试运行下面这段代码</li>
</ul>
<pre><code>button.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {

        new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    Thread.sleep(3000);

                    new Handler.post(new Runnable() {
                        @Override
                        public void run() {
                            textView.setText(&quot;clicked&quot;);
                            Log.d(&quot;MainActivity&quot;, &quot;run: &quot;);
                        }
                    });
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }).start();
    }
});
</code></pre><ul>
<li>抛出了exception， Can’t create handler inside thread that has not called Looper.prepare()，那么这次尝试先执行Looper.prepare()，UI没有更新，原因和looper的机制有关暂时不去研究，只要把handler改为在主线程中创建即可</li>
</ul>
<pre><code>handler = new Handler();
    button.setOnClickListener(new View.OnClickListener() 
    ...
</code></pre><h3 id="postDelay"><a href="#postDelay" class="headerlink" title="postDelay"></a>postDelay</h3><ul>
<li>postDelay方法提供了一个参数，它用来设定run方法执行的时间，通常可以用来延迟执行UI更新</li>
</ul>
<ul>
<li>这一段代码可以用来实现应用的启动logo，延迟设定一个宽高属性为match_parent的view的Visibility属性，在它遮盖整个界面的情况下onCreate中界面的初始化还可以进行,一定程度上提高了用户体验</li>
</ul>
<pre><code>new Handler().postDelayed(new Runnable() {
    @Override
    public void run() {
        HomeActivity.this.findViewById(R.id.home_fl_logo)
                .setVisibility(View.GONE);
    }
},3000);        
</code></pre><h3 id="sendMessage"><a href="#sendMessage" class="headerlink" title="sendMessage"></a>sendMessage</h3><ul>
<li>查看源码发现它是一个空方法，接受message必须重写它才行</li>
</ul>
<pre><code>/**
* Subclasses must implement this to receive messages.
*/
public void handleMessage(Message msg) {
} 
</code></pre><ul>
<li>这次使用sendMessage更新UI</li>
</ul>
<pre><code>handler = new Handler(){

    @Override
    public void handleMessage(Message msg) {
        super.handleMessage(msg);
        switch (msg.what){
            case 1:
                textView.setText(&quot;clicked&quot;);
                Log.d(&quot;MainActivity&quot;, &quot;run: &quot;);
                break;
            default:
                break;
        }
    }
}; 

...

new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    Thread.sleep(3000);
                    Message msg = new Message();
                    msg.what = 1;
                    handler.sendMessage(msg);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }).start();
</code></pre><ul>
<li>这种方式分为两个步骤，重写 handleMessage 在switch语句中以Message.what为标识更新UI，调用sendMessage传入message对象</li>
<li>注意，msg.setData()方法可以接受一个Bundle对象为参数，利用Bundle的putParcelable()就可以传递自定义的数据了</li>
<li>使用Message.obtain()方法获取Message对象，避免反复创建实例        </li>
</ul>
<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><h3 id="原因"><a href="#原因" class="headerlink" title="- 原因"></a>- 原因</h3><ul>
<li>handler的生命周期与activity不一致，handler关联了looper管理message队列，这个队列在整个Application的生命周期中存在，handler不会因为Activity的finish()被销毁</li>
<li>非静态（匿名）内部类会持有外部对象，当我们这样重写handler时它就成了一个匿名内部类，这样结合前面如果finish时handler有message未处理，Activity就不能被销毁</li>
</ul>
<pre><code> handler = new Handler(){

    @Override
    public void handleMessage(Message msg) {
        super.handleMessage(msg);
        switch (msg.what){
            case 1:
                textView.setText(&quot;clicked&quot;);
                Log.d(&quot;MainActivity&quot;, &quot;run: &quot;);
                break;
            default:
                break;
        }
    }
}; 
</code></pre><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="- 解决方案"></a>- 解决方案</h3><ul>
<li>在外部新建一个类完全可以解决这个问题，但有时内部类确实比较方便</li>
<li>这时我们可以使用静态内部类和弱引用，当一个对象只被弱引用依赖时它会被gc回收</li>
<li>首先不使用弱引用，我们在onResume中延迟发送消息并马上finish()，handler是一个静态内部类，它显式引用Activity</li>
</ul>
<pre><code>    @Override
protected void onResume() {
super.onResume();
Message message = Message.obtain();
message.what =1;
handler.sendMessageDelayed(message,5000);
finish();
}

...

    private static class MyHandler extends Handler {

//private WeakReference&lt;Activity&gt; reference;
private Activity reference;

public MyHandler(Activity activity){
    //reference = new WeakReference&lt;&gt;(activity);
    reference = activity;
}

@Override
public void handleMessage(Message msg) {
    super.handleMessage(msg);
    switch (msg.what){
        case 1:
            if(reference!= null){
            Log.d(&quot;Main2Activity&quot;, &quot;Leak!! &quot;);
            }else {
                Log.d(&quot;Main2Activity&quot;, &quot;not leak: &quot;);
            }
            break;
        default:
            break;
        }
    }
}
</code></pre><ul>
<li>启动这个Activity之后，马上手动gc，收到log，Activity没有被回收</li>
</ul>
<pre><code>07-14 10:38:43.958 24909-24909/com.linjiamin.handler D/Main2Activity: Leak!! 
</code></pre><ul>
<li><p>这次使用弱引用，注意判空条件为 reference.get()!= null</p>
<pre><code>private static class MyHandler extends Handler {

private WeakReference&lt;Activity&gt; reference;
//private Activity reference;

public MyHandler(Activity activity){
    reference = new WeakReference&lt;&gt;(activity);
    //reference = activity;
}

@Override
public void handleMessage(Message msg) {
    super.handleMessage(msg);
    switch (msg.what){
        case 1:
            if(reference.get()!= null){
            Log.d(&quot;Main2Activity&quot;, &quot;Leak!! &quot;);
            }else {
                Log.d(&quot;Main2Activity&quot;, &quot;not leak: &quot;);
            }
            break;
        default:
            break;
    }
}
</code></pre><p>  }</p>
</li>
</ul>
<ul>
<li>手动gc，收到log，Activity已销毁，Activity内存泄漏的问题已经解决了</li>
</ul>
<pre><code>07-14 10:40:12.400 26112-26112/com.linjiamin.handler D/Main2Activity: not leak: 
</code></pre><ul>
<li>那么如果不使用静态类，只使用弱引用</li>
</ul>
<pre><code>private class MyHandler extends Handler {
</code></pre><ul>
<li>Activity没有被销毁，原因应该是非静态内部类隐式持有了外部类Activity的引用导致无法释放</li>
</ul>
<pre><code>07-14 10:43:41.252 29232-29232/com.linjiamin.handler D/Main2Activity: Leak!!    
</code></pre><ul>
<li>因此我们需要同时使用static和弱引用避免内存泄漏</li>
</ul>
<h2 id="Handler机制"><a href="#Handler机制" class="headerlink" title="Handler机制"></a>Handler机制</h2><ul>
<li>多线程访问UI会导致控件处于不可预期状态，使用线程锁会导致UI访问效率降低，线程阻塞等问题，所以Android使用了单线程来管理UI控件</li>
<li>Handler机制由MessageQueue，Looper和Handler本身组成</li>
<li>Looper用于循环查找MessageQueue中的消息，最终消息会交由Runnable或handler的handlerMessage()处理</li>
</ul>
<h3 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h3><ul>
<li>MessageQueue的中的enqueueMessage可以将消息插入管理消息的单链表，接受参数Message message和Long when就是需要被插入的消息，when是一个位置标记，写过单链表的增删查改的话，下面的操作应该很眼熟了，知道有这回事就够了  </li>
</ul>
<pre><code>Message prev;
        for (;;) {
            prev = p;
            p = p.next;
            if (p == null || when &lt; p.when) {
                break;
            }
        ...
        }
        msg.next = p; // invariant: p == prev.next
        prev.next = msg;
    }
</code></pre><ul>
<li>MessageQueue还有一个next()方法，返回一个Message，并将其从链表中删除</li>
</ul>
<h3 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h3><ul>
<li>有了MessageQueue保存和管理Message的方法，那么当然还需要有这些方法的使用者，它就是looper</li>
<li>looper会不停地查看 MessageQueue中是否有新的Message</li>
<li>只有在主线程中才可以认为有默认的looper在工作，在其他线程中直接创建Handler就会报错</li>
</ul>
<pre><code>Can’t create handler inside thread that has not called Looper.prepare()
</code></pre><ul>
<li>因此在一个子线程中要使用 looper，需要调用Looper的两个静态方法，Looper.prepare可以为当前线程创建一个Looper，Looper.loop会开启Looper的无限循坏，这样就有一个正在工作的Looper了</li>
</ul>
<pre><code>Looper.prepare();
Looper.loop(); 
</code></pre><h3 id="Handler-1"><a href="#Handler-1" class="headerlink" title="Handler"></a>Handler</h3><ul>
<li>从上面了解到Looper只是在不停的查看MessageQueue，那么还需要有 Message的发送者和处理者，它就是Handler</li>
<li>Handler有sendMessage方法和post方法，后者就是基于前者来实现的，最终只是向MessageQueue添加一个Message而已</li>
</ul>
<pre><code>queue.enqueueMessage(msg, uptimeMillis);
</code></pre><ul>
<li>Looper会将Message交由handler处理，而handler会执行dispatchMessage方法查看有没有 callback，这个callback就是我们post的Runnable对象了，如果没有就会调用我们重写的handleMessage方法</li>
</ul>
<pre><code>public void dispatchMessage(Message msg) {
if (msg.callback != null) {
    handleCallback(msg);
} else {
    if (mCallback != null) {
        if (mCallback.handleMessage(msg)) {
            return;
        }
    }
    handleMessage(msg);
        }
    }   
</code></pre><ul>
<li><p>从整体上看，Looper在一个线程中创建，它的操作都在这个线程中，我们在其他线程使用Handler其实最终都是给Looper发送Message，然后Looper再调用handler的方法，所以我们的操作能够在Looper的线程中执行</p>
</li>
<li><p>另外之所以子线程中不能修改UI，其实是由于ViewRoot的实现类有一个检查当前线程是否是主线程的方法，子线程修改UI时的Exception就是它抛出的</p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Okhttp 基本用法]]></title>
      <url>/2017/07/13/Net/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<h2 id="HttpClient"><a href="#HttpClient" class="headerlink" title="HttpClient"></a>HttpClient</h2><p><strong>过时的HttpClient</strong></p>
<ul>
<li>Android 5.1后的版本已经废弃HttpClinet，继续使用需要添加依赖</li>
<li>HttpClinet虽然比较灵活，但是api数量过多使得在Android上使用不稳定，Google已经放弃了对它的扩展，转而推荐使用HttpURLConnection</li>
</ul>
<h2 id="OkHttp"><a href="#OkHttp" class="headerlink" title="OkHttp"></a>OkHttp</h2><ul>
<li>首先需要添加依赖，okhttp目前已更新到3.8.1版本，okio会一并获得</li>
</ul>
<pre><code>compile &apos;com.squareup.okhttp3:okhttp:3.8.1&apos;
</code></pre><ul>
<li>jar包可以上okhttp官网下载，需要okhttp和okio两个包</li>
</ul>
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><h4 id="同步"><a href="#同步" class="headerlink" title="- 同步"></a>- 同步</h4><ul>
<li>只要是网络请求，我们就需要在AndroidManifest文件中添加权限，并且开启子线程</li>
<li>同步的意思是一直等待http请求，直到返回了响应</li>
<li>一个类库要完成一次请求需要请求方法, 请求地址, 请求协议, 请求头, 请求体，查看okhttp中Request的类属性，除了协议在Response中以外，其他都能找到</li>
</ul>
<pre><code>public final class Request {
private final HttpUrl url;
private final String method;
private final Headers headers;
private final RequestBody body;
private final Object tag;
</code></pre><ul>
<li>get方法比较简单，我们需要一个OkHttpClient的实例和Request对象的实例，使用这两者来构造RealCall对象</li>
<li>RealCall用来发送请求和读取响应，执行execute请求能够得到一个response对象，response.body()返回的ResponseBody对象就是获取的结果</li>
<li>调用ResponseBody我们可以得到想要的数据或数据流，数据流为大文件下载提供了支持，超过1mb的文档不应该使用string方法，它会把文档加入到内存当中，应当使用流来操作</li>
</ul>
<pre><code>new Thread(new Runnable() {
                @Override
                public void run() {
                    try {
                    OkHttpClient okHttpClient = new OkHttpClient();
                    Request request = new Request.Builder().url(&quot;Https://baidu.com&quot;).build();

                        Response response = okHttpClient.newCall(request).execute();
                        Log.d(&quot;MainActivity&quot;,response.body().string());
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }).start();
</code></pre><h4 id="异步"><a href="#异步" class="headerlink" title="- 异步"></a>- 异步</h4><ul>
<li>okhttp支持异步线程，只需要重写传入参数的Callback的两个方法即可，它们分别在请求成功和失败时被调用，回调方法在子线程中调用</li>
</ul>
<pre><code>OkHttpClient okHttpClient = new OkHttpClient();
Request request = new Request.Builder().url(&quot;Https://baidu.com&quot;).build();
okHttpClient.newCall(request).enqueue(new Callback() {
    @Override
    public void onFailure(Call call, IOException e) {

        Log.d(&quot;MainActivity&quot;, &quot;onFailure: &quot;);

    }

    @Override
    public void onResponse(Call call, Response response) throws IOException {

        Log.d(&quot;MainActivity&quot;, response.body().string());
    }

});
</code></pre><h3 id="post"><a href="#post" class="headerlink" title="post"></a>post</h3><ul>
<li>post方法和get类似，只需要调用post方法并传入body参数即可</li>
<li>构建一个body，使用FormBody.Builder，MultipartBody.Builder和使用RequestBody.create()，FormEncodingBuilder已过时，RequestBody.create()可以设定文件的类型，具体的参数在需要时<a href="http://tool.oschina.net/commons/" target="_blank" rel="external">查找</a>即可</li>
</ul>
<pre><code>RequestBody RequestBody = new FormBody.Builder().add(&quot;str&quot;,&quot;1&quot;).build();
RequestBody.create(MediaType.parse(&quot;image/jpeg; charset=utf-8&quot;),new File(path));
</code></pre><h3 id="取消Call"><a href="#取消Call" class="headerlink" title="取消Call"></a>取消Call</h3><ul>
<li>调用Call.cancle()可以取消一个call，不论它是同步还是异步的，也可以使用OkHttpClient.cancel(tag)来取消，tag在RequestBuilder的tag()方法中设置</li>
<li>设置超时响应也可以结束call</li>
</ul>
<pre><code>        OkHttpClient okHttpClient = new OkHttpClient();
new OkHttpClient.Builder()
        .connectTimeout(10, TimeUnit.SECONDS)
        .writeTimeout(10,TimeUnit.SECONDS).build();
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ListView 使用与优化]]></title>
      <url>/2017/07/12/ListView/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><strong>本篇未完</strong></p>
<h2 id="BaseAdapter"><a href="#BaseAdapter" class="headerlink" title="BaseAdapter"></a>BaseAdapter</h2><p><strong>主要学习BaseAdapter的几个方法，ArrayAdapter是BaseAdapter的子类，用法相似</strong></p>
<h3 id="重写方法"><a href="#重写方法" class="headerlink" title="重写方法"></a>重写方法</h3><ul>
<li>BaseAdapter实现了ListAdapter接口，ListAdapter接口继承自Adapter接口，在Adapter中找到getView方法，它需要三个参数，position，view是需要的数据在数据集合中的位置，convertView是旧的View，Adapter会缓存一个刚离开屏幕的View，使用它可以避免反复的查找子View，parent就是使用Adapter的ListView，当然也可能不是ListView，这要看哪个控件使用这个Adapter</li>
</ul>
<pre><code>int position, View convertView, ViewGroup parent
</code></pre><ul>
<li>getItemId，getItem，item指的是数据集合中的每一个元素，ItemId是Item的标记，前者返回position指定的item的id，后者返回position指定Item</li>
</ul>
<ul>
<li>getCount，返回Item的数量，通常为容器的大小</li>
<li>总的来说实现一个adapter的步骤为</li>
</ul>
<pre><code>public class NewsListAdapter extends BaseAdapter {

private int mResourceId;
private BitmapCache mCache;
private Context mContext;
private List mDataList;

public NewsListAdapter(Context context, int resourceId, List&lt;NewsBase&gt; dataList){
mResourceId = resourceId;
mContext = context;
mDataList = dataList;
mCache = new 
    }

@Override
public int getCount() {
return mDataList.size();
}

@Override
public Object getItem(int position) {
return mDataList.get(position);
}

@Override
public long getItemId(int position) {
return position;
}

@Override
public @NonNull View getView(int position,View convertView,@NonNull ViewGroup parent){

View view = null;
ViewHolder viewHolder;
if(convertView == null) {
    view = LayoutInflater.from(getContext()).inflate(mResourceId, parent, false);
    viewHolder = new ViewHolder();
    viewHolder.***View = (***View)view.findViewById(R.id.item_***);
    //通过view.findViewById查找view
    ...         
    view.setTag(viewHolder);

}else {
    view = convertView;
    viewHolder = (ViewHolder)view.getTag();
}

Item item = (Item) getItem(position);
if(item == null)
    return view;

viewHolder.***View.set(item.get***());
//设置界面信息
...


return view;
}

public Context getContext() {
return mContext;
}

private class ViewHolder{

***View  ***View;
//需要缓存的子view引用
...

    }
}
</code></pre><ul>
<li>一般情况下position和itemId可以共用，getItemId返回position即可，getItem返回data.get(position)即可</li>
<li>使用ViewHolder，这样虽然不能保证convertView每次都缓存成功，但能够保证convertView缓存成功时，我们不用通过convertView的findViewById去查找它的子View</li>
</ul>
<h2 id="进一步优化"><a href="#进一步优化" class="headerlink" title="进一步优化"></a>进一步优化</h2><h3 id="LruCache"><a href="#LruCache" class="headerlink" title="- LruCache"></a>- LruCache</h3><ul>
<li>当convertView被用来修改成新view时，旧的数据也就没有了，这时如果用户往回拖动ListView，又得重新加载，可以使用LruCache保留这些数据</li>
<li>LruCache使用泛型，但对于ListView来说通常需要缓存的是Bitmap，下面实现一个LruCache的工具类</li>
</ul>
<pre><code>public class BitmapCache {

public static int MAX_MEMORY = (int)(Runtime.getRuntime().maxMemory()/1024);
private LruCache&lt;String,Bitmap&gt; mCache;

public BitmapCache(int cacheSize){
mCache = new LruCache&lt;String,Bitmap&gt;(cacheSize){
    @Override
    protected int sizeOf(String url,Bitmap bitmap) {
        return bitmap.getByteCount() / 1024;
    }
};
}

/**
*
* 该方法用于将图片放入缓存
* @param url 链接，或其他标识
* @param bitmap 图片
*
*/
public void put(String url,Bitmap bitmap){
  mCache.put(url,bitmap);
}

/**
*
* 该方法用于将图片从缓存中取出
* @param url 链接，或其他标识
* @return 图片，当缓存中没有指定图片时返回null
*
*/
public Bitmap get(String url){
    return mCache.get(url);
    }
}
</code></pre><ul>
<li>LrCache通常只需要设定类型和缓存大小，这个大小最好不要写入一个常值，而是根据运行时的内存大小来设定</li>
</ul>
<pre><code>public static int MAX_MEMORY = (int)(Runtime.getRuntime().maxMemory()/1024);
</code></pre><h3 id="隐藏滚动条"><a href="#隐藏滚动条" class="headerlink" title="- 隐藏滚动条"></a>- 隐藏滚动条</h3><ul>
<li>ListView默认会有一个比较鸡肋的滚动条，可以在XML中隐藏</li>
</ul>
<pre><code>android:scrollbars=&quot;none&quot;   
</code></pre><h3 id="无数据提示"><a href="#无数据提示" class="headerlink" title="- 无数据提示"></a>- 无数据提示</h3><ul>
<li>ListView提供了一个方法用来在没有数据时提示用户</li>
</ul>
<pre><code>lv.setEmptyView(R.id.empty);
</code></pre><h3 id="滑动监听"><a href="#滑动监听" class="headerlink" title="- 滑动监听"></a>- 滑动监听</h3><h4 id="OnScrollListener"><a href="#OnScrollListener" class="headerlink" title="OnScrollListener"></a>OnScrollListener</h4><ul>
<li>实现 OnScrollListener，在不同的状态下自定义ListView      </li>
</ul>
<pre><code>lv.setOnScrollListener(new AbsListView.OnScrollListener() {
    @Override
    public void onScrollStateChanged(AbsListView view, int scrollState) {
        switch (scrollState){
            case AbsListView.OnScrollListener.SCROLL_STATE_IDLE:
                break;
            case AbsListView.OnScrollListener.SCROLL_STATE_TOUCH_SCROLL:
                break;
            case AbsListView.OnScrollListener.SCROLL_STATE_FLING:
                break;

        }
    }

    @Override
    public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) {

    }
});
</code></pre><h4 id="OnTouchListener"><a href="#OnTouchListener" class="headerlink" title="OnTouchListener"></a>OnTouchListener</h4><ul>
<li>实现 OnTouchListener，在不同的状态下自定义ListView</li>
</ul>
<pre><code>lv.setOnTouchListener(new View.OnTouchListener() {
    @Override
    public boolean onTouch(View v, MotionEvent event) {
        switch (event.getAction()){
            case MotionEvent.ACTION_DOWN:
                break;
            case MotionEvent.ACTION_MOVE:
                break;
            case MotionEvent.ACTION_UP:
                break;
        }
        return false;
    }
});
</code></pre><h3 id="解决乱序"><a href="#解决乱序" class="headerlink" title="- 解决乱序"></a>- 解决乱序</h3><ul>
<li>由于网络请求加载的速度远小于 <a href="#RecycleBin">RecycleBin</a> 返回view的速度，当一个图片没有加载完成就被划出屏幕，这时又开启了新的网络请求，也就是说会有两张图片需要被加载到同一个ImageView中</li>
<li>通常前一个请求会先完成，接着后一个请求得到的bitmap会进行覆盖，加载效果会变得很混乱</li>
<li>如果前一个请求没有及时完成可能导致图片乱序的问题</li>
<li><p>解决方案是在开启网络请求时使用ImageView的setTag方法</p>
<pre><code>image.setTag(url)
</code></pre></li>
<li><p>当我们下载完图片时，先使用url去查找ImageVIew而不是直接将bitmap设置到ImageView上</p>
<pre><code>ImageView imageView = (ImageView) listView.findViewWithTag(imageUrl); 
if(imageView!=null){
    ...
}    
</code></pre></li>
<li><p>当开启第二次请求前原先的url会被覆盖，第一次请求就会得到空值，这样就不会造成混乱了</p>
<h2 id="适配器模式与ListView"><a href="#适配器模式与ListView" class="headerlink" title="适配器模式与ListView"></a>适配器模式与ListView</h2><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="- 适配器模式"></a>- 适配器模式</h3></li>
<li><p>适配器模式是指将一个类的接口转换为用户类需要的接口，使得不同结构的对象可以通过适配器为用户提供服务</p>
</li>
<li>ListView是一个用户，它调用adapter的目标接口（Target），而这些接口本身是抽象的，实现这些统一的接口使得数据集合与ListView可以通过adapter这个桥梁连接起来，这时我们的数据可以是数组，集合，还可以是游标等，具体是什么数据结构ListView是不会去关心的，因为它获取的是Adapter提供的View</li>
</ul>
<h3 id="RecycleBin机制"><a href="#RecycleBin机制" class="headerlink" title="RecycleBin机制"></a><span id="RecycleBin">RecycleBin机制</span></h3><ul>
<li>ListView还有一个比较特殊的机制，它为Adapter在获取数据的同时还为adapter返回一个数据，convertView</li>
<li>AbsListView中有一个内部类RecycleBin，它使用数组来保存当前使用的所有View，当一个View被滑出屏幕时，它调用addScrapView将这个view从数组中移除并且缓存起来，ListView在调用我们实现的getView方法之前会调用RecycleBin的getScrapView，将获取到的对象（可能为null，可能是重用的View）提供给adapter作为convertView参数</li>
<li>RecycleBin这种循环复用的机制一定程度上避免了OOM</li>
</ul>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ContentProvider 常见操作]]></title>
      <url>/2017/07/12/ContentProvider/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<h2 id="运行时权限"><a href="#运行时权限" class="headerlink" title="运行时权限"></a>运行时权限</h2><p><strong>每当跨应用传递数据和信息时都要考虑是否需要申请权限，申请权限的授予分两种情况，系统自动授权和运行时授权</strong></p>
<ul>
<li>compileSdk小于23的程序在6.0以上的系统运行，所有的权限只要在XML中注册即可，大于23的版本若需要获取dangerous类型的权限必须动态申请否则程序会崩溃</li>
<li>动态申请的权限也必须在AndroidManifest中注明</li>
<li>获取运行时权限的步骤还是比较简单的，首先使用ContextCompat.checkSelfPermission方法检查是否已被授权，若未授权着调用ActivityCompat.requestPermissions方法申请权限，系统会自动调用onRequestPermissionsResult，在里面写入想要进行的操作即可</li>
</ul>
<pre><code>button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                if(ContextCompat.checkSelfPermission
                (MainActivity.this, Manifest.permission.CALL_PHONE)
                != PackageManager.PERMISSION_GRANTED){

                    ActivityCompat.requestPermissions(MainActivity.this,
                    new String[]{Manifest.permission.CALL_PHONE},1);
                }

                else{
                    call();
                }
            }
     });

    }

    public void call(){
        try{
            Intent intent = new Intent(Intent.ACTION_CALL);
            intent.setData(Uri.parse(&quot;tel:10086&quot;));
            MainActivity.this.startActivity(intent);

        }catch (SecurityException e){
            e.printStackTrace();
        }
    }

@Override
    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults);

        switch (requestCode){
            case 1:
                if (grantResults.length&gt;0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED){
                    call();
                }
        }
    }
}
</code></pre><ul>
<li>经过测试在API 23以下的虚拟机自动获取到了这个权限，ContextCompat.checkSelfPermission 返回 PERMISSION_GRANTED</li>
</ul>
<h2 id="Uri"><a href="#Uri" class="headerlink" title="Uri"></a>Uri</h2><p><strong>HTTP中规定的资源标识符</strong></p>
<ul>
<li>一个Uri由三部分组成，scheme (android中为content://)，主机名或Authority (如com.example.contenttest )，路径 (如/test/20)</li>
</ul>
<pre><code>content://com.example.contenttest/test/20
//test为表名，20位id
//使用*和#通配符匹配任意长度的字符和数字，可得到一个表中的所有数据
</code></pre><ul>
<li>用一个字符串获取Uri，只需调用Uri.parse(“”)方法</li>
</ul>
<h2 id="UriMatcher"><a href="#UriMatcher" class="headerlink" title="UriMatcher"></a>UriMatcher</h2><p><strong>Uri匹配工具</strong></p>
<ul>
<li>向外界共享数据时，首先要考虑什么数据可以共享，什么数据不可以共享，所以第一步需要将可以匹配的Uri进行注册,这里使用了<a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9D%97">初始化块</a></li>
</ul>
<pre><code>public class NewsProvider extends ContentProvider {
    public static final int NEWS_ALL = 0;
    public static final int NEWS_ITEM = 1;

    public static final String AUTHORITY = &quot;com.linjiamin.provider&quot;;
    private static UriMatcher uriMatcher;

    static{
        uriMatcher = new UriMatcher(UriMatcher.NO_MATCH);
        uriMatcher.addURI(AUTHORITY,&quot;News&quot;,NEWS_ALL);
        uriMatcher.addURI(AUTHORITY,&quot;News/#&quot;,NEWS_ITEM);
    }
</code></pre><ul>
<li><p>uriMatcher.addURI中的第三个参数是uri匹配时会返回的值，可以用它来标记查询的内容</p>
</li>
<li><p>接着重写几个数据库方法，返回对应的cursor，在switch中我们使用uriMatcher.match(uri)来得到刚刚的NEWS_ALL等标记</p>
</li>
</ul>
<pre><code>@Override
public Cursor query(Uri uri, String[] projection, String selection,
                    String[] selectionArgs, String sortOrder) {
    SQLiteDatabase db = newsDatabaseHelper.getReadableDatabase();
    Cursor cursor =  null;
    switch (uriMatcher.match(uri)){
        case NEWS_ALL:
            cursor = db.query(&quot;news&quot;,new String[]{&quot;id&quot;,&quot;title&quot;,&quot;image_url&quot;,&quot;has_read&quot;,&quot;multipic&quot;},&quot;date=? and from_Home=?&quot;,new String[]{&quot;20170710&quot;,&quot;true&quot;},null,null,null);
            break;
        case NEWS_ITEM:
            String id = uri.getPathSegments().get(1);
            cursor = db.query(&quot;news&quot;,new String[]{&quot;id&quot;,&quot;title&quot;,&quot;image_url&quot;,&quot;has_read&quot;,&quot;multipic&quot;},&quot;id=?&quot;,new String[]{id,&quot;true&quot;},null,null,null);
            break;

        default:
            break;
    }

    return cursor;
}
</code></pre><ul>
<li>CRUD的方法只要使用数据库就可以实现了，除此之外只有一个方法比较特殊，它需要返回MIME类型，MIME Type由媒体类型(type)与子类型(subtype)组成，在intent-filter中添加MIME Type属性可以定义一个Activity可以打开什么类型的文件，provider中自定义MIME Type的规范为  vnd.android.cursor.dir(或item)/vnd.com.linjiamin.provider.news(表名)”</li>
</ul>
<pre><code>@Override
    public String getType(Uri uri) {
        switch(uriMatcher.match(uri)){
            case NEWS_ALL:
                return &quot;vnd.android.cursor.dir/vnd.com.linjiamin.provider.news&quot;;

            case NEWS_ITEM:
                return &quot;vnd.android.cursor.item/vnd.com.linjiamin.provider.news&quot;;

            default:
                break;
        }
</code></pre><ul>
<li><p>接着在另一个应用中获取数据，调用getContentResolver得到cursor</p>
<pre><code>button.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        Uri uri = Uri.parse(&quot;content://com.linjiamin.provider/news&quot;);
        Cursor cursor = getContentResolver().query(uri,null,null,null,null);
        if(cursor!=null){
            cursor.moveToFirst();
            Log.d(&quot;MainActivity&quot;, &quot;onClick: &quot;+cursor.getString(cursor.getColumnIndex(&quot;title&quot;)));
        }
</code></pre></li>
</ul>
<ul>
<li>得到一条新闻标题，可见数据跨应用传输了 </li>
</ul>
<pre><code>MainActivity: onClick: 为什么民航航班会在途中绕圈？
</code></pre><h2 id="初始化块"><a href="#初始化块" class="headerlink" title="初始化块"></a><span id="初始化块">初始化块</span></h2><ul>
<li>在一个类声明中可以包含多个代码块并在其中进行简单的逻辑操作，这些代码块会在构造器运行之前调用，在JDK6之前一个程序甚至可以没有main入口</li>
</ul>
<pre><code>public class Hello{
    static{
        System.out.println(&quot;hello world&quot;);
    }
}
</code></pre><ul>
<li>当一个类的静态域比较复杂，可以使用静态初始化块进行初始化</li>
</ul>
<pre><code>static{

    ...
    ...

}
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 常用布局的使用方法和场景]]></title>
      <url>/2017/07/11/Layout/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<h2 id="使用RelativeLayout减少层级"><a href="#使用RelativeLayout减少层级" class="headerlink" title="使用RelativeLayout减少层级"></a>使用RelativeLayout减少层级</h2><h3 id="层级的影响"><a href="#层级的影响" class="headerlink" title="层级的影响"></a>层级的影响</h3><ul>
<li>要完整地显示一个界面就需要对所有的View进行一次绘制工作，Android通过递归查找View树，而多叉树的层级越深，耗时就越长</li>
<li>布局层次深会增加内存的消耗，甚至会引起栈溢出等问题</li>
<li>RelativeLayout也有性能的问题，它会对子View进行竖直和水平的两次测量，但如果LinearLayout中含有weight属性那么LinearLayout也同样需要进行两次测量</li>
<li>可以在XML界面中的Component Tree或是AS自带的Hierachy View 工具中查看一个界面的层级</li>
</ul>
<h3 id="RelativeLayout替换LinearLayout"><a href="#RelativeLayout替换LinearLayout" class="headerlink" title="- RelativeLayout替换LinearLayout"></a>- RelativeLayout替换LinearLayout</h3><ul>
<li><p>以这个界面为例</p>
<p>  <img src="http://i2.kiimg.com/1949/a4919b1895abe7ea.png" alt=""></p>
</li>
</ul>
<ul>
<li>这是一个评论ListView的Item视图，在一个LinearLayout中嵌套了两个LinearLayout来实现，可能还不算太深</li>
</ul>
<pre><code>\&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?\&gt;
\&lt;LinearLayout
xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
android:orientation=&quot;vertical&quot;
android:layout\_width=&quot;match\_parent&quot;
android:layout\_height=&quot;wrap\_content&quot;
android:background=&quot;#FFFAFA&quot;\&gt;

\&lt;LinearLayout
    android:orientation=&quot;horizontal&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;&gt;

    &lt;ImageView
        android:id=&quot;@+id/item_iv_avatar&quot;
        android:layout_width=&quot;36dp&quot;
        android:layout_height=&quot;36dp&quot;
        android:layout_marginStart=&quot;4dp&quot;
        android:layout_marginTop=&quot;4dp&quot;
        android:scaleType=&quot;fitXY&quot; /&gt;

    &lt;TextView
        android:id=&quot;@+id/item_tv_author&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:paddingStart=&quot;8dp&quot;
        android:paddingEnd=&quot;8dp&quot;
        android:paddingTop=&quot;8dp&quot;
        android:textSize=&quot;17sp&quot;
        android:textColor=&quot;#303030&quot;/&gt;
    &lt;/LinearLayout&gt;

    &lt;TextView
        android:id=&quot;@+id/item_tv_content&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:paddingStart=&quot;50dp&quot;
        android:paddingEnd=&quot;8dp&quot;
        android:lineSpacingMultiplier=&quot;1.2&quot;
        android:layout_marginBottom=&quot;8dp&quot;
        android:textSize=&quot;16sp&quot;
        android:textColor=&quot;#3B3B3B&quot;/&gt;

    &lt;LinearLayout
        android:orientation=&quot;horizontal&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_marginBottom=&quot;8dp&quot;&gt;

        &lt;TextView
            android:id=&quot;@+id/item_tv_time&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:paddingStart=&quot;50dp&quot;
            android:paddingEnd=&quot;8dp&quot;
            android:layout_marginBottom=&quot;8dp&quot;
            android:textSize=&quot;12sp&quot;
            android:textColor=&quot;#66000000&quot;/&gt;

        &lt;TextView
            android:id=&quot;@+id/item_tv_likes&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;match_parent&quot;
            android:paddingStart=&quot;2dp&quot;
            android:paddingEnd=&quot;2dp&quot;
            android:paddingTop=&quot;8dp&quot;
            android:textSize=&quot;12sp&quot;
            android:textColor=&quot;#AAFF4040&quot;/&gt;
    &lt;/LinearLayout&gt;
</code></pre><p></p>
<ul>
<li>现在尝试使用一层RelativeLayout来实现，只要确定好子View之间的位置关系，使用 android:layout_toRightOf等<a href="http://blog.csdn.net/notenlife/article/details/7256363" target="_blank" rel="external">相对属性</a>很快就能替换</li>
</ul>
<pre><code>    &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
    &lt;RelativeLayout
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:orientation=&quot;vertical&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:background=&quot;#FFFAFA&quot;&gt;


    &lt;ImageView
        android:id=&quot;@+id/item_iv_avatar&quot;
        android:layout_width=&quot;36dp&quot;
        android:layout_height=&quot;36dp&quot;
        android:layout_marginStart=&quot;4dp&quot;
        android:layout_marginTop=&quot;4dp&quot;
        android:scaleType=&quot;fitXY&quot; /&gt;

    &lt;TextView
        android:id=&quot;@+id/item_tv_author&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_toRightOf=&quot;@id/item_iv_avatar&quot;
        android:paddingStart=&quot;8dp&quot;
        android:paddingEnd=&quot;8dp&quot;
        android:paddingTop=&quot;8dp&quot;
        android:textSize=&quot;15sp&quot;
        android:textColor=&quot;#303030&quot;/&gt;


    &lt;TextView
        android:id=&quot;@+id/item_tv_content&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_below=&quot;@id/item_tv_author&quot;
        android:paddingStart=&quot;50dp&quot;
        android:paddingTop=&quot;18dp&quot;
        android:paddingEnd=&quot;8dp&quot;
        android:lineSpacingMultiplier=&quot;1.1&quot;
        android:layout_marginBottom=&quot;8dp&quot;
        android:textSize=&quot;16sp&quot;
        android:textColor=&quot;#3B3B3B&quot;/&gt;

        &lt;TextView
            android:id=&quot;@+id/item_tv_time&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:layout_below=&quot;@id/item_tv_content&quot;
            android:paddingStart=&quot;50dp&quot;
            android:paddingEnd=&quot;8dp&quot;
            android:paddingTop=&quot;8dp&quot;
            android:paddingBottom=&quot;8dp&quot;
            android:textSize=&quot;12sp&quot;
            android:textColor=&quot;#66000000&quot;/&gt;

        &lt;TextView
            android:id=&quot;@+id/item_tv_likes&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;match_parent&quot;
            android:layout_below=&quot;@id/item_tv_content&quot;
            android:layout_toEndOf=&quot;@id/item_tv_time&quot;
            android:paddingStart=&quot;2dp&quot;
            android:paddingEnd=&quot;2dp&quot;
            android:paddingTop=&quot;8dp&quot;
            android:paddingBottom=&quot;8dp&quot;
            android:textSize=&quot;12sp&quot;
            android:textColor=&quot;#AAFF4040&quot;/&gt;

&lt;/RelativeLayout&gt;
</code></pre><ul>
<li>就这两种布局而言，当层级较深时我们可以使用RelativeLayout来优化，层级较浅时则优先使用便捷的LinearLayout</li>
</ul>
<h2 id="其他布局"><a href="#其他布局" class="headerlink" title="其他布局"></a>其他布局</h2><p><strong>RelativeLayout，LinearLayout比较常用，这里主要了解一下其他布局的属性</strong></p>
<h3 id="TableLayout"><a href="#TableLayout" class="headerlink" title="- TableLayout"></a>- TableLayout</h3><p><strong>表格布局，所有子元素以表格的形式摆放</strong></p>
<ul>
<li>android:shrinkColumns，若内容过多，指定的列会收缩，为其他列提供空间</li>
<li>android:stretchColumns，当内容过少，指定的列会伸展，填满多余空间</li>
<li>android:collapseColumns，隐藏指定的列</li>
<li>android:layout_column，设置view的行位置</li>
<li>android:layout_span，设置view的占据的列数(宽度)</li>
</ul>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;TableLayout
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
xmlns:tools=&quot;http://schemas.android.com/tools&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot;
tools:context=&quot;com.linjiamin.layout.MainActivity&quot;
android:stretchColumns=&quot;0&quot;
android:collapseColumns=&quot;1&quot;
android:shrinkColumns =&quot;2&quot;&gt;
&lt;!--使用stretchColumns，第一行被伸展--&gt;
&lt;!--使用collapseColumns，第二行被隐藏--&gt;
&lt;TableRow
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot;&gt;
&lt;TextView
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:textSize=&quot;80sp&quot;
    android:text=&quot;0&quot;/&gt;
&lt;TextView
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:textSize=&quot;80sp&quot;
    android:text=&quot;1&quot; /&gt;
&lt;TextView
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:textSize=&quot;80sp&quot;
    android:text=&quot;2&quot;/&gt;
&lt;TextView
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:textSize=&quot;80sp&quot;
    android:text=&quot;3&quot;/&gt;
&lt;/TableRow&gt;
&lt;TableRow
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot;&gt;
&lt;TextView
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:text=&quot;4&quot;
    android:textSize=&quot;80sp&quot; /&gt;
&lt;/TableRow&gt;
&lt;TableRow
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot;&gt;
&lt;!-- 使用layout_column ，显示在第三格--&gt;
&lt;!-- 使用layout_span ，占据两列--&gt;
&lt;TextView
    android:layout_column =&quot;2&quot;
    android:layout_span=&quot;2&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:text=&quot;5&quot;
    android:textSize=&quot;80sp&quot;
    /&gt;
    &lt;/TableRow&gt;
&lt;/TableLayout&gt;
</code></pre><ul>
<li>显示效果如下</li>
</ul>
<p><img src="http://i1.buimg.com/1949/2fffb0e58fd813b1.png" alt=""></p>
<h3 id="AbsoluteLayout"><a href="#AbsoluteLayout" class="headerlink" title="- AbsoluteLayout"></a>- AbsoluteLayout</h3><p><strong>绝对布局，已淘汰，知道即可</strong></p>
<ul>
<li>写swing的时候曾经使用过这种布局，当时在不同的系统上测试时发现界面会出现一定的差异，不过还挺好用的……</li>
<li>由于手机屏幕的尺寸种类较多，这个布局会对适配造成很大的影响，因此已经被废置了</li>
<li>android:layout_x  指定X坐标</li>
<li>android:layout_y 指定Y坐标</li>
</ul>
<h3 id="GridLayout"><a href="#GridLayout" class="headerlink" title="- GridLayout"></a>- GridLayout</h3><p><strong>网格布局，使用矩阵排列</strong></p>
<ul>
<li>每一个子View都有唯一的坐标，从0开始计数，但大小可以不同</li>
<li>android:columnCount，最大列数</li>
<li>android:rowCount，最大行数</li>
<li>android:useDefaultMargins，使行边距和列边距的大小相同</li>
<li>android:layout_row，子view的行位置</li>
<li>android:layout_column，子view的列位置</li>
<li>android:layout_rowSpan，子view占据的行数</li>
<li>android:layout_columnSpan，子view占据的列数</li>
</ul>
<pre><code>    &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
    &lt;GridLayout
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    tools:context=&quot;com.linjiamin.layout.MainActivity&quot;
    android:columnCount = &quot;4&quot;
    android:useDefaultMargins = &quot;true&quot;&gt;
&lt;!--使用columnCount，最大为4列--&gt;
&lt;!--使用useDefaultMargins，行距和列距相等--&gt;
    &lt;TextView
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:textSize=&quot;80sp&quot;
    android:text=&quot;0&quot;/&gt;

    &lt;!--使用layout_column，显示在第一行地四列--&gt;
    &lt;TextView
    android:layout_column =&quot;3&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:textSize=&quot;80sp&quot;
    android:text=&quot;1&quot;/&gt;
    &lt;!--使用layout_columnSpan，占据两列--&gt;
    &lt;TextView
    android:layout_columnSpan=&quot;2&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:textSize=&quot;80sp&quot;
    android:text=&quot;2&quot;/&gt;
    &lt;!--使用layout_rowSpan，占据两行，所有下方没有数字--&gt;
    &lt;TextView
    android:layout_rowSpan=&quot;2&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:textSize=&quot;80sp&quot;
    android:text=&quot;3&quot;/&gt;

    &lt;TextView
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:textSize=&quot;80sp&quot;
    android:text=&quot;4&quot;/&gt;

    &lt;TextView
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:textSize=&quot;80sp&quot;
    android:text=&quot;5&quot;/&gt;

    &lt;TextView
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:textSize=&quot;80sp&quot;
    android:text=&quot;6&quot;/&gt;

    &lt;TextView
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:textSize=&quot;80sp&quot;
    android:text=&quot;7&quot;/&gt;
    &lt;/GridLayout&gt;
</code></pre><ul>
<li>显示效果如下</li>
</ul>
<p><img src="http://i2.kiimg.com/1949/964a6d449f23347a.png" alt=""></p>
<ul>
<li>Table不能设置Span属性，它的行数和列数不确定，控件不能跨行跨列，实现复杂的界面会比较困难，这种情况下应当使用GridLayout</li>
</ul>
<h3 id="frameLayout"><a href="#frameLayout" class="headerlink" title="- frameLayout"></a>- frameLayout</h3><p><strong>帧布局</strong></p>
<ul>
<li>帧布局是功能最少的布局</li>
<li>帧布局的大小由最大的控件决定，底层的控件会被覆盖</li>
<li>android:foreground，设置前景图像，前景图像永远不会被覆盖</li>
<li>android:foregroundGravity，设置背景图像</li>
<li>当我们需要通过覆盖来实现界面时，就会使用到frameLayout</li>
</ul>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[BroadcastReceiver 使用入门]]></title>
      <url>/2017/07/11/Broadcast/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p><strong>Intent的四个基本属性包括Action、Data、Category、Extras</strong></p>
<ul>
<li>ACTION是一个字符串，它代表一个动作，可以是创建一个Activity，启动应用，或者用来发送广播等</li>
<li>ACTION值可以自定义，只要Intent-filter中ACTION的值与自定义的相同，Intent就可以被接收</li>
<li>自定义ACTION的规范为 package name + activity name + ACTION，ACTION需要大写并使用下划线隔开</li>
</ul>
<h3 id="发送广播"><a href="#发送广播" class="headerlink" title="发送广播"></a>发送广播</h3><ul>
<li>有序广播与标准广播发送的过程都是类似的，只是最后发送时调用的方法可能不同而已</li>
</ul>
<pre><code>Intent intent = new Intent();
intent.setAction(&quot;com.linjiamin.broadcast.NORMAL&quot;);
intent.putExtra(&quot;key&quot;,&quot;value&quot;);
sendBroadcast(intent);
//sendOrderedBroadcast(intent,null);
//有序广播
//接收至少接收两个参数，一个为intent，另一个为权限，只有持有权限的应用才可以接收
</code></pre><ul>
<li>本地广播的发送方式则有些不同，需要获取localBroadcastManager的实例并调用其方法来发送</li>
</ul>
<pre><code>Intent intent = new Intent(&quot;com.linjiamin.broadcast.NORMAL&quot;);
LocalBroadcastManager localBroadcastManager = LocalBroadcastManager.getInstance(MainActivity.this);
localBroadcastManager.sendBroadcast(intent);
</code></pre><h3 id="注册广播"><a href="#注册广播" class="headerlink" title="注册广播"></a>注册广播</h3><p><strong>注册广播分为两种方式，静态和动态</strong>  </p>
<ul>
<li>静态注册，在新建BroadcastReceiver子类时，AS会自动生成</li>
</ul>
<pre><code>&lt;receiver
    android:name=&quot;.MyReceiver&quot;
    android:enabled=&quot;true&quot;
    android:exported=&quot;true&quot;&gt;
&lt;/receiver&gt; 
</code></pre><ul>
<li>我们只需要添加Intent-filter 属性，通过priority还可以设置优先级，优先级范围在 -1000~1000</li>
</ul>
<pre><code>&lt;receiver
    android:name=&quot;.MyReceiver&quot;
    android:enabled=&quot;true&quot;
    android:exported=&quot;true&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;com.linjiamin.broadcast.NORMAL&quot;/&gt;
    &lt;/intent-filter&gt;

&lt;/receiver&gt;
</code></pre><ul>
<li>动态注册，需要BroadcastReceiver和IntentFilter的实例，并调用注册方法</li>
</ul>
<pre><code> ....

    MyReceiver receiver = new MyReceiver();
    IntentFilter intentFilter = new IntentFilter();

 ....     
   intentFilter.addAction(&quot;com.linjiamin.broadcast.NORMAL&quot;);
    registerReceiver(receiver,intentFilter);

//LocalBroadcastManager localBroadcastManager = LocalBroadcastManager.getInstance(MainActivity.this);
//localBroadcastManager.registerReceiver(receiver,intentFilter);            
//本地广播注册同样要获取LocalBroadcastManager实例
</code></pre><ul>
<li>不要忘记解除注册</li>
</ul>
<pre><code>unregisterReceiver(receiver);
</code></pre><ul>
<li>如果接收的是有序广播，可以选择终止传递</li>
</ul>
<pre><code>    @Override
public void onReceive(Context context, Intent intent) {

    Log.d(&quot;MyReceiver&quot;, &quot;onReceive: receive&quot;);
    abortBroadcast();
}
</code></pre><ul>
<li>注册系统广播的方法是相同的，但有时需要在androidManifest中添加权限</li>
</ul>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;
</code></pre><h2 id="本地广播"><a href="#本地广播" class="headerlink" title="本地广播"></a>本地广播</h2><ul>
<li>本地广播的用法和一般广播类似</li>
<li>本地广播只会在同一个app中传递，不用担心信息泄露而且可以提高效率</li>
</ul>
<h2 id="自定义权限"><a href="#自定义权限" class="headerlink" title="自定义权限"></a>自定义权限</h2><p><strong>在androidManifest中还可以自定义权限，此时除了权限的名称（规范和action基本一致）外，还有一个protectionLevel需要指定</strong></p>
<pre><code>&lt;permission
android:name=&quot;com.linjiamin.permission.TEST&quot;
android:protectionLevel=&quot;normal&quot; /&gt;
</code></pre><ul>
<li>protectionLevel有四个可选值</li>
</ul>
<pre><code>normal：无需用户确认，申请了就可使用
dangerous：用户确认后申请才有效
signature：当使用权限的应用与声明权限的应用打包时签名相同申请才有效
signatureOrSystem：符合上述signature条件或者请求应用为系统应用时申请有效
</code></pre><ul>
<li>申请方法是相同的</li>
</ul>
<pre><code>&lt;uses-permission android:name=&quot;com.linjiamin.permission.TEST&quot;/&gt;
</code></pre><ul>
<li>注册时需要添加权限属性</li>
</ul>
<pre><code>&lt;receiver
    android:name=&quot;.MyReceiver&quot;
    android:enabled=&quot;true&quot;
    android:exported=&quot;true&quot;
    android:permission=&quot;com.linjiamin.permission.TEST&quot;&gt;
    &lt;action android:name=&quot;com.linjiamin.broadcast.TEST&quot;/&gt;
&lt;/receiver&gt;
</code></pre><ul>
<li><p>使用带权限参数的方法发送广播</p>
<pre><code>sendBroadcast(intent,&quot;com.linjiamin.permission.TEST&quot;);
</code></pre></li>
</ul>
<h3 id="onReceive-耗时操作"><a href="#onReceive-耗时操作" class="headerlink" title="onReceive 耗时操作"></a>onReceive 耗时操作</h3><ul>
<li>查看文档我们发现除非使用registerReceiver，onReceive是执行在主线程中的，这意味着一般不能进行耗时操作</li>
</ul>
<pre><code>* This method is always called within the main thread of its process, unless you
* explicitly asked for it to be scheduled on a different thread using
* {@link android.content.Context#registerReceiver(BroadcastReceiver,
* IntentFilter, String, android.os.Handler)}. When it runs on the main
* thread you should
* never perform long-running operations in it (there is a timeout of
* 10 seconds that the system allows before considering the receiver to
* be blocked and a candidate to be killed). You cannot launch a popup dialog
* in your implementation of onReceive().
</code></pre><ul>
<li>那么不妨尝试在onReceive开启一个子线程，同时使用另一个应用发送广播</li>
</ul>
<pre><code>    @Override
    public void onReceive(Context context, Intent intent) {

new Thread(new Runnable() {
    @Override
    public void run() {

        try {
            Thread.sleep(10000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        Log.d(&quot;MyReceiver&quot;, &quot;onReceive: receive&quot;);
    }
}).start();
</code></pre><ul>
<li>当我们设定sleep方法参数为10秒时，我们可以收到日志，设定为1分钟，依然收到了数据，从日志信息可见确实过了1分钟</li>
</ul>
<pre><code>07-13 12:53:35.212 30154-30154/? I/art: Not late-enabling -Xcheck:jni (already on)
07-13 12:53:35.600 30154-30154/com.linjiamin.broadcast W/System: ClassLoader referenced unknown path: /data/app/com.linjiamin.broadcast-1/lib/x86
07-13 12:54:35.618 30154-30169/com.linjiamin.broadcast D/MyReceiver: onReceive: receive
</code></pre><ul>
<li>但是根据网络上的说法，BroadcastReceiver的生命周期很短，onReceive执行完就结束了，这时我们建立的BroadcastReceiver的进程就成了空进程，很容易被杀死，这里可能跟内存占用有关，不管怎样，在onReceive中开启子线程不太可靠，一般来说会使用service进行耗时操作</li>
</ul>
<h3 id="单进程与广播"><a href="#单进程与广播" class="headerlink" title="单进程与广播"></a>单进程与广播</h3><p><a href="http://blog.csdn.net/crazy_yyyyy/article/details/51318092" target="_blank" rel="external">参考</a></p>
<ul>
<li>实践上单进程很少使用本地广播，广播是一种相对耗时，占用空间较多的方式，onReceive方法中可以得到context参数，如果不需要用到相关的方法，就不需要使用广播，可以选择EventBus</li>
</ul>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[实践使用服务]]></title>
      <url>/2017/07/10/Service/</url>
      <content type="html"><![CDATA[<p>onCreate</p>
<a id="more"></a>
<p><strong><a href="https://alberthumbert.github.io/2017/07/10/aboutService/">或者看这里</a></strong></p>
<p><strong>主要通过实践对<a href="https://alberthumbert.github.io/2017/04/30/firstCodeLine/#%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">Service的内容</a>进行复习</strong></p>
<p><br></p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p><br></p>
<h3 id="startService形式"><a href="#startService形式" class="headerlink" title="startService形式"></a>startService形式</h3><ul>
<li>在Activity中使用 startService来启动服务，必要数据可以通过Intent来传递</li>
</ul>
<pre><code>...

Intent(HomeActivity.this,NewsService.class);

...

vpDownload.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                Intent intent = new 
                intent.putExtra(&quot;date&quot;,GetDate.today());
                startService(intent);
            }
});
</code></pre><ul>
<li>在Service的 onStartCommand中开启线程，注意需要返回父类方法的结果</li>
</ul>
<pre><code>public int onStartCommand(final Intent intent, int flags, int startId) {


new Thread(new Runnable() {
    @Override
    public void run() {
        String date = intent.getStringExtra(&quot;date&quot;);
        if(date == null)return;
        JsonFromUrl jsonFromUrl= new JsonFromUrl();
        jsonFromUrl.setApi(NewsApi.COMMON+NewsApi.BEFORE+date);
        Log.d(TAG, &quot;run: &quot;+NewsApi.COMMON+NewsApi.BEFORE+date);
        JSONObject jsonObject = null;
        try {
            jsonObject = jsonFromUrl.getJson();
            Log.d(TAG, &quot;run: &quot;+jsonObject.toString());
        } catch (IOException | JSONException e) {
            e.printStackTrace();
        }

        List newsList = new ArrayList();
        JsonAnalysis.analyze(newsList,jsonObject,NewsApi.BEFORE,null);
    }
}).start();

return super.onStartCommand(intent, flags, startId);
}
</code></pre><ul>
<li>为避免内存泄漏，必须在内部或外部将service停止</li>
</ul>
<pre><code>//in activity
protected void onStop(){
        super.onStop();
        stopService(intent);
    } 

    //in service
    ...
    stopSelf()
...
</code></pre><ul>
<li>注意当一个service被多次执行时请使用 stopSelf(Int startId)方法保证请求被正确终止，  startId由service的onStartCommand参数提供，它标记了请求的编号用以一一对应</li>
</ul>
<p> <br></p>
<h3 id="bindService形式"><a href="#bindService形式" class="headerlink" title="bindService形式"></a>bindService形式</h3><p>**<br>引入binder机制，实现Activity与service的通信<br>**</p>
<ul>
<li>这次我们使用bindService形式启动</li>
</ul>
<pre><code>vpDownload.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                intent.putExtra(&quot;date&quot;,GetDate.today());
                bindService(intent, HomeActivity.this,Service.BIND_AUTO_CREATE);                
            }
        });
</code></pre><ul>
<li>在service中应当实现一个binder，用以传递service的句柄，如此Activity便可以持有service从而调用service的方法了，这个binder在onBind中被传递</li>
</ul>
<pre><code>   @Override
   public IBinder onBind(Intent intent) {
       return new Binder();
   }

   public class Binder extends android.os.Binder{
       public NewsService getService(){
           return NewsService.this;
       }
}
</code></pre><ul>
<li>注意此时，线程应该写在onCreate中，如果不混合使用两种启动方式，此时的onStartCommand是不会被调用的</li>
</ul>
<pre><code>@Override
public void onCreate(){
    super.onCreate();
    //write your THREAD here !!
    Log.d(TAG, &quot;onCreate: &quot;);
}
</code></pre><ul>
<li>返回到Activity中，再实现一个ServiceConnection接口，这个接口只有两个方法必须实现，可以看到service成功进入到了我们的Activity内</li>
</ul>
<pre><code>@Override
public void onServiceConnected(ComponentName name, IBinder service) {
    binder = (NewsService.Binder)service;
    NewsService newsService = binder.getService();
    newsService.showConnection();
}

@Override
public void onServiceDisconnected(ComponentName name) {

} 
</code></pre><ul>
<li><a href="http://blog.csdn.net/u013553529/article/details/54754491?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="external">多次调用bindService()，onBind()只会执行一次</a></li>
</ul>
<p><br></p>
<h2 id="service-生命周期"><a href="#service-生命周期" class="headerlink" title="service 生命周期"></a>service 生命周期</h2><p><br></p>
<h3 id="startService形式-1"><a href="#startService形式-1" class="headerlink" title="startService形式"></a>startService形式</h3><ul>
<li>startService()->onCreate()->onStartCommand()->onDestroy</li>
<li>必须显式关闭service</li>
</ul>
<p><br></p>
<h3 id="bindService形式-1"><a href="#bindService形式-1" class="headerlink" title="bindService形式"></a>bindService形式</h3><ul>
<li>bindService()->onCreate()->onBind()->onUnbind()->onDestriy</li>
<li>service和所有客户端接触绑定之后才会被系统销毁，因此它的生命周期不用过多关心</li>
</ul>
<p><br></p>
<h2 id="Service的存在意义"><a href="#Service的存在意义" class="headerlink" title="Service的存在意义"></a>Service的存在意义</h2><p><strong>service本身是在主线程运行的，这是就是使用service还需要另外开启子线程的原因，那么为什么还要用到service？</strong></p>
<ul>
<li>service的运行是不依赖UI的，即使活动被销毁，service也可以一直运行</li>
<li>Activity很难对内部创建的子线程进行控制，而service可以和所有Activity进行通信</li>
<li>通过前台service提高优先级，在状态栏可以一直为用户提供功能，这是简单地在Activity中创建一个子线程所办不到的</li>
</ul>
<p><br></p>
<h2 id="前台service使用实例"><a href="#前台service使用实例" class="headerlink" title="前台service使用实例"></a>前台service使用实例</h2><p><strong>前台service和后台Service的使用方法基本与前述的Service基本无异，需要了解的只有Notification和startForeground方法</strong><br><strong>这次通过bindService和startForeground来发送通知</strong></p>
<ul>
<li><p>前面在onServiceConnected中使用binder获取了service的实例，这个时候只要发送通知并调用service的startForeground即可，这一部分写在onCreate也是一样的</p>
<pre><code>//in onServiceConnected
binder = (NewsService.Binder)service;
    final NewsService newsService = binder.getService();
    new Handler().postDelayed(new Runnable() {
        @Override
        public void run() {
            List list= newsService.getNewsList();
            if(list==null)return;
            Notification.Builder builder = new Notification.Builder(HomeActivity.this);
            Intent intent = new Intent(HomeActivity.this,HomeActivity.class);
            builder.setContentIntent(PendingIntent.getActivity(HomeActivity.this,0,intent,0))
                    .setContentTitle(((NewsBase)list.get(1)).getTitle())
                    .setSmallIcon(R.mipmap.news_ic_launcher);
            Notification notification = builder.build();
            newsService.startForeground(1,notification);

        }
    },1000);
</code></pre></li>
</ul>
<ul>
<li>为了使通知能够多次更新，可以考虑使用onStartCommand</li>
<li>Notification<a href="http://blog.csdn.net/zhou452840622/article/details/52028896" target="_blank" rel="external">可设置的属性</a>非常多，它采取了非常典型的构造者模式，内部通过return this实现链式调用</li>
</ul>
<p><br></p>
<h2 id="IntentService使用实例"><a href="#IntentService使用实例" class="headerlink" title="IntentService使用实例"></a>IntentService使用实例</h2><p><strong>当要执行多套后台操作时我们首先使用的是onStartCommand，但是在开启线程和关闭请求时会比较繁琐，而IntentService提供简洁的使用方式</strong></p>
<ul>
<li>IntentService必须要有的方法之有两个，构造器和onHandleIntent</li>
<li>构造器必须调用父类方法</li>
</ul>
<pre><code>public NewsIntentService() {
    super(&quot;NewsIntentService&quot;);
    }

    //查看源码发现super(name)使用它的参数来标记线程的名称，而这个名称只在调试时有用
    //Used to name the worker thread, important only for debugging.
</code></pre><ul>
<li>onHandleIntent()该方法运行于子线程中，所以不用自己开启线程</li>
</ul>
<pre><code>protected void onHandleIntent(@Nullable Intent intent) {

JsonFromUrl jsonFromUrl= new JsonFromUrl();
jsonFromUrl.setApi(NewsApi.COMMON+NewsApi.LATEST);
JSONObject jsonObject = null;
try {
    jsonObject = jsonFromUrl.getJson();
} catch (IOException | JSONException e) {
    e.printStackTrace();
}
setNewsList(JsonAnalysis.analyze(newsList,jsonObject,NewsApi.LATEST,null));
Notification.Builder builder = new Notification.Builder(this);
builder.setContentIntent(PendingIntent.getActivity(this,0,intent,0))
        .setContentTitle(((NewsBase)newsList.get(1)).getTitle())
        .setSmallIcon(R.mipmap.news_ic_launcher);
Notification notification = builder.build();
startForeground(1,notification);
}
</code></pre><ul>
<li>有时我们需要获取数据更新UI，那么只需要将Messenger传递给IntentService即可。现在我们发现，利用binder、handler和broadcastReceiver，信息可以很方便地在Activity和service间传输了</li>
</ul>
<pre><code>Handler handler = new Handler(){

@Override
public void handleMessage(Message msg){

    Bundle bundle = msg.getData();
    String message = bundle.getString(&quot;message&quot;);
    switch(message){
        case &quot;update something&quot;:
        ... 
    }
    return;
}
};

        intent = new Intent(HomeActivity.this,NewsService.class);
intent.putExtra(&quot;messager&quot;,new Messenger(handler));
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Activity 知识补充]]></title>
      <url>/2017/07/10/AdditionOfActivity/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><strong>参考资料</strong></p>
<p><a href="http://blog.csdn.net/liuhe688/article/details/6733407" target="_blank" rel="external">liuhe688</a></p>
<p><a href="http://blog.csdn.net/weizongwei5/article/details/50515719" target="_blank" rel="external">weizongwei5</a></p>
<p><a href="http://download.csdn.net/detail/jsntghf/9602444" target="_blank" rel="external">Android开发艺术探索</a></p>
<p>**<br>第一行代码中Activity的内容比较简单，因此额外找了一些内容进一步学习<br>**</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul>
<li>首先看一下<a href="https://alberthumbert.github.io/2017/04/30/firstCodeLine/#%E6%B4%BB%E5%8A%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">Android生命周期的普通过程</a>，这一部分应该已经学习过几遍了，不再赘述，通过一个简单的demo进行回顾，稍后修改这个demo并切入主题</li>
</ul>
<pre><code>public class LifeActivity extends AppCompatActivity {

    private static final String TAG = &quot;LifeActivity&quot;;
    @Override
    protected void onCreate(Bundle savedInstanceState){
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_life);
        Log.i(TAG, &quot;onCreate called&quot;);
    }

    @Override
    protected void onStart() {
        super.onStart();
        Log.i(TAG, &quot;onStart called&quot;);
    }

 @Override
    protected void onRestart() {
        super.onRestart();
        Log.i(TAG, &quot;nRestart called&quot;);
    }

    @Override
    protected void onResume() {
        super.onResume();
        Log.i(TAG, &quot;onResume called&quot;);
    }

    @Override
    protected void onPause() {
        super.onPause();
        Log.i(TAG, &quot;onPause called&quot;);
    }

    @Override
    protected void onStop() {
        super.onStop();
        Log.i(TAG, &quot;onStop called&quot;);
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        Log.i(TAG, &quot;onDestroy called&quot;);
    }
}
</code></pre><ul>
<li>启动Activity</li>
</ul>
<pre><code>LifeActivity: onCreate called
LifeActivity: onStart called
LifeActivity: onResume called
</code></pre><ul>
<li>启动另一个Activity，可以看到前一个Activity的onPause执行之后下一个Activity的onCreated才会执行，这就是onPause耗时操作要少的原因，应当考虑能否将这部分操作在onStoped进行</li>
</ul>
<pre><code>LifeActivity: onPause called
AnotherActivity: onCreate called
AnotherActivity: onStart called
AnotherActivity: onResume called
LifeActivity: onStop called
</code></pre><ul>
<li>back键返回LifeActivity，同样前一个Activity的onPause执行后下一个Activity的onRestart才会执行</li>
</ul>
<pre><code>AnotherActivity: onPause called
LifeActivity: onRestart called
LifeActivity: onStart called
AnotherActivity: onStop called
AnotherActivity: onDestroy called
</code></pre><ul>
<li>点击home键</li>
</ul>
<pre><code>LifeActivity: onPause called
LifeActivity: onStop called     
</code></pre><ul>
<li>点击home键后回到应用</li>
</ul>
<pre><code>lifeActivity: oRestart called
ifeActivity: onStart called
LifeActivity: onResume called
</code></pre><p>**<br>接下来对这些调用方法进行一些奇怪的操作<br>**</p>
<ul>
<li>在onCreate执行之前让Activity结束</li>
</ul>
<pre><code>...
finish();
super.onCreate(savedInstanceState);
...
</code></pre><ul>
<li>输出</li>
</ul>
<pre><code>LifeActivity: onCreate called
LifeActivity: onDestroy called
</code></pre><ul>
<li>很正常，onCreate被完整执行后onDestory()被执行了</li>
</ul>
<ul>
<li>在onStart()中执行finish()，从结果可见没有进入前台期，与onStart对应的onStop被执行了</li>
</ul>
<pre><code>onStart called
onStop called
onDestroy called
</code></pre><ul>
<li>接下来尝试在onRestart()中执行finish()，然后在第二个Activity中按back键。有点奇怪，LifeActivity并不直接执行onStop，而是回到了前台，经历了一个非常完整的生命周期并且在第二个Activity之前被销毁</li>
</ul>
<pre><code>AnotherActivity: onPause called
LifeActivity: onRestart called
LifeActivity: onStart called
LifeActivity: onResume called
LifeActivity: onPause called
LifeActivity: onStop called
LifeActivity: onDestroy called
AnotherActivity: onStop called
AnotherActivity: onDestroy called
</code></pre><ul>
<li>到这里本来想测试一下Activity因内存不足而被销毁会经历什么过程，于是把虚拟机内存调为了128m，但是没能成功实现内存不足的情况…搜索到了使用adb模拟内存不足销毁应用的方法</li>
</ul>
<pre><code>adb shell am kill-all
adb shell am kill package-name 
# 我们关注的应用只有一个，所以这两个命令是一样的
</code></pre><ul>
<li>如无意外，应用会被kill，然而这里出现一个错误导致缓冲区被锁，log无法打印，暂时没有找到解决办法，实在不行以后下载个大点的游戏进行真机调试……</li>
</ul>
<pre><code>E/Surface: getSlotFromBufferLocked: unknown buffer: 0xb40152c0
</code></pre><ul>
<li>另外屏幕旋转会导致Activity被销毁重建，销毁过程为</li>
</ul>
<pre><code>AnotherActivity: onPause called
AnotherActivity: onStop called
AnotherActivity: onDestroy called
</code></pre><h2 id="onWindowFocusChanged"><a href="#onWindowFocusChanged" class="headerlink" title="onWindowFocusChanged"></a>onWindowFocusChanged</h2><p>**<br>这个方法会在Activity窗口获得或失去焦点被调用，和生命周期方法一样，程序员不应该自己去调用它<br>**</p>
<pre><code>onResume called
onWindowFocusChanged called
</code></pre><ul>
<li>当我们在想在onCreate方法中获取组件大小时，有可能会因为window对象未创建而失败，必须保证在onCreate方法完成之后再执行</li>
<li>重写onWindowFocusChanged方法可以解决这个问题</li>
</ul>
<h2 id="onSaveInstanceState"><a href="#onSaveInstanceState" class="headerlink" title="onSaveInstanceState"></a>onSaveInstanceState</h2><p>**<br>这是一个为了Activity被调离栈顶时保存数据而存在的方法<br>**</p>
<ul>
<li>被调用的位置，下一个活动进入前台，而之前的活动转为不可见时</li>
</ul>
<pre><code>AnotherActivity: onResume called
LifeActivity: onSaveInstanceState called
LifeActivity: onStop called
</code></pre><ul>
<li>注意一个会被销毁的Activity是不会调用这个方法的，只在可以被返回的Activity中重写它</li>
</ul>
<pre><code>    @Override
    protected void onSaveInstanceState(Bundle outState){
    outState.putInt(&quot;param&quot;,param);
    Log.i(TAG, &quot;onSaveInstanceState called&quot;);
}
</code></pre><h2 id="onRestoreInstanceState"><a href="#onRestoreInstanceState" class="headerlink" title="onRestoreInstanceState"></a>onRestoreInstanceState</h2><p>**<br>生命周期相关的方法总是两两配对，而onRestoreInstanceState的作用自然是获取保留下来的数据了，不过它的情况有点特殊，只会在Activity在后台被杀死或者屏幕旋转时被调用<br>**</p>
<ul>
<li>同样重写这个方法，以键值对的形式得到数据</li>
</ul>
<pre><code>@Override
    protected void onRestoreInstanceState(Bundle savedInstanceState){
        param = savedInstanceState.getInt(&quot;param&quot;);
        Log.i(TAG, &quot;onRestoreInstanceState called get&quot;+param);
        super.onRestoreInstanceState(savedInstanceState);
    } 
</code></pre><ul>
<li>旋转屏幕并恢复</li>
</ul>
<pre><code>LifeActivity: onCreate called
LifeActivity: onStart called
LifeActivity: onRestoreInstanceState called get 1
LifeActivity: onResume called
LifeActivity: onWindowFocusChanged called 
</code></pre><h2 id="启动模式与Flags"><a href="#启动模式与Flags" class="headerlink" title="启动模式与Flags"></a>启动模式与Flags</h2><p>**<br>除了<a href="https://alberthumbert.github.io/2017/04/30/firstCodeLine/#%E5%9B%9B%E4%B8%AA%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F">在XML中设置启动模式</a>，<br>下面还有一种设置启动模式的方法<br>**</p>
<ul>
<li>Flags标记位有许多作用，其中一种是设置启动模式</li>
<li><p>Flags标记位的优先级要大于XML属性，但它无法设置singleInstance模式，使用方式如下</p>
<pre><code>public static void actionStart(Context context){

        Intent intent = new Intent(context,FlagActivity.class);
        intent.addFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
        context.startActivity(intent);
    }
</code></pre></li>
</ul>
<ul>
<li>几种常用的Flags</li>
</ul>
<pre><code>FLAG_ACTIVITY_NEW_TASK
//指定singleTask模式

FLAG_ACTIVITY_SINGLE_TOP
//指定singleTop模式

FLAG_ACTIVITY_CLEAR_TOP
//启动时所用该Activity之上的Activity全部出栈，一般与singleTask一起使用
//如果采用standard模式，该Activity与其上的Activity会出栈并建立新的Activity

FLAG_ACTIVITY_FROM_RECENTS
//Activity不出现在历史列表中
</code></pre><ul>
<li><p>我们使用 FLAG_ACTIVITY_NEW_TASK 为例循环启动3个Activity，不在XML中标记，可以看出依然为standard模式</p>
<pre><code>Run #6: ActivityRecord{fd1d8c9 u0 com.linjiamin.myapplication/.NewTaskActivity t138}
 Run #5: ActivityRecord{47b8982 u0 com.linjiamin.myapplication/.NewTaskActivity t138}
 Run #4: ActivityRecord{60095cc u0 com.linjiamin.myapplication/.MainActivity t138}
 Run #3: ActivityRecord{786e788 u0 com.linjiamin.myapplication/.Main2Activity t138}
 Run #2: ActivityRecord{87a03a5 u0 com.linjiamin.myapplication/.Main2Activity t138}
 Run #1: ActivityRecord{9471e17 u0 com.linjiamin.myapplication/.NewTaskActivity t138}
 Run #0: ActivityRecord{49c4ac2 u0 com.linjiamin.myapplication/.MainActivity t138}
</code></pre></li>
<li><p>接着在XML中标记为SingleInstance模式，FLAG依然不起作用，singleTask亦同</p>
<pre><code>   TaskRecord{bfd2cdd #139 A=com.linjiamin.myapplication U=0 sz=5}
  Run #5: ActivityRecord{6fd6eee u0 com.linjiamin.myapplication/.Main2Activity t139}
TaskRecord{98a6f23 #140 A=com.linjiamin.myapplication U=0 sz=1}
  Run #4: ActivityRecord{1d577f4 u0 com.linjiamin.myapplication/.NewTaskActivity t140}
TaskRecord{bfd2cdd #139 A=com.linjiamin.myapplication U=0 sz=5}
  Run #3: ActivityRecord{3ba4af9 u0 com.linjiamin.myapplication/.MainActivity t139}
  Run #2: ActivityRecord{4a4b5bc u0 com.linjiamin.myapplication/.Main2Activity t139}
  Run #1: ActivityRecord{5e70342 u0 com.linjiamin.myapplication/.Main2Activity t139}
  Run #0: ActivityRecord{b3bab83 u0 com.linjiamin.myapplication/.MainActivity t139}
</code></pre></li>
<li><p>查看文档，这个Flag确实用来标记(或者曾经用来标记)singleTask模式，实践发现手动设置Flag已经不起作用，但文档却没有修改，存在一定的误导性</p>
<pre><code>* &lt;p&gt;When using this flag, if a task is already running for the activity
* you are now starting, then a new activity will not be started; instead,
* the current task will simply be brought to the front of the screen with
* the state it was last in.  See {@link #FLAG_ACTIVITY_MULTIPLE_TASK} for a flag
* to disable this behavior.
</code></pre></li>
</ul>
<h2 id="TaskAffinity"><a href="#TaskAffinity" class="headerlink" title="TaskAffinity"></a>TaskAffinity</h2><p><strong>TaskAffinity，指定了Activity将归属于哪一个任务栈，一般只配合singleTask和singleInstance模式使用</strong></p>
<h3 id="查看和修改任务栈"><a href="#查看和修改任务栈" class="headerlink" title="查看和修改任务栈"></a>查看和修改任务栈</h3><ul>
<li>首先，需要查看Activity任务栈信息的手段，使用adb shell dumpsys activity可以查看所有与Activity相关的信息，但是输出非常冗长，不妨这样</li>
</ul>
<pre><code>adb shell dumpsys activity activities | sed -En -e &apos;/Running activities/,/Run #0/p&apos;
</code></pre><ul>
<li>TaskRecord 信息就是我们需要的，例如 com.linjiamin.lifecycle 就是Task的名字</li>
</ul>
<pre><code>TaskRecord{776e103 #53 A=com.linjiamin.lifecycle U=0 sz=3}
</code></pre><ul>
<li>taskAffinity指定Activity应属于哪一个任务栈，默认情况下它等于包名，这意味着Activity倾向于属于同一个任务，通过XML可以设置这个属性，以singleTask模式为例</li>
</ul>
<pre><code>&lt;activity
    android:name=&quot;.FlagActivity&quot;
    android:launchMode=&quot;singleTask&quot;
    android:taskAffinity=&quot;com.linjiamin.lifecycle.task3&quot;&gt;
    &lt;/activity&gt;
</code></pre><ul>
<li>执行 adb shell dumpsys，可见任务栈的已被修改，task3出现了</li>
</ul>
<pre><code>TaskRecord{1605ccbd #52 A=com.linjiamin.lifecycle.task3 U=0 sz=1}
TaskRecord{2300c203 #51 A=com.linjiamin.lifecycle U=0 sz=2}
</code></pre><h3 id="TaskAffinity与任务栈"><a href="#TaskAffinity与任务栈" class="headerlink" title="TaskAffinity与任务栈"></a>TaskAffinity与任务栈</h3><ul>
<li>启动一个singleTask属性的Activity，系统首先会查找Activity想要的task，若不存在就会创建这个task。而Activity具体需的Task名，默认情况是使用包名，若标记了TaskAffinity就会使用TaskAffinity指定的值</li>
</ul>
<ul>
<li>使用Standard模式启动Activity，会将Activity加入启动它的Activity的任务栈中，除非是用TaskAffinity去标记MainActivity（一般不会这样），否则TaskAffinity和sandard配合时TaskAffinity是没有意义的</li>
</ul>
<pre><code>&lt;activity android:name=&quot;.LifeActivity&quot;
    android:taskAffinity=&quot;com.linjiamin.lifecycle.task1&quot;
    android:launchMode=&quot;standard&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;

        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;

//输出为
 TaskRecord{21a9d665 #57 A=com.linjiamin.lifecycle.task1 U=0 sz=4}
</code></pre><ul>
<li>当使用ApplicationContext去启动standard模式的Activity时，Application根本就没有任务栈，所以这时会报错，为解决这个问题，需要将Activity的FLAG标记为singleTask模式，即</li>
</ul>
<pre><code>FLAG_ACTIVITY_NEW_TASK
</code></pre><ul>
<li>当使用 singleInstance，若实例存在，它的任务栈不会改变，如果实例不存在且栈不存在，则会创建TaskAffinity指定的任务栈和实例</li>
</ul>
<h2 id="使用Bundle传递数据"><a href="#使用Bundle传递数据" class="headerlink" title="使用Bundle传递数据"></a>使用Bundle传递数据</h2><p>**<br>考虑一种情况，当一个组数据需要在Activity间多次添加、修改、传递，如果<a href="https://alberthumbert.github.io/2017/04/30/firstCodeLine/#%E4%BD%BF%E7%94%A8Intent%E5%9C%A8%E6%B4%BB%E5%8A%A8%E4%B9%8B%E9%97%B4%E7%A9%BF%E6%A2%AD">只使用Intent</a>是否会相当麻烦？<br>**</p>
<ul>
<li>使用Bundle可以使数据的传输变得简单许多，创建Bundle并调用intent的putExtras(Bundle extras)方法即可</li>
</ul>
<pre><code>        button.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        Bundle bundle = new Bundle();
        bundle.putBoolean(&quot;aBooleanParam&quot;,false);
        bundle.putInt(&quot;anIntParam&quot;,1);
        bundle.putString(&quot;aStringParam&quot;,&quot;2&quot;);
        Intent intent = new Intent(AnotherActivity.this,FlagActivity.class);
        intent.putExtras(bundle);
        startActivity(intent);
    }
}); 
</code></pre><ul>
<li>获取数据的方法和intent相同，也可以用putParcelable传递自定义的类型</li>
</ul>
<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_flag);
    Bundle bundle = getIntent().getExtras();
    Log.d(TAG, &quot;onCreate: &quot;+bundle.getBoolean(&quot;aBooleanParam&quot;));
    Log.d(TAG, &quot;onCreate: &quot;+bundle.getInt(&quot;anIntParam&quot;));
    Log.d(TAG, &quot;onCreate: &quot;+bundle.getString(&quot;aStringParam&quot;));
}       
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Gradle 从入门到......]]></title>
      <url>/2017/07/08/Gradle/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><strong>Gradle是一种依赖管理工具，它使用一种基于jvm的动态语言Groovy</strong></p>
<p><br></p>
<h3 id="Project-和-Task"><a href="#Project-和-Task" class="headerlink" title="Project 和 Task"></a>Project 和 Task</h3><p>**<br>这是gradle中最基本的概念，其中Project并非Android Studio所指的Project<br>**</p>
<ul>
<li>每一个build.gradle对应一个project，每一个project对应一个相对完整的构建部分，如module</li>
<li>执行build.gradle会为每个Project创建和配置所有task，每一个task对应一个逻辑上的执行单元，task又由一系列的action组成</li>
</ul>
<pre><code>//在最外层的build.gradle中可以看见这样一个task
//它用于删除bulid目录
task clean(type: Delete) {
    delete rootProject.buildDir
}
</code></pre><ul>
<li>为更好地理解task，可以自定义一个task，在任意层级的build.gradle中加入如下代码</li>
</ul>
<pre><code>task hello &lt;&lt; {
    println &apos;hello&apos;
}
</code></pre><p>在终端界面中输入 ./gradlew hello （*nix），gradlew hello（windows，maybe…），会出现</p>
<pre><code>:hello
hello
</code></pre><p>这说明这个任务被成功执行了，由于我没有安装ndk所以还输出了一大堆诸如 NDK is missing a “platforms” directory的提示，另外输出的提示还有</p>
<pre><code>The Task.leftShift(Closure) method has been deprecated and is scheduled to be removed in Gradle 5.0. Please use Task.doLast(Action) instead.
</code></pre><p>leftShift(Closure)？？为什么出现它？？其实 \&lt;\&lt; 就相当于 leftShift() 方法，它是一个重载，表示添加一个action，并且已经过时了，可以修改为</p>
<pre><code>task hello {  
    doLast {      
        println &apos;hello&apos;      
    }      
}   
</code></pre><p><br>       </p>
<h3 id="gradle-脚本"><a href="#gradle-脚本" class="headerlink" title="gradle 脚本"></a>gradle 脚本</h3><p>**<br>暂时需要了解的只有build.gradle和setting.gradle<br>**</p>
<p><br></p>
<h4 id="settings-gradle"><a href="#settings-gradle" class="headerlink" title="- settings.gradle"></a>- settings.gradle</h4><ul>
<li>这个文件在初始化时期执行，定义了需要被构建的module</li>
</ul>
<pre><code>include &apos;:app&apos;, &apos;:newsmodule&apos;, &apos;:newslibrary&apos;
</code></pre><ul>
<li>如果只有一个模块，它将会长成下面这样子，而且这个文件可以被删除</li>
</ul>
<pre><code>include &apos;:app&apos;
</code></pre><p><br>       </p>
<h4 id="根目录的build-gradle"><a href="#根目录的build-gradle" class="headerlink" title="- 根目录的build.gradle"></a>- 根目录的build.gradle</h4><pre><code>// Top-level build file where you can add configuration options common to all sub-projects/modules.

buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath &apos;com.android.tools.build:gradle:2.3.1&apos;

        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
}

allprojects {
    repositories {
        jcenter()
    }
}

task clean(type: Delete) {
    delete rootProject.buildDir
}
</code></pre><h5 id="repositorie"><a href="#repositorie" class="headerlink" title="repositorie"></a>repositorie</h5><ul>
<li><a href="#repositories">详见</a></li>
</ul>
<h5 id="buildscript"><a href="#buildscript" class="headerlink" title="buildscript"></a>buildscript</h5><ul>
<li>buildscript，该闭包中是关于gradle的构建工具的配置，dependecbies就是所依赖的构建工具的信息，由于在AS中，所以用到的是Android Gradle plugin</li>
</ul>
<h5 id="allprojects"><a href="#allprojects" class="headerlink" title="allprojects"></a>allprojects</h5><ul>
<li>allprojects，该闭包中是关于所有子项目的配置，这意味着可以直接在里面添加任务</li>
<li>buildscript和allprojects的本质不同在于，buildscript用于配置gradle本身，而allprojects用于配置需要被构建的子项目  <a href="https://stackoverflow.com/questions/30158971/whats-the-difference-between-buildscript-and-allprojects-in-build-gradle" target="_blank" rel="external">difference between buildscript and allprojects</a></li>
</ul>
<p><br></p>
<h4 id="模块内的build-gradle"><a href="#模块内的build-gradle" class="headerlink" title="- 模块内的build.gradle"></a>- 模块内的build.gradle</h4><pre><code>apply plugin: &apos;com.android.application&apos;

android {
    compileSdkVersion 24
    buildToolsVersion &quot;25.0.3&quot;
    defaultConfig {
        applicationId &quot;com.linjiamin.daily_linjiamin&quot;
        minSdkVersion 19
        targetSdkVersion 24
        versionCode 1
        versionName &quot;1.0&quot;
        testInstrumentationRunner       &quot;android.support.test.runner.AndroidJUnitRunner&quot;
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;
        }
    }
}

dependencies {
    compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])
    androidTestCompile(&apos;com.android.support.test.espresso:espresso-core:2.2.2&apos;, {
        exclude group: &apos;com.android.support&apos;, module: &apos;support-annotations&apos;
    })
    compile &apos;com.android.support:appcompat-v7:24.2.1&apos;
    compile &apos;com.android.support.constraint:constraint-layout:1.0.2&apos;

    testCompile &apos;junit:junit:4.12&apos;
}
</code></pre><p><br>       </p>
<h5 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h5><ul>
<li>apply plugin，表示为脚本添加插件，插件包括了已经定义好的属性和task，可以提供扩展功能，如下面的android标签就是Android application所插件提供，只有添加了它才能使用</li>
</ul>
<p><br></p>
<h5 id="compileSdkVersion"><a href="#compileSdkVersion" class="headerlink" title="compileSdkVersion"></a>compileSdkVersion</h5><ul>
<li>编译时使用的API版本</li>
</ul>
<p><br></p>
<h5 id="buildToolsVersion"><a href="#buildToolsVersion" class="headerlink" title="buildToolsVersion"></a>buildToolsVersion</h5><ul>
<li>构建工具的版本号，构建工具包括了一系列的命令</li>
</ul>
<p><br></p>
<h5 id="defaultConfig"><a href="#defaultConfig" class="headerlink" title="defaultConfig"></a>defaultConfig</h5><ul>
<li>关于app的属性配置，它将重写AndroidManifest.xml</li>
</ul>
<p><br></p>
<h5 id="applicationId"><a href="#applicationId" class="headerlink" title="applicationId"></a>applicationId</h5><ul>
<li>用于标识不同的app版本，不直接使用包名划分是因为包名会用于命名R文件，如果创建新版本时还需要修改R文件那将十分麻烦</li>
</ul>
<p><br></p>
<h5 id="versionCode"><a href="#versionCode" class="headerlink" title="versionCode"></a>versionCode</h5><ul>
<li>versionCode 和 versionName 用于标识app版本，程序本身不会在任何地方调用到这个值，在开发过程中versionCode往往会变化非常快，会成为一个很大的值，这对用户来说不便，于是就产生了versionName这一字符串标识</li>
</ul>
<p><br></p>
<h5 id="buildTypes"><a href="#buildTypes" class="headerlink" title="buildTypes"></a>buildTypes</h5><ul>
<li>设置构建版本和混淆文件</li>
</ul>
<p><br></p>
<h5 id="dependencies"><a href="#dependencies" class="headerlink" title="dependencies"></a>dependencies</h5><ul>
<li><a href="#dependencies">详见</a></li>
</ul>
<p><br></p>
<h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p>**<br>当项目需要用到其他开发者的依赖库时，我们不需要手动下载jar包so包到指定位置，更不需要未版本的迭代而操心，gradle已经解决了这些问题<br>**</p>
<p><br></p>
<h4 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a><span id="repositories">仓库</span></h4><ul>
<li>repositories，远程仓库，它是依赖包的来源，Android Studio默认为jcenter，也可以为maven，Ivy等</li>
<li>当执行build构建时依赖包会从这些远程仓库里下载并在本地留下缓存</li>
<li>Gradle默认使用三个maven仓库，mavenCrentral，jcenter，mavenLocal，有些依赖包并不在其中，这时只需</li>
</ul>
<pre><code>repositories {
    maven {
        url &quot;.....&quot;//填写maven仓库地址
    }
}
</code></pre><p><br></p>
<h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a><span id="dependencies">依赖</span></h4><ul>
<li>完整的依赖包含三个元素，group，通常为包名，name，library的唯一标识，version，版本号，通常写法为</li>
</ul>
<pre><code>dependencies {
    compile &apos;com.google.code.gson:gson:2.7&apos;
}
</code></pre><ul>
<li>也可以这样展开</li>
</ul>
<pre><code>dependencies {
compile group: &apos;com.google.code.gson&apos;, name: &apos;gson&apos;, version:&apos;2.7&apos;
}
</code></pre><ul>
<li>为避免键入错误，还可以在File->Project Structure-Dependencies 中联网查找并导入</li>
</ul>
<p><br></p>
<h4 id="本地依赖"><a href="#本地依赖" class="headerlink" title="本地依赖"></a>本地依赖</h4><p><br></p>
<h4 id="导入jar包"><a href="#导入jar包" class="headerlink" title="- 导入jar包"></a>- 导入jar包</h4><ul>
<li>在一个app的build.gradle中我们可以找到如下配置</li>
</ul>
<pre><code>compile fileTree(include: [&apos;*.jar&apos;], dir: &apos;libs&apos;)
</code></pre><ul>
<li>这意味着需要使用本地jar包时只要将其放入模块的libs文件即可</li>
</ul>
<p><br></p>
<h4 id="导入aar包"><a href="#导入aar包" class="headerlink" title="- 导入aar包"></a>- 导入aar包</h4><ul>
<li>添加文件夹 </li>
</ul>
<pre><code>repositories {
    flatDir {
    dirs &apos;aarlibs&apos;
}
</code></pre><ul>
<li>添加依赖</li>
</ul>
<pre><code>compile(name:&apos;aarlibrary&apos;, ext:&apos;aar&apos;)  
</code></pre><p><br></p>
<h4 id="导入so包"><a href="#导入so包" class="headerlink" title="- 导入so包"></a>- 导入so包</h4><ul>
<li>指定文件夹位置，将so包放入文件夹中即可</li>
</ul>
<pre><code>sourceSets {
    main {
        jniLibs.srcDirs = [&apos;src/main/LibsName&apos;]
    }
}
</code></pre><ul>
<li>Android Studio 默认 src/main/jniLibs 放置so包，这意味着可以直接新建一个jniLibs文件夹而不需要进行任何配置</li>
</ul>
<p><br></p>
<h4 id="使用模块"><a href="#使用模块" class="headerlink" title="- 使用模块"></a>- 使用模块</h4><ul>
<li>创建一个模块作为依赖包(library)时，Android Studio会自动在它的build.gradle配置对应的插件</li>
</ul>
<pre><code>apply plugin: &apos;com.android.library&apos;
</code></pre><ul>
<li>并且会在setting.gradle添加模块</li>
</ul>
<pre><code>include &apos;:app&apos;, &apos;:mylibrary&apos;
</code></pre><ul>
<li>所有只需要在调用到该模块的app的build.module中添加依赖即可，同样可以在File->Project Structure-Dependencies中导入</li>
</ul>
<pre><code>dependencies {
    compile project(&apos;:mylibrary&apos;)
}       
</code></pre><h4 id="其他配置"><a href="#其他配置" class="headerlink" title="- 其他配置"></a>- 其他配置</h4><ul>
<li>build.gradle中还能看到</li>
</ul>
<pre><code>testCompile &apos;junit:junit:4.12&apos;
androidTestCompile(&apos;com.android.support.test.espresso:espresso-core:2.2.2&apos;, {
        exclude group: &apos;com.android.support&apos;, module: &apos;support-annotations&apos;
    })          
</code></pre><ul>
<li>依赖本身有五种配置，compile只是默认的一个，其他可能用到的一般只有提供单元测试的testCompile和androidTestCompile，有空再来学习</li>
</ul>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Studio 基本操作]]></title>
      <url>/2017/07/05/ASShortcut/</url>
      <content type="html"><![CDATA[<p>还有这种操作？</p>
<a id="more"></a>
<p><br></p>
<h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><p><strong><br>Android Studio提供了大量的默认快捷键，当然用户也可以自定义快捷键。<br>Preference-&gt;keymap中可查看所有快键键，右键选择Add Keyboard shortcut 或 Add Mouse Shortcut 可自定义快捷键，<br>注意有些快捷键在特定的情况下才会触发。<br>浏览 Tip of the day 弹窗的每日介绍，是熟悉上手这些快捷键的好方法。
</strong></p>
<ul>
<li><strong>Cmd + “-“/“+”</strong> (mac)，<strong>Ctrl + Shift + “+”/”-“</strong> (win) ，展开或者以更简洁的方式显示代码</li>
<li><strong>Cmd + F</strong>(mac)，<strong>Ctrl + F</strong>(win)，快速查找，在对应的窗口中进行模糊查找</li>
<li><strong>Cmd + B</strong>(mac)，<strong>Ctrl + B</strong>(win)，查看类文件或方法的内容或变量被使用的地方</li>
<li><strong>Cmd + P</strong>(mac)，<strong>Ctrl + P</strong>(win)，查看方法所需变量类型</li>
<li><strong>Cmd + D</strong>(mac)，<strong>Ctrl + D</strong>(win)，复制并粘贴选中内容或当前光标所在行</li>
<li><strong>Cmd + N</strong>(mac)，<strong>Alt＋Insert</strong>(win)，添加构造器，getter，setter等</li>
<li><strong>Cmd + O</strong>(mac)，<strong>Ctrl + N</strong>(win)，快速打开类</li>
<li><strong>Cmd + /</strong>(mac)，<strong>Ctrl + /</strong>(win)，将当前行改为注释</li>
<li><strong>Cmd + F12</strong>(mac)，<strong>Ctrl + F12</strong>(win)，显示当前类结构</li>
<li><strong>Cmd + Shift + /</strong>(mac)，<strong>Ctrl + Shift + /</strong>(win)，添加注释，mac可能会同时触发Help-&gt;search的快捷键，建议在Keymap中修改</li>
<li><strong>Cmd + W</strong>(mac)，关闭当前窗口</li>
<li><strong>Cmd + Q</strong>(mac)，退出Android studio</li>
<li><strong>Alt +↑↓← →</strong>，快速 选择块/移动光标</li>
<li><strong>Ctrl + O / I</strong>，显示所有可 重写/实现 的方法，选中后输入模板</li>
<li><strong>Shift + F1</strong>，打开光标所在元素的网页文档，<strong>然而你可能被墙了</strong></li>
<li><strong>Ctrl + ~</strong>，更改显示选项</li>
</ul>
<p><br></p>
<h2 id="实用功能"><a href="#实用功能" class="headerlink" title="实用功能"></a>实用功能</h2><p><br></p>
<h3 id="书签"><a href="#书签" class="headerlink" title="- 书签"></a>- 书签</h3><p><strong><br>书签为代码位置提供一个标记。<br>在 Navigate-&gt;bookmark 中可对书签进行相应管理。
</strong></p>
<ul>
<li><strong>F3</strong> (mac)，<strong>F11</strong> (win)，添加/删除 书签</li>
<li><strong>Alt + F3</strong> (mac)，<strong>Ctrl + F11</strong> (win)，添加/删除 带有名称的书签</li>
<li><strong>Cmd + F3</strong> (mac) ，<strong>Shift + F11</strong> (win)，查看和管理所有标签</li>
<li><strong>Ctrl + NAME</strong>，当书签带有名称，可使用该操作进行快速跳转</li>
</ul>
<p><br></p>
<h3 id="版本控制"><a href="#版本控制" class="headerlink" title="- 版本控制"></a>- 版本控制</h3><p><strong><br>VCS-&gt;git 中可以实现常用git命令的功能，Android Stuido 还提供了图形化的比较工具
</strong></p>
<ul>
<li><strong>Ctrl + V</strong>(mac)，<strong>Alt + `</strong>(win)，弹出版本控制菜单</li>
<li>git-&gt;Compare With Branch，比较当前文件与分支中的修改</li>
<li>Version Control-&gt;Log，显示git log –graph日志</li>
</ul>
<p><br></p>
<h3 id="正则表达式检查工具"><a href="#正则表达式检查工具" class="headerlink" title="- 正则表达式检查工具"></a>- 正则表达式检查工具</h3><p><strong><br>将普通正则转化为Java中的正则表达式，并提供用实例检查的功能
</strong></p>
<ul>
<li><strong>Alt + Enter</strong>，需要在matches(“”)的双引号中才会触发</li>
<li>Sample 中输入例子进行检查</li>
</ul>
<p><br></p>
<h3 id="模板"><a href="#模板" class="headerlink" title="- 模板"></a>- 模板</h3><p><strong><br>模板，Live Template，是一种输入特定字符并利用编译器自动补全的方法
</strong></p>
<ul>
<li><strong>Cmd + J</strong>(mac)，<strong>Ctrl + J</strong>(win)，列出所有模板，这意味着并不需要记住所有匹配字符</li>
<li>Preference &gt; Editor &gt; Live Templates 可自定义模板，注意使用$符号将变量名包围</li>
<li>File and Code Template 中还可以自定义文件创建时自动添加的模板，Android Studio 中类开头的文档注释就是这么生成的</li>
</ul>
<p><br></p>
<h2 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h2><ul>
<li>preference-&gt;plugins中可以在线下载插件，下载完后点击重启AS即可，十分方便</li>
<li><a href="http://www.open-open.com/lib/view/open1480329318348.html" target="_blank" rel="external">插件能够提供的功能非常丰富</a></li>
<li><a href="http://blog.csdn.net/lmj623565791/article/details/51548272" target="_blank" rel="external">通过编写jar程序也可以实现简单的插件</a></li>
</ul>
<p><br></p>
<h2 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h2><p><strong><br>Android Studio中的Project-Module关系相当于，Eclipse中的Workplace-Project，VS中的解决方法-工程。
</strong><br><br></p>
<h3 id="创建Module"><a href="#创建Module" class="headerlink" title="创建Module"></a>创建Module</h3><ul>
<li>File-&gt;new-&gt;new module中可选择新建或导入不同类型的module</li>
<li>Phone &amp; Table Module，Android Module，Android TV module，Google Cloud Module，分别对应不同平台上的程序</li>
<li>Android Library，Java Library，分别生成aar和jar文件作为依赖库</li>
<li>每个module作为一个独立的程序可以单独运行和调试</li>
<li>原则上Android Library可以当做Java Library来使用，区别在于aar可以携带文件，调用android API<br><a href="https://stackoverflow.com/questions/28154681/android-studio-java-library-module-vs-android-library-module" target="_blank" rel="external">Difference between Android library and Java library</a></li>
</ul>
<p><br></p>
<h3 id="调用Module"><a href="#调用Module" class="headerlink" title="- 调用Module"></a>- 调用Module</h3><ul>
<li><a href="https://alberthumbert.github.io/2017/07/08/aboutGradle/">详见</a></li>
</ul>
<p><br></p>
<h2 id="性能分析工具"><a href="#性能分析工具" class="headerlink" title="性能分析工具"></a>性能分析工具</h2><p><br></p>
<h3 id="Profile-GPU-Rendering"><a href="#Profile-GPU-Rendering" class="headerlink" title="Profile GPU Rendering"></a>Profile GPU Rendering</h3><p><strong><br>当一个view被绘制，主要经过三个过程，GPU准备数据，GPU从缓存列表获取数据，Display设备绘制，这三个过程的耗时可通过 Profile GPU Rendering 查看
</strong></p>
<ul>
<li>在开发者选项中找到 Profile GPU Rendering 开关（或者叫GPU呈现模式分析），打开后可以看见一系列彩色柱状图</li>
<li>红，黄，蓝，紫分别对应每一帧在不同阶段的耗时情况</li>
<li>蓝 ,表示创建Display List所花费的时间，具体来说就是执行onDraw方法的时间，当蓝色的线很高时可能需要考虑优化onDraw方法</li>
<li>红，表示2D渲染Display List所消耗的时间，过高时可能是重新提交视图所致</li>
<li>黄，CPU告诉GPU进行绘制每一帧会后会等待GPU的回复，如果柱状图过高，表示GUP繁忙</li>
<li>紫，资源转移到渲染线程的时间</li>
</ul>
<p><br></p>
<h3 id="Trace-View"><a href="#Trace-View" class="headerlink" title="Trace View"></a>Trace View</h3><p><strong><br>Profile GPU Rendering提供的信息非常模糊，无法满足优化代码的需求，Trace View 可以分析到具体每一个方法的耗时
</strong></p>
<p><br></p>
<h4 id="获取-Trace-文件"><a href="#获取-Trace-文件" class="headerlink" title="- 获取 Trace 文件"></a>- 获取 Trace 文件</h4><ul>
<li>调试应用</li>
<li>打开DDMS</li>
<li>点击Strarted Method Profiling</li>
<li>操作应用后点击Stop Method Profiling会跳出一个非常丑的界面，它就是Trace View分析视图</li>
</ul>
<p><br></p>
<h4 id="TraceView-视图"><a href="#TraceView-视图" class="headerlink" title="- TraceView 视图"></a>- TraceView 视图</h4><ul>
<li>Timeline Panel 面板，X轴表示时间，Y轴表示不同的线程</li>
<li>Profile Panel 面板，主要关注Calls+Recur Calls / Total 和CPU time / call，表示调用次数和耗时</li>
</ul>
<p><br></p>
<h3 id="SYStrace-UI"><a href="#SYStrace-UI" class="headerlink" title="SYStrace UI"></a>SYStrace UI</h3><ul>
<li>打开DDMS，点击 SYStrace按钮（capture system wide…）</li>
<li>配置信息后生成Trace文件，用Chrome打开（只能用chrome），这个更丑的界面就是SYStrace UI类</li>
<li>Alert界面，标记了有问题的地方并提供了描述</li>
<li>点击 F字母标记的圆，当显示为红色或黄色时表示渲染耗时过长，达不到60fps，查看提示以及系统正在进行的任务以分析问题</li>
</ul>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[pro git 1-6章 笔记]]></title>
      <url>/2017/05/22/ProGit/</url>
      <content type="html"><![CDATA[<p>onCreate</p>
<a id="more"></a>
<h2 id="第一章-起步"><a href="#第一章-起步" class="headerlink" title="第一章 起步"></a>第一章 起步</h2><hr>
<p>**  略 **</p>
<p><br></p>
<h2 id="第二章-Git-基础"><a href="#第二章-Git-基础" class="headerlink" title="第二章 Git 基础"></a>第二章 Git 基础</h2><hr>
<p><br></p>
<h3 id="获取git仓库"><a href="#获取git仓库" class="headerlink" title="获取git仓库"></a>获取git仓库</h3><hr>
<p><br></p>
<h4 id="git-init-初始化仓库"><a href="#git-init-初始化仓库" class="headerlink" title="git init - 初始化仓库"></a>git init - 初始化仓库</h4><p><strong>创建.git目录</strong></p>
<ul>
<li>.git，包含一个git仓库中所有必须的文件，这即是说当要清除版本控制时只需要执行：</li>
</ul>
<pre><code>$ rm -rf .git
</code></pre><ul>
<li>init 参数只会执行初始化操作，所以还需要对现有文件进行选择性的跟踪和提交：</li>
</ul>
<pre><code>$ git add *.c
$ git add LICENSE
$ git commit -m &apos;initial project version&apos;
</code></pre><ul>
<li>init执行后 .git 中至少包含：</li>
</ul>
<pre><code>refs/
# 指向commit的指针，即commit的SHA-1值


HEAD
# 指示目前被检出的分支
# 内容形如： ref: refs/heads/master

config
# 包含配置信息
# 内容形如：
# repositoryformatversion = 0
# filemode = true 
# ...

description
# 仅供 GitWeb 程序使用，无需关心

hooks/
# 目录包含客户端或服务端的钩子脚本

info/
# 包含一个名为exclude的全局性排除文件
# 可以追加不希望被记录在.gitignore的排除内容，如：
# *.[oa] 
# *~
# 在这里添加的排除信息不会提交到仓库，也就不会影响到别人

objects/
# 储存版本控制的所有数据
</code></pre><p><br>          </p>
<h4 id="git-clone-url-克隆现有仓库"><a href="#git-clone-url-克隆现有仓库" class="headerlink" title="git clone [url] - 克隆现有仓库"></a>git clone [url] - 克隆现有仓库</h4><p><strong>拉取仓库中每个文件的每个版本</strong></p>
<ul>
<li>clone会创建.git文件夹将所有数据放入在内并读取最新版本的文件</li>
<li>url支持多种协议格式，如https协议，git协议，ssh协议</li>
<li>clone会自动添加远程仓库并以origin为简写</li>
<li>clone会自动设置本地master分支跟踪克隆的远程仓库的master分支（默认分支）</li>
</ul>
<p><br></p>
<h3 id="记录每次更新到仓库"><a href="#记录每次更新到仓库" class="headerlink" title="记录每次更新到仓库"></a>记录每次更新到仓库</h3><hr>
<p><br></p>
<h4 id="git-status-检查当前文件状态"><a href="#git-status-检查当前文件状态" class="headerlink" title="git status - 检查当前文件状态"></a>git status - 检查当前文件状态</h4><ul>
<li>文件根据是否纳入版本控制存在两种状态，已跟踪和未跟踪</li>
<li>已跟踪文件分为三种状态，未修改，已修改，已暂存</li>
<li>Changes not staged for commit 下的文件属于已修改状态</li>
<li>Changes to be committed 下的文件处于已暂存状态</li>
<li>使用参数 -s 可得到简略输出</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">？？  # 未跟踪文件</div><div class="line">A    # 新添加到暂存区的文件</div><div class="line"> M   # 修改后未暂存</div><div class="line">M    # 修改后已暂存</div><div class="line">MM   # 修改暂存后又修改</div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="git-add-flie-跟踪与暂存文件"><a href="#git-add-flie-跟踪与暂存文件" class="headerlink" title="git add [flie] - 跟踪与暂存文件"></a>git add [flie] - 跟踪与暂存文件</h4><ul>
<li>git 不会自动跟踪之前提交中没有的文件</li>
<li>add 使用文件或目录为参数，如果参数是路径，将递归地跟踪或暂存该目录下的所有文件</li>
<li>add 只会暂存当前时刻的版本，再次修改需重新暂存</li>
</ul>
<p><br></p>
<h4 id="gitignore-忽略文件"><a href="#gitignore-忽略文件" class="headerlink" title=".gitignore - 忽略文件"></a>.gitignore - 忽略文件</h4><ul>
<li>日志文件，编译临时文件等不需要纳入版本控制，可在.gitignore中添加排除信息</li>
<li>数十种语言的 gitignore文件 <a href="https://github.com/github/gitignore" target="_blank" rel="external">https://github.com/github/gitignore</a></li>
<li>格式规范</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#   开头，被忽略，通常用于注释</div><div class="line">/   开头，防止递归，只忽略当前目录所匹配的文件</div><div class="line">/   结尾，指定目录</div><div class="line">!   开头，取反</div><div class="line">*   任意匹配0或多个字符</div><div class="line">?   任意匹配一个字符</div><div class="line">[ ] 任意匹配括号中的一个字符  </div><div class="line">**  任意匹配中间目录</div></pre></td></tr></table></figure>
<ul>
<li>下面是一个java项目可用的文件：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"># Compiled class file</div><div class="line">*.class</div><div class="line"></div><div class="line"># Log file</div><div class="line">*.log</div><div class="line"></div><div class="line"># BlueJ files</div><div class="line">*.ctxt</div><div class="line"></div><div class="line"># Mobile Tools for Java (J2ME)</div><div class="line">.mtj.tmp/</div><div class="line"></div><div class="line"># Package Files #</div><div class="line">*.jar</div><div class="line">*.war</div><div class="line">*.ear</div><div class="line">*.zip</div><div class="line">*.tar.gz</div><div class="line">*.rar</div><div class="line"></div><div class="line"># virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xml</div><div class="line">hs_err_pid*</div></pre></td></tr></table></figure>
<p><br>      </p>
<h4 id="git-diff-查看修改"><a href="#git-diff-查看修改" class="headerlink" title="git diff - 查看修改"></a>git diff - 查看修改</h4><p><strong>显示修改的具体信息</strong> </p>
<ul>
<li>git diff 只显示尚未暂存的改动，而不是上次提交以来的所有改动</li>
<li>git diff –staged 只显示已暂存的改动</li>
</ul>
<p><br></p>
<h4 id="git-commit-提交更新"><a href="#git-commit-提交更新" class="headerlink" title="git commit - 提交更新"></a>git commit - 提交更新</h4><ul>
<li>每次提交前应先用git status查看是否有文件未暂存</li>
<li>git commit 默认启动shell环境变量 $EDITOR所指定的编辑器</li>
<li>在编辑器中，所有注释将会在生成提交时被移除，而提交信息会保留</li>
<li>git commit -m “[description]” 允许在命令中添加提交信息</li>
<li>git commit -a 允许跳过暂存操作，所有跟踪过的文件会被一并提交</li>
</ul>
<p><br></p>
<h4 id="git-rm-file-移除文件"><a href="#git-rm-file-移除文件" class="headerlink" title="git rm [file] - 移除文件"></a>git rm [file] - 移除文件</h4><ul>
<li>rm 参数只对已跟踪的文件起作用</li>
<li>git rm 会将文件从将暂存区和工作目录中删除</li>
<li>git rm -f 删除修改过并且已放到暂存区的文件</li>
<li>git rm –cached 只将文件从暂存区中移除，文件会恢复为未跟踪状态，不会被删除，因此可能需要手动添加到.gitignore</li>
</ul>
<p><br></p>
<h3 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h3><hr>
<p><br></p>
<h4 id="git-log-查看提交历史"><a href="#git-log-查看提交历史" class="headerlink" title="git log - 查看提交历史"></a>git log - 查看提交历史</h4><ul>
<li>git log 会按时间由后到前列出所有更新信息</li>
<li>git log -p 附带每次提交内容的差异</li>
<li>git log –stat 附带被修改文件的名称、数量和修改类型</li>
<li>git log –pretty=format 使用占位符修改输出信息</li>
<li>git log –graph 附带描述分支合并历史的图表</li>
</ul>
<p><br></p>
<h3 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h3><hr>
<p><br></p>
<h4 id="git-commit-–amend-修改提交"><a href="#git-commit-–amend-修改提交" class="headerlink" title="git commit –amend -修改提交"></a>git commit –amend -修改提交</h4><ul>
<li>git commit –amend 会将暂存中的文件与上一次提交合并，可以用来补充遗漏</li>
<li>amend选项覆盖的提交是可恢复的，详见数据恢复章节</li>
</ul>
<p><br></p>
<h4 id="git-reset-取消暂存的文件"><a href="#git-reset-取消暂存的文件" class="headerlink" title="git reset - 取消暂存的文件"></a>git reset - 取消暂存的文件</h4><ul>
<li>git reset HEAD [file] 可以将文件修改为未暂存状态</li>
<li>reset 和 rm –cached 的区别：reset不会使文件变为未跟踪状态 </li>
<li><a href="https://stackoverflow.com/questions/17122480/difference-between-git-rm-cached-and-git-reset-head" target="_blank" rel="external">https://stackoverflow.com/questions/17122480/difference-between-git-rm-cached-and-git-reset-head</a></li>
</ul>
<p><br></p>
<h4 id="git-checkout-–-file-撤销修改"><a href="#git-checkout-–-file-撤销修改" class="headerlink" title="git checkout – [file] - 撤销修改"></a>git checkout – [file] - 撤销修改</h4><ul>
<li>git checkout – [file] 会将文件还原为上次提交时的内容</li>
<li>这是一个危险的命令，它造成的效果是不可逆的</li>
</ul>
<p><br></p>
<h3 id="远程仓库的使用"><a href="#远程仓库的使用" class="headerlink" title="远程仓库的使用"></a>远程仓库的使用</h3><hr>
<p><br></p>
<h4 id="git-remote-查看远程仓库"><a href="#git-remote-查看远程仓库" class="headerlink" title="git remote - 查看远程仓库"></a>git remote - 查看远程仓库</h4><ul>
<li>git remote 会显示远程仓库列表，如果已经克隆了仓库，那么至少可以看到 origin</li>
<li>git remote 会显示读写远程仓库使用的简写与其对应的URL</li>
<li>git remote show [remote-name] 会显示一个远程仓库的更多信息</li>
</ul>
<p><br></p>
<h4 id="git-remote-add-添加远程仓库"><a href="#git-remote-add-添加远程仓库" class="headerlink" title="git remote add - 添加远程仓库"></a>git remote add - 添加远程仓库</h4><ul>
<li>git remote add [shortname] [url] 添加一个新的远程Git仓库，同时指定一个可以引用的简写</li>
<li>git remote rename [oldname] [newname] 可以修改远程仓库的简写</li>
<li>git remote rm [remote-name] 将会移除一个远程仓库</li>
</ul>
<p><br></p>
<h4 id="git-fetch-从远程仓库中抓取与拉取"><a href="#git-fetch-从远程仓库中抓取与拉取" class="headerlink" title="git fetch - 从远程仓库中抓取与拉取"></a>git fetch - 从远程仓库中抓取与拉取</h4><ul>
<li>git fetch [remote-name] 会拉取远程仓库中的所有分支和数据</li>
<li>git fetch origin 会抓取克隆或上一次抓取后推送的所有工作</li>
<li>git fetch 不会自动合并和修改当前的工作，必须手动合并</li>
</ul>
<p><br></p>
<h4 id="git-push-推送到远程仓库"><a href="#git-push-推送到远程仓库" class="headerlink" title="git push - 推送到远程仓库"></a>git push - 推送到远程仓库</h4><ul>
<li>git push [remote-name][branch-name]，只有拥有所克隆服务器的写入权限并且之前没有人推送过时，命令才会生效</li>
<li>当他人先将数据推送到上游时命令会被拒绝，必须先将他人的工作拉取并合并后才能推送</li>
<li>git push origin [tagname]，push不会将标签推送到服务器上，在创建完标签后必须显式地推送</li>
<li>git push origin –tags ，推送所有标签</li>
</ul>
<p><br></p>
<h3 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h3><hr>
<p><br></p>
<h4 id="git-tag-列出标签"><a href="#git-tag-列出标签" class="headerlink" title="git tag - 列出标签"></a>git tag - 列出标签</h4><ul>
<li>git tag 会以字母顺序列出标签</li>
<li>可以用特定的模式查找标签，如</li>
</ul>
<pre><code>git tag -l &apos; v1.* &apos;
</code></pre><p><br></p>
<h4 id="git-tag-a-创建标签"><a href="#git-tag-a-创建标签" class="headerlink" title="git tag -a 创建标签"></a>git tag -a 创建标签</h4><ul>
<li>git tag -a (v1.0) -m ‘my version 1.0’ ，为最新的提交打上附注标签，若无 -m参数，编辑器会被打开</li>
<li>git tag -a v1.0 9fceb02，为指定提交打标签，需要在末尾指定提交的校验和</li>
<li>git tag (v1.0)  ,为最新的提交打上轻量标签</li>
<li>附注标签是Git数据库中的一个完整对象，可以被校验，包含多种信息</li>
<li>轻量标签是一个特定提交的引用，类似分支，只是将校验和存储到一个文件里而已</li>
</ul>
<p><br></p>
<h3 id="git别名"><a href="#git别名" class="headerlink" title="git别名"></a>git别名</h3><p>** 略 **</p>
<p><br></p>
<h2 id="第三章-Git-分支"><a href="#第三章-Git-分支" class="headerlink" title="第三章 Git 分支"></a>第三章 Git 分支</h2><hr>
<p><strong>分支，一个包含对象校验和（长度为40的SHA-1值字符串）的文件</strong></p>
<p><br></p>
<h3 id="commit-object-提交对象"><a href="#commit-object-提交对象" class="headerlink" title="commit object - 提交对象"></a>commit object - 提交对象</h3><ul>
<li>git保存的不是文件的变化和差异，而是不同时刻的文件快照</li>
<li>除首次提交外，每次提交产生的提交对象都有父对象，多分支合并产生的提交有多个父对象，构成提交对象的树（图）结构</li>
<li>git仓库至少有三种对象，包括 blob对象（保存文件快照），树对象（记录目录结构和blob对象索引）以及提交对象（包含指向树对象的指针和所有提交信息）</li>
<li>git init默认创建的分支名是master，master不是一个特殊的分支，它和其他分支相比没有任何本质区别</li>
<li><strong>git分支本质上只是指向提交对象的可变指针</strong></li>
</ul>
<p><br></p>
<h3 id="使用分支"><a href="#使用分支" class="headerlink" title="使用分支"></a>使用分支</h3><hr>
<p><br></p>
<h4 id="git-branch-分支创建"><a href="#git-branch-分支创建" class="headerlink" title="git branch - 分支创建"></a>git branch - 分支创建</h4><ul>
<li>git branch [branchname]，会创建一个新的分支</li>
<li>创建新分支实际上只是在当前提交对象上创建了一个可移动的新指针</li>
<li>HEAD指针，这是一个特殊指针，永远指向当前分支</li>
<li>git branch 只会创建分支并不会自动切换到新分支</li>
<li>git checkout -b [branchname]，会创建一个新分支并切换到这个新分支上</li>
<li>git branch -d [branchname]，会删除一个分支，当分支已被合并时理应进行删除操作</li>
<li>git branch -D [branchname]，会强制删除一个分支</li>
<li>git log –oneline –decorate 可以显示各个分支当前指向的提交对象</li>
<li>git log –oneline –decorate –graph –all 可以显示提交历史、各分支的指向以及项目的分支分叉情况</li>
</ul>
<p><br></p>
<h4 id="git-checkout-分支切换"><a href="#git-checkout-分支切换" class="headerlink" title="git checkout - 分支切换"></a>git checkout - 分支切换</h4><ul>
<li>git checkout [branchname] ，会将HEAD切换到新分支，即更换当前分支</li>
<li>提交更新时只有head指向的分支会向前移动，其他分支则依然停留在原先的版本</li>
<li>git checkout [branchname] 本质上做了两件事，将head指向另外的分支，将工作目录恢复为该分支所指向的快照内容</li>
</ul>
<p><br></p>
<h4 id="git-merge-合并分支"><a href="#git-merge-合并分支" class="headerlink" title="git merge - 合并分支"></a>git merge - 合并分支</h4><ul>
<li>git merge [branchname] 会将当前分支与指定分支合并</li>
<li>fast-forward 模式，两个分支是直接的上下游关系，合并分支只会简单地将指针向前推进</li>
<li>两个不同的分支对同一个文件的同一个部分进行了不同的修改时，git不会提交合并，需要手动解决冲突</li>
<li>git branch –merged，可以查看已合并的分支，通常这些分支可以删除</li>
<li>git branch –no-merged，可以查看未合并的分支</li>
<li>产生冲突时使用git status查看包含冲突而未合并的文件，解决后使用git add将文件标价为冲突已解决</li>
</ul>
<p><br></p>
<h3 id="分支开发工作流"><a href="#分支开发工作流" class="headerlink" title="分支开发工作流"></a>分支开发工作流</h3><hr>
<p>** 略 **</p>
<p><br></p>
<h3 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h3><hr>
<p><br></p>
<h4 id="远程引用"><a href="#远程引用" class="headerlink" title="远程引用"></a>远程引用</h4><ul>
<li>远程引用是对远程仓库的引用（指针），包括分支、标签等</li>
<li>git ls-remote [remotename]，会显示远程引用的完整列表</li>
</ul>
<p><br></p>
<h4 id="远程跟踪分支"><a href="#远程跟踪分支" class="headerlink" title="远程跟踪分支"></a>远程跟踪分支</h4><ul>
<li>远程跟踪分支，以[remote] / [branch] 形式命名，是不能手动移动的本地引用，当进行网络通信操作时会自动移动</li>
<li>远程跟踪分支类似上次连接到远程仓库时的书签</li>
<li>当使用git clone时，git会自动将远程仓库命名为origin并创建一个名为origin/master的远程分支，同时还会创建一个相同的本地master分支</li>
<li>origin无特殊含义，和其他所有远程仓库引用是一致的，如果喜欢可以使用 git clone -o [name] 来自己命名</li>
<li>git remote add [shortname] [url] ，会添加一个新的远程仓库引用到当前项目</li>
</ul>
<p><br></p>
<h4 id="git-fetch-更新远程仓库引用"><a href="#git-fetch-更新远程仓库引用" class="headerlink" title="git fetch - 更新远程仓库引用"></a>git fetch - 更新远程仓库引用</h4><p><strong>以origin为例</strong></p>
<ul>
<li>只要不与服务器连接，origin/master就不会移动</li>
<li>git fetch origin ， 将会查找origin指代的服务器，抓取本地没有的数据并更新本地数据库，移动origin/master指针</li>
</ul>
<p><br></p>
<h4 id="git-push-推送"><a href="#git-push-推送" class="headerlink" title="git push - 推送"></a>git push - 推送</h4><ul>
<li>想要公开分享一个分支时，需要将其推送到有写入权限的远程仓库上</li>
<li>git push [remote][branch]，可以更新远程分支</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># 例：</div><div class="line">$ git push origin serverfix</div><div class="line"># git 会自动将serverfix展开为refs/heads/serverfix:refs/heads/serverfix</div><div class="line"># 这意味着本地serverfix会更新远程仓库的serverfix分支</div><div class="line"># 它相当于 git push serverfix:serverfix</div><div class="line"># 详见 Git内部原理 章节</div></pre></td></tr></table></figure>
<ul>
<li>抓取远程分支时不会自动形成可编辑的副本拷贝，被抓取的[remote][branch] 只有不可修改的指针，需要使用 git merge [remote][branch] 将这个分支合并到当前分支</li>
<li>git push [remote] –delete [branchname] 可以在服务器上删除远程分支</li>
</ul>
<p><br></p>
<h4 id="本地跟踪分支"><a href="#本地跟踪分支" class="headerlink" title="本地跟踪分支"></a>本地跟踪分支</h4><p><strong>注：书中使用远程跟踪分支和跟踪分支这两个概念，为了避免混淆这里将跟踪分支叫做本地跟踪分支，举例来说两者间的区别就是 origin/master和master的区别</strong></p>
<ul>
<li>从远程跟踪分支检出一个本地分支会自动创建一个本地跟踪分支，在本地跟踪分支上使用git pull 还会自动识别需要抓取合并的分支</li>
<li>克隆一个仓库时，会自动创建一个跟踪origin/master分支的本地master分支</li>
<li>git checkout -b [branch] [remotename]/[branch]，将创建一个本地跟踪分支</li>
<li>git checkout –track [remotename]/[branch] 为简写</li>
<li>git branch -u [remotename]/[branchname]，可以初始化或修改当前分支跟踪的远程分支，-u全写为 –set-upstream-to</li>
<li>git branch -vv，查看所有的本地跟踪分支</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">例：</div><div class="line">$git branch -vv</div><div class="line">* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it</div><div class="line"># 当前分支为 serverfix</div><div class="line"># 跟踪的分支为 teamone/server-fix-good</div><div class="line"># 本地有三次提交未上传合并，服务器上有一次提交未拉取合并</div></pre></td></tr></table></figure>
<ul>
<li>可以使用@{upstream}或@{u}快捷方式来引用当前分支跟踪的远程分支</li>
</ul>
<p><strong>值得一提的是在远程分支上进行git pull时git会声称当前不在一条分支上面，大概upstream和branch是两个不同的概念</strong></p>
<p><br></p>
<h4 id="git-pull-拉取分支"><a href="#git-pull-拉取分支" class="headerlink" title="git pull -拉取分支"></a>git pull -拉取分支</h4><ul>
<li>git pull 大多数情况下的含义是git fetch 后紧跟一个git merge</li>
<li>git pull 容易让人困惑，通常单独显式地使用fetch 和 merge 会更好</li>
</ul>
<p><br></p>
<h3 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h3><hr>
<p><strong>gayhub的由来(才怪)</strong></p>
<p><strong>不常用，仅作了解</strong><br><br></p>
<h4 id="git-rebase-变基的基本操作"><a href="#git-rebase-变基的基本操作" class="headerlink" title="git rebase - 变基的基本操作"></a>git rebase - 变基的基本操作</h4><ul>
<li>merge 被称为三方合并，它选取两个分支的最新快照与两者最近的共同祖先合并形成一个新的快照</li>
<li>rebese 命令将提交到某一分支上的修改移到另一分支上，它造成的结果和merge是一样的，但提交历史会是更加简洁的一条直线</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">列：</div><div class="line">$ git checkout experiment</div><div class="line">$ git rebase master</div><div class="line"># 此时当前maser所在位置相当于experiment的直接上游</div><div class="line">$ git checkout experiment</div><div class="line">$ git rebase master</div><div class="line"># 将experiment的修改在master上重演，相当于fast-forward模式</div></pre></td></tr></table></figure>
<p><br>      </p>
<h4 id="非目标分支上的重演"><a href="#非目标分支上的重演" class="headerlink" title="非目标分支上的重演"></a>非目标分支上的重演</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git rebase --onto master server client</div><div class="line"># 意思是取出client分支，找出client分支和server分支的共同祖先后的修改，让他们在master分支上重演一遍</div></pre></td></tr></table></figure>
<p><br></p>
<font size="5">第四、五章中关于服务器上git仓库的内容全部跳过</font>

<p><br></p>
<h2 id="第四章-服务器上的git"><a href="#第四章-服务器上的git" class="headerlink" title="第四章 服务器上的git"></a>第四章 服务器上的git</h2><hr>
<p><strong>略</strong></p>
<p><br></p>
<h2 id="第五章-分布式git"><a href="#第五章-分布式git" class="headerlink" title="第五章 分布式git"></a>第五章 分布式git</h2><hr>
<p><strong>成为合格的贡献者和整合者</strong></p>
<p><br></p>
<h3 id="分布式工作流程"><a href="#分布式工作流程" class="headerlink" title="分布式工作流程"></a>分布式工作流程</h3><hr>
<p><br></p>
<h4 id="集中式工作流"><a href="#集中式工作流" class="headerlink" title="- 集中式工作流"></a>- 集中式工作流</h4><p><strong>开发团队常用模式</strong></p>
<ul>
<li>以接受代码的仓库为中心，若干开发者为节点将工作与仓库同步</li>
<li>若有两个开发者从中心仓库克隆代码并修改，只有第一个开发者可以顺利地把数据推送回共享服务器，第二个开发者必须先将第一个人的工作合并，这样才不会覆盖第一个人的修改</li>
</ul>
<p><br></p>
<h4 id="集成管理者工作流"><a href="#集成管理者工作流" class="headerlink" title="- 集成管理者工作流"></a>- 集成管理者工作流</h4><p><strong>Github常用模式</strong></p>
<ul>
<li>每个开发者拥有自己仓库的读写权限和其他所有人的读取权限，为代表官方项目的权威仓库贡献</li>
<li><p>维护者将开发者的仓库作为远程仓库添加，在本地测试变更，将其合并进入官方仓库</p>
<pre><code>例：

1. 项目维护者推送到主仓库
2. 贡献者克隆此仓库，做出修改
3. 贡献者将数据推送到自己的公开仓库
4. 贡献者给维护者发送邮件，请求拉取自己的更新
5. 维护者在自己的本地仓库中，将贡献者的仓库加为远程仓库合并修改
6. 维护者将合并后的修改推送到主仓库
</code></pre></li>
</ul>
<p><br></p>
<h4 id="提交准则"><a href="#提交准则" class="headerlink" title="- 提交准则"></a>- 提交准则</h4><p><strong>写好 Git Commit 信息的 7 个建议：<a href="http://blog.jobbole.com/92713/" target="_blank" rel="external">http://blog.jobbole.com/92713/</a></strong></p>
<ul>
<li>git diff –check，显示空白错误，空白错误指文件中的tab等字符，这些字符也会被视为修改内容，不应将这些修改提交</li>
<li>让每一个提交成为一个逻辑上的独立变更，即不要尝试一次解决多个问题然后上传一个巨大的提交</li>
<li>提交信息，应当少于50个字符（25个汉字）的单行开始且简要地描述变更，接着是一个空白行，再接着是一个更加详细的解释（每行小于72字符）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#################################################</div><div class="line"></div><div class="line">    修改的摘要（50个字符或更少）</div><div class="line">    # 首字母大写，若只需要这一行，可以直接使用-m参数</div><div class="line">     </div><div class="line">    关于修改的更多解释（每行小于72字符）</div><div class="line">    # 使用空行分隔段落，可以使用 - 符号开头，注意git不会自动换行</div><div class="line">     </div><div class="line">##################################################</div><div class="line">     </div><div class="line">列：</div><div class="line">     </div><div class="line">commit eb0b56b19017ab5c16c745e6da39c53126924ed6</div><div class="line">Author: Pieter Wuille &lt;pieter.wuille@gmail.com&gt;</div><div class="line">Date:   Fri Aug 1 22:57:55 2014 +0200</div><div class="line">     </div><div class="line"> Simplify serialize.h&apos;s exception handling</div><div class="line"> </div><div class="line"> Remove the &apos;state&apos; and &apos;exceptmask&apos; from serialize.h&apos;s stream</div><div class="line"> implementations, as well as related methods.</div><div class="line"> </div><div class="line"> As exceptmask always included &apos;failbit&apos;, and setstate was always</div><div class="line"> called with bits = failbit, all it did was immediately raise an</div><div class="line"> exception. Get rid of those variables, and replace the setstate</div><div class="line"> with direct exception throwing (which also removes some dead code).</div><div class="line"> </div><div class="line"> As a result, good() is never reached after a failure (there are</div><div class="line"> only 2 calls, one of which is in tests), and can just be replaced</div><div class="line"> by !eof().</div><div class="line"> </div><div class="line"> fail(), clear(n) and exceptions() are just never called. Delete them.</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="第六章-GitHub"><a href="#第六章-GitHub" class="headerlink" title="第六章 GitHub"></a>第六章 GitHub</h2><hr>
<p><strong>暂略</strong></p>
<p><br></p>
<h2 id="第七章-Git-工具"><a href="#第七章-Git-工具" class="headerlink" title="第七章 Git 工具"></a>第七章 Git 工具</h2><hr>
<p><br>   </p>
<h3 id="引用技巧"><a href="#引用技巧" class="headerlink" title="引用技巧"></a>引用技巧</h3><hr>
<p><br>   </p>
<h4 id="简短的SHA-1"><a href="#简短的SHA-1" class="headerlink" title="- 简短的SHA-1"></a>- 简短的SHA-1</h4><ul>
<li>可以使用开头的几个字符（不少于4个）代替完整SHA-1</li>
<li>git log –abbrev-commit，会显示简短且唯一的值，默认7个字符，如果有冲突会增加字符</li>
</ul>
<p><br>   </p>
<h4 id="分支引用"><a href="#分支引用" class="headerlink" title="- 分支引用"></a>- 分支引用</h4><ul>
<li>指明一个提交最直接的方法是有一个指向它的分支引用，可以用分支引用代替SHA-1</li>
<li>git rev-parse [branchname]，显示分支指代的SHA-1</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git rev-parse master</div><div class="line">          </div><div class="line">25303d395e6075d5d627a79ce914ad0fb47f352c</div></pre></td></tr></table></figure>
<p><br>  </p>
<h4 id="git-reflog-引用日志"><a href="#git-reflog-引用日志" class="headerlink" title="git reflog - 引用日志"></a>git reflog - 引用日志</h4><ul>
<li>git会在后台保存一个引用日志（reflog）记录进几个月HEAD和分支引用指向的历史</li>
<li>每当HEAD所指向的位置发生了变化，git就会将信息存储到引用日志里</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ git reflog</div><div class="line"></div><div class="line">25303d3 HEAD@&#123;0&#125;: commit: Fix image source database</div><div class="line">367fcf7 HEAD@&#123;1&#125;: checkout: moving from 367fcf7d44af7e90ad2e8505cf3e4aa5b69d401d to master</div><div class="line">367fcf7 HEAD@&#123;2&#125;: checkout: moving from master to origin/master</div><div class="line">367fcf7 HEAD@&#123;3&#125;: pull: Fast-forward</div><div class="line">b7c7faa HEAD@&#123;4&#125;: commit: Add README</div><div class="line">77e24b9 HEAD@&#123;5&#125;: commit (initial): First commit</div></pre></td></tr></table></figure>
<ul>
<li><p>可以使用@{n} 来引用reflog中输出的提交记录</p>
<pre><code>$ git show HEAD@{5}
</code></pre></li>
<li><p>也可以查看某个分支在特定时间前的位置</p>
<pre><code>$ git show master@{yesterday}
</code></pre></li>
</ul>
<p><br>      </p>
<h4 id="祖先引用"><a href="#祖先引用" class="headerlink" title="^~ - 祖先引用"></a>^~ - 祖先引用</h4><ul>
<li>祖先引用符号 ^ 会被解析为它前面的引用的上一个版本，HEAD^、d9219970^等写法都是合理的</li>
<li>祖先引用符号 ~ 一般和 ^ 是等价的，唯一的区别在于，~后的数字为倒退的次数，^后的数字为父提交的序号（只有存在多个父提交时才能这么使用），即 ~3 等价于 ^^^，而 ^2 相当于父提交中被合并的次级分支</li>
</ul>
<pre><code>例：
$ git show HEAD^^^
</code></pre><h4 id="…-提交区间"><a href="#…-提交区间" class="headerlink" title="^… - 提交区间"></a>^… - 提交区间</h4><ul>
<li>双点符号 .. ，用于列出在一个分支而不在另一个分支的提交</li>
</ul>
<pre><code>例：
$ git log master..experiment
D
C
</code></pre><ul>
<li>双点常被用来查看即将推送的内容</li>
</ul>
<pre><code>$ git log origin/master..HEAD

# 等价于

$ git log origin/master..

# HEAD可以省略
</code></pre><ul>
<li>多点符号^，用于列出不被包含在其中的提交</li>
</ul>
<pre><code>$ git log refA..refB

# 等价于

$ git log ^refA refB

# 等价于

$ git log refB --not refA
</code></pre><ul>
<li>多点符号存在的意义在于它可以查询两个以上的引用</li>
</ul>
<pre><code>$ git log refA refB --not refC
</code></pre><ul>
<li>三点符号 … ，用于列出被两个引用中的一个包含但又不被两者同时包含的提交</li>
</ul>
<pre><code>$ git log master...experiment
F
E
D
C

# EF只在master分支上，CD只在experiment分支上     # 等价于


$ git log --left-right master...experiment 
&lt;F
&lt;E
&gt;D
&gt;C
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 群英传 笔记]]></title>
      <url>/2017/05/20/AndroidHeros/</url>
      <content type="html"><![CDATA[<p>onStop</p>
<a id="more"></a>
<p><br></p>
<h2 id="第三章-控件架构与自定义控件"><a href="#第三章-控件架构与自定义控件" class="headerlink" title="第三章 控件架构与自定义控件"></a>第三章 控件架构与自定义控件</h2><hr>
<p><br></p>
<h3 id="Android-控件架构"><a href="#Android-控件架构" class="headerlink" title="Android 控件架构"></a>Android 控件架构</h3><hr>
<p><br></p>
<h4 id="控件"><a href="#控件" class="headerlink" title="控件"></a>控件</h4><ul>
<li>Android的每个控件都会在界面中获得一块矩形的区域</li>
<li>控件分为两类，View控件和ViewGroup控件</li>
<li>ViewGroup以包含多个View的方式令所有控件形成一个树形结构，上层控件负责处理下层子控件的测量与绘制并传递交互事件</li>
<li>findViewById以深度优先遍历来查找对应元素</li>
</ul>
<p><br></p>
<h4 id="视图架构"><a href="#视图架构" class="headerlink" title="视图架构"></a>视图架构</h4><ul>
<li>Window，每个Activity都包含一个Window负责控制视图，通常由PhoneWindow来实现，它包含一个封装了窗口操作方法的DectorView来作为整个应用的顶级视图</li>
<li>DectorView，包含一个ContentRoot为唯一子视图，一般为竖直的LinearLayout，上面是标题栏TitleView（可设置），下面是内容栏ContentView</li>
<li>ContentView，id为content的FrameLayout，是所有传入的view的父布局，因此也被命名为ContentParen</li>
<li>所有View的监听事件都通过WindowManagerService来接收并回调Activity的 * Listener来处理<br><br></li>
</ul>
<h3 id="View的测量"><a href="#View的测量" class="headerlink" title="View的测量"></a>View的测量</h3><p><strong>——系统在绘制View前必须在onMeasure( ) 中对View进行测量</strong></p>
<hr>
<p><br> </p>
<h4 id="三种测量模式"><a href="#三种测量模式" class="headerlink" title="三种测量模式"></a>三种测量模式</h4><ul>
<li><p>EXACTLY，指定数值的精确模式，如</p>
<pre><code>android:layout_width=&quot;100dp&quot;
android:layout_width=&quot;match_parent&quot;
</code></pre></li>
<li><p>AT_MOST</p>
</li>
<li>UNSPECIFIED</li>
</ul>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 安卓 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[第一行代码 笔记]]></title>
      <url>/2017/04/30/FirstCodeLine/</url>
      <content type="html"><![CDATA[<hr>
<a id="more"></a>
<h2 id="第一章-开始启程"><a href="#第一章-开始启程" class="headerlink" title="第一章 开始启程"></a>第一章 开始启程</h2><p><br></p>
<h3 id="Android-系统架构"><a href="#Android-系统架构" class="headerlink" title="Android 系统架构"></a>Android 系统架构</h3><hr>
<ul>
<li>Linux 内核层，为各种硬件提供底层驱动，如显示驱动，音频驱动，电源管理等</li>
<li>系统运行库层，包括提供主要特性支持的C/C++库，如SQLite库、Webkit库等，以及系统运行时库（提供java语言支持的核心库、Dalvik虚拟机）</li>
<li>应用框架层，提供构建各种应用可能用到的API</li>
<li>应用层，所有安装的应用都在这一层<br><br></li>
</ul>
<h3 id="项目中的资源"><a href="#项目中的资源" class="headerlink" title="项目中的资源"></a>项目中的资源</h3><hr>
<p><br></p>
<h4 id="资源文件夹"><a href="#资源文件夹" class="headerlink" title="- 资源文件夹"></a>- 资源文件夹</h4><ul>
<li>drawable，放置图片</li>
<li>mipmap，放置应用图标</li>
<li>value，放置字符串，样式，颜色等配置</li>
<li>layout，放置布局文件<br><br></li>
</ul>
<h4 id="资源使用方式"><a href="#资源使用方式" class="headerlink" title="- 资源使用方式"></a>- 资源使用方式</h4><ul>
<li>在代码中，形如 R.string.app_name</li>
<li>在xml中，形如 @string/app_name</li>
<li>同一xml文件不应该出现同名id，最好的做法是避免所有重名的情况</li>
</ul>
<pre><code>&lt;application
    android : allowBackup=&quot;true&quot;
    android : icon=&quot;@mipmap/ic_launcher&quot;
    android : laybel=&quot;@string/app_name&quot;
    android : supportsRtl=&quot;true&quot;
    android : theme=&quot;@style/AppTheme&quot;
    ...
&lt;/application&gt;
</code></pre><ul>
<li>关于各引用写法的含义以及区别，参考：<br><a href="http://blog.csdn.net/zfrong/article/details/7332545" target="_blank" rel="external">http://blog.csdn.net/zfrong/article/details/7332545</a></li>
</ul>
<p><br>   </p>
<h3 id="详解build-gradle"><a href="#详解build-gradle" class="headerlink" title="详解build.gradle"></a>详解build.gradle</h3><hr>
<p><br></p>
<h4 id="app目录下"><a href="#app目录下" class="headerlink" title="- app目录下"></a>- app目录下</h4><p>*<br>        apply plugin: ‘com.android.application’<br>        // 应用一个插件，有两种可选值<br>        // com.android.application 表示应用程序模块<br>        // com.android.library 表示库模块<br>        // 前者可以直接运行，后者依赖与其他应用程序模块运行</p>
<pre><code>android {
// android闭包可以配置项目构建的各种属性

    compileSdkVersion 25
    // 指定项目的编译版本

    buildToolsVersion &quot;25.0.2&quot;
    // 指定项目的构建工具版本

    defaultConfig {
    // defaultConfig闭包可以进行更多细节的配置

        applicationId &quot;activitytest.example.com.myapplication&quot;
        // 指定项目的包名
        minSdkVersion 15
        // 指定项目最低兼容版本
        targetSdkVersion 25
        // 指定目标版本
        // 表示在该版本上已经进行了充分的测试，系统会启动一些最新的功能和特性

        versionCode 1
        // 指定版本编号
        versionName &quot;1.0&quot;
        // 指定版本名
        // 这两个属性在生成安装文件时非常重要

}
buildTypes {        
// buildTypes 闭包用于指定生成安装文件的相关配置
// buildTypes 通常有两个子包 debug 和 release
// debug 测试版安装文件配置，可以忽略不写
// release 正式版安装文件配置

    release {
        minifyEnabled false
        // 指定是否对代码进行混淆
        proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;
        // 指定混淆时使用的规则文件
        // proguard-android.txt 在SDK目录，proguard-rules.pro 在当前项目根目录
        // 通过Android Studio直接运行项目生成的都是测试版安装文件
        }
    }
    }

dependencies {
// dependencies 闭包用于指定当前所有的依赖关系
// Android Studio 项目有本地依赖，库依赖，远程依赖
// 本地依赖可以对本地的jar包或目录添加依赖关系
// 库依赖可以对项目中的库模块添加依赖关系
// 远程依赖可以对jcenter库上的开源项目添加依赖关系

    compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])
    // 本地依赖声明，将libs文件夹中所有jar后缀文件添加到项目的构建路径当中
    compile &apos;com.android.support:appcompat-v7:25.2.0&apos;
    // 远程依赖声明，&apos;com.android.support是域名部分，其后为组名称，用于和同一公司的不同库作区分
    compile project(&apos; :helper&apos;)
    // 库依赖声明 compile project后加上库名称

}
</code></pre><p><br>      </p>
<h4 id="最外层目"><a href="#最外层目" class="headerlink" title="- 最外层目"></a>- 最外层目</h4><p>*<br>        buildscript {<br>            repositories {<br>                jcenter()<br>            // 使用jcenter 代码托管仓库<br>        }<br>        dependencies {<br>            classpath ‘com.android.tools.build:gradle:2.3.0’<br>            // 声明Gradel插件<br>            }<br>        }</p>
<pre><code>allprojects {
    repositories {
        jcenter()
    }
}
</code></pre><p><br>  </p>
<h3 id="日志工具的使用"><a href="#日志工具的使用" class="headerlink" title="日志工具的使用"></a>日志工具的使用</h3><p><strong>—— 别再System.out.println()了</strong></p>
<hr>
<ul>
<li>Log.v() ，打印琐碎信息</li>
<li>Log.d() ，打印调试信息</li>
<li>Log.i() ，打印重要数据</li>
<li>Log.w() ，打印警告信息</li>
<li>Log.e() ，打印错误信息</li>
<li>用例：Log.d(“类名”,”内容”)</li>
</ul>
<h2 id="第二章-探究活动"><a href="#第二章-探究活动" class="headerlink" title="第二章 探究活动"></a>第二章 探究活动</h2><p><br></p>
<h3 id="创建和加载布局"><a href="#创建和加载布局" class="headerlink" title="创建和加载布局"></a>创建和加载布局</h3><p><strong>——Android讲究逻辑和视图分离，最好每个活动都能对应一个布局，布局就是用来显示界面内容的</strong></p>
<hr>
<ul>
<li><p>在app/src/main/res 中创建目录并新建布局资源文件</p>
<pre><code>&lt;LinearLayout 
在创建布局时选择了LinearLayou为根元素，根元素自动创建
...          
&lt;Button
android:id=&quot;@+id/button_1&quot;
给当前的元素定义一个标识符

android:layout_width=&quot;match_parent&quot;
指定当前元素的宽度，让元素和父元素一样宽

   android:layout_height=&quot;wrap_content&quot;
   指定当前元素的高度，让元素刚好能包含内容

android:text=&quot;Button 1&quot;
指定元素中显示的文字内容
   /&gt;           
&lt;/LinearLayout&gt;
</code></pre></li>
</ul>
<ul>
<li>在app/src/main/java/*Activity中扩展onCreate()，任何活动都应该重写这个方法</li>
</ul>
<pre><code>setContentView(R.layout.first_layout);
//该方法给当前活动添加一个布局，它需要布局文件的id
//项目中任何添加的资源都会在R文件中生成相应的id，用文件名调用即可
</code></pre><ul>
<li><p>在AndroidManifest文件中注册，as已负责完成，只需添加主活动</p>
<pre><code> &lt;activity android:name=&quot;.MainActivity&quot;
    android:label=&quot;This is a Activity&quot;&gt;
    指定活动标签栏的内容

    &lt;intent-fliter&gt;
        &lt;antion android:name=&quot;android.intent.action.MAIN&quot;/&gt;
        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;
    &lt;/intent-fliter&gt;
    配置主活动，这是程序最先运行的活动

&lt;/activity&gt;
</code></pre></li>
</ul>
<h3 id="使用Toast"><a href="#使用Toast" class="headerlink" title="使用Toast"></a>使用Toast</h3><p><strong>——一种用于提示短小信息的方式</strong></p>
<hr>
<ul>
<li>在活动中通过findViewById()方法获取布局文件中定义的元素，该方法返回一个View对象，需要向下转型为View子类对象</li>
<li>使用静态makeText方法创建Toast对象<pre><code>...
Button button1 = (Button)findViewById(R.id.button_1);
button1.setOnClickListener(new View.OnClickListener(){
   public void onClick(View v){
   Toast.makeText(MainActivity.this,&quot;You Clicked it!&quot;,Toast.LENGTH_SHORT).show();
   //三个参数分别为上下文context，文本内容，时常Toast.LENGTH_SHORT或Toast.LENGTH_LONG
        }
    });
...
</code></pre></li>
</ul>
<h3 id="使用Menu"><a href="#使用Menu" class="headerlink" title="使用Menu"></a>使用Menu</h3><p><strong>——不占用界面空间的菜单</strong></p>
<hr>
<ul>
<li>在res目录新建一个menu文件夹即可选择创建Menu resouce file，在main.xml中添加控件信息<pre><code>&lt;item
    android:id=&quot;@+id/add_item&quot;
android:title=&quot;Add&quot;/&gt;
&lt;item
    android:id=&quot;@+id/removed_item&quot;
    android:title=&quot;removed&quot; /&gt;
</code></pre></li>
</ul>
<ul>
<li><p>重写onCreateOptionsMenu()方法</p>
<pre><code> public boolean onOptionsItemSelected(MenuItem item){

    switch(item.getItemId()){
    case R.id.add_item:
        Toast.makeText(this,&quot;clicked add&quot;,Toast.LENGTH_SHORT).show();
    break;

    case R.id.removed_item:
        Toast.makeText(this,&quot;clicked removed&quot;,Toast.LENGTH_SHORT).show();
    break;

    default:
    }
    return true;
}
</code></pre></li>
</ul>
<ul>
<li>销毁一个活动，在适当的地方，如监听器中添加，finish()方法，活动会自行退出<pre><code>...
button1.setOnClickListener(new View.OnClickListener(){
    public void onClick(View v){
        Toast.makeText(MainActivity.this,&quot;You Clicked it!&quot;,Toast.LENGTH_SHORT).show();
        finish();
    }
});
...
</code></pre></li>
</ul>
<h3 id="使用Intent在活动之间穿梭"><a href="#使用Intent在活动之间穿梭" class="headerlink" title="使用Intent在活动之间穿梭"></a>使用Intent在活动之间穿梭</h3><p><strong>——组件间交互的方式</strong></p>
<hr>
<h4 id="显式Intent"><a href="#显式Intent" class="headerlink" title="- 显式Intent"></a>- 显式Intent</h4><ul>
<li>启动活动，调用Activity类的startActivity()方法，该方法接受一个Intent参数</li>
<li>Intent 有多个构造器，其中一个 Intent( Context packageContext, Class\&lt;?>cls )，要求传入一个启动活动的上下文和要启动的目标活动，这种构造方法很好地说明了意图，因此称它为显式的<pre><code>...
button1.setOnClickListener(new View.OnClickListener(){
    public void onClick(View v){
        Intent intent = new Intent(MainActivity.this,SecondActivity.class);
        startActivity(intent);
    }
});
...
</code></pre></li>
</ul>
<h4 id="隐式Intent"><a href="#隐式Intent" class="headerlink" title="- 隐式Intent"></a>- 隐式Intent</h4><ul>
<li>在<activity>标签下配置action和category内容</activity></li>
</ul>
<pre><code>...
&lt;activity
    android:name=&quot;.MainActivity&quot;
    android:label=&quot;This is a Activity&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
    &lt;/intent-filter&gt;
 &lt;/activity&gt;
 ...
</code></pre><ul>
<li>调用Intent的另一构造器，该构造器接受一个action字段</li>
<li>调用Intent的add()方法，该构造器接受一个category字段</li>
<li><p>一个Intent可以有多个category字段，默认为DEFAULT，但action只能有一个</p>
<pre><code>...
button1.setOnClickListener(new View.OnClickListener(){
    public void onClick(View v){

    Intent intent = new Intent(&quot;activitytest.example.com.ACTION_START&quot;);
    intent.addCategory(&quot;activitytest.example.com.MY_CATEGORY&quot;);
    startActivity(intent);

    }
});
...
</code></pre></li>
</ul>
<h4 id="更多隐式Intent-的用法"><a href="#更多隐式Intent-的用法" class="headerlink" title="- 更多隐式Intent 的用法"></a>- 更多隐式Intent 的用法</h4><ul>
<li><p>打开网页</p>
<pre><code>...
Button button1 = (Button)findViewById(R.id.button_1);
button1.setOnClickListener(new View.OnClickListener(){
    public void onClick(View v){

       Intent intent = new Intent(Intent.ACTION_VIEW);
        //Intent.ACTION_VIEW是一个常量，值为android.intent.action.view

       intent.setData(Uri.parse(&quot;http://www.baidu.com&quot;));
        //Uri.parse()方法解析一个域名字符串，返回Uri对象，setData指定Intent正在操作的数据
        startActivity(intent);
    }
});
...
</code></pre></li>
<li>拨号界面</li>
</ul>
<pre><code>...
Intent intent = new Intent(Intent.ACTION_VIEW);
    intent.setData(Uri.parse(&quot;tel:10086&quot;));
    //tel: 指定号码
    startActivity(intent);
...
</code></pre><ul>
<li><p>向下一个活动传递消息</p>
<pre><code>     ...
         String data = &quot;hello SecondActivity&quot;;
         Intent intent = new Intent(MainActivity.this,SecondActivity.class);
         intent.putExtra(&quot;extra_data&quot;,data);
         // putExtra 用于放入要传递的数据
         startActivity(intent);
     ...

     ...
public class SecondActivity extends AppCompatActivity {

     @Override
     protected void onCreate(Bundle savedInstanceState) {
  super.onCreate(savedInstanceState);
     setContentView(R.layout.activity_second);

     Intent intent = getIntent();
     String data = intent.getStringExtra(&quot;extra_data&quot;);
     // 形如 get**Extra
     Log.d(&quot;SecondActivity&quot;,data);
     ...
</code></pre></li>
</ul>
<ul>
<li><p>返回数据给上一个活动</p>
<pre><code>// in MainActivity
button1.setOnClickListener(new View.OnClickListener(){
    public void onClick(View v){

        Intent intent = new Intent(MainActivity.this,SecondActivity.class);
        startActivityForResult(intent,1);
        // 1 为requestCode ，用于标识发送请求的活动

    }
});

// in SecondActivity
button2.setOnClickListener(new View.OnClickListener(){
    public void onClick(View v){
        Intent intent = new Intent();
        intent.putExtra(&quot;data_return&quot;,&quot;Hello MainActivity&quot;);
        setResult(RESULT_OK,intent);
        // resultCode 为处理结果。新建intent返回
        finish();
    }
});

 // in MainActivity
 protected void onActivityResult(int requestCode,int resultCode,Intent data){
switch (requestCode){
    case 1:
        if(resultCode == RESULT_OK){
            String returnedData = data.getStringExtra(&quot;data_return&quot;);
            Log.d(&quot;FirstActivity&quot;,returnedData);
            // 通过 requestCode 检查来源并提取数据
        }
        break;
    default:
    }
}
</code></pre></li>
</ul>
<p><br>      </p>
<h3 id="活动生命周期"><a href="#活动生命周期" class="headerlink" title="活动生命周期"></a>活动生命周期</h3><hr>
<p><br>  </p>
<h4 id="返回栈"><a href="#返回栈" class="headerlink" title="- 返回栈"></a>- 返回栈</h4><ul>
<li>Android 使用任务（Task）来管理活动，一个任务就是一组存放在栈里的活动的集合，这个栈也被称作返回栈（Back Task）</li>
<li>启动活动，活动入栈</li>
<li>销毁活动，Back键或finish()，活动出栈<br><br>  </li>
</ul>
<h4 id="活动状态"><a href="#活动状态" class="headerlink" title="- 活动状态"></a>- 活动状态</h4><ul>
<li>运行，栈顶时</li>
<li>暂停，非栈顶但可见时</li>
<li>停止，非栈顶不可见时</li>
<li>销毁，从栈中移除之后</li>
<li>被回收可能性 运行\&lt;暂停\&lt;停止\&lt;销毁<br><br>  </li>
</ul>
<h4 id="七个回调方法"><a href="#七个回调方法" class="headerlink" title="- 七个回调方法"></a>- 七个回调方法</h4><ul>
<li>Activity中定义了7个回调方法，覆盖了活动生命周期的每一个环节 </li>
<li>onCreate()，第一次被创建时调用，应在这个方法中完成活动的初始化操作</li>
<li>onStart()，活动由不可见变为可见时调用</li>
<li>onResume()，活动准备好和用户交互时调用</li>
<li>onPause()，启动或恢复另一个活动时调用</li>
<li>onStop()，活动变为不可见时调用</li>
<li>onDestory()，活动被销毁前调用</li>
<li>onRestar()，活动由停止变为运行状态时调用<br><br>  </li>
</ul>
<h4 id="三个生存期"><a href="#三个生存期" class="headerlink" title="- 三个生存期"></a>- 三个生存期</h4><ul>
<li>完整生存期，onCreate()和onDestory()之间</li>
<li>可见生存期，onStart()和onStop()之间，总是可见</li>
<li>前台生存期，onResume()和onPause()之间，可交互<br><br>  </li>
</ul>
<h4 id="四个启动模式"><a href="#四个启动模式" class="headerlink" title="- 四个启动模式"></a>- 四个启动模式</h4><ul>
<li>standard，不管活动是否已在栈中存在都会创建新实例</li>
<li>singleTop，启动活动时若栈顶已是该活动则不再创建新实例</li>
<li>singleTask，启动活动时若栈中含有该活动则将其上的活动全部出栈</li>
<li>singleInstance，使用单独的返回栈来管理活动，实现实例的共享</li>
<li>用例：<pre><code>&lt;activity
    android:name=&quot;.FirstActivity&quot;
    android:laucMode=&quot;singleTask&quot;
    ....
</code></pre><br>  </li>
</ul>
<h3 id="活动的实践技巧"><a href="#活动的实践技巧" class="headerlink" title="活动的实践技巧"></a>活动的实践技巧</h3><hr>
<ul>
<li>知晓当前活动<pre><code>//让其他类继承这个类
public class BaseActivity extends AppCompatActivity {
protected void onCreate(Bundle savedInstanceState){
super.onCreate(savedInstanceState);
Log.d(&quot;BaseActivity&quot;,getClass().getSimpleName());
//获取活动名
｝
</code></pre></li>
</ul>
<ul>
<li><p>随时随地退出程序</p>
<pre><code>//创建一个类充当容器
public class ActivityCollector {

public static List&lt;Activity&gt; activities = new ArrayList&lt;&gt;();

public static void addActivity(Activity activity){
activities.add(activity);

}

public static void removeActivity(Activity activity){
activities.remove(activity);
}

public static void  finishAll(){
for(Activity activity:activities){
    if(!activity.isFinishing()){
        activity.finish();
        }
    }
    activities.clear();
    //别忘了清空容器 
    }
}

//在BaseActivity，使新建的对象加入到容器中
protected void onCreate(Bundle savedInstanceState){
super.onCreate(savedInstanceState);
ActivityCollector.addActivity(this);

}
    protected void onDestory(){
super.onDestroy();
ActivityCollector.removeActivity(this);
}

//在想要推出程序的地方，调用finishAll()
button2.setOnClickListener(new View.OnClickListener(){
    public void onClick(View v){

    ActivityCollector.finishAll();

    }
});
</code></pre></li>
</ul>
<ul>
<li><p>启动活动的最佳写法</p>
<pre><code>//在活动中写一个开启自己的静态方法
public static void actionStart(Context context, String data1, String data2){

Intent intent = new Intent(context,SecondActivity.class);
intent.putExtra(&quot;param1&quot;,data1);
intent.putExtra(&quot;param2&quot;,data2);
context.startActivity(intent);
}

//在任意地方调用这个方法
 button1.setOnClickListener(new View.OnClickListener(){
    public void onClick(View v){
SecondActivity.actionStart(MainActivity.this,&quot;data1&quot;,&quot;data2&quot;);

    }
});
</code></pre><p><br>  </p>
</li>
</ul>
<h2 id="第三章-UI开发"><a href="#第三章-UI开发" class="headerlink" title="第三章 UI开发"></a>第三章 UI开发</h2><hr>
<p><br>  </p>
<h3 id="常用控件的使用方法"><a href="#常用控件的使用方法" class="headerlink" title="常用控件的使用方法"></a>常用控件的使用方法</h3><hr>
<ul>
<li>所有控件都直接或间接继承至View，View是最基本的一种控件</li>
<li>View在屏幕上绘制一块矩形区域，并响应这块区域的所有事件</li>
<li>TextView，显示文本信息</li>
</ul>
<pre><code>&lt;TextView
    android:id=&quot;@+id/text_view&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:gravity=&quot;center&quot;
    android:textSize=&quot;24sp&quot;
    android:textColor=&quot;#0033ff&quot;
    android:text=&quot;This is TextView&quot; /&gt;
</code></pre><ul>
<li>Button，按钮</li>
</ul>
<pre><code>&lt;Button
   android:id=&quot;@+id/button&quot;
   android:layout_width=&quot;match_parent&quot;
   android:layout_height=&quot;wrap_content&quot;
   android:text=&quot;Button&quot;/&gt;
</code></pre><ul>
<li>EditText，输入框</li>
</ul>
<pre><code>&lt;EditText
    android:id=&quot;@+id/edit_text&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:maxLines=&quot;2&quot;/&gt;
</code></pre><ul>
<li>ImageView，展示图片</li>
</ul>
<pre><code>&lt;ImageView
    android:id=&quot;@+id/image_view&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:src=&quot;@drawable/img_1&quot;/&gt;
</code></pre><ul>
<li>ProgressBar，进度条</li>
</ul>
<pre><code>&lt;ProgressBar
    android:id=&quot;@+id/progress_bar&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot; /&gt;
</code></pre><ul>
<li>监听器</li>
</ul>
<pre><code>public class MainActivity extends AppCompatActivity implements View.OnClickListener{

        private EditText editText;
        private ImageView imageView;
        private ProgressBar progressBar;

    @Override
    protected void onCreate(Bundle savedInstanceState) {

    super.onCreate(savedInstanceState);
    //恢复数据

    setContentView(R.layout.activity_main);     
    Button button = (Button)findViewById(R.id.button);
    editText = (EditText)findViewById(R.id.edit_text);
    imageView = (ImageView)findViewById(R.id.image_view);
    progressBar = (ProgressBar)findViewById(R.id.progress_bar);
    //调用实例

    button.setOnClickListener(this);
    //设置监听器
    }

    public void onClick(View v){

    switch(v.getId()){
        case R.id.button:
            String inputText = editText.getText().toString();
            //获取输入

            Toast.makeText(MainActivity.this,
            inputText,Toast.LENGTH_SHORT).show();

            imageView.setImageResource(R.drawable.img_2);
            //更换图片

            if(progressBar.getVisibility() == View.GONE){
                progressBar.setVisibility(View.VISIBLE);
            }else{
                progressBar.setVisibility(View.GONE);
            }
            //设置可见属性

            AlertDialog.Builder dialog = 
            new AlertDialog.Builder(MainActivity.this);
            dialog.setTitle(&quot;this is a dialog&quot;);
            dialog.setMessage(&quot;something important&quot;);
            dialog.setCancelable(false);
            dialog.setPositiveButton        
            (&quot;ok&quot;, new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int which) {

            }
        });
            dialog.setNegativeButton
            (&quot;cancel&quot;, new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int which) {

                }
            });
            dialog.show();
            //显示对话框

            ProgressDialog progressDialog =
            new ProgressDialog(MainActivity.this);
            progressDialog.setTitle(&quot;this is a progressDialog&quot;);
            progressDialog.setMessage(&quot;Loading&quot;);
            progressDialog.setCancelable(true);
            progressDialog.show();
            //进度对话框

            break;

        default:
            break;
        }
    }
}
</code></pre><p><br>  </p>
<h3 id="布局管理器"><a href="#布局管理器" class="headerlink" title="布局管理器"></a>布局管理器</h3><hr>
<ul>
<li>所有布局都直接或间接继承自ViewGroup，ViewGroup是一种特殊的View</li>
<li>ViewGroup可以包含很多的子View和子ViewGroup，是一个用于放置控件和容器的布局</li>
<li>线性布局，让控件在线性方向上依次排列，可以指定对其方式和比例</li>
<li>相对布局，让控件以相对定位方式排列</li>
<li>帧布局，简单的布局，控件会重叠</li>
<li>百分比布局，按任意比例分割布局</li>
<li>引入布局，创建布局xml，使用 <include layout="@layout/文件名"><br><br>  </include></li>
</ul>
<h3 id="自定义控件"><a href="#自定义控件" class="headerlink" title="自定义控件"></a>自定义控件</h3><hr>
<p><strong>（待续）</strong><br><br>  </p>
<h3 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h3><p><strong>——滚动列表</strong></p>
<hr>
<p><br>  </p>
<h4 id="简单用法"><a href="#简单用法" class="headerlink" title="-  简单用法"></a>-  简单用法</h4><ul>
<li>适配器，数组中的数据无法直接传给ListView，需要借助适配器来完成</li>
<li>ArrayAdapter，使用泛型，含有多个构造器的重载</li>
<li>布局</li>
</ul>
<pre><code>&lt;ListView
    android:id=&quot;@+id/list_view&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;&gt;
</code></pre><ul>
<li>使用</li>
</ul>
<pre><code>public class MainActivity extends AppCompatActivity{

    private String[] data ={&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;10&quot;,&quot;11&quot;,&quot;12&quot;};

    protected void onCreate(Bundle savedInstanceState){
        super.onCreate(savedInstanceState);
        setContentView(R.layout.list_view_test);

        ArrayAdapter&lt;String&gt; adapter = 
        new ArrayAdapter&lt;String&gt;(MainActivity.this,android.R.layout.simple_list_item_1,data);
        //传入当前上下文，ListView子项布局id，数据
        //simple_list_item_1，这是一个Android内置的布局文件，里面只有一个TextView

        ListView listView = (ListView)findViewById(R.id.list_view);
        istView.setAdapter(adapter);
    }
}
</code></pre><p><br>  </p>
<h4 id="界面定制"><a href="#界面定制" class="headerlink" title="- 界面定制"></a>- 界面定制</h4><ul>
<li><p>定义实体类，作为适配器的适配类型</p>
<pre><code>public class ItemTest {

    private String name;
    private int imageId;

    public ItemTest(String name, int imageId) {
        this.name = name;
        this.imageId = imageId;
    }

    public String getName() {
        return name;
    }

    public int getImageId() {
        return imageId;
        }
}
</code></pre></li>
</ul>
<ul>
<li>为ListView子项目定义布局</li>
</ul>
<pre><code>&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&gt;

&lt;ImageView
    android:id=&quot;@+id/item_image&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot; /&gt;
&lt;TextView
    android:id=&quot;@+id/text_view&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:layout_gravity=&quot;center_vertical&quot;
    android:layout_margin=&quot;10dp&quot;/&gt;
&lt;/LinearLayout&gt;
</code></pre><ul>
<li><p>自定义适配器</p>
<pre><code>public class TestAdapter extends ArrayAdapter&lt;ItemTest&gt; {

private int resourceId;

public TestAdapter(Context context,int testViewResourceId,List&lt;ItemTest&gt; object){

    super(context,testViewResourceId,object);
    resourceId = testViewResourceId;

}

public int getResourceId() {
    return resourceId;
}

public void setResourceId(int resourceId) {
    this.resourceId = resourceId;
}

public View getView(int position,View convertView,ViewGroup parent){

    ItemTest item = getItem(position);
    View view = LayoutInflater.from(getContext()).inflate(
    resourceId,parent,false);
    // 只让 parent 中的layout属性生效，但不添加为父布局

    ImageView imageView = (ImageView)view.findViewById(R.id.item_image);
    TextView textView = (TextView)view.findViewById(R.id.text_view);
    imageView.setImageResource(item.getImageId());
    textView.setText(item.getName());
    return view;
    }

}
</code></pre></li>
</ul>
<ul>
<li><p>使用</p>
<pre><code>public class MainActivity extends AppCompatActivity{

private List data = new ArrayList();

protected void onCreate(Bundle savedInstanceState){
    super.onCreate(savedInstanceState);
    setContentView(R.layout.list_view_test);
    initItem();
    TestAdapter adapter = new TestAdapter(MainActivity.this, R.layout.test_item, data);

    ListView listView = (ListView)findViewById(R.id.list_view);
    listView.setAdapter(adapter);
}

private void initItem(){
    ItemTest item1 = new ItemTest(&quot;1&quot;,R.drawable.img_1);
    data.add(item1);
    ItemTest item2 = new ItemTest(&quot;2&quot;,R.drawable.img_2);
    data.add(item2);
    ItemTest item3 = new ItemTest(&quot;3&quot;,R.drawable.img_3);
    data.add(item3);
    ....
}
}
</code></pre></li>
</ul>
<p><br></p>
<h4 id="提升效率"><a href="#提升效率" class="headerlink" title="- 提升效率"></a>- 提升效率</h4><p><strong>（待续）</strong><br><br></p>
<h4 id="点击事件"><a href="#点击事件" class="headerlink" title="- 点击事件"></a>- 点击事件</h4><ul>
<li>添加监听器</li>
</ul>
<pre><code>listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
        @Override
        public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) {

            ItemTest itemTest = data.get(position);
            Toast.makeText(MainActivity.this,itemTest.getName(),Toast.LENGTH_SHORT).show();
        }
    });
</code></pre><p><br></p>
<h3 id="RecycleView"><a href="#RecycleView" class="headerlink" title="RecycleView"></a>RecycleView</h3><p><strong>——更强大的滚动控件</strong></p>
<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="- 基本用法"></a>- 基本用法</h4><ul>
<li>在 app/build.gradle 文件中的dependencies闭包中添加依赖库<pre><code>compile &apos;com.android.support:recyclerview-v7:24.2.1&apos;
</code></pre></li>
</ul>
<ul>
<li><p>创建item布局，注意RecyclerView本身不具备点击动画，需要自行设置</p>
<pre><code>&lt;LinearLayout
xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
android:orientation=&quot;vertical&quot;
android:background=&quot;?android:attr/selectableItemBackground&quot;
android:clickable=&quot;true&quot;
android:focusable=&quot;true&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;wrap_content&quot;&gt;

&lt;ImageView
    android:background=&quot;?android:attr/selectableItemBackground&quot;
    android:clickable=&quot;true&quot;
    android:focusable=&quot;true&quot;
    android:id=&quot;@+id/item_iv&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot; /&gt;
&lt;TextView
    android:id=&quot;@+id/item_tv&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:layout_gravity=&quot;center_vertical&quot;
    android:layout_marginStart=&quot;10dp&quot;/&gt;
&lt;/LinearLayout&gt;
</code></pre></li>
</ul>
<ul>
<li><p>创建adapter，应重写ViewHolder，onCreateViewHolder，onBindViewHolder，getItemCount，点击事件应该在onCreateViewHolder中实现</p>
<pre><code>public class RecyclerViewAdapter extends RecyclerView.Adapter&lt;RecyclerViewAdapter.ViewHolder&gt; {

    private List&lt;String&gt; dataList;

    public RecyclerViewAdapter(){
        dataList = new ArrayList&lt;&gt;();
        for(int i = 0;i&lt;10;i++){
            dataList.add(&quot;item : &quot;+i);
        }
    }

static class ViewHolder extends RecyclerView.ViewHolder{

    ImageView imageView;
    TextView textView;

    public ViewHolder(View itemView) {
        super(itemView);
        imageView = (ImageView)itemView.findViewById(R.id.item_iv);
        textView = (TextView)itemView.findViewById(R.id.item_tv);
        imageView.setImageResource(R.mipmap.ic_launcher);

    }
}

@Override
public ViewHolder onCreateViewHolder(final ViewGroup parent, int viewType) {
    View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.recycler_item,parent,false);
    final ViewHolder holder = new ViewHolder(view);
    holder.imageView.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            Toast.makeText(v.getContext(),&quot;click &quot;+dataList.get(holder.getAdapterPosition()),Toast.LENGTH_SHORT).show();

        }
    });
    return holder;
}

@Override
public void onBindViewHolder(ViewHolder holder, int position) {

    String str = dataList.get(position);
    holder.textView.setText(&quot;item : &quot;+str);
}

@Override
public int getItemCount() {
    return dataList.size();
}

}
</code></pre></li>
</ul>
<ul>
<li>通过指定LinearLayoutManager，GridLayoutManager，StaggeredGridLayoutManager 分别可以实现线性，网格布局，瀑布流布局</li>
</ul>
<p><br></p>
<h2 id="第四章-探究碎片"><a href="#第四章-探究碎片" class="headerlink" title="第四章 探究碎片"></a>第四章 探究碎片</h2><hr>
<p><br></p>
<h3 id="碎片的使用方式"><a href="#碎片的使用方式" class="headerlink" title="碎片的使用方式"></a>碎片的使用方式</h3><hr>
<p><br></p>
<h4 id="简单用法-1"><a href="#简单用法-1" class="headerlink" title="- 简单用法"></a>- 简单用法</h4><ul>
<li>为碎片设置布局</li>
</ul>
<pre><code>    ...
\&lt;fragment
    android:id=&quot;@+id/left_fragment&quot;
    android:name=&quot;com.linjiamin.myapplication.LeftFragment&quot;
    android:layout_width=&quot;0dp&quot;
    android:layout_height=&quot;match_parent&quot;
    android:layout_weight=&quot;1&quot;/&gt;
\&lt;fragment
    android:id=&quot;@+id/right_fragment&quot; 
    android:name=&quot;com.linjiamin.myapplication.RightFragment&quot;
    android:layout_width=&quot;0dp&quot;
    android:layout_height=&quot;match_parent&quot;
    android:layout_weight=&quot;1&quot;/&gt;
    ...
</code></pre><ul>
<li>创建碎片</li>
</ul>
<pre><code>public class LeftFragment extends Fragment{
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState){
        View view = inflater.inflate(R.layout.left_fragment,container,false);
        return view;
    }
}
</code></pre><p><br></p>
<h4 id="动态加载碎片"><a href="#动态加载碎片" class="headerlink" title="- 动态加载碎片"></a>- 动态加载碎片</h4><ul>
<li>创建待添加的碎片实例</li>
<li>获取FragmentManager，在活动中调用getSupportFragementManage 方法</li>
<li>开启一个事务，调用beginTransaction 方法</li>
<li>向容器类添加或替换碎片，调用事务的replace 方法，需要传入容器的id和待添加的碎片实例</li>
<li>提交事务，调用事务的commit 方法</li>
</ul>
<pre><code>public class MainActivity extends AppCompatActivity implements View.OnClickListener{

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button button = (Button)findViewById(R.id.button);
        button.setOnClickListener(this);
        replaceFragment(new RightFragment());
    }

    public void replaceFragment(Fragment fragment){
        FragmentManager fragmentManager = getSupportFragmentManager();
        FragmentTransaction transaction = fragmentManager.beginTransaction();
        transaction.replace(R.id.right_layout,fragment);
        transaction.commit();
    }

    @Override
    public void onClick(View v){
        switch (v.getId()){
            case R.id.button:
                replaceFragment(new AnotherFragment());
                break;
            default:
                break;
        }
    }
}
</code></pre><p><br></p>
<h4 id="模拟返回栈"><a href="#模拟返回栈" class="headerlink" title="- 模拟返回栈"></a>- 模拟返回栈</h4><ul>
<li>调用事务的addBackStack 方法，需要传入一个名字用于描述返回栈的状态，一般传入null即可</li>
</ul>
<p><br></p>
<h4 id="碎片与活动进行通信"><a href="#碎片与活动进行通信" class="headerlink" title="- 碎片与活动进行通信"></a>- 碎片与活动进行通信</h4><ul>
<li>调用FragmentManager的findViewById 方法，可以在活动中获取相应碎片的实例</li>
<li>调用Fragment的 getActivity 方法，可以在碎片中获取活动</li>
<li>利用活动为桥梁，可以在碎片和碎片之间通信</li>
</ul>
<p><br></p>
<h3 id="碎片的生命周期"><a href="#碎片的生命周期" class="headerlink" title="碎片的生命周期"></a>碎片的生命周期</h3><hr>
<p><br></p>
<h4 id="碎片的状态与回调"><a href="#碎片的状态与回调" class="headerlink" title="- 碎片的状态与回调"></a>- 碎片的状态与回调</h4><ul>
<li>Running，碎片可见，关联的活动正处于运行状态</li>
<li>Pause，碎片可见，关联的活动进入暂停状态，</li>
<li>Stop，碎片不可见，关联的活动进入停止状态，或调用了事务的remove，replace 方法</li>
<li>Killed，活动被销毁，或调用了事务的remove，replace 方法</li>
</ul>
<h4 id="附加的回调方法"><a href="#附加的回调方法" class="headerlink" title="- 附加的回调方法"></a>- 附加的回调方法</h4><ul>
<li>onAttach，碎片和活动建立关联的时候调用</li>
<li>onCreateView，为碎片创立视图的时候调用</li>
<li>onActivityCreated，确保碎片相关联的活动已经创立完毕的时候调用</li>
<li>onDestoryView，当碎片相关联的视图被移除的时候调用</li>
<li>onDetach，当碎片和活动接触关联的时候调用</li>
</ul>
<p><br></p>
<h3 id="动态加载布局"><a href="#动态加载布局" class="headerlink" title="动态加载布局"></a>动态加载布局</h3><hr>
<p><br></p>
<h4 id="使用限定符"><a href="#使用限定符" class="headerlink" title="- 使用限定符"></a>- 使用限定符</h4><ul>
<li>程序会通过在文件夹名称后追加 -限定符 来判断使用何种布局，形如 layout-large</li>
<li>small，normal，large，xlarge，提供给不同大小的屏幕使用</li>
<li>ldpi，mdpi，hdpi，xhdpi，xxhdpi，提供给不同分辨率的设备使用</li>
<li>land，port，提供横屏和竖屏的设备使用</li>
<li>swXXXdp，用于指定最小宽度</li>
</ul>
<p><br></p>
<h2 id="第五章-详解广播"><a href="#第五章-详解广播" class="headerlink" title="第五章 详解广播"></a>第五章 详解广播</h2><hr>
<p><br></p>
<h3 id="广播机制"><a href="#广播机制" class="headerlink" title="广播机制"></a>广播机制</h3><hr>
<p><br></p>
<h3 id="接受系统广播"><a href="#接受系统广播" class="headerlink" title="接受系统广播"></a>接受系统广播</h3><hr>
<p><br></p>
<h4 id="动态注册监听网络变化"><a href="#动态注册监听网络变化" class="headerlink" title="- 动态注册监听网络变化"></a>- 动态注册监听网络变化</h4><p><br></p>
<h4 id="静态注册开机启动"><a href="#静态注册开机启动" class="headerlink" title="- 静态注册开机启动"></a>- 静态注册开机启动</h4><p><br></p>
<h3 id="发送自定义广播"><a href="#发送自定义广播" class="headerlink" title="发送自定义广播"></a>发送自定义广播</h3><p><br></p>
<h4 id="发送标准广播"><a href="#发送标准广播" class="headerlink" title="- 发送标准广播"></a>- 发送标准广播</h4><p><br></p>
<h4 id="发送有序广播"><a href="#发送有序广播" class="headerlink" title="- 发送有序广播"></a>- 发送有序广播</h4><p><br></p>
<h4 id="使用本地广播"><a href="#使用本地广播" class="headerlink" title="- 使用本地广播"></a>- 使用本地广播</h4><p><br></p>
<h2 id="第六章-数据储存"><a href="#第六章-数据储存" class="headerlink" title="第六章 数据储存"></a>第六章 数据储存</h2><hr>
<p><br></p>
<h3 id="文件储存"><a href="#文件储存" class="headerlink" title="文件储存"></a>文件储存</h3><p><strong>——最基本的一种储存方式，不对内容进行任何格式化处理，所有数据原封不动地保存到文件当中</strong></p>
<hr>
<ul>
<li>文件储存比较适合于储存一些简单的文本数据或二进制数据</li>
<li>Context中提供一个openFileOutput方法，用于将数据储存到指定的文件当中</li>
<li><p>openFileOutput()的第一个参数是文件名，不可以包括路径，第二个参数是操作模式，有两种可选，MODE_PRIVATE 和 MODE_APPEND，表示覆盖和追加</p>
<pre><code>public void save(){

    String data = &quot;data to save&quot;;
    FileOutputStream out = null;
    BufferedWriter writer = null;

    try{
        out = openFileOutput(&quot;data&quot;, Context.MODE_PRIVATE);
        writer = new BufferedWriter(new OutputStreamWriter(out));
        writer.write(data);
    }catch(IOException e){
        e.printStackTrace();
    }finally{
        try{
            if(writer != null){
                writer.close();
            }
        }catch (IOException e){
            e.printStackTrace();
        }
    }
}
</code></pre></li>
</ul>
<ul>
<li>Context中提供一个openFileInput方法，用于从文件中读取数据，它只接受一个参数，即文件名</li>
</ul>
<pre><code>public String Load(){

        FileInputStream in ;
        BufferedReader reader = null;
        StringBuilder content = new StringBuilder();

        try{
            in = openFileInput(&quot;data&quot;);
            reader = new BufferedReader(new InputStreamReader(in));
            String line;
            while ((line = reader.readLine())!= null){
                content.append(line);
            }
        }catch (IOException e){
            e.printStackTrace();
        }finally{
            try {
                 if(reader != null){
                    reader.close();    
                 }               
            }catch (IOException e){
                e.printStackTrace();
            }
        }
    }
</code></pre><ul>
<li>可以考虑将save()和load()这样的方法写在onDestory()和onCreate()中<br><br></li>
</ul>
<h3 id="SharedPreferences储存"><a href="#SharedPreferences储存" class="headerlink" title="SharedPreferences储存"></a>SharedPreferences储存</h3><p><strong>——支持多类型、使用键值对的储存方</strong>  </p>
<hr>
<p><br></p>
<h4 id="三种方法获取对象"><a href="#三种方法获取对象" class="headerlink" title="- 三种方法获取对象"></a>- 三种方法获取对象</h4><ul>
<li>使用SharedPreferences存储数据必须获取SharedPreferences对象</li>
<li>Context类中的getSharedPreferences方法，接受两个参数，文件名和操作模式，操作模式只有MODE_PRIVATE一种可选，与0相同，表示只有当前应用程序可以对该文件进行读写</li>
<li>Activity类中的getPreferences方法，接受一个参数并自动将类名作为文件名</li>
<li>PreferenceManager类中的getDefaultSharedPreferences方法，静态方法，接受一个Context参数并将Context的包名作为前缀<br><br></li>
</ul>
<h4 id="三个步骤存储数据"><a href="#三个步骤存储数据" class="headerlink" title="- 三个步骤存储数据"></a>- 三个步骤存储数据</h4><ul>
<li>调用edit()方法获取一个SharedPreferences.Editor对象</li>
<li>向Editor中添加数据，如调用putBoolean()等*</li>
<li>调用apply()方法将添加的数据提交  </li>
</ul>
<pre><code>saveData.setOnClickListener(new View.OnClickListener(){

    public void onClick(View V) {
        SharedPreferences.Editor editor = getSharedPreferences(&quot;data&quot;,MODE_PRIVATE).edit();
        editor.putString(&quot;name&quot;,&quot;Tom&quot;);
        editor.putInt(&quot;age&quot;,29);
        editor.putBoolean(&quot;married&quot;,false);
        editor.apply();
    }
</code></pre><p><br></p>
<h4 id="两个步骤读取数据"><a href="#两个步骤读取数据" class="headerlink" title="- 两个步骤读取数据"></a>- 两个步骤读取数据</h4><ul>
<li>调用edit()方法获取一个SharedPreferences.Editor对象</li>
<li><p>从Editor中获取数据，如调用getBoolean()等</p>
<pre><code>saveData.setOnClickListener(new View.OnClickListener(){
    public void onClick(View V) {
        SharedPreferences.Editor editor = getSharedPreferences(&quot;data&quot;,MODE_PRIVATE).edit();
        editor.putString(&quot;name&quot;,&quot;Tom&quot;);
        editor.putInt(&quot;age&quot;,29);
        editor.putBoolean(&quot;married&quot;,false);
        editor.apply();
    }
</code></pre></li>
</ul>
<h3 id="SQLite数据库存储"><a href="#SQLite数据库存储" class="headerlink" title="SQLite数据库存储"></a>SQLite数据库存储</h3><p><strong>——一个轻量级关系型数据库</strong></p>
<hr>
<h4 id="创建更新数据库"><a href="#创建更新数据库" class="headerlink" title="- 创建更新数据库"></a>- 创建更新数据库</h4><ul>
<li>使用SQLiteOpenHelper帮助类可以非常简单地对数据库进行创建和升级</li>
<li>SQLiteOpenHelper有两个抽象方法，onCreate()和onUpgrade()用于创建和升级数据库的逻辑</li>
<li>SQLiteOpenHelper有两个实例方法，getReadableDatabase()和getWritableDatabase()，用于获取一个现有或新建的数据库</li>
<li>SQLiteOpenHelper有两个构造方法可供重写，其中一个接受Context，数据库名，Cursor，版本号为参数</li>
<li>使用数据库</li>
</ul>
<pre><code>public class MainActivity extends AppCompatActivity {

private MyDatabaseHelper dbHelper;

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    dbHelper = new MyDatabaseHelper(this,&quot;BookStore&quot;,null,3);
    //修改版本号可进行数据库的更新

    Button getData = (Button)findViewById(R.id.button);
    getData.setOnClickListener(new View.OnClickListener(){
        public void onClick(View V) {
            dbHelper.getWritableDatabase();
            //若硬盘空间已满则抛出异常

            }
        });
    }
}
</code></pre><ul>
<li><p>创建和更新数据库</p>
<pre><code>public class MyDatabaseHelper extends SQLiteOpenHelper {

//建表语句，autoincrement
public static final String CREATE_BOOK = &quot;create table book(&quot;
        + &quot;id integer primary key autoincrement,&quot;
        + &quot;author text,&quot;
        + &quot;price real,&quot;
        + &quot;name text)&quot;;

public static final String CREATE_CATEGORY = &quot;create table Category(&quot;
        + &quot;id integer primary key autoincrement,&quot;
        + &quot;category_name text,&quot;
        + &quot;category_code integer)&quot;;

private  Context mContext;

public MyDatabaseHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) {
    super(context, name, factory, version);
    mContext = context;
}

//创建表格，如果表已存在则该onCreate()方法不执行
public void onCreate(SQLiteDatabase db) {
    db.execSQL(CREATE_BOOK);
    db.execSQL(CREATE_CATEGORY);
    Toast.makeText(mContext,&quot;Create succeeded&quot;,Toast.LENGTH_SHORT).show();
}

//更新表格，输入新版本号将会执行
public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
    db.execSQL(&quot;drop table if exists Book&quot;);
    db.execSQL(&quot;drop table if exists Category&quot;);
 //删除表格
    onCreate(db);
    //重新建表
    }
}
</code></pre></li>
</ul>
<h4 id="增删查改数据库"><a href="#增删查改数据库" class="headerlink" title="- 增删查改数据库"></a>- 增删查改数据库</h4><ul>
<li>添加数据，SQLiteDatabase提供insert()方法专门用于添加数据</li>
<li>insert()方法接受3个参数，分别为表名，可以为空的列，ContentValues对象</li>
<li><p>ContentValues提供一系列的put()方法用于添加数据</p>
<pre><code>SQLiteDatabase db = dbHelper.getWritableDatabase();
ContentValues values = new ContentValues();
values.put(&quot;name&quot;,&quot;The Da Vinci Code&quot;);
values.put(&quot;author&quot;,&quot;Dan Brown&quot;);
values.put(&quot;pages&quot;,454);
values.put(&quot;price&quot;,16.96);
db.insert(&quot;Book&quot;,null,values);
</code></pre></li>
</ul>
<ul>
<li>删除数据，SQLiteDatabase提供delete()方法专门用于删除数据</li>
<li>delete()方法接受3个参数，分别为表名和对行列的约束</li>
</ul>
<pre><code>SQLiteDatabase db = dbHelper.getWritableDatabase();
db.delete(&quot;Book&quot;,&quot;pages &gt; ?&quot;,new String[]{&quot;500&quot;});
</code></pre><ul>
<li>查询数据，SQLiteDatabase提供query()方法专门用于查询数据</li>
<li>query()其中一个重载接受7个参数，分别为表名，列名，where约束条件，where中占位符的具体值，要group by的列，对group by的进一步约束，查询结果的排列方式，除表头外均可为null<h2 id="第七章-跨程序共享数据"><a href="#第七章-跨程序共享数据" class="headerlink" title="第七章 跨程序共享数据"></a>第七章 跨程序共享数据</h2></li>
</ul>
<hr>
<p><strong>（待续）</strong><br><br>  </p>
<h2 id="第八章-运用手机多媒体"><a href="#第八章-运用手机多媒体" class="headerlink" title="第八章 运用手机多媒体"></a>第八章 运用手机多媒体</h2><hr>
<p><strong>（待续）</strong><br><br>  </p>
<h3 id="使用通知"><a href="#使用通知" class="headerlink" title="使用通知"></a>使用通知</h3><p><strong>——通过状态栏发送消息</strong></p>
<hr>
<p><br>  </p>
<h4 id="通知的基本用法"><a href="#通知的基本用法" class="headerlink" title="- 通知的基本用法"></a>- 通知的基本用法</h4><ul>
<li>通过Context的getSystemService()方法获得NotificationManager对象对通知进行管理</li>
<li>getSystemService()接受一个字符串参数用于确定获取系统的哪个服务，传入Context.NOTIFICATION_SERVICE即可</li>
<li>使用NotificationCompat类的Bulider构造器创建Notification对象并设置各种属性</li>
<li>使用NotificationManager的notify()方法显示通知，该方法接受两个参数，id和Notification对象</li>
<li>实现通知的点击效果，需要调用setContentIntent()方法，该方法传入一个PendingIntent参数</li>
<li>关闭通知有两种方式setAutoCancel(true)和manager.cancel(id)</li>
</ul>
<pre><code>Intent intent = new Intent(this,MainActivity.class);
PendingIntent pi = PendingIntent.getActivity(this,0,intent,0);
NotificationManager manager = (NotificationManager)                        getSystemService(Context.NOTIFICATION_SERVICE);
Notification notification = new NotificationCompat.Builder(this)
        .setContentTitle(&quot;title&quot;)
        .setContentText(&quot;text&quot;)
        .setWhen(System.currentTimeMillis())
        .setSmallIcon(R.mipmap.ic_launcher)
        //小图必须设置否则无法显示通知
        .setLargeIcon(BitmapFactory.decodeResource(getResources(),R.mipmap.ic_launcher))
        .setContentIntent(pi)
        .setAutoCancel(true)
        .build();
manager.notify(1,notification);
</code></pre><p><br>  </p>
<h2 id="第九章-网络技术"><a href="#第九章-网络技术" class="headerlink" title="第九章 网络技术"></a>第九章 网络技术</h2><hr>
<p><br>  </p>
<h3 id="WebView用法"><a href="#WebView用法" class="headerlink" title="WebView用法"></a>WebView用法</h3><hr>
<ul>
<li><p>设置WebView </p>
<pre><code>protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
 WebView webView = (WebView)findViewById(R.id.web_view);
    webView.getSettings().setJavaScriptEnabled(true);
    webView.setWebViewClient(new WebViewClient());
    webView.loadUrl(&quot;http://www.baidu.com&quot;);

}
</code></pre></li>
</ul>
<ul>
<li>声明权限，访问网络需要声明权限，声明权限需要修改AndroidManifest.xml文件<pre><code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;
</code></pre></li>
</ul>
<p><br>  </p>
<h3 id="HTTP协议访问网络"><a href="#HTTP协议访问网络" class="headerlink" title="HTTP协议访问网络"></a>HTTP协议访问网络</h3><hr>
<p><br>  </p>
<h4 id="使用HttpURLConnection"><a href="#使用HttpURLConnection" class="headerlink" title="- 使用HttpURLConnection"></a>- 使用HttpURLConnection</h4><ul>
<li>使用流程</li>
</ul>
<pre><code>public class MainActivity extends AppCompatActivity implements View.OnClickListener {

private TextView responseText;

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    Button sendRequest = (Button)findViewById(R.id.button);
    responseText = (TextView)findViewById(R.id.response_text);
    sendRequest.setOnClickListener(this);
}

@Override
public void onClick(View v) {
    if(v.getId() == R.id.button){
        sendRequestWithHttpURLConnection();
    }
}

private void sendRequestWithHttpURLConnection(){
    new Thread(new Runnable() {
        @Override
        public void run() {
            HttpURLConnection connection = null;
            BufferedReader reader = null;
            try{

                URL url = new URL(&quot;https://www.baidu.com&quot;);
                // 获取HttpURLConnection实例需要new一个URL对象，并传入目标网络地址
                connection = (HttpURLConnection)url.openConnection();
                // 调用openConnection方法即返回需要的实例

                connection.setRequestMethod(&quot;GET&quot;);
                // 设置HTTP请求所使用的方法，一般为GET或POST，表示希望从服务器获取数据或者希望提交数据
                connection.setConnectTimeout(8000);
                // 设置连接超时毫秒数
                connection.setReadTimeout(8000);
                // 设置读取超时毫秒数
                InputStream in = connection.getInputStream();

                //读取输入流
                reader = new BufferedReader(new InputStreamReader(in));
                StringBuilder response = new StringBuilder();
                String line;
                while ((line = reader.readLine()) != null){
                    response.append(line);
                }
                showResponse(response.toString());
            }catch (Exception e){
                e.printStackTrace();
            }finally {
                if(reader != null){
                    try{
                        reader.close();
                    }catch (IOException e){
                        e.printStackTrace();
                    }
                }
                if (connection != null){
                    connection.disconnect();
                    // 将HTTP连接关闭
                }
            }
    }
    }).start();
}

private void showResponse(final String response){
    runOnUiThread(new Runnable() {
        @Override
        public void run() {
            responseText.setText(response);
            }
        });
    }
}
</code></pre><h4 id="解析JSON格式数据"><a href="#解析JSON格式数据" class="headerlink" title="- 解析JSON格式数据"></a>- 解析JSON格式数据</h4><p><strong>参考来源：<a href="http://www.cnblogs.com/SkySoot/archive/2012/04/17/2453010.html" target="_blank" rel="external">http://www.cnblogs.com/SkySoot/archive/2012/04/17/2453010.html</a></strong></p>
<ul>
<li>基础结构，JSON建构于两种结构，”名称/值”对的集合，值的有序列表</li>
<li>“名称/值”对：{ “firstName”: “Brett”, “lastName”:”McLaughlin”, “email”: “aaaa” }</li>
<li>“名称/数组”对</li>
</ul>
<pre><code>{ &quot;people&quot;: [
{ &quot;firstName&quot;: &quot;Brett&quot;, &quot;lastName&quot;:&quot;McLaughlin&quot;, &quot;email&quot;: &quot;aaaa&quot; },
{ &quot;firstName&quot;: &quot;Jason&quot;, &quot;lastName&quot;:&quot;Hunter&quot;, &quot;email&quot;: &quot;bbbb&quot;},
{ &quot;firstName&quot;: &quot;Elliotte&quot;, &quot;lastName&quot;:&quot;Harold&quot;, &quot;email&quot;: &quot;cccc&quot; }
}   
</code></pre><ul>
<li><p>用例</p>
<pre><code>protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    Button sendRequest = (Button)findViewById(R.id.button);
    sendRequest.setOnClickListener(this);

}

@Override
public void onClick(View v) {
    getJsonWithHttpURLConnection();
}

private void getJsonWithHttpURLConnection() {
//不要试图在main的线程中打开网络连接
    new Thread(new Runnable() {
        @Override
        public void run() {
            BufferedReader rd = null;
            HttpURLConnection connection = null;
            JSONArray resultJsonArray;
            JSONObject json;

            try {
                URL url = new URL(&quot;http://news-at.zhihu.com/api/4/news/latest&quot;);
                connection = (HttpURLConnection) url.openConnection();
                connection.setRequestMethod(&quot;GET&quot;);
                rd = new BufferedReader(new InputStreamReader(connection.getInputStream()));

                //读取流中的字符
                StringBuilder sb = new StringBuilder();
                int cp;
                while ((cp = rd.read()) != -1) {
                sb.append((char) cp);
                }

                json = new JSONObject(sb.toString());
                resultJsonArray = json.getJSONArray(&quot;stories&quot;);
                // 获取Json数组

                Log.d(&quot;Main&quot;, resultJsonArray.getJSONObject(3).getString(&quot;title&quot;));
                // 获取数组中的值

            } catch (IOException e) {
                e.printStackTrace();
            } catch (JSONException e) {
                e.printStackTrace();
            } finally {
                if (rd != null) {
                    try {
                     rd.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
                if (connection != null) {
                    connection.disconnect();
                }
            }
        }
    }).start();
}
</code></pre></li>
</ul>
<ul>
<li>回调机制，请求服务器时应该定义一个接口，在其中的onFinish方法中执行逻辑处理，而在onError方法中对异常状况进行处理</li>
<li>关于java、android的回调机制，参考<br><a href="http://blog.csdn.net/xiaanming/article/details/8703708/" target="_blank" rel="external">http://blog.csdn.net/xiaanming/article/details/8703708/</a><br><br></li>
</ul>
<h2 id="第十章-探究服务"><a href="#第十章-探究服务" class="headerlink" title="第十章 探究服务"></a>第十章 探究服务</h2><p><strong>——实现程序后台运行的方案</strong></p>
<hr>
<p><br>  </p>
<h3 id="Android-多线程编程"><a href="#Android-多线程编程" class="headerlink" title="Android 多线程编程"></a>Android 多线程编程</h3><hr>
<p><br>  </p>
<h4 id="线程的基本用法"><a href="#线程的基本用法" class="headerlink" title="- 线程的基本用法"></a>- 线程的基本用法</h4><ul>
<li><p>Runable 接口定义线程</p>
<pre><code>class MyThread implements Runnable{
 @Override
    public void run() {

    }
}

...

MyThread myThread = new MyThread();
new Thread(myThread).start();
</code></pre></li>
<li><p>匿名类实现接口</p>
<pre><code>new Thread(new Runnable() {
            @Override
            public void run() {

            }
        }).start();
</code></pre></li>
</ul>
<p><br>  </p>
<h4 id="异步消息处理机制"><a href="#异步消息处理机制" class="headerlink" title="- 异步消息处理机制"></a>- 异步消息处理机制</h4><ul>
<li>更新UI元素需要在主线程中进行</li>
<li>Android的异步消息由四个部分组成：Messag、handler、MessageQueue、Looper</li>
<li>Message，可以在内部携带少量消息，用于在不同线程之间传递数据，可选的字段类型有what，arg1，arg2，obj</li>
<li>Handler，用于发送和处理消息，发送消息使用sendMessage()方法，消息最终会传递到handleMessage中自动调用</li>
<li>MessageQueue，存放所有通过Handler发送的消息，每一个线程中只会有一个MessageQueue对象</li>
<li>Looper，调用loop()方法后开启取出和传递消息的循环发送到handler的handleMessage中，每一个线程只会有一个Looper对象</li>
</ul>
<pre><code>public  static final int UPDATE_TEXT = 1;
// 表示更新TextView的字段
private Handler handler = new Handler(){
    public void handleMessage(Message msg){
        switch (msg.what){
            case UPDATE_TEXT:
                text.setText(&quot;Nice to meet you&quot;);
                break;
            default:
                break;
        }
    }
};

public void onClick(View v) {
    switch (v.getId()){
        case R.id.button:
            new Thread(new Runnable() {
                @Override
                public void run() {
                    Message message = new Message();
                    message.what = UPDATE_TEXT;
                    handler.sendMessage(message);
                }
            }).start();
        }
    }
}
</code></pre><p><br>  </p>
<h4 id="使用AsyncTask"><a href="#使用AsyncTask" class="headerlink" title="- 使用AsyncTask"></a>- 使用AsyncTask</h4><ul>
<li>AsyncTask对异步消息处理做了很好的封装</li>
<li>AsyncTask包含三个泛型参数，Params，执行AsyncTask时需要使用的数据类型，Progress，进度单位的类型，Result，返回值类型</li>
<li>AsyncTask包含四个经常重写的方法:</li>
<li>onPreExecute()，后台任务开始之前调用，用于进行界面上的初始化操作</li>
<li>doInBackground(Params …)，用于运行耗时任务，所有代码都会在子线程中运行，不可以进行UI操作</li>
<li>onProgressUpdate(Progress …)，在调用publishProgress(Progress …)方法后马上被调用，可以进行UI操作，用参数中的数值进行相应的更新</li>
<li>onPostExecute，后台任务执行完毕并通过return返回时被调用，可以利用返回值进行一些收尾的UI操作</li>
<li>启动一个AsyncTask，使用new MyAsyncTask.execute()</li>
</ul>
<pre><code>public class DownloadTask extends AsyncTask&lt;Void,Integer,Boolean&gt;{

    @Override
    protected void onPreExecute(){
        progressDialog.show();      
    }

    @Override
    protected Boolean doInBackground(Void... params) {
        try{
            while (true){
                int downloadPrecent = doDownload();
                publishProgress(downloadPrecent);
                if (downloadPrecent&gt;=100){
                    break;
                }
            }
        }catch (Exception e){
            return false;
        }
        return true;
    }

    @Override
    protected void onProgressUpdate(Integer...values){       
        progressDialog.setMessage(&quot;Download&quot;+values[0]+&quot;%&quot;);
    }

    @Override
    protected void onPostExecute(Boolean result){
        progressDialog.dismiss();
        if(result){
            Toast.makeText(context,&quot;Download succeeded&quot;,
            Toast.LENGTH_SHORT).show();
        }
        else {
            Toast.makeText(context,&quot;Download failed&quot;,
            Toast.LENGTH_SHORT).show();
        }
    }
}
</code></pre><p><br>  </p>
<h3 id="服务的基本用法"><a href="#服务的基本用法" class="headerlink" title="服务的基本用法"></a>服务的基本用法</h3><hr>
<p><br>  </p>
<h4 id="定义一个服务"><a href="#定义一个服务" class="headerlink" title="- 定义一个服务"></a>- 定义一个服务</h4><ul>
<li>新建一个Service，有连个可选属性，Exported，表示是否让其他程序访问该服务，Enabled，表示是否启用这个服务</li>
<li>Service有三个常用方法，onCreated()会在服务创建时调用，onStartCommand()会在每次服务启动的时候调用，onDestroy()会在服务销毁的时候被调用</li>
<li>启用和停止服务，构建intent对象传入startService()和stopService()，这两个方法定义在context中，另外在Service的任何地方调用stopSelf()都可以让其停止下来</li>
</ul>
<pre><code>@Override
    public void onClick(View v) {
        switch (v.getId()){
            case R.id.start_service:
                Intent startIntent = new Intent(this,MyService.class);
                startService(startIntent);
                break;
            case R.id.stop_service:
                Intent stopIntent = new Intent(this,MyService.class);
                stopService(stopIntent);
                break;
            default:
                break;
        }
    }
</code></pre><p><br>  </p>
<h4 id="活动和服务进行通信"><a href="#活动和服务进行通信" class="headerlink" title="- 活动和服务进行通信"></a>- 活动和服务进行通信</h4><ul>
<li>在Service中新建继承自Binder的子类，在其中提供具体服务的方法，并在onBind中返回这个子类的实例</li>
<li>在活动中创建一个ServiceConnection类，重写onServiceConnected()方法和onServiceDisconnected()方法，分别在绑定与断开时会被调用</li>
<li>在onServiceConnected()方法中向下转型获得binder的实例，此时可以通过binder指挥服务</li>
<li><p>可能是书中的一个错误，应使用boolean值标记绑定状态并检查，否则重复解绑会抛出异常，参考 <a href="http://stackoverflow.com/questions/22079909/android-java-lang-illegalargumentexception-service-not-registered" target="_blank" rel="external">http://stackoverflow.com/questions/22079909/android-java-lang-illegalargumentexception-service-not-registered</a></p>
<pre><code>public class MyService extends Service {

    private DownloadBinder mBinder = new DownloadBinder();

    class DownloadBinder extends Binder {

        public void startDownload(){
            Log.d(&quot;MyService&quot;,&quot;startDownload executed&quot;);
        }

        public int getProgress(){
            Log.d(&quot;MyService&quot;,&quot;getProgress executed&quot;);
            return 0;
        }
    }

    @Override
    public IBinder onBind(Intent intent) {
        return mBinder;
    }

    public MyService() {
    }

    @Override
    public void onCreate(){
        super.onCreate();
        Log.d(&quot;My Service&quot;,&quot;onCreate executed&quot;);
    }

    @Override
    public int onStartCommand(Intent intent,int flags,int startId){
        Log.d(&quot;My Service&quot;,&quot;onStartCommand executed&quot;);
        return super.onStartCommand(intent,flags,startId);
    }

    @Override
    public void onDestroy(){
        super.onDestroy();
        Log.d(&quot;My Service&quot;,&quot;onDestroy executed&quot;);
    }
}

...

private ServiceConnection connection = new ServiceConnection() {
        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            downloadBinder = (MyService.DownloadBinder)service;
            downloadBinder.startDownload();
            downloadBinder.getProgress();
     }

        @Override
        public void onServiceDisconnected(ComponentName name) {
        }
    };

    ...

        Intent bindIntent = new Intent(this,MyService.class);
        bindService(bindIntent,connection,BIND_AUTO_CREATE);
</code></pre><p><br>  </p>
</li>
</ul>
<h4 id="服务的生命周期"><a href="#服务的生命周期" class="headerlink" title="- 服务的生命周期"></a>- 服务的生命周期</h4><ul>
<li>一个项目的任何位置调用了Context的startService()方法，相应的服务都会启动</li>
<li>每个服务只有一个实例，一个服务只要被启动或者绑定之后就会一直处于运行状态</li>
<li>只有当启动和绑定都取消时服务才会被销毁<br><br>  </li>
</ul>
<h3 id="服务的更多技巧"><a href="#服务的更多技巧" class="headerlink" title="服务的更多技巧"></a>服务的更多技巧</h3><hr>
<p><br>  </p>
<h4 id="使用前台服务"><a href="#使用前台服务" class="headerlink" title="-使用前台服务"></a>-使用前台服务</h4><ul>
<li>服务的系统优先级比较低，当出现内存不足时就有可能被被回收</li>
<li>若希望服务一直处于运行状态，考虑使用前台服务</li>
<li>创建前台服务，只需要修改Service的onCreate()方法，启动一个通知即可</li>
<li>startForeground方法接受两个参数，通知的id和Notification对象</li>
</ul>
<pre><code>public void onCreate(){
        super.onCreate();
        Log.d(&quot;My Service&quot;,&quot;onCreate executed&quot;);

        Intent intent = new Intent(this,MainActivity.class);
        PendingIntent pi = PendingIntent.getActivity(this,0,intent,0);
        Notification notification = new NotificationCompat.Builder(this)
                .setContentTitle(&quot;This is content title&quot;)
                .setContentText(&quot;This is content text&quot;)
                .setWhen(System.currentTimeMillis())
                .setSmallIcon(R.mipmap.ic_launcher)
                .setLargeIcon(BitmapFactory.decodeResource(getResources(),
                R.mipmap.ic_launcher))
                .setContentIntent(pi)
                .build();
        startForeground(1,notification);
    }
</code></pre><p><br>  </p>
<h4 id="使用IntentService"><a href="#使用IntentService" class="headerlink" title="- 使用IntentService"></a>- 使用IntentService</h4><ul>
<li>为避免出现ANR，耗时逻辑应该开启子线程去处理，一个比较标准的写法如下</li>
</ul>
<pre><code>@Override
public void onStartCommand(Intent intent, int flags,int startId){
    new Thread(new Runnable(){
        @Override
        public void run(){
        //处理耗时逻辑
        stopSelf();
        //可选
        }
    }).start();
}
</code></pre><ul>
<li><p>为避免忘记开启线程或停止服务，可以使用IntentService类</p>
<pre><code>public class MyIntentService extends IntentService {

    public MyIntentService(){
        //调用父类的有参构造器
        super(&quot;MyIntentService&quot;);
    }

    @Override
    protected void onHandleIntent(Intent intent) {
        //处理具体逻辑
        Log.d(&quot;MyIntentService&quot;,&quot;Thread id is&quot;+Thread.currentThread().getId());
    }

    @Override
    public void onDestroy(){
        super.onDestroy();
        Log.d(&quot;MyIntentService&quot;,&quot;onDestroy executed&quot;);
    }
}
</code></pre><p><br>  </p>
</li>
</ul>
<h2 id="第十一章-基于位置的服务"><a href="#第十一章-基于位置的服务" class="headerlink" title="第十一章 基于位置的服务"></a>第十一章 基于位置的服务</h2><hr>
<p><br>  </p>
<h2 id="第十二章-Material-Design"><a href="#第十二章-Material-Design" class="headerlink" title="第十二章 Material Design"></a>第十二章 Material Design</h2><hr>
<p><br>  </p>
<h2 id="第十三章-高级技巧"><a href="#第十三章-高级技巧" class="headerlink" title="第十三章 高级技巧"></a>第十三章 高级技巧</h2><hr>
<p><br>  </p>
<h3 id="全局获取Context"><a href="#全局获取Context" class="headerlink" title="全局获取Context"></a>全局获取Context</h3><hr>
<ul>
<li>在某些情况下无法获取Activity-Context，考虑使用全局获取Application-Context</li>
<li>需要在AndroidManifest中使用完整包名指定Application name为Application的子类</li>
<li>关于Activity-Context与Application-Context的区别，详见：<br><a href="http://www.jianshu.com/p/94e0f9ab3f1d" target="_blank" rel="external">http://www.jianshu.com/p/94e0f9ab3f1d</a><br><a href="http://www.cnblogs.com/wenjiang/archive/2012/10/15/2724923.html" target="_blank" rel="external">http://www.cnblogs.com/wenjiang/archive/2012/10/15/2724923.html</a></li>
</ul>
<pre><code>public class MyApplication extends Application {
    private static Context context;

    @Override
    public void onCreate() {
        super.onCreate();
        // 书中没有调用父类的onCreate()，编译器报错
        // 搜索之后发现两种做法都存在，估计影响不大
        context = getApplicationContext();
    }

    public static Context getContext() {
        return context;
    }
}
</code></pre><p><br>  </p>
<h3 id="使用Intent传递对象"><a href="#使用Intent传递对象" class="headerlink" title="使用Intent传递对象"></a>使用Intent传递对象</h3><hr>
<p><br>  </p>
<h4 id="Serializable-方式"><a href="#Serializable-方式" class="headerlink" title="- Serializable 方式"></a>- Serializable 方式</h4><ul>
<li>使用Intent的putExtra()方法传递自定义的类，需要实现Serializable</li>
<li>传入方法，intent.putExtra(“person_data”, person);</li>
<li>取出方法，Person person = (person) getIntent().getSerializableExtra(“person_data”);<br><br>  </li>
</ul>
<h4 id="Parcelable-方法"><a href="#Parcelable-方法" class="headerlink" title="- Parcelable 方法"></a>- Parcelable 方法</h4><ul>
<li>Serializable 方式传递对象会将对象序列化，效率较低，考虑使用Parcelable 方式</li>
<li>实现Parcelable接口需要重写describeContents()方法和writeToParcel方法()，还必须提供一个名为CREATER的常量</li>
<li>describeContents()方法直接返回0即可</li>
<li>writeToParcel()方法需将对象中的字段用write…()方法顺序写出</li>
<li>CREATER的泛型为被写入对象的类型，并要实现CreateFromName()方法和newArray方法</li>
<li>CreateFromName()方法需将对象中的字段用read…()方法顺序读出</li>
<li>newArray()方法只需new出一个被写入对象的数组，根据传入的变量作为数组大小即可</li>
<li>传入方法，intent.putExtra(“person_data”, person);</li>
<li>取出方法，Person person = (person) getIntent().getParcelableExtra(“person_data”);</li>
</ul>
<pre><code>public class Person implements Parcelable {
    private String name;
    private int age;

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
    dest.writeString(name);
    dest.writeInt(age);
    }

    public static final Parcelable.Creator&lt;Person&gt; CREATOR = new Parcelable.
            Creator&lt;Person&gt;(){

        @Override
        public Person createFromParcel(Parcel source){
            Person person = new Person();
            person.name = source.readString();
            person.age = source.readInt();
            return person;
        }

        @Override
        public Person[] newArray(int size){
            return new Person[size];
        }
    };
}
</code></pre><p><br>  </p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 安卓 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[unix网络编程 笔记]]></title>
      <url>/2017/02/21/Unp/</url>
      <content type="html"><![CDATA[<p>onDestroy</p>
<a id="more"></a>
<h2 id="函数与头文件"><a href="#函数与头文件" class="headerlink" title="函数与头文件"></a>函数与头文件</h2><p>netinet/in.h</p>
<pre><code>struct sockaddr_in

{
short sin_family;
//Address family一般来说为AF_INET（地址族）PF_INET（协议族）

unsigned short sin_port;
//Port number 必须要采用网络数据格式
//普通数字可以用htons()函数转换成网络数据格式的数字

struct in_addr sin_addr;
//IP address in network byte order（Internet address）


unsigned char sin_zero[8];
//没有实际意义,只是为了跟SOCKADDR结构在内存中对齐
}
</code></pre><p>sys/socket.h </p>
<pre><code>int socket( int af, int type, int protocol) 
</code></pre><p>string.h</p>
<pre><code>void *memset(void *s, int ch, size_t n)
</code></pre><p>stdio.h</p>
<pre><code>int fputs(char * string, FILE * stream)
</code></pre><p>unistd.h</p>
<pre><code>ssize_t read(int fd,void * buf ,size_t count)
</code></pre><p>arpa/inet.h</p>
<pre><code>int inet_pton(int af, const char *src, void *dst)
</code></pre><p>time.h</p>
<pre><code>ctime()
</code></pre><h2 id="daytime客户端程序"><a href="#daytime客户端程序" class="headerlink" title="daytime客户端程序"></a>daytime客户端程序</h2><pre><code>#include &lt;stdio.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;unistd.h&gt;
#include &lt;time.h&gt;


int
main(int argc,char **argv)
{
</code></pre><p>用来保存文件描述符（fd = file descriptor）</p>
<pre><code>int sockfd,n;
</code></pre><p>用来保存返回的字符</p>
<pre><code>char recvline[41];

struct sockaddr_in servaddr;

if(argc !=2)
{ 
    printf(&quot;usage: a.out &lt;IPaddress&gt;&quot;);
    exit(0);
}
</code></pre><p>AF_INET：协议族，常量2，socket只能使用这个协议</p>
<p>SOCK_STREAM： 提供面向连接的稳定数据传输，即TCP协议</p>
<p>参数protocol : 指定socket所使用的传输协议编号,这一参数通常不具体设置，一般设置为0即可（0即为默认）</p>
<p>这里创建一个套接字，采用tcp协议，并获取这个socket的文件描述符</p>
<pre><code>if((sockfd = socket(AF_INET,SOCK_STREAM,0))&lt;0)
{
    printf(&quot;socket error&quot;);
    exit(0);
}
</code></pre><p>初始化一个sockaddr_in结构，采用相同协议族</p>
<pre><code>memset(&amp;servaddr,0,sizeof(servaddr));
servaddr.sin_family=AF_INET;
</code></pre><p>sin_port : 存储端口号（使用网络字节顺序）<br>htons：将整型变量从主机字节顺序转变成网络字节顺序<br>13：daytime端口</p>
<pre><code>servaddr.sin_port = htons(13);
</code></pre><p>inet_pton()将IP地址从字符串格式转换成网络地址格式，支持Ipv4和Ipv6</p>
<pre><code>if(inet_pton(AF_INET,argv[1],&amp;servaddr.sin_addr)&lt;=0)
{
    printf(&quot;inet_pton error for %s&quot;,argv[1]);
}
</code></pre><p>connect函数利用文件描述符与地址，为客户端建立tcp连接<br>sockaddr和sockaddr_in的结构是一致的<br>但sockaddr一般保留给计算机使用，所以需要强制转换</p>
<pre><code>if(connect(sockfd,(struct sockaddr*)&amp;servaddr,sizeof(servaddr))&lt;0)
{
    printf(&quot;connect error&quot;);
    exit(0);
}
</code></pre><p>read()读取服务器应答，无法保证一次读取完全部数据，因此使用循环</p>
<pre><code>while((n=read(sockfd,recvline,40))&gt;0)
{
  recvline[n]=0;
  if(fputs(recvline,stdout)==EOF) 
</code></pre><p>输出到控制台</p>
<pre><code>exit(0);

if(n&lt;0)
{
    printf(&quot;read error&quot;);
    exit(0);
}

}

exit(0);
}
</code></pre><h2 id="daytime服务器程序"><a href="#daytime服务器程序" class="headerlink" title="daytime服务器程序"></a>daytime服务器程序</h2><pre><code>int main(int argc,char **argv)
{


int listenfd,connfd;
socklen_t len;
struct sockaddr_in servaddr,cliaddr;
char buff[40];
time_t ticks;

if( ( listenfd = socket(AF_INET,SOCK_STREAM,0 ) )&lt;0)
printf(&quot;socket error&quot;),exit(0);
memset(&amp;servaddr,0,sizeof(servaddr));
servaddr.sin_family = AF_INET;
</code></pre><p>-</p>
<pre><code>servaddr.sin_port = htons(9999);
</code></pre><p>选择端口，1024以下的端口一般保留给系统内部使用，书中使用daytime的端口13，但是这么做并没有任何意义，该程序通过time()、ctime()获取系统时间</p>
<pre><code>servaddr.sin_addr.s_addr =htonl(INADDR_ANY);
if(bind(listenfd,(struct sockaddr *)&amp;servaddr ,sizeof(servaddr))==-1)
printf(&quot;bind error &quot;),exit(0);
</code></pre><p>当用socket()函数创建套接字以后，套接字在名称空间(网络地址族)中存在，但没有任何地址给它赋值。bind()把用addr指定的地址与文件描述符代表的套接字sockfd绑定。addrlen指定了以addr所指向的地址结构体的字节长度</p>
<p>使用tcp协议通信时客户端不需要使用bind()</p>
<pre><code>if(listen(listenfd,2)==-1)printf(&quot;listen error\n&quot;),exit(0);
</code></pre><p>listen函数使用主动连接套接口变为被连接套接口，使得一个进程可以接受其它进程的请求，从而成为一个服务器进程。在TCP服务器编程中listen函数把进程变为一个服务器，并指定相应的套接字变为被动连接</p>
<pre><code>for(;;)
 {
len=sizeof(cliaddr);
connfd = accept(listenfd,(struct sockaddr *)&amp;cliaddr,&amp;len);
</code></pre><p>accept()按照顺序提取用于监听的socket所监听到的连接请求，用相应的端口以及通信地址创建一个新的socket，并将其文件描述符返回</p>
<pre><code>if(connfd==-1)printf(&quot;accept error\n&quot;),exit(0);
printf(&quot;connection from %s,port %d\n&quot;,inet_ntop(AF_INET,
&amp;cliaddr.sin_addr,buff,sizeof(buff)),ntohs(cliaddr.sin_port));
</code></pre><p>ntohs()将一个无符号短整形数从网络络字节顺序转换为主机字节顺序</p>
<p> -</p>
<pre><code>ticks = time(NULL);
</code></pre><p>获取系统时间</p>
<pre><code>snprintf(buff,sizeof(buff),&quot;%.24s\r\n&quot;,ctime(&amp;ticks));
</code></pre><p>ctime()将参数&amp;ticks所指的time_t结构中的信息转换成真实世界所使用的时间日期表示方法，然后将结果以字符串形态返回。<br>snprintf()将可变个参数(…)按照format格式化成字符串，然后将其复制到str中</p>
<pre><code>write(connfd,buff,strlen(buff));
</code></pre><p>write函数将buff中的nbytes字节内容写入socket,成功时返回写的字节数</p>
<pre><code>if(close(connfd)==-1)printf(&quot;close error\n&quot;),exit(0);
</code></pre><p>关闭本进程的socket id，但链接还是开着的，用这个socket id的其它进程还能用这个链接，能读或写这个socket id</p>
<pre><code>  }
}
</code></pre><h2 id="概念说明"><a href="#概念说明" class="headerlink" title="概念说明"></a>概念说明</h2><p>socket: 一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭）</p>
<p>Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。<br>在设计模式中，Socket其实就是一个门面模式<br>它把复杂的TCP/IP协议族隐藏在Socket接口后面<br>对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议</p>
<p>OSI: open system insterconnection 开放系统互连模型</p>
<p>物理层、数据链路层：设备驱动程序、网络硬件<br>网络层：IPv4／IPv6<br>传输层：TCP、UDP<br>（这之间的接口是构建api的自然位置）<br>回话、表示、应用层：应用层<br>传输层：TCP、UDP和SCTP</p>
<p>UDP：一个简单的传输层协议，往一个UDP套接字写入消息，<br>    该消息随后被封装到一个UDP数据报，<br>    该UDP数据报进而又被封装到一个IP数据报，然后发送到目的地<br>    UDP的特点是记录边界，提供无连接服务，缺乏可靠性</p>
<p>TCP：提供客户与服务器之间的连接，TCP客户先与某个给定的服务器建立一个连接，<br>    再跨该连接与那个服务器交换数据，然后终止这个连接<br>    TCP的特点是自动重传，动态估算往返时间（RTT），数据排序<br>    流量控制，全双工</p>
<p>SCTP：类似TCP，但面向消息，有多宿性</p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> unix </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ubuntu 16.04 开启daytime服务（端口13）]]></title>
      <url>/2017/02/20/Daytime/</url>
      <content type="html"><![CDATA[<hr>
<a id="more"></a>
<p>学习《unix网络编程》时，解决完编译问题，第一个程序又出现如下错误代码</p>
<pre><code>connect error: Connection refused
</code></pre><p>这个serve一般被系统默认关闭，用书中的daytimesrv程序可以暂时打开端口</p>
<p>不过最好通过xinetd（守护进程服务程序）开启</p>
<p>ubuntu不自带xinetd，因此</p>
<pre><code>sudo apt install xinetd
</code></pre><p>这个时候又报错 : (</p>
<pre><code>......
E: Unable to locate package xinetd
</code></pre><p>尝试用upgrade更新源依然失败<br>在系统设置->软件和更新->下载自：->其他站点中选择最佳服务区<br>再次安装xinetd成功</p>
<p>然后在/etc/xinetd.d中将daytime的两个disable改为no<br>（注意在vim中修改只读模式仍然可能无法保存，建议使用sudo chmod）</p>
<p>最后重新启动xinetd</p>
<pre><code>/etc/init.d/xinetd restart
</code></pre><p>运行，正常</p>
<pre><code>$ ./daytimetcpcli 127.0.0.1

20 FEB 2017 23:39:29 CST
counter = 1
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> unix </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[新年贺图]]></title>
      <url>/2017/01/25/2017/</url>
      <content type="html"><![CDATA[<p>不肝了，不肝了<br><a id="more"></a></p>
<p><img src="http://p1.bqimg.com/567571/9c34ec604599fff3.jpg"></p>
<p>魔学第一集的设定<br>线稿阶段本来没想那么多，然而越画越复杂<br>顺便尝试一下多色块的赛璐璐，结果是配色配到头晕</p>
<p>过几天再来看才感觉饱和度用低了，这个习惯很难改啊</p>
<p>pixiv地址：<a href="http://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=61224806" target="_blank" rel="external">http://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=61224806</a></p>
<p>个人页面：<a href="http://www.pixiv.net/member.php?id=7314348" target="_blank" rel="external">http://www.pixiv.net/member.php?id=7314348</a></p>
<p>whatever：<a href="https://alberthumbert.github.io/2016/10/15/mypaintings/">https://alberthumbert.github.io/2016/10/15/mypaintings/</a></p>
]]></content>
      
        <categories>
            
            <category> 创作 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 涂鸦 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[简单栈和树的简单操作]]></title>
      <url>/2017/01/23/LinearList2/</url>
      <content type="html"><![CDATA[<hr>
<a id="more"></a>
<h2 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"> #include &lt;stdio.h&gt;</div><div class="line"> #include &lt;stdlib.h&gt;</div><div class="line"> #include&lt;time.h&gt;</div><div class="line"> #define OK 1</div><div class="line"> #define ERROR 0      </div><div class="line"> #define MAXSIZE 30</div><div class="line"></div><div class="line">typedef int SElemType;</div><div class="line">typedef int Status;</div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">SElemType data[MAXSIZE];</div><div class="line">int top;</div><div class="line">&#125;SqStack;</div><div class="line"></div><div class="line">void StackPrint(SqStack *sp);</div><div class="line">Status Push(SqStack *sp,SElemType e);</div><div class="line">Status Pop(SqStack *sp,SElemType * ep);</div><div class="line"></div><div class="line">int</div><div class="line">main(void)</div><div class="line">&#123;</div><div class="line">int i,e,k,*ep=&amp;e;</div><div class="line">SqStack S;</div><div class="line">SqStack *sp=&amp;S;</div><div class="line">srand(time(0));</div><div class="line"></div><div class="line">//初始化随机栈</div><div class="line">i=rand()%10;</div><div class="line">S.top=i;</div><div class="line">for(k=0;k&lt;=i;k++)</div><div class="line"> S.data[k]=rand()%100+1;</div><div class="line"> StackPrint(sp);</div><div class="line"></div><div class="line">//进栈操作</div><div class="line">e=rand()%100+1;</div><div class="line">Push(sp,e);</div><div class="line">StackPrint(sp);</div><div class="line"></div><div class="line">//出栈操作</div><div class="line">Pop(sp,ep);</div><div class="line">StackPrint(sp);</div><div class="line"></div><div class="line">printf(&quot;done !\n\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void StackPrint(SqStack * sp)</div><div class="line">&#123;</div><div class="line">printf(&quot;new list: &quot;);</div><div class="line">for(int i=0;i&lt;=sp-&gt;top;i++)</div><div class="line"> printf(&quot;%d &quot;,sp-&gt;data[i]);</div><div class="line"> printf(&quot;\n&quot;);</div><div class="line"> &#125;</div><div class="line"></div><div class="line">Status Push(SqStack *sp,SElemType e)</div><div class="line">&#123;</div><div class="line">if(sp-&gt;top==MAXSIZE-1)</div><div class="line">&#123;</div><div class="line"> printf(&quot;Push Failed\n&quot;);</div><div class="line"> return ERROR;</div><div class="line">&#125;</div><div class="line">sp-&gt;top++;</div><div class="line">sp-&gt;data[sp-&gt;top]=e;</div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status Pop(SqStack *sp,SElemType * ep)</div><div class="line">&#123;</div><div class="line">if(sp-&gt;top==-1)</div><div class="line">&#123;</div><div class="line"> printf(&quot;Pop Failed\n&quot;);</div><div class="line"> return ERROR;</div><div class="line">&#125;</div><div class="line">*ep=sp-&gt;data[sp-&gt;top];</div><div class="line">sp-&gt;top--;</div><div class="line">return OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="两栈共享空间"><a href="#两栈共享空间" class="headerlink" title="两栈共享空间"></a>两栈共享空间</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include&lt;time.h&gt;</div><div class="line">#define OK 1</div><div class="line">#define ERROR 0</div><div class="line">#define MAXSIZE 30</div><div class="line">typedef int ElemType;</div><div class="line">typedef int Status;</div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">ElemType data[MAXSIZE];</div><div class="line">int top1;</div><div class="line">int top2;</div><div class="line">&#125;DoubleStack;</div><div class="line"></div><div class="line">Status Push(DoubleStack *S,ElemType e,int StackNumber);</div><div class="line">Status Pop(DoubleStack *S,ElemType *e,int StackNumber);</div><div class="line">Status StackInit(DoubleStack *S);</div><div class="line">Status stackprint(DoubleStack *S);</div><div class="line"></div><div class="line">int</div><div class="line">main()</div><div class="line">&#123;</div><div class="line">DoubleStack S;</div><div class="line">StackInit(&amp;S);</div><div class="line">int e,*pe=&amp;e;</div><div class="line"></div><div class="line">e=1;</div><div class="line">Push(&amp;S,e,1);</div><div class="line">stackprint(&amp;S);</div><div class="line"></div><div class="line">e=2;</div><div class="line">Push(&amp;S,e,2);</div><div class="line">stackprint(&amp;S);</div><div class="line"></div><div class="line">Pop(&amp;S,pe,1);</div><div class="line">stackprint(&amp;S);</div><div class="line"></div><div class="line">Pop(&amp;S,pe,2);</div><div class="line">stackprint(&amp;S);</div><div class="line">   </div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status StackInit(DoubleStack *S)</div><div class="line">&#123;</div><div class="line">S-&gt;top1=-1;</div><div class="line">S-&gt;top2=MAXSIZE;</div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status Push(DoubleStack *S,ElemType e,int StackNumber)</div><div class="line">&#123;</div><div class="line">if(S-&gt;top2+1==S-&gt;top2)</div><div class="line">    return ERROR;</div><div class="line">if(StackNumber==1)S-&gt;data[++S-&gt;top1]=e;</div><div class="line">if(StackNumber==2)S-&gt;data[--S-&gt;top2]=e;</div><div class="line"></div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status Pop(DoubleStack *S,ElemType *e,int StackNumber)</div><div class="line">&#123;</div><div class="line">if(StackNumber==1)</div><div class="line">&#123;</div><div class="line">    if(S-&gt;top1==-1)return ERROR;</div><div class="line">    *e=S-&gt;data[S-&gt;top1--];</div><div class="line">&#125;</div><div class="line"></div><div class="line">if(StackNumber==2)</div><div class="line">&#123;</div><div class="line">    if(S-&gt;top2==MAXSIZE)return ERROR;</div><div class="line">    *e=S-&gt;data[S-&gt;top2++];</div><div class="line">&#125;</div><div class="line"></div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status stackprint(DoubleStack *S)</div><div class="line">&#123;</div><div class="line">for(int i=0;i&lt;=S-&gt;top1;i++)</div><div class="line">    printf(&quot; %d &quot;,S-&gt;data[i]);</div><div class="line"></div><div class="line">for(int i=MAXSIZE-1;i&gt;=S-&gt;top2;i--)</div><div class="line">    printf(&quot; %d &quot;,S-&gt;data[i]);</div><div class="line">printf(&quot;\n&quot;);</div><div class="line"></div><div class="line"></div><div class="line">return OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include&lt;time.h&gt;</div><div class="line">#define OK 1</div><div class="line">#define ERROR 0</div><div class="line">#define MAXSIZE 30</div><div class="line"></div><div class="line">typedef int ElemType;</div><div class="line">typedef int Status;</div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line"> ElemType data;</div><div class="line"> struct StackNode *next;</div><div class="line">&#125;StackNode,*LinkStackPtr;</div><div class="line"></div><div class="line">typedef struct LinkStack</div><div class="line">&#123;</div><div class="line">LinkStackPtr top;</div><div class="line">int count;</div><div class="line">&#125;LinkStack;</div><div class="line"> </div><div class="line">Status Push(LinkStack *S,ElemType e);</div><div class="line">Status Pop(LinkStack *S,ElemType *e);</div><div class="line">Status StackInit(LinkStack *S);</div><div class="line">Status stackprint(LinkStack S);</div><div class="line"></div><div class="line">int </div><div class="line">main()</div><div class="line">&#123;</div><div class="line">LinkStack S;</div><div class="line">int e,*pe=&amp;e;</div><div class="line">StackInit(&amp;S);</div><div class="line"></div><div class="line">e=1;</div><div class="line">Push(&amp;S, e);</div><div class="line">stackprint(S);</div><div class="line"></div><div class="line">e=2;</div><div class="line">Push(&amp;S, e);</div><div class="line">stackprint(S);</div><div class="line"></div><div class="line"></div><div class="line">Pop(&amp;S, pe);</div><div class="line">stackprint(S);</div><div class="line"></div><div class="line">Pop(&amp;S, pe);</div><div class="line">stackprint(S)；</div><div class="line"></div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status Push(LinkStack *S,ElemType e)</div><div class="line">&#123;</div><div class="line">LinkStackPtr tmp=(LinkStackPtr)malloc(sizeof(StackNode));</div><div class="line">tmp-&gt;next=S-&gt;top;</div><div class="line">tmp-&gt;data=e;</div><div class="line">S-&gt;count++;</div><div class="line">S-&gt;top=tmp;</div><div class="line"></div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status Pop(LinkStack *S,ElemType *pe)</div><div class="line">&#123;</div><div class="line">LinkStackPtr tmp;</div><div class="line">if(S-&gt;top==NULL)</div><div class="line">    return ERROR;</div><div class="line">*pe=S-&gt;top-&gt;data;</div><div class="line">tmp=S-&gt;top;</div><div class="line">S-&gt;top=S-&gt;top-&gt;next;</div><div class="line">free(tmp);</div><div class="line">S-&gt;count--;</div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status StackInit(LinkStack *S)</div><div class="line">&#123;</div><div class="line">S-&gt;top=NULL;</div><div class="line">S-&gt;count=0;</div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status stackprint(LinkStack S)</div><div class="line">&#123;</div><div class="line">LinkStackPtr seek=S.top;</div><div class="line">while(seek)</div><div class="line">&#123;</div><div class="line">printf(&quot;%d &quot;,seek-&gt;data);</div><div class="line">seek=seek-&gt;next;</div><div class="line">&#125;</div><div class="line">printf(&quot;\n&quot;);</div><div class="line">return OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">  #include &lt;stdio.h&gt;</div><div class="line">  #include &lt;stdlib.h&gt;</div><div class="line">#include&lt;time.h&gt;</div><div class="line">#define OK 1</div><div class="line">#define ERROR 0</div><div class="line">#define MAXSIZE 20</div><div class="line">typedef int ElemType;</div><div class="line">typedef int Status;</div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">  ElemType data[MAXSIZE];</div><div class="line">  int front;</div><div class="line">  int rear;</div><div class="line">&#125;Queue;</div><div class="line"></div><div class="line">Status QueueInit(Queue *Q);</div><div class="line">Status QueueEn(Queue *Q,ElemType e);</div><div class="line">Status QueueDe(Queue *Q,ElemType *e);</div><div class="line">Status QueuePr(Queue Q);</div><div class="line">int QueueLength(Queue Q);</div><div class="line"></div><div class="line">int</div><div class="line">main()</div><div class="line">&#123;</div><div class="line">int e;</div><div class="line">//初始化队列</div><div class="line">Queue Q;</div><div class="line">QueueInit(&amp;Q);</div><div class="line"></div><div class="line">//入队列操作</div><div class="line">for(e=1;e&lt;=MAXSIZE;e++)</div><div class="line">&#123;</div><div class="line">QueueEn(&amp;Q, e);</div><div class="line">QueuePr(Q);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//出队列操作</div><div class="line">for(e=1;e&lt;=MAXSIZE;e++)</div><div class="line">&#123;</div><div class="line">    QueueDe(&amp;Q, &amp;e);</div><div class="line">    QueuePr(Q);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">&#125;</div><div class="line">Status QueueInit(Queue *Q)</div><div class="line">&#123;</div><div class="line"> Q-&gt;front=0;</div><div class="line"> Q-&gt;rear=0;</div><div class="line"></div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status QueueEn(Queue *Q,ElemType e)</div><div class="line">&#123;</div><div class="line"> if((Q-&gt;rear+1)%MAXSIZE==Q-&gt;front)</div><div class="line"> &#123;</div><div class="line">    printf(&quot;QueueEn failed\n&quot;);</div><div class="line">    return ERROR;</div><div class="line"> &#125;</div><div class="line"> Q-&gt;data[Q-&gt;rear]=e;</div><div class="line"> Q-&gt;rear=(Q-&gt;rear+1)%MAXSIZE;</div><div class="line"></div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">Status QueueDe(Queue *Q,ElemType *e)</div><div class="line">&#123;</div><div class="line">  if(Q-&gt;front==Q-&gt;rear)</div><div class="line"> &#123;</div><div class="line">    printf(&quot;QueueDe failed!\n&quot;);</div><div class="line">    return ERROR;</div><div class="line"> &#125;</div><div class="line"></div><div class="line">  Q-&gt;front=(Q-&gt;front+1)%MAXSIZE;</div><div class="line"></div><div class="line">  return OK;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">int QueueLength(Queue Q)</div><div class="line">&#123;</div><div class="line">  return (Q.rear+MAXSIZE-Q.front)%MAXSIZE;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status QueuePr(Queue Q)</div><div class="line">&#123;</div><div class="line">  if(QueueLength(Q)==0)</div><div class="line">  &#123;</div><div class="line">    return ERROR;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  for(int seek=Q.front;seek!=Q.rear;seek=(seek+1)%MAXSIZE)</div><div class="line">  printf(&quot;%d &quot;,Q.data[seek]);</div><div class="line">  printf(&quot;\n&quot;);</div><div class="line"></div><div class="line">  return OK;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h2 id="链队列"><a href="#链队列" class="headerlink" title="链队列"></a>链队列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include&lt;time.h&gt;</div><div class="line">#define OK 1</div><div class="line">#define ERROR 0</div><div class="line">#define MAXSIZE 20</div><div class="line">typedef int ElemType;</div><div class="line">typedef int Status;</div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">  ElemType data;</div><div class="line">  struct Node *next;</div><div class="line">&#125;Node,*QueuePtr;</div><div class="line"></div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line"> QueuePtr front,rear;</div><div class="line">&#125;LinkQueue;</div><div class="line"></div><div class="line">Status EnQueue(LinkQueue *Q,ElemType e);</div><div class="line">Status DeQueue(LinkQueue *Q,ElemType *e);</div><div class="line">Status InQueue(LinkQueue *Q);</div><div class="line">Status PrQueue(LinkQueue Q);</div><div class="line"></div><div class="line">int</div><div class="line">main()</div><div class="line">&#123;</div><div class="line">LinkQueue Q;</div><div class="line">int e,*pe=&amp;e;</div><div class="line">InQueue(&amp;Q);</div><div class="line"></div><div class="line">for(e=1;e&lt;=20;e++)</div><div class="line">&#123;</div><div class="line">EnQueue(&amp;Q, e);</div><div class="line">PrQueue(Q);</div><div class="line">&#125;</div><div class="line"></div><div class="line">for(e=1;e&lt;=20;e++)</div><div class="line">&#123;</div><div class="line"></div><div class="line">DeQueue(&amp;Q, pe);</div><div class="line">PrQueue(Q);</div><div class="line">&#125;</div><div class="line"></div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status EnQueue(LinkQueue *Q,ElemType e)</div><div class="line">&#123;</div><div class="line">QueuePtr new=(QueuePtr)malloc(sizeof(Node));</div><div class="line">new-&gt;data=e;</div><div class="line">new-&gt;next=NULL;</div><div class="line">Q-&gt;rear-&gt;next=new;</div><div class="line">Q-&gt;rear=new;</div><div class="line"></div><div class="line"></div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status DeQueue(LinkQueue *Q,ElemType *e)</div><div class="line">&#123;</div><div class="line">if(Q-&gt;front==Q-&gt;rear)</div><div class="line">  &#123;</div><div class="line">    printf(&quot;delete failed\n&quot;);</div><div class="line">    return ERROR;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">QueuePtr del=Q-&gt;front-&gt;next;</div><div class="line">*e=del-&gt;data;</div><div class="line">Q-&gt;front-&gt;next=del-&gt;next;</div><div class="line">if(del==Q-&gt;rear)</div><div class="line">    Q-&gt;rear=Q-&gt;front;</div><div class="line">free(del);</div><div class="line"></div><div class="line"></div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status InQueue(LinkQueue *Q)</div><div class="line">&#123;</div><div class="line"> QueuePtr new=(QueuePtr)malloc(sizeof(Node));</div><div class="line"> Q-&gt;front=new;</div><div class="line"> Q-&gt;rear=new;</div><div class="line"> return OK;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">Status PrQueue(LinkQueue Q)</div><div class="line">&#123;</div><div class="line"> if(Q.front==Q.rear)</div><div class="line">&#123;</div><div class="line">    printf(&quot;PrQueue failed\n&quot;);</div><div class="line">    return ERROR;</div><div class="line"></div><div class="line">&#125;</div><div class="line">QueuePtr seek=Q.front-&gt;next;</div><div class="line">while(seek!=NULL)</div><div class="line">&#123;</div><div class="line">    printf(&quot;%d &quot;,seek-&gt;data);</div><div class="line">    seek=seek-&gt;next;</div><div class="line">&#125;</div><div class="line">printf(&quot;\n&quot;);</div><div class="line"></div><div class="line">return OK;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/*</div><div class="line">//几种树的结构</div><div class="line">#define MAX_TREE_SIZE 100</div><div class="line">typedef int ElemType;</div><div class="line">typedef  struct Node</div><div class="line">&#123;</div><div class="line">    ElemType data;</div><div class="line">    int parent;</div><div class="line">&#125;Node;</div><div class="line"></div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">    Node nodes[MAX_TREE_SIZE];</div><div class="line">    int r,n;</div><div class="line">&#125;Tree;</div><div class="line">*/</div><div class="line"> </div><div class="line">/*</div><div class="line">#define MAX_TREE_SIZE 100</div><div class="line">typedef int ElemType;</div><div class="line">typedef struct Node</div><div class="line">&#123;</div><div class="line">    int child;</div><div class="line">    struct Node *next;</div><div class="line">&#125;* ChildPtr;</div><div class="line"></div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">ElemType data;</div><div class="line">ChildPtr firstchild;</div><div class="line">&#125;Box;</div><div class="line"></div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">Box nodes[MAX_TREE_SIZE];</div><div class="line">int r,n;</div><div class="line">&#125;Tree;</div><div class="line">*/</div><div class="line"> </div><div class="line">/*</div><div class="line">#define MAX_TREE_SIZE 100</div><div class="line">typedef int ElemType;</div><div class="line">typedef struct Node</div><div class="line">&#123;</div><div class="line">    ElemType data;</div><div class="line">    struct Node *firstchild,*rightsib;</div><div class="line">&#125;Node,*Tree;</div><div class="line">*/</div><div class="line"> </div><div class="line">#include&lt;stdio.h&gt;</div><div class="line">typedef char ElemType;</div><div class="line">typedef struct Node</div><div class="line">&#123;</div><div class="line">    ElemType data;</div><div class="line">    struct Node * lchild,*rchild;</div><div class="line"> </div><div class="line">&#125;Node,* Tree;</div><div class="line">void CreatTree(Tree *T);</div><div class="line">void PreOrderTraverse(Tree T);</div><div class="line">void InOrderTreaverse(Tree T);</div><div class="line">void PostOrderTraverse(Tree T);</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line"> </div><div class="line">//创建二叉树</div><div class="line">Tree T;</div><div class="line">CreatTree(&amp;T);</div><div class="line"></div><div class="line">//前序遍历二叉树</div><div class="line">PreOrderTraverse(T);</div><div class="line">printf(&quot;\n&quot;);</div><div class="line"></div><div class="line">//中序遍历二叉树</div><div class="line">InOrderTreaverse(T);</div><div class="line">printf(&quot;\n&quot;);</div><div class="line"></div><div class="line">//后序遍历二叉树</div><div class="line">PostOrderTraverse(T);</div><div class="line">printf(&quot;\n\n&quot;);</div><div class="line">return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void CreatTree(Tree *T)</div><div class="line">&#123;</div><div class="line">ElemType ch;</div><div class="line">scanf(&quot;%c&quot;,&amp;ch);</div><div class="line">if(ch==&apos;#&apos;)*T=NULL;</div><div class="line">else</div><div class="line">  &#123;</div><div class="line">    (*T)=(Tree)malloc(sizeof(Node));</div><div class="line">    if(!*T)return;</div><div class="line">     (*T)-&gt;data=ch;</div><div class="line">    CreatTree(&amp;(*T)-&gt;lchild);</div><div class="line">    CreatTree(&amp;(*T)-&gt;rchild);</div><div class="line">   </div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">void PreOrderTraverse(Tree T)</div><div class="line">&#123;</div><div class="line">if(T==NULL)</div><div class="line">       return;</div><div class="line"></div><div class="line">printf(&quot;%c&quot;,T-&gt;data);</div><div class="line">PreOrderTraverse(T-&gt;lchild);</div><div class="line">PreOrderTraverse(T-&gt;rchild);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">void InOrderTreaverse(Tree T)</div><div class="line">&#123;</div><div class="line">if(T==NULL)</div><div class="line">    return;</div><div class="line"></div><div class="line">PreOrderTraverse(T-&gt;lchild);</div><div class="line">printf(&quot;%c&quot;,T-&gt;data);</div><div class="line">PreOrderTraverse(T-&gt;rchild);</div><div class="line"></div><div class="line">&#125;   </div><div class="line">void PostOrderTraverse(Tree T)</div><div class="line">&#123;</div><div class="line">  if(T==NULL)</div><div class="line">        return;</div><div class="line"></div><div class="line">  PreOrderTraverse(T-&gt;lchild);</div><div class="line">  PreOrderTraverse(T-&gt;rchild);</div><div class="line">    printf(&quot;%c&quot;,T-&gt;data);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 代码 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[各类简单线性表的简单操作]]></title>
      <url>/2017/01/11/LinearList/</url>
      <content type="html"><![CDATA[<hr>
<a id="more"></a>
<h2 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h2><p>   指的是用一段地址连续的存储单元依次存储线性的数据元素， c中以数组实现<br>   对于线性表顺序存储结构：<br>   查找 时间复杂度为o[1]<br>   插入，删除 时间复杂度为o[n]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div></pre></td><td class="code"><pre><div class="line">   </div><div class="line">#define MAXSIZE 20</div><div class="line">#define OK 1</div><div class="line">#define ERROR 0</div><div class="line">#define TURE 1</div><div class="line">#define FALSE 10</div><div class="line"></div><div class="line">typedef int ElemType;</div><div class="line">typedef int Status;</div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">ElemType data[MAXSIZE];</div><div class="line">int length;</div><div class="line">&#125;SqList;</div><div class="line"></div><div class="line">Status Initialize(SqList * pL);</div><div class="line">Status GetElem(SqList L,int i,ElemType *pe);</div><div class="line">Status ListInsert(SqList * pL,int i,ElemType e);</div><div class="line">Status ListPrint(SqList * pL);</div><div class="line">Status ListDelete(SqList *pL,ElemType e);</div><div class="line"></div><div class="line">int</div><div class="line">main(void)</div><div class="line">&#123;</div><div class="line">ElemType e;</div><div class="line">ElemType * pe=&amp;e;</div><div class="line">SqList L;</div><div class="line">SqList *pL=&amp;L;</div><div class="line">L.length=10;</div><div class="line">int i;</div><div class="line"></div><div class="line">Initialize(pL);</div><div class="line">ListPrint(pL);</div><div class="line"></div><div class="line">//读取元素</div><div class="line">printf(&quot;intput a number of element :&quot;);</div><div class="line">scanf(&quot;%d&quot;,&amp;i);</div><div class="line">GetElem(L, i, pe);</div><div class="line">printf(&quot;GetElem :%d\n\n&quot;,e);</div><div class="line"></div><div class="line">//插入元素</div><div class="line">printf(&quot;intput a number to insert :&quot;);</div><div class="line">scanf(&quot;%d&quot;,&amp;e);</div><div class="line">printf(&quot;intput location to insert :&quot;);</div><div class="line">scanf(&quot;%d&quot;,&amp;i);</div><div class="line"></div><div class="line">ListInsert(pL,i,e);</div><div class="line">printf(&quot;new list :&quot;);</div><div class="line">ListPrint(pL);</div><div class="line">printf(&quot;\n&quot;);</div><div class="line"></div><div class="line">//删除元素</div><div class="line">printf(&quot;intput location to delete :&quot;);</div><div class="line">scanf(&quot;%d&quot;,&amp;i);</div><div class="line">ListDelete(pL, i);</div><div class="line">printf(&quot;new list :&quot;);</div><div class="line">ListPrint(pL);</div><div class="line">printf(&quot;\n&quot;);</div><div class="line"></div><div class="line">return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status GetElem(SqList L,int i,ElemType *pe)</div><div class="line">&#123;</div><div class="line">if(i&lt;1||L.length==0||i&gt;MAXSIZE)return ERROR;</div><div class="line">else *pe=L.data[i-1];</div><div class="line"></div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"> Status Initialize(SqList * pL)</div><div class="line">&#123;</div><div class="line">for(int i=0;i&lt;10;i++)</div><div class="line">    pL-&gt;data[i]=i;</div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status ListPrint(SqList * pL)</div><div class="line">&#123;</div><div class="line">for(int i=0;i&lt;pL-&gt;length;i++)</div><div class="line">    printf(&quot;%d &quot;,pL-&gt;data[i]);</div><div class="line">printf(&quot;\n&quot;);</div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status ListInsert(SqList * pL,int i,ElemType e)</div><div class="line">&#123;</div><div class="line">if(pL-&gt;length==MAXSIZE)return ERROR;</div><div class="line">if(i&lt;1||i&gt;=pL-&gt;length+2)return ERROR;</div><div class="line">if(i&lt;=pL-&gt;length)</div><div class="line">    for(int k=pL-&gt;length-1;k&gt;=i-1;k--)</div><div class="line">        pL-&gt;data[k+1]=pL-&gt;data[k];</div><div class="line"></div><div class="line">pL-&gt;data[i-1]=e;</div><div class="line">pL-&gt;length++;</div><div class="line"></div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status ListDelete(SqList *pL,ElemType i)</div><div class="line">&#123;</div><div class="line">if(pL-&gt;length==0)return ERROR;</div><div class="line">if(i&lt;1||i&gt;pL-&gt;length)return ERROR;</div><div class="line">if(i&lt;=pL-&gt;length)</div><div class="line">    for(int k=i;k&lt;pL-&gt;length;k++)</div><div class="line">        pL-&gt;data[k-1]=pL-&gt;data[k];</div><div class="line">pL-&gt;length--;</div><div class="line"></div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include&lt;time.h&gt;</div><div class="line">#define OK 1</div><div class="line">#define ERROR 0</div><div class="line">typedef int ElemType;</div><div class="line">typedef int Status;</div><div class="line">typedef struct Node</div><div class="line">&#123;</div><div class="line">ElemType data;</div><div class="line">struct Node * next;</div><div class="line">&#125;Node;</div><div class="line">typedef struct Node * LinkList;</div><div class="line"> </div><div class="line">void CreateListTail(LinkList L,int n);</div><div class="line">void ListPrint(LinkList L);</div><div class="line">Status GetElem(LinkList L,int i,ElemType * pe);</div><div class="line">Status ListInsert(LinkList L,int i,ElemType e);</div><div class="line">Status ListDelete(LinkList L,int i,ElemType * pe);</div><div class="line">Status ListClear(LinkList L);</div></pre></td></tr></table></figure>
<p>xcode下运行通过（下同）</p>
<h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><p>指用链式存储结构，用一组任意的存储单元存放线性表的元素</p>
<p>对于单链表：<br>查找 时间复杂度为o[n]<br>插入，删除 时间复杂度为o[1]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include&lt;time.h&gt;</div><div class="line">#define OK 1</div><div class="line">#define ERROR 0</div><div class="line">typedef int ElemType;</div><div class="line">typedef int Status;</div><div class="line">typedef struct Node</div><div class="line">&#123;</div><div class="line">ElemType data;</div><div class="line">struct Node * next;</div><div class="line">&#125;Node;</div><div class="line">typedef struct Node * LinkList;</div><div class="line"> </div><div class="line">void CreateListTail(LinkList L,int n);</div><div class="line">void ListPrint(LinkList L);</div><div class="line">Status GetElem(LinkList L,int i,ElemType * pe);</div><div class="line">Status ListInsert(LinkList L,int i,ElemType e);</div><div class="line">Status ListDelete(LinkList L,int i,ElemType * pe);</div><div class="line">Status ListClear(LinkList L);</div><div class="line"></div><div class="line">int</div><div class="line">main(void)</div><div class="line">&#123;</div><div class="line">LinkList L=(LinkList)malloc(sizeof(Node));</div><div class="line">int n,i,e;</div><div class="line">int *pe=&amp;e;</div><div class="line"> </div><div class="line">//初始化链表(尾插法)</div><div class="line">//注意：该链表头节点记录链表长度，从头节点的相邻节点开始计数</div><div class="line">printf(&quot;Input total number of nodes :&quot;);</div><div class="line">scanf(&quot;%d&quot;,&amp;n);</div><div class="line">CreateListTail(L,n);</div><div class="line">ListPrint(L);</div><div class="line"> </div><div class="line">//读取节点数据</div><div class="line">printf(&quot;Input location of node &quot;);</div><div class="line">scanf(&quot;%d&quot;,&amp;i);</div><div class="line">GetElem(L,i,pe);</div><div class="line">printf(&quot;GetElem :&quot;);</div><div class="line">printf(&quot;%d\n\n&quot;,e);</div><div class="line"> </div><div class="line">//插入节点</div><div class="line">printf(&quot;Input location to insert :&quot;);</div><div class="line">scanf(&quot;%d&quot;,&amp;i);</div><div class="line">printf(&quot;Input data to insert :&quot;);</div><div class="line">scanf(&quot;%d&quot;,&amp;e);</div><div class="line">ListInsert(L,i,e);</div><div class="line">ListPrint(L);</div><div class="line"> </div><div class="line">//删除节点</div><div class="line">printf(&quot;Input location to delete :&quot;);</div><div class="line">scanf(&quot;%d&quot;,&amp;i);</div><div class="line">ListDelete(L,i,pe);</div><div class="line">ListPrint(L);</div><div class="line"> </div><div class="line">//删除链表</div><div class="line">ListClear(L);</div><div class="line">printf(&quot;ListClear :&quot;);</div><div class="line">ListPrint(L);</div><div class="line">printf(&quot;Well done!\n\n&quot;);</div><div class="line">  </div><div class="line">return 0;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">void CreateListTail(LinkList L,int n)</div><div class="line">&#123;</div><div class="line">LinkList tmp,tail;</div><div class="line">L-&gt;data=n;</div><div class="line">tail=L;</div><div class="line">srand(time(0));</div><div class="line">for(int i=0;i&lt;n;i++)</div><div class="line">&#123;</div><div class="line">tmp=(LinkList)malloc(sizeof(Node));</div><div class="line">tmp-&gt;data=rand()%100+1;</div><div class="line">tail-&gt;next=tmp;</div><div class="line">tail=tmp;</div><div class="line">&#125;</div><div class="line">tail-&gt;next=NULL;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">void ListPrint(LinkList L)</div><div class="line">&#123;</div><div class="line">LinkList s;</div><div class="line">s=L;</div><div class="line">printf(&quot;new list :&quot;);</div><div class="line">while(s!=NULL)</div><div class="line">&#123;</div><div class="line">printf(&quot;%d &quot;,s-&gt;data);</div><div class="line">s=s-&gt;next;</div><div class="line">&#125;</div><div class="line">printf(&quot;\n\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status GetElem(LinkList L,int i,ElemType * pe)</div><div class="line">&#123;</div><div class="line">LinkList tmp;</div><div class="line">tmp=L-&gt;next;</div><div class="line">for(int j=1;tmp&amp;&amp;j&lt;i;j++)</div><div class="line">tmp=tmp-&gt;next;</div><div class="line"> </div><div class="line">if(!tmp||i&lt;1)</div><div class="line">&#123;   printf(&quot;\nerror!\n&quot;);</div><div class="line"> return ERROR;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">*pe=tmp-&gt;data;</div><div class="line"> </div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status ListInsert(LinkList L,int i,ElemType e)</div><div class="line">&#123;</div><div class="line"> LinkList tmp,new;</div><div class="line"> tmp=L;</div><div class="line"> for(int j=1;j&lt;i;j++)</div><div class="line">     tmp=tmp-&gt;next;</div><div class="line"> if(!tmp||i&lt;1)</div><div class="line"> &#123;   printf(&quot;\nerror!\n&quot;);</div><div class="line">     return ERROR;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> new=(LinkList)malloc(sizeof(Node));</div><div class="line"> new-&gt;data=e;</div><div class="line"> new-&gt;next=tmp-&gt;next;</div><div class="line"> tmp-&gt;next=new;</div><div class="line"> L-&gt;data++;</div><div class="line">     return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status ListDelete(LinkList L,int i,ElemType * pe)</div><div class="line">&#123;</div><div class="line"> LinkList tmp,dele;</div><div class="line"> //tmp-&gt;next指向第一元素</div><div class="line"> tmp=L;</div><div class="line"> for(int j=1;tmp-&gt;next&amp;&amp;j&lt;i;j++)</div><div class="line">     tmp=tmp-&gt;next;</div><div class="line"> if(!tmp-&gt;next||i&lt;1)</div><div class="line"> &#123;   printf(&quot;\nerror!\n&quot;);</div><div class="line">     return ERROR;</div><div class="line"> &#125;</div><div class="line"> dele=tmp-&gt;next;</div><div class="line"> * pe=dele-&gt;data;</div><div class="line"> tmp-&gt;next=dele-&gt;next;</div><div class="line"> free(dele);</div><div class="line"> L-&gt;data--;</div><div class="line"> return OK;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> Status ListClear(LinkList L)</div><div class="line">&#123;</div><div class="line"> LinkList dele,tmp;</div><div class="line"> dele=L-&gt;next;</div><div class="line"> while(dele)</div><div class="line"> &#123;</div><div class="line">     tmp=dele-&gt;next;</div><div class="line">     free(dele);</div><div class="line">     dele=tmp;</div><div class="line"> &#125;</div><div class="line"> L-&gt;data=0;</div><div class="line"> L-&gt;next=NULL;</div><div class="line"> return OK;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h2 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h2><p>指用数组描述的链表，也叫游标实现法<br>为没有指针的高级语言提供一种链表的实现方法</p>
<p>查找 时间复杂度为o[n]<br>插入，删除 时间复杂度为o[1]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include&lt;time.h&gt;</div><div class="line">#define OK 1</div><div class="line">#define ERROR 0</div><div class="line">#define MAXSIZE 30</div><div class="line">typedef int Status;</div><div class="line">typedef int ElemType;</div><div class="line"></div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">ElemType data;</div><div class="line">int cur;</div><div class="line">&#125;Component,StaticLinkList[MAXSIZE];</div><div class="line"></div><div class="line">Status ListInit(StaticLinkList L);</div><div class="line">Status ListPrint(StaticLinkList L);</div><div class="line">int MallocSLL(StaticLinkList L);</div><div class="line">int ListLength(StaticLinkList L);</div><div class="line">void FreeSSL(StaticLinkList L,int k);</div><div class="line">Status ListInsert(StaticLinkList L,int i,ElemType e);</div><div class="line">Status ListDelete(StaticLinkList L,int i);</div><div class="line">  </div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">StaticLinkList L;</div><div class="line">int i,e;</div><div class="line">srand(time(0));</div><div class="line"></div><div class="line">//初始化链表</div><div class="line">//第一个元素的cur存放第一个空闲节点的下标</div><div class="line">//最后一个元素的cur存放第一个占用节点的下标，相当于头节点</div><div class="line">   </div><div class="line">printf(&quot;new list :&quot;);</div><div class="line">ListInit(L);</div><div class="line">ListPrint(L);</div><div class="line">printf(&quot;\n&quot;);</div><div class="line"></div><div class="line">//生成随机链表</div><div class="line">printf(&quot;input the total number of element :&quot;);</div><div class="line">scanf(&quot;%d&quot;,&amp;i);</div><div class="line">for(int j=0;j&lt;i;j++)</div><div class="line">&#123;</div><div class="line">    e=rand()%100+1;</div><div class="line">    ListInsert(L,1,e);</div><div class="line">&#125;</div><div class="line">printf(&quot;new list :&quot;);</div><div class="line">ListPrint(L);</div><div class="line">printf(&quot;\n&quot;);</div><div class="line"></div><div class="line">//插入单个元素</div><div class="line">printf(&quot;input positio to insert :&quot;);</div><div class="line">scanf(&quot;%d&quot;,&amp;i);</div><div class="line">printf(&quot;input data to insert :&quot;);</div><div class="line">scanf(&quot;%d&quot;,&amp;e);</div><div class="line">ListInsert(L,i,e);</div><div class="line">printf(&quot;new list :&quot;);</div><div class="line">ListPrint(L);</div><div class="line">printf(&quot;\n&quot;);</div><div class="line"></div><div class="line">//删除元素</div><div class="line">printf(&quot;input positio to delete :&quot;);</div><div class="line">scanf(&quot;%d&quot;,&amp;i);</div><div class="line">ListDelete(L, i);</div><div class="line">printf(&quot;new list: &quot;);</div><div class="line">ListPrint(L);</div><div class="line">printf(&quot;\n&quot;);</div><div class="line"></div><div class="line">printf(&quot;done !\n\n&quot;); </div><div class="line">&#125;</div><div class="line"></div><div class="line">Status ListInit(StaticLinkList L)</div><div class="line">&#123;</div><div class="line">int i;</div><div class="line">for(i=0;i&lt;MAXSIZE-1;i++)</div><div class="line">    L[i].cur=i+1;</div><div class="line">L[MAXSIZE-1].cur=0;</div><div class="line">L[0].data=0;</div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status ListPrint(StaticLinkList L)</div><div class="line">&#123;</div><div class="line">int i=L[MAXSIZE-1].cur;</div><div class="line">if(!i)printf(&quot;init !&quot;);</div><div class="line">while(i)</div><div class="line">&#123;</div><div class="line">    printf(&quot;%d &quot;,L[i].data);</div><div class="line">    i=L[i].cur;</div><div class="line">&#125;</div><div class="line">printf(&quot;\n&quot;);</div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int MallocSLL(StaticLinkList L)</div><div class="line">&#123;   </div><div class="line">int i=L[0].cur;</div><div class="line">if(L[0].cur)</div><div class="line">    L[0].cur=L[i].cur;</div><div class="line">return i;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void FreeSSL(StaticLinkList L,int k)</div><div class="line">&#123;</div><div class="line">L[0].cur=L[k].cur;</div><div class="line">L[k].cur=0;</div><div class="line">return;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status ListInsert(StaticLinkList L,int i,ElemType e)</div><div class="line">&#123;</div><div class="line">int seek,new,k;</div><div class="line">seek=MAXSIZE-1;</div><div class="line">if(i&lt;0||i&gt;ListLength(L)+1)</div><div class="line">&#123;</div><div class="line">    printf(&quot;Insert Failed!\n&quot;);</div><div class="line">    return ERROR;</div><div class="line">&#125;</div><div class="line">new=MallocSLL(L);</div><div class="line">if(new)</div><div class="line">&#123;</div><div class="line">    L[new].data=e;</div><div class="line">    for(k=0;k&lt;i-1;k++)</div><div class="line">        seek=L[seek].cur;</div><div class="line">    L[new].cur=L[seek].cur;</div><div class="line">    L[seek].cur=new;</div><div class="line">    L[0].data++;</div><div class="line">    return OK;</div><div class="line">&#125;</div><div class="line">else</div><div class="line">&#123;</div><div class="line">    printf(&quot;Malloc Failed!\n&quot;);</div><div class="line">    return ERROR;</div><div class="line">&#125;</div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status ListDelete(StaticLinkList L,int i)</div><div class="line">&#123;</div><div class="line">int j,k;</div><div class="line">if(i&lt;1||i&gt;ListLength(L))</div><div class="line">&#123;   printf(&quot;Delete Failed\n&quot;);</div><div class="line">    return ERROR;</div><div class="line">&#125;</div><div class="line">k=MAXSIZE-1;</div><div class="line">for(j=1;j&lt;=i-1;j++)</div><div class="line">    k=L[k].cur;</div><div class="line">j=L[k].cur;</div><div class="line">L[k].cur=L[j].cur;</div><div class="line">FreeSSL(L, j);</div><div class="line">L[0].data--;</div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int ListLength(StaticLinkList L)</div><div class="line">&#123;</div><div class="line">int j=0,i=MAXSIZE-1;</div><div class="line">while(i)</div><div class="line">&#123;</div><div class="line">    i=L[i].cur;</div><div class="line">    j++;</div><div class="line">&#125;</div><div class="line">return j;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h2><p>头尾相连的环状单链表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include&lt;time.h&gt;</div><div class="line">#define OK 1</div><div class="line">#define ERROR 0</div><div class="line">typedef int ElemType;</div><div class="line">typedef int Status;</div><div class="line">typedef struct Node</div><div class="line">&#123;</div><div class="line">ElemType data;</div><div class="line">struct Node * next;</div><div class="line">&#125;Node;</div><div class="line">typedef struct Node * LinkList;</div><div class="line"></div><div class="line">Status ListInit(LinkList * L,int n);</div><div class="line">void ListPrint(LinkList L);</div><div class="line">Status GetElem(LinkList L,int i,ElemType * pe);</div><div class="line">Status ListInsert(LinkList *L,int i,ElemType e);</div><div class="line">Status ListDelete(LinkList *L,int i,ElemType * pe);</div><div class="line">Status ListClear(LinkList *L);</div><div class="line"></div><div class="line">int</div><div class="line">main(void)</div><div class="line">&#123;</div><div class="line">LinkList L;</div><div class="line">srand(time(0));</div><div class="line">int n=rand()%10+1;</div><div class="line">int e,*pe=&amp;e;</div><div class="line"></div><div class="line">//初始化链表</div><div class="line">ListInit(&amp;L,n);</div><div class="line">ListPrint(L);</div><div class="line"></div><div class="line">//获取节点数据</div><div class="line">printf(&quot;input number of node :&quot;);</div><div class="line">scanf(&quot;%d&quot;,&amp;n);</div><div class="line">GetElem(L, n, pe);</div><div class="line"></div><div class="line">//删除节点</div><div class="line">printf(&quot;input number of node to delete :&quot;);</div><div class="line">scanf(&quot;%d&quot;,&amp;n);</div><div class="line">ListDelete(&amp;L, n, pe);</div><div class="line">ListPrint(L);</div><div class="line"></div><div class="line">//清空链表</div><div class="line">ListClear(&amp;L);</div><div class="line">ListPrint(L);</div><div class="line"></div><div class="line">printf(&quot;done!\n\n&quot;);</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">Status ListInit(LinkList * L,int n)</div><div class="line">&#123;</div><div class="line">(*L)=(LinkList)malloc(sizeof(struct Node));</div><div class="line">if(!*L)</div><div class="line">&#123;</div><div class="line">    printf(&quot;malloc failed&quot;);</div><div class="line">    return ERROR;</div><div class="line">&#125;</div><div class="line">(*L)-&gt;next=*L;</div><div class="line">(*L)-&gt;data=1;</div><div class="line">for(int i=1;i&lt;=n;i++)</div><div class="line">&#123;</div><div class="line">    int e=rand()%100+1;</div><div class="line">    ListInsert(L, i, e);</div><div class="line">&#125;</div><div class="line">printf(&quot;Init!\n&quot;);</div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line">  </div><div class="line">void ListPrint(LinkList L)</div><div class="line">&#123;</div><div class="line">LinkList seek;</div><div class="line">seek=L-&gt;next;</div><div class="line">printf(&quot;new list:&quot;);</div><div class="line">while(seek!=L)</div><div class="line">&#123;</div><div class="line">    printf(&quot;%d &quot;,seek-&gt;data);</div><div class="line">    seek=seek-&gt;next;</div><div class="line">&#125;</div><div class="line">printf(&quot;\n\n&quot;);</div><div class="line">return;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">Status GetElem(LinkList L,int i,ElemType * pe)</div><div class="line">&#123;</div><div class="line">LinkList seek;</div><div class="line">int k=1;</div><div class="line">seek=L-&gt;next;</div><div class="line">while(k&lt;i)</div><div class="line">&#123;</div><div class="line">    seek=seek-&gt;next;</div><div class="line">    k++;</div><div class="line">&#125;</div><div class="line">*pe=seek-&gt;data;</div><div class="line">printf(&quot;GetElem: %d\n\n&quot;,*pe);</div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"> Status ListInsert(LinkList *L,int i,ElemType e)</div><div class="line">&#123;</div><div class="line">int k=0;</div><div class="line">LinkList seek=(*L)-&gt;next;</div><div class="line">LinkList tmp;</div><div class="line">if(i&lt;0||i&gt;(*L)-&gt;data)</div><div class="line">&#123;</div><div class="line">    printf(&quot;Insert failed&quot;);</div><div class="line">    return ERROR;</div><div class="line">&#125;</div><div class="line"></div><div class="line">while(k&lt;i-1)</div><div class="line">&#123;</div><div class="line">    seek=seek-&gt;next;</div><div class="line">    k++; </div><div class="line">&#125;</div><div class="line">    tmp=(LinkList)malloc(sizeof(struct Node));</div><div class="line">    tmp-&gt;next=seek-&gt;next;</div><div class="line">    tmp-&gt;data=e;</div><div class="line">    seek-&gt;next=tmp;</div><div class="line">    (*L)-&gt;data++;</div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status ListDelete(LinkList *L,int i,ElemType * pe)</div><div class="line">&#123;</div><div class="line"></div><div class="line">LinkList seek;</div><div class="line">int k=1;</div><div class="line">if(i&lt;0||i&gt;(*L)-&gt;data)</div><div class="line">&#123;</div><div class="line">    printf(&quot;Delete failed&quot;);</div><div class="line">    return ERROR;</div><div class="line">&#125;</div><div class="line">seek=(*L)-&gt;next;</div><div class="line">while(k&lt;i-1)</div><div class="line">&#123;</div><div class="line">    seek=seek-&gt;next;</div><div class="line">    k++;</div><div class="line">&#125;</div><div class="line">LinkList tmp=seek-&gt;next;</div><div class="line">seek-&gt;next=tmp-&gt;next;</div><div class="line">*pe=tmp-&gt;data;</div><div class="line">free(tmp);</div><div class="line">(*L)-&gt;data--;</div><div class="line">return OK;  </div><div class="line">&#125;</div><div class="line"></div><div class="line">Status ListClear(LinkList *L)</div><div class="line">&#123;</div><div class="line">LinkList seek,tmp;</div><div class="line">seek=(*L)-&gt;next;</div><div class="line">while(seek!=*L)</div><div class="line">&#123;</div><div class="line">    tmp=seek;</div><div class="line">    seek=seek-&gt;next;</div><div class="line">    free(tmp);</div><div class="line">&#125;</div><div class="line">(*L)-&gt;next=*L;</div><div class="line">(*L)-&gt;data=1;</div><div class="line">return OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>具有前驱指针与后继指针的链表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include&lt;time.h&gt;</div><div class="line">#define OK 1</div><div class="line">#define ERROR 0</div><div class="line">typedef int ElemType;</div><div class="line">typedef int Status;</div><div class="line">typedef struct Node</div><div class="line">&#123;</div><div class="line">ElemType data;</div><div class="line">struct Node * prev;</div><div class="line">struct Node * next;</div><div class="line">&#125;Node;</div><div class="line">typedef struct Node * LinkList;</div><div class="line"></div><div class="line">Status ListInit(LinkList * L,int n);</div><div class="line">void ListPrint(LinkList L);</div><div class="line">Status GetElem(LinkList L,int i,ElemType * pe);</div><div class="line">Status GetPrevElem(LinkList tmp,ElemType * pe);</div><div class="line">Status ListInsert(LinkList *L,int i,ElemType e);</div><div class="line">Status ListDelete(LinkList *L,int i,ElemType * pe);</div><div class="line">Status ListClear(LinkList *L);</div><div class="line"></div><div class="line">int</div><div class="line">main()</div><div class="line">&#123;</div><div class="line">LinkList L;</div><div class="line">srand(time(0));</div><div class="line">int n=rand()%10+1;</div><div class="line">int e,*pe=&amp;e;</div><div class="line">  </div><div class="line"></div><div class="line">//初始化链表</div><div class="line">ListInit(&amp;L,n);</div><div class="line">ListPrint(L);</div><div class="line"></div><div class="line">//读取节点数据</div><div class="line">printf(&quot;input number of node :&quot;);</div><div class="line">scanf(&quot;%d&quot;,&amp;n);</div><div class="line">GetElem(L, n, pe);</div><div class="line">printf(&quot;GetElem: %d\n\n&quot;,*pe);</div><div class="line"></div><div class="line">//读取前一节点数据</div><div class="line">printf(&quot;input number of node :&quot;);</div><div class="line">scanf(&quot;%d&quot;,&amp;n);</div><div class="line">LinkList seek=L-&gt;next;</div><div class="line">for(int k=1;k&lt;=n;k++)</div><div class="line">&#123;</div><div class="line">seek=seek-&gt;next;</div><div class="line">k++;</div><div class="line">&#125;</div><div class="line">GetPrevElem(seek, pe);</div><div class="line">printf(&quot;GetPrevElem: %d\n\n&quot;,*pe);</div><div class="line"></div><div class="line">//删除节点数据</div><div class="line">printf(&quot;input number of node to delete :&quot;);</div><div class="line">scanf(&quot;%d&quot;,&amp;n);</div><div class="line">ListDelete(&amp;L, n, pe);</div><div class="line">ListPrint(L);</div><div class="line"></div><div class="line">//清空链表</div><div class="line">ListClear(&amp;L);</div><div class="line">printf(&quot;ListClear \n&quot;);</div><div class="line">ListPrint(L);</div><div class="line"></div><div class="line">printf(&quot;done!\n\n&quot;);</div><div class="line">return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line"> Status ListInit(LinkList * L,int n)</div><div class="line">&#123;</div><div class="line">(*L)=(LinkList)malloc(sizeof(Node));</div><div class="line">if(!*L)</div><div class="line">&#123;</div><div class="line">    printf(&quot;malloc failed!\n&quot;);</div><div class="line">    return ERROR;</div><div class="line">&#125;</div><div class="line"></div><div class="line">(*L)-&gt;data=1;</div><div class="line">(*L)-&gt;next=NULL;</div><div class="line">(*L)-&gt;prev=NULL;</div><div class="line">for(int i=1;i&lt;=n;i++)</div><div class="line">&#123;</div><div class="line">    int e=rand()%100+1;</div><div class="line">    ListInsert(L, i, e);</div><div class="line">&#125;</div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void ListPrint(LinkList L)</div><div class="line">&#123;</div><div class="line">LinkList seek=L-&gt;next;</div><div class="line">printf(&quot;new list :&quot;);</div><div class="line">while(seek)</div><div class="line">&#123;</div><div class="line">    printf(&quot;%d &quot;,seek-&gt;data);</div><div class="line">    seek=seek-&gt;next;</div><div class="line">&#125;</div><div class="line">printf(&quot;\n\n&quot;);</div><div class="line">return;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status GetElem(LinkList L,int i,ElemType * pe)</div><div class="line">&#123;</div><div class="line">LinkList seek=L-&gt;next;</div><div class="line">if(i&lt;1||i&gt;L-&gt;data)</div><div class="line">&#123;</div><div class="line">    printf(&quot;GetElem failed!\n&quot;);</div><div class="line">    return ERROR;</div><div class="line">&#125;</div><div class="line"></div><div class="line">for(int k=1;k&lt;i;k++)</div><div class="line">    seek=seek-&gt;next;</div><div class="line">*pe=seek-&gt;data;</div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">Status GetPrevElem(LinkList tmp,ElemType * pe)</div><div class="line">&#123;</div><div class="line">*pe=tmp-&gt;prev-&gt;data;</div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">Status ListInsert(LinkList *L,int i,ElemType e)</div><div class="line">&#123;</div><div class="line">int k=1;</div><div class="line">LinkList seek=(*L);</div><div class="line">if(i&lt;1||i&gt;(*L)-&gt;data)</div><div class="line">&#123;</div><div class="line">    printf(&quot;ListInsert failed!\n&quot;);</div><div class="line">    return ERROR;</div><div class="line">&#125;</div><div class="line"></div><div class="line">while(k&lt;i)</div><div class="line">&#123;</div><div class="line">    seek=seek-&gt;next;</div><div class="line">    k++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">LinkList tmp=(LinkList)malloc(sizeof(struct Node));</div><div class="line">tmp-&gt;data=rand()%100+1;</div><div class="line">tmp-&gt;next=seek-&gt;next;</div><div class="line">tmp-&gt;prev=seek;</div><div class="line">seek-&gt;next=tmp;</div><div class="line">(*L)-&gt;data++;</div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status ListDelete(LinkList *L,int i,ElemType * pe)</div><div class="line">&#123;</div><div class="line">LinkList seek=(*L)-&gt;next;</div><div class="line">if(i&lt;1||i&gt;(*L)-&gt;data)</div><div class="line">&#123;</div><div class="line">    printf(&quot;ListDeletet failed!\n&quot;);</div><div class="line">    return ERROR;</div><div class="line">&#125;</div><div class="line"></div><div class="line">for(int k=1;k&lt;i-1;k++)</div><div class="line">    seek=seek-&gt;next;</div><div class="line"></div><div class="line">LinkList tmp=seek-&gt;next;</div><div class="line">seek-&gt;next=tmp-&gt;next;</div><div class="line">free(tmp);</div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status ListClear(LinkList *L)</div><div class="line">&#123;</div><div class="line">LinkList seek=(*L)-&gt;next;</div><div class="line">LinkList tmp;</div><div class="line">while(seek)</div><div class="line">&#123;</div><div class="line">    tmp=seek;</div><div class="line">    seek=seek-&gt;next;</div><div class="line">    free(tmp);</div><div class="line">&#125;</div><div class="line">(*L)-&gt;next=NULL;</div><div class="line">(*L)-&gt;data=1;</div><div class="line">return OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="循环双链表"><a href="#循环双链表" class="headerlink" title="循环双链表"></a>循环双链表</h2><p>具有双指针的环状链表<br>这里的几种链表的实现代码其实并没有太大区别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include&lt;time.h&gt;</div><div class="line">#define OK 1</div><div class="line">#define ERROR 0</div><div class="line">typedef int ElemType;</div><div class="line">typedef int Status;</div><div class="line">typedef struct Node</div><div class="line">&#123;</div><div class="line">ElemType data;</div><div class="line">struct Node * prev;</div><div class="line">struct Node * next;</div><div class="line">&#125;Node;</div><div class="line">typedef struct Node * LinkList;</div><div class="line">Status ListInit(LinkList * L,int n);</div><div class="line">void ListPrint(LinkList L);</div><div class="line">Status GetElem(LinkList L,int i,ElemType * pe);</div><div class="line">Status GetPrevElem(LinkList tmp,ElemType * pe);</div><div class="line">Status ListInsert(LinkList *L,int i,ElemType e);</div><div class="line">Status ListDelete(LinkList *L,int i,ElemType * pe);</div><div class="line">Status ListClear(LinkList *L);</div><div class="line"> </div><div class="line">int</div><div class="line">main()</div><div class="line">&#123;  </div><div class="line"> LinkList L;</div><div class="line">srand(time(0));</div><div class="line">int n=rand()%10+1;</div><div class="line">int e,*pe=&amp;e;</div><div class="line"> </div><div class="line">//初始化链表</div><div class="line">//尾插法</div><div class="line">ListInit(&amp;L,n);</div><div class="line">ListPrint(L);</div><div class="line"> </div><div class="line">//读取节点数据</div><div class="line">printf(&quot;input number of node :&quot;);</div><div class="line">scanf(&quot;%d&quot;,&amp;n);</div><div class="line">GetElem(L, n, pe);</div><div class="line">printf(&quot;GetElem: %d\n\n&quot;,*pe);</div><div class="line"> </div><div class="line">//读取前一节点数据</div><div class="line">printf(&quot;input number of node :&quot;);</div><div class="line">scanf(&quot;%d&quot;,&amp;n);</div><div class="line">LinkList seek=L-&gt;next;</div><div class="line">for(int k=1;k&lt;=n;k++)</div><div class="line">&#123;</div><div class="line">seek=seek-&gt;next;</div><div class="line">k++;</div><div class="line">&#125;</div><div class="line">GetPrevElem(seek, pe);</div><div class="line">printf(&quot;GetPrevElem: %d\n\n&quot;,*pe);</div><div class="line"> </div><div class="line">//删除节点数据</div><div class="line">printf(&quot;input number of node to delete :&quot;);</div><div class="line">scanf(&quot;%d&quot;,&amp;n);</div><div class="line">ListDelete(&amp;L, n, pe);</div><div class="line">ListPrint(L);</div><div class="line"> </div><div class="line">//清空链表</div><div class="line">ListClear(&amp;L);</div><div class="line">printf(&quot;ListClear \n&quot;);</div><div class="line">ListPrint(L);</div><div class="line">   </div><div class="line">printf(&quot;done!\n\n&quot;);</div><div class="line"></div><div class="line">return 0;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">Status ListInit(LinkList * L,int n)</div><div class="line">&#123;</div><div class="line">(*L)=(LinkList)malloc(sizeof(Node));</div><div class="line">if(!*L)</div><div class="line">&#123;</div><div class="line">printf(&quot;malloc failed!\n&quot;);</div><div class="line">return ERROR;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">(*L)-&gt;data=1;</div><div class="line">(*L)-&gt;next=(*L);</div><div class="line">(*L)-&gt;prev=(*L);</div><div class="line">LinkList new,tail;</div><div class="line">tail=(*L);</div><div class="line"> </div><div class="line">for(int i=1;i&lt;=n;i++)</div><div class="line"> &#123;</div><div class="line"> int e=rand()%100+1;</div><div class="line"> new=(LinkList)malloc(sizeof(Node));</div><div class="line"> new-&gt;data=e;</div><div class="line"> </div><div class="line"> tail-&gt;next=new;</div><div class="line"> new-&gt;prev=tail;</div><div class="line"> new-&gt;next=(*L);</div><div class="line"> (*L)-&gt;prev=new;</div><div class="line"> tail=new;</div><div class="line"> (*L)-&gt;data++;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">void ListPrint(LinkList L)</div><div class="line">&#123;</div><div class="line">LinkList seek=L-&gt;next;</div><div class="line">printf(&quot;new list :&quot;);</div><div class="line">while(seek!=L)</div><div class="line">&#123;</div><div class="line">printf(&quot;%d &quot;,seek-&gt;data);</div><div class="line">seek=seek-&gt;next;</div><div class="line">&#125;</div><div class="line">printf(&quot;\n\n&quot;);</div><div class="line">return;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"> </div><div class="line">Status GetElem(LinkList L,int i,ElemType * pe)</div><div class="line">&#123;</div><div class="line">LinkList seek=L-&gt;next;</div><div class="line">if(i&lt;1||i&gt;L-&gt;data)</div><div class="line">&#123;</div><div class="line">printf(&quot;GetElem failed!\n&quot;);</div><div class="line">return ERROR;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">for(int k=1;k&lt;i;k++)</div><div class="line">seek=seek-&gt;next;</div><div class="line">*pe=seek-&gt;data;</div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">Status GetPrevElem(LinkList tmp,ElemType * pe)</div><div class="line">&#123;</div><div class="line">*pe=tmp-&gt;prev-&gt;data;</div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"> </div><div class="line">Status ListInsert(LinkList *L,int i,ElemType e)</div><div class="line">&#123;</div><div class="line">int k=1;</div><div class="line">LinkList seek=(*L);</div><div class="line">if(i&lt;1||i&gt;(*L)-&gt;data)</div><div class="line">&#123;</div><div class="line">printf(&quot;ListInsert failed!\n&quot;);</div><div class="line">return ERROR;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">while(k&lt;i)</div><div class="line">&#123;</div><div class="line">seek=seek-&gt;next;</div><div class="line">k++;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">LinkList tmp=(LinkList)malloc(sizeof(struct Node));</div><div class="line">tmp-&gt;data=rand()%100+1;</div><div class="line">tmp-&gt;next=seek-&gt;next;</div><div class="line">tmp-&gt;prev=seek;</div><div class="line">seek-&gt;next=tmp;</div><div class="line">(*L)-&gt;data++;</div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">Status ListDelete(LinkList *L,int i,ElemType * pe)</div><div class="line">&#123;</div><div class="line">LinkList seek=(*L)-&gt;next;</div><div class="line">if(i&lt;1||i&gt;(*L)-&gt;data)</div><div class="line">&#123;</div><div class="line">printf(&quot;ListDeletet failed!\n&quot;);</div><div class="line">return ERROR;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">for(int k=1;k&lt;i-1;k++)</div><div class="line">seek=seek-&gt;next;</div><div class="line"> </div><div class="line">LinkList tmp=seek-&gt;next;</div><div class="line">seek-&gt;next=tmp-&gt;next;</div><div class="line">free(tmp);</div><div class="line">(*L)-&gt;data--;</div><div class="line"> </div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">Status ListClear(LinkList *L)</div><div class="line">&#123;</div><div class="line">LinkList seek=(*L)-&gt;next;</div><div class="line">LinkList tmp;</div><div class="line">while(seek!=(*L))</div><div class="line">&#123;</div><div class="line">tmp=seek;</div><div class="line">seek=seek-&gt;next;</div><div class="line">free(tmp);</div><div class="line">&#125;</div><div class="line">(*L)-&gt;next=(*L);</div><div class="line">(*L)-&gt;prev=(*L);</div><div class="line">(*L)-&gt;data=1;</div><div class="line"> </div><div class="line">return OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h2><p>栈是限定仅在表尾进行插入和删除操作的线性表<br>顺序存储结构的栈简称顺序栈</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include&lt;time.h&gt;</div><div class="line">#define OK 1</div><div class="line">#define ERROR 0</div><div class="line">#define MAXSIZE 30</div><div class="line">typedef int SElemType;</div><div class="line">typedef int Status;</div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">SElemType data[MAXSIZE];</div><div class="line">int top;</div><div class="line">&#125;SqStack;</div><div class="line"></div><div class="line">void StackPrint(SqStack *sp);</div><div class="line">Status Push(SqStack *sp,SElemType e);</div><div class="line">Status Pop(SqStack *sp,SElemType * ep);</div><div class="line"></div><div class="line">int</div><div class="line">main(void)</div><div class="line">&#123;</div><div class="line">int i,e,k,*ep=&amp;e;</div><div class="line">SqStack S;</div><div class="line">SqStack *sp=&amp;S;</div><div class="line">srand(time(0));</div><div class="line"></div><div class="line">//初始化随机栈</div><div class="line">i=rand()%10;</div><div class="line">S.top=i;</div><div class="line">for(k=0;k&lt;=i;k++)</div><div class="line">    S.data[k]=rand()%100+1;</div><div class="line">StackPrint(sp);</div><div class="line"></div><div class="line">//进栈操作</div><div class="line">e=rand()%100+1;</div><div class="line">Push(sp,e);</div><div class="line">StackPrint(sp);</div><div class="line"></div><div class="line">//出栈操作</div><div class="line">Pop(sp,ep);</div><div class="line">StackPrint(sp);</div><div class="line"></div><div class="line">printf(&quot;done !\n\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void StackPrint(SqStack * sp)</div><div class="line">&#123;</div><div class="line">printf(&quot;new list: &quot;);</div><div class="line">for(int i=0;i&lt;=sp-&gt;top;i++)</div><div class="line">    printf(&quot;%d &quot;,sp-&gt;data[i]);</div><div class="line">printf(&quot;\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status Push(SqStack *sp,SElemType e)</div><div class="line">&#123;</div><div class="line">if(sp-&gt;top==MAXSIZE-1)</div><div class="line">&#123;</div><div class="line">    printf(&quot;Push Failed\n&quot;);</div><div class="line">    return ERROR;</div><div class="line">&#125;</div><div class="line">sp-&gt;top++;</div><div class="line">sp-&gt;data[sp-&gt;top]=e;</div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line">   </div><div class="line">Status Pop(SqStack *sp,SElemType * ep)</div><div class="line">&#123;</div><div class="line">if(sp-&gt;top==-1)</div><div class="line">&#123;</div><div class="line">    printf(&quot;Pop Failed\n&quot;);</div><div class="line">    return ERROR;</div><div class="line">&#125;</div><div class="line">*ep=sp-&gt;data[sp-&gt;top];</div><div class="line">sp-&gt;top--;</div><div class="line">return OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>栈的其它几种结构以及进一步操作看上一篇</p>
]]></content>
      
        <categories>
            
            <category> 代码 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Core Java 笔记]]></title>
      <url>/2017/01/11/JavaCore/</url>
      <content type="html"><![CDATA[<hr>
<a id="more"></a>
<h1 id="Core-Java-卷-1"><a href="#Core-Java-卷-1" class="headerlink" title="Core Java 卷 1"></a>Core Java 卷 1</h1><p><strong>（待续…）</strong></p>
<h2 id="第四章：类与对象"><a href="#第四章：类与对象" class="headerlink" title="第四章：类与对象"></a>第四章：类与对象</h2><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><ul>
<li>构造器与类同名</li>
<li>每个类可能有一个以上的构造器</li>
<li>构造器可以有0或多个参数</li>
<li><p>构造器没有返回值</p>
</li>
<li><p>构造器总是伴随着new操作一起调用</p>
</li>
<li>不要在构造器中定义与实例域重名的局部变量</li>
<li>仅当没有编写构造器时，系统才会提供一个无参构造器将实例域设置为默认</li>
<li>构造器的第一个语句若形如this（…），将调用同一个类的另一个构造器，可以重用代码</li>
</ul>
<h3 id="访问器"><a href="#访问器" class="headerlink" title="访问器"></a>访问器</h3><pre><code>public String getName()
{
    return name;
}
</code></pre><ul>
<li>访问器只返回实例域值</li>
<li>一个方法可以访问所属类的所有对象的私有数据</li>
<li>注意不要编写返回引用可变对象的访问器方法</li>
</ul>
<h3 id="域"><a href="#域" class="headerlink" title="域"></a>域</h3><ul>
<li>在实现一个类时，应该将所有的数据域都设为私有</li>
<li>获得和设置实例域的值，应提供私有的数据域，公有的访问器，公有的域更改器</li>
<li>每个对象的实例域都有一份自己的拷贝，每个类只有一个static静态域，静态域属于类而非对象</li>
<li>public static final double PI ， 用这种方法定义一个常量</li>
<li>初始化块</li>
</ul>
<pre><code>class Employee
{
private static int nextId；
private int id；
private String name；
{
id = nextId;
nextId++;
}
}
</code></pre><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li>java总是按值传递，方法得到的是参数的拷贝</li>
<li>方法不能修改一个基本数据类型的参数，但可以修改对象参数的状态</li>
<li>方法不能让对象参数引用一个新的对象</li>
<li>java允许重载任何方法，但返回类型不是方法签名的一部分，不能单独修改</li>
<li>参数变量会把同名的实例域屏蔽，用this.* 可以解除屏蔽<br>this.name=name</li>
<li>某个资源需要在使用完后立刻被关闭，应该使用close完成清理操作</li>
</ul>
<h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><ul>
<li>使用包的目的：组织自己的代码，方便与别人的代码库分开管理；确保类名唯一性</li>
<li>使用import或者类全名来引用各个包中的类 ,使用package将一个类放入包中</li>
<li>为实现类名的唯一性，通常将因特网域名以逆序的形式作为包名，如com.abc.efg</li>
<li>从编译器的角度来看，嵌套的包之间没有任何关系，例如java.util和java.util.jar</li>
<li><p>如果类名冲突</p>
<pre><code>import java.util.*;
import java.sql.*;
import java.util.Date;//指明选定的类
</code></pre></li>
<li><p>引入静态方法和静态域<br>import static java.lang,System.*;</p>
</li>
</ul>
<h3 id="类设计技巧"><a href="#类设计技巧" class="headerlink" title="类设计技巧"></a>类设计技巧</h3><ul>
<li>一定要保证数据私有</li>
<li>一定要对数据初始化</li>
<li>不要在类中使用过多的基本类型，用其他类去代替他们</li>
<li>将指责过多的类分解</li>
<li>类名和方法名要能够体现它们的职责</li>
<li>优先使用不可变的类</li>
</ul>
<h2 id="第五章：继承"><a href="#第五章：继承" class="headerlink" title="第五章：继承"></a>第五章：继承</h2><h3 id="is-a-关系"><a href="#is-a-关系" class="headerlink" title="is-a 关系"></a>is-a 关系</h3><ul>
<li>is-a 关系是继承的一个明显特征：它表明子类的每一个对象也是超类</li>
<li>is-a 规则的另一种表述法是置换法则：它表明程序中出现超类对象的任何地方都可以用子类对象置换</li>
</ul>
<h3 id="子类"><a href="#子类" class="headerlink" title="子类"></a>子类</h3><pre><code>public class Manager extends Employee
{
    添加方法和域
}
</code></pre><ul>
<li><p>子类的方法必须通过公有的接口（访问器）才能访问父类定义的私有域</p>
<pre><code>super.getSalary()
</code></pre></li>
<li><p>子类构造器：子类必须利用父类的构造器对父类的私有域进行初始化，如果没有显式的调用超类的构造器，则自动调用超类的默认无参构造器，若该构造器不存在则报错</p>
<pre><code>public Manager(String name,double salary,int  year,int mouth,int day)
{ 
  super(name l,salary,year,month,day);
 bonus=0;
 }
</code></pre></li>
<li>子类引用类型不能指向父类，  超类数组引用可以被赋予子类数组</li>
<li>用final阻止某类被继承，或某方法被覆盖</li>
</ul>
<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><ul>
<li>使用类型转换的唯一原因：使用对象的全部功能</li>
<li>在进行类型转换时先查看是否能成功地转换，否则可能产生编译错误<pre><code>  if(staff[1] instanceof Manager)
{
    boss = (Manager)staff[1];
}
</code></pre></li>
<li>只能在继承层次内进行类型转换</li>
<li>一般情况下应少用类型转换</li>
</ul>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ul>
<li>为了提高程序的清晰度，包含一个或多个抽象方法的类本身必须被声明为抽象</li>
<li>抽象类可以有具体的域和方法</li>
<li><p>抽象类不能被实例化，但可以有构造器给子类调用</p>
<pre><code>public abstract class Person
{
        private String name;
        public Person(String name)
        {
        this.name =name;
        }

        public abstract String getDescription();

        public String getName()
        {
            return name;
        }
}
</code></pre></li>
<li><p>扩展抽象类时定义部分或者不定义抽象方法，就必须把子类标记为抽象;定义全部抽象方法，则子类不再抽象</p>
</li>
<li>抽象类的非抽象方法可用不重写</li>
<li>可以定义一个抽象类的引用对象，但它只能引用非抽象子类的对象（多态）<h3 id="受保护访问"><a href="#受保护访问" class="headerlink" title="受保护访问"></a>受保护访问</h3></li>
<li>protected让类对本包和所有子类可见</li>
<li>prtected允许方法或域被子类访问</li>
</ul>
<h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><ul>
<li>Object类是所有类的超类，可以利用Object类的引用对象引用任何类的实例</li>
<li>java中只有基本类型不是对象</li>
<li>Oject类中，equals方法用于检测引用的相等性，然而许多类重写了equals方法，使其用来检测状态的相等性</li>
<li>如果在子类中重新定义equals，一般要包含调用super.equals（other）</li>
<li>hashCode方法，是由对象导出的一个整形值，Objec类的hashCode方法导出对象的存储地址，可以调用hash方法重写hashCode使根据内容导出</li>
<li>重写equals方法就要重写hashCod方法</li>
<li>toString方法，用于返回对象值的字符串</li>
</ul>
<h2 id="第六章-接口与内部类"><a href="#第六章-接口与内部类" class="headerlink" title="第六章 接口与内部类"></a>第六章 接口与内部类</h2><h3 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口 interface"></a>接口 interface</h3><ul>
<li>接口不是类，而是对类的一组需求描述，不能使用new来实例化</li>
<li>接口中的所有方法自动地属于public，所有域自动属于public static final，因此接口中的方法不必特地声明这些关键字</li>
<li>提供实例域和方法实现的任务应该由实现接口的那个类来完成</li>
<li><p>实现一个接口要在声明时使用关键字implement以及定义接口中的所有方法，一个类可以声明多个接口</p>
<pre><code>class Employe implements Cloneable,Comparable
</code></pre></li>
<li><p>可以用instanceof检查对象是否实现了某个特定的接口</p>
<pre><code>if(anObject instanceof Comparable)
//使用sort方法的对象必须实现这个接口，实现这个接口必须实现compareTo方法
</code></pre></li>
<li><p>与建立类的继承关系一样，接口也可以被扩展</p>
<pre><code>public interface Power extends Moveable
{
    double milesPerGallon;
    double SPEED_LIMIT=95;
}
</code></pre></li>
<li>有些接口只定义了常量，实现它们的类自动继承这些常量，但这种用法似乎偏离了接口设计的初衷，最好不要使用</li>
</ul>
<p><strong>第十版中新增的lambda表达式、静态方法、默认方法和对象克隆暂时略过</strong></p>
<h3 id="内部类-inner-class"><a href="#内部类-inner-class" class="headerlink" title="内部类 inner class"></a>内部类 inner class</h3><ul>
<li>内部类是一个定义在另一个类中的类</li>
<li>内部类，可以访问外部类的所有数据；可以对同一个包的其他类隐藏；可以用匿名内部类减小代码量</li>
<li>内部类中所有的静态域都必须是final</li>
<li>局部内部类，声明在方法中，可以访问外部类的域和局部变量，但局部变量必须是final</li>
<li><p>匿名内部类，在创造实例的时候定义，可以临时实现一个接口，也可以扩展一个类，这样的新类自然没有类名，也就没有构造器，但参数会传给父类的构造器</p>
<pre><code>new SuperType(construction parameter)
{
    inner class methods and data
    // SuperType可以是接口，也可以是类

}
</code></pre></li>
<li>静态内部类，内部类不需要引用外部对象时将其声明为static，静态内部类可以有静态域和方法</li>
<li>声明在接口中的内部类自动称为static和public</li>
</ul>
<h2 id="第七章-异常、断言和日志"><a href="#第七章-异常、断言和日志" class="headerlink" title="第七章 异常、断言和日志"></a>第七章 异常、断言和日志</h2><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><ul>
<li>某个方法不能够采取正常的途径完成任务，就可以通过抛出一个封装了错误信息的对象退出方法，此时方法不会返回任何值</li>
<li>异常对象都是派生于throwable类的一个实例</li>
<li>运行时异常，RumtimeException，包括：错误的类型转换，数组访问越界，访问null指针<blockquote>
<p>“如果出现RumtimeException，那么就一定是你的问题。”</p>
</blockquote>
</li>
<li>输入输出异常，IOException，包括：试图在文件尾部后面读取数据，试图打开一个不存在的文件，试图根据给定的字符串查找不存在的class对象等等</li>
<li>自己编写方法时不必声明所有抛出的异常，但必须声明所有可能抛出的受查异常，如果没有声明所有的受查异常，编译器将报错</li>
<li>如果一个方法声明将会抛出一个特定类型的异常，那么结果它可能抛出这个类型或其子类的异常</li>
<li>抛出已存在异常类的步骤：找到一个合适的异常类，创造这个类的一个对象，将对象抛出  <pre><code>String readData(Scanner in)throws EOFException
{
...
while(...)
{
    if(!in.hasNext())
    {
    if(n&lt;len)
    throw new EOFException();
    }
}
}
</code></pre></li>
<li><p>创建异常类：定义一个派生于Exception或其子类的类，该类应该包含两个构造器：一个为默认构造器，另一个为带有详细信息的构造器，超类Throwable的toString方法会打印出这些详细信息，e.getMessage可以得到错误信息</p>
<pre><code>Class FileFormatException extends IOException
{
    public FileFormatException(){}
    public FileFormatException(String gripe)
    {
        super(gripe);
    }
}
</code></pre><h3 id="异常语块"><a href="#异常语块" class="headerlink" title="异常语块"></a>异常语块</h3></li>
<li>使用try/catch语块，如果try中的任何代码抛出了catch说明的异常类，那么try中剩余的语句将被跳过，执行catch中的处理器代码<pre><code>try
{
    code
    more code
    more code
}
catch(ExceptionType e)
{
    handler for this type
}
catch(ExceptionType2 e)
{
    handler for this type
}
catch(ExceptionType3 e)
{
    handler for this type
}
</code></pre></li>
</ul>
<ul>
<li>最好的办法是方法只抛出异常，然后什么也不做，由调用者去处理，而不是尝试在方法中解决问题，唯一的例外是如果覆盖了超类的一个没有异常的方法，就必须捕获每一个异常</li>
<li><p>解决过程相同时可以捕获多个异常，但这些异常不能存在子类关系</p>
<pre><code>catch(FileNotFoundException|EOFException e)
</code></pre></li>
<li><p>包装异常，catch字句可以再次抛出一个异常，当要抛出更高级的异常时建议使用包装的技巧</p>
<pre><code>try
{
    access the database
}
catch(SQLException)
{
    Throwable se = new ServletException(&quot;database error&quot;);
    se.initCause(e);
    throw se; 
}

...
Throwable e=se.getCause();
...
</code></pre></li>
<li><p>finally 字句，不管是否有异常被捕获，finally字句中的代码都会被执行，try语句可以只有finally字句而没有catch字句</p>
<pre><code>InputStream in = new FileInputStream(...);
try
{
    code that might throw exception
}
catch(IOException)
{
    show error message
}
finally
{
    in.close
}
</code></pre></li>
<li>当利用return语句在try中退出时，finally字句中的内容将被执行，如果finally语句中含有return，返回值将被后者覆盖</li>
<li>带资源的try语句，假设资源属于一个实现了AutoCloseable接口的类，try块退出时会自动调用声明了异常的close方法，因此用于关闭资源的finally语句可以省略，另外可以指定多个资源<pre><code>try(Resoure res = ...)
{
        work with res
}
</code></pre></li>
</ul>
<hr>
<pre><code>try(Scanner in = new Scanner(new FileInputStream(&quot;/usr/share/dict/words&quot;),&quot;UTF-8&quot;);
PrintWriter out = new PrintWriter(&quot;out.txt&quot;))
{
    while(in.hasNext())
        out.println(in.next().toUpperCase());
}
</code></pre><ul>
<li>堆栈轨迹 <strong>(待续…)</strong></li>
</ul>
<h3 id="使用异常机制的技巧"><a href="#使用异常机制的技巧" class="headerlink" title="使用异常机制的技巧"></a>使用异常机制的技巧</h3><ul>
<li>异常处理不能代替简单的if测试，这样会会花费更多运行时间</li>
<li>不要过分细化异常，与其反复使用try-catch，不如让一个try语块捕获多个异常</li>
<li>利用异常的结构层次：不要只抛出RuntimeException异常，应该寻找更加适当的子类或者创建自己的异常类；不要只捕获Thowable异常，否则代码会更难读、更难维护</li>
<li>不要压制异常</li>
<li>有时传递异常比捕获异常更有必要</li>
</ul>
<h3 id="使用断言-assert"><a href="#使用断言-assert" class="headerlink" title="使用断言 assert"></a>使用断言 assert</h3><ul>
<li>开启与禁用断言，默认关闭，在运行程序时使用-ea选项启用</li>
<li>断言机制允许在测试期间向代码插入一段检查语句，当代码发布时，这些插入的检查语句会被自动移走</li>
<li>断言失败是致命的，不可恢复的错误；断言只用于开发和检查阶段<blockquote>
<p>“在靠近海岸时穿上救生衣，但在海中央时就把救生衣抛掉吧”</p>
</blockquote>
</li>
<li>断言的两种形式：assert 条件；  assert 条件：表达式；</li>
<li>表达式的值可以传入AssertionError的构造器转换成消息字符串显示出来</li>
</ul>
<h3 id="记录日志"><a href="#记录日志" class="headerlink" title="记录日志"></a>记录日志</h3><p><strong>Java自带的log工具已不再流行，取而代之的应该是用log4j，暂时先只学习自带log的用法</strong><br>*</p>
<pre><code>...     
log = Logger.getLogger(&quot;aLog&quot;);
//新建日志对象
log.setLevel(Level.INFO);
try{
    ConsoleHandler consoleHandler = new ConsoleHandler();
    consoleHandler.setLevel(Level.ALL);
    log.addHandler(consoleHandler);
    //ConsoleHandler 向控制台发送日志消息
    FileHandler fileHandler = new FileHandler(&quot;/Users/alberthumbert/Desktop/log.text&quot;);
    log.addHandler(fileHandler);
    //FileHandler 将日志消息发送到指定文件中
    }catch(IOException e){}

log.info(&quot;test&quot;);
//发送消息
</code></pre><h2 id="第八章-泛型程序设计"><a href="#第八章-泛型程序设计" class="headerlink" title="第八章 泛型程序设计"></a>第八章 泛型程序设计</h2><p><small><br>在泛型之前，如ArrayList的类只维护一个object类的数组，当获取一个值时必须进行强制类型转换，加入对象时也没有错误检查，而后泛型提供了很好的解决方案：参数化类型<br></small></p>
<blockquote>
<p>“泛型的魅力在于，使程序具有更好的可读性和安全性”</p>
</blockquote>
<h3 id="定义简单泛型类"><a href="#定义简单泛型类" class="headerlink" title="定义简单泛型类"></a>定义简单泛型类</h3><ul>
<li><p>一个泛型类就是具有一个或多个类型变量的类</p>
<pre><code>public class Pair&lt;T&gt;
{   //或者public class Pair&lt;T,U&gt;

    private T first;
    private T second;

    public Pair()
    { first = null ; second = nulll;    }
    public Pair( T first , T second )
    {   this.first = first; this.second =second; }

    public T getFirst(){ return first; }
    public T getSecond(){ return second; }

    public void setFirst( T newValue){ first = newValue ; }
    public void setSecond( T newValue){ Second = newValue ; }
</code></pre></li>
</ul>
<pre><code>}
</code></pre><ul>
<li>类型变量使用大写形式，且比较短，java库中变量E表示集合的元素类型，K和V分别表示表的关键字与值的类型。T、U、S等表示“任意类型”，用具体的类型替换类型变量就可以实例化泛型类型，如Pair<string></string></li>
</ul>
<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><ul>
<li><p>泛型方法可以定义在普通类中也可以定义在泛型类中，类型变量放在修饰符的后面，返回类型的前面</p>
<pre><code>class ArrayAlg
{
    public static &lt;T&gt; T getMiddle(T ... a)
    //省略号表示可变参数，用数组包裹
    {
        return a[a.length/2];
    }
}

...
String middle = ArrayAlg.&lt;String&gt;getMiddle(&quot;John&quot;,&quot;Q&quot;,&quot;Public&quot;);
...
</code></pre></li>
<li><p>在大多数情况下泛型方法可以省去泛型变量，参数给了编译器足够的信息进行判断</p>
</li>
</ul>
<h3 id="类型变量的限定"><a href="#类型变量的限定" class="headerlink" title="类型变量的限定"></a>类型变量的限定</h3><ul>
<li>有时要确信所属的类具有特定的IS-A关系，可以使用限定变量类型<pre><code>public static &lt; T extends Comparable &gt; T min( T[] a)
{
    code for someting...
}
</code></pre></li>
<li>类型变量和绑定类型可以是类也可以是接口，都使用extends关键字</li>
<li>一个类型变量或通配符可以有多个限定，如果用作为限定，它一定是列表中的第一个<pre><code>T extends Comparable &amp; Serializable
</code></pre>* </li>
</ul>
<p><strong>(待续…)</strong></p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h3><ul>
<li>以队列为例，每一个队列的实现都可以通过一个实现了Queue接口的类来表示</li>
<li>可以直接调用实现了集合接口的类，如ArrayDeque、LinkedList等</li>
<li><p>集合的基本接口是Collection和Map，Collection接口有两个基本方法，add方法用于添加元素，Iterator(迭代器)方法用于返回一个实现了Iterator接口的对象</p>
<pre><code>public interface Collection&lt;E&gt;
{   
        boolean add(E element);                                                                     Iterator&lt;E&gt; iterator();

}
</code></pre></li>
<li><p>迭代器，Iterator接口含有next方法和hasNext方法。想要查看集合中的每一个元素，就请求一个迭代器，在hasNext返回true时反复调用next方法，编译器将for each循环翻译为带有迭代器的循环，它可以与任何实现了Iterable接口的对象一起工作。Collection接口就扩展了Iterable接口</p>
</li>
</ul>
<h3 id="链表-LinkedList"><a href="#链表-LinkedList" class="headerlink" title="链表 LinkedList"></a>链表 LinkedList</h3><ul>
<li><p>在Java中所有链表其实都是双向链表，基本操作：  </p>
<pre><code>LinkedList&lt;String&gt; staff = new LinkedList&lt;String&gt;();
staff.add(&quot;amy&quot;);
staff.add(&quot;amy&quot;);
staff.add(&quot;amy&quot;);
staff.add(&quot;bob&quot;);
staff.add(&quot;carl&quot;);
//add方法把对象添加到尾部

Iterator&lt;String&gt; iter = staff.iterator();
//使用泛型避免强制转换
String first =  iter.next();
iter.remove();
//迭代器通常用于遍历容器
staff.remove(0);

String second = staff.get(1);
System.out.println(second);

for(String e:staff)
{
    System.out.println(e);

}
</code></pre></li>
<li>只有对自然有序的集合使用迭代器添加元素才有实际意义</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>ListIterator的迭代器的add和set都是在迭代器所在位置的前一个位置进行操作（实际上迭代器的位置应该理解为在两个元素之间），并且set会取代链表元素</li>
<li>不要用复数的迭代器同时遍历和结构性修改链表，那样会抛出异常，注意set不被视为结构性修改</li>
<li><p>链表不支持快速随机访问，它必定会从头开始查找，如果要用整数索引访问元素，通常不用链表，更不要写出下面这种效率极低的代码，请使用迭代器</p>
<pre><code>for（int i=0;i&lt;list.size;i++）
do something with list.get(i);
</code></pre></li>
<li>建议避免使用整数索引表示链表中位置的所有方法。如果需要对集合进行随机访问，请使用ArrayList</li>
<li>使用链表的唯一理由就是尽可能的减少在链表中间插入或删除元素所付出的代价，如果链表只有少数几个元素，完全可以使用ArrayList</li>
</ul>
<h3 id="数组列表-ArrayList"><a href="#数组列表-ArrayList" class="headerlink" title="数组列表 ArrayList"></a>数组列表 ArrayList</h3><ul>
<li>ArrayList封装了一个动态再分配的对象数组</li>
<li>在只使用一个线程， 或者不需要同步时使用ArrayList而非Vector，Vector的同步操作会耗费大量时间</li>
<li>使用索引的get和set方法对ArrayList类非常适用</li>
</ul>
<h3 id="散列集-hash-table"><a href="#散列集-hash-table" class="headerlink" title="散列集 hash table"></a>散列集 hash table</h3><ul>
<li>散列表可以快速地查找所需要的对象，它为每个对象准备一个散列码（整数），散列码是由对象实例域产生的一个整数，不同的数据域会有不同的散列码</li>
<li>在Java中，散列表用链表数组实现，每个链表被称为桶，对象的散列码与桶的总数取余所得到的就是对象的索引</li>
<li><p>散列表用语实现几种重要的数据结构，如HashSet类</p>
<pre><code>    public class SetText {
public static void main(String[] args)
{
Set&lt;String&gt; words =new HashSet&lt;String&gt;();
long totalTime = 0;
try(Scanner in = new Scanner(System.in))
{
    while(in.hasNext()){
    String word = in.next();
    if(word.equals(&quot;Q&quot;))break;
    long callTime = System.currentTimeMillis();
    words.add(word);
    callTime = System.currentTimeMillis()-callTime;
    totalTime += callTime;

    }
}

Iterator&lt;String&gt; iter = words.iterator();
for(int i=1;i&lt;=20&amp;&amp;iter.hasNext();i++)
System.out.println(iter.next());
System.out.println(&quot;...&quot;);
System.out.println(words.size()+&quot; words &quot;+totalTime+&quot; miliseconds.&quot;);

    }

}
</code></pre></li>
<li>散列集的迭代器只是依次访问所有桶，而元素的位置是随机的，所以只有不关心元素的顺序时才适用HashSet</li>
<li>contains方法用于快速查找某元素是否在集合中，它只在某个桶中查找元素，而不需要遍历整个集合</li>
<li>如果要自定义类就要负责实现这个类的散列码方法，并且让散列码方法与equals方法兼容</li>
</ul>
<h3 id="树集-TreeSet"><a href="#树集-TreeSet" class="headerlink" title="树集 TreeSet"></a>树集 TreeSet</h3><ul>
<li>树集是个有序集合，可以任意插入元素，每个元素将自动排序</li>
<li>树集添加元素比散列集要慢，但比算上检查重复的时间还是要比数组和链表快的</li>
<li>树集的任意两个元素必须可比，并且只有相等时才为0</li>
<li>通过使用一个定制的比较器来按照描述信息排序</li>
</ul>
<p><strong>(待续…)</strong></p>
<h3 id="队列-Quque"><a href="#队列-Quque" class="headerlink" title="队列 Quque"></a>队列 Quque</h3><ul>
<li>队列，可以在尾部添加元素，头部删除元素</li>
<li>双端队列，可以在头部和尾部同时添加或删除元素</li>
<li>优先级队列，可以按任意的顺序插入，却总是按排序检索，用自我调整的二叉树实现，添加和删除的元素会移动到根</li>
</ul>
<h3 id="映射-map"><a href="#映射-map" class="headerlink" title="映射 map"></a>映射 map</h3><ul>
<li><p>Java为映射提供了两个通用实现，HashMap和TreeMap，如果需要排序就使用TreeMap</p>
</li>
<li><p>每当往映射中添加对象时必须提供一个键，要检索对象时必须提供一个键, 如果在映射中没有给定键的对应信息，get返回null，也可以用getOrDefault (java 8) 方法将null修改为返回自定义的值</p>
</li>
</ul>
<pre><code>    Map&lt;String, Employee&gt; staff = new HashMap();
    // 这里的键是一个字符串
    Employee harry = new Employee(&quot;Harry Hacker&quot;);
    staff.put(&quot;987-98-9996&quot;,harry);

String id = &quot;987-98-9996&quot;;
e = staff.get(id);  

Map&lt;String, Integer&gt; scores=...;
int score = score.get(id , 0);
//若id不存在就返回0      
</code></pre><ul>
<li>对同一个键使用两次put方法，第二个值会代替第一个值，可以使用putIfAbsent (java 8) 方法，它只在原先键存在时才会放入一个值</li>
</ul>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><strong>(待续…)</strong></p>
<h2 id="第十-十二章-图形程序设计"><a href="#第十-十二章-图形程序设计" class="headerlink" title="第十 ~ 十二章 图形程序设计"></a>第十 ~ 十二章 图形程序设计</h2><h3 id="框架-JFrame"><a href="#框架-JFrame" class="headerlink" title="框架 JFrame"></a>框架 JFrame</h3><ul>
<li>顶层窗口（没有包含在其他窗口中的窗口）被称为框架</li>
<li>如果没有明确地指定框架的大小，所有的框架的默认值为0*0像素</li>
<li>JFrame有四层面板，程序员只用关心内容隔窗（content pane）</li>
<li>在1.4以后的版本中可以直接使用frame.add添加组件</li>
<li>使用ToolKit类得到本地窗口系统信息</li>
</ul>
<pre><code>class SizedFrame extends JFrame
{

public SizedFrame(){
Toolkit kit =Toolkit.getDefaultToolkit();
//Toolkit对象中有许多关于本地系统窗口的方法
//使用Toolkit有利于尺寸的兼容性
Dimension screenSize =kit.getScreenSize();
//这个方法会返回一个Dimension对象
//Dimension对象持有屏幕的尺寸
int screenHeight=screenSize.height;
int screenWidth=screenSize.width;

setSize(screenWidth/2,screenHeight/2);
//JFrame的setSize方法设置框架大小
setLocationByPlatform(true);
//该方法让窗口系统控制窗口位置
//通常会是距离最后一个窗口很少偏移量的位置

Image img =new ImageIcon(&quot;icon.gif&quot;).getImage();
//加载图标
setIconImage(img);
//设置标题栏图标

}
</code></pre><ul>
<li>新建一个框架，需要注意以下步骤<pre><code>JFrame frame = new SizedFrame();
frame.setTitle(&quot;SizedFrame&quot;);
//设置标题栏的文字frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    //定义关闭的响应动作
    frame.setVisible(true);
    //框架默认不可见，为了显示框架需要调用该方法
</code></pre></li>
</ul>
<h3 id="绘制组件"><a href="#绘制组件" class="headerlink" title="绘制组件"></a>绘制组件</h3><ul>
<li>绘制一个组件，需要定义一个扩展JComponent的类，并覆盖其中的paintComponent方法</li>
<li><p>paintComponent有一个Graphics类型的参数，它保存着用于绘制图形和文本的设置</p>
<pre><code>Class MyComponent extends JComponent
{
    public void paintComponent(Graphics g)
    {
        绘制的代码
    ｝
    ｝
</code></pre></li>
<li><p>一定不要自己调用paintComponent方法，这个方法将被系统在有需要的时候自动调用，程序员可以使用repaint方法刷新屏幕<br><strong>（待续…）</strong></p>
</li>
</ul>
<h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><ul>
<li>事件源是一个能够注册监听器对象并发出事件对象的对象</li>
<li>监听器对象是一个实现了特定监听器接口的类的实例</li>
<li>当事件发生时，事件源将事件对象传递给所有注册的监听器</li>
<li>监听器对象将利用事件对象中的信息决定如何对事件作出响应</li>
<li>事件相关的信息封装在一个事件对象中，所有的事件对象最终都派生于EventObject类</li>
<li><p>actionPerformed方法是ActionListener中唯一的方法，事件监听器对象通常需要执行一些对其他对象可能产生影响的操作，可以策略性地将监听器类放置在需要修改状态的那个类中</p>
<pre><code>class MyListener implements ActionListener
｛
...
public void actionPerformed（ActionEvent event）
{ 
//实现ActionListener接口，监听类必须有一个actionPerformed方法

            响应方法
}
}
</code></pre></li>
<li><p>使用匿名类可以相对简洁地定义监听类</p>
</li>
</ul>
<h3 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h3><ul>
<li>窗口监听类可以捕获窗口事件，但必须实现七个方法，为此，有一个窗口适配器实现了所有方法，但没有做任何事情</li>
<li><p>通过覆盖某一个方法扩展适配器的功能</p>
<pre><code>frame.addWindowListener(new WindowAdapter(){
//这便是一个匿名类
public void windowClosing(WindowEvent e)
{
if()....
}

})
</code></pre></li>
</ul>
<h3 id="动作和鼠标事件"><a href="#动作和鼠标事件" class="headerlink" title="动作和鼠标事件"></a>动作和鼠标事件</h3><p><strong>（待续…）</strong></p>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><ul>
<li>通常组件放在容器中，布局管理器决定容器中组件具体放置的位置和大小</li>
<li>按钮、文本域和其他用户界面元素都继承于Component类，组件可以放置在面板JPanel这样的容器中</li>
<li>JPanel默认使用流布局管理器，它完全控制每个组件的放置位置</li>
<li>JFrame默认使用边框布局管理器，它允许为每个组件选择一个位置（CENTER, NORTH,SOUTH,EAST,WEST），但可能会进行覆盖</li>
<li>使用panel.revalidate方法会重新计算所有组件的大小，然后立即重新布局</li>
</ul>
<h3 id="文本域-JTextField"><a href="#文本域-JTextField" class="headerlink" title="文本域 JTextField"></a>文本域 JTextField</h3><ul>
<li>文本域只能接受单行输入<pre><code>JPanel textPanel=new JPanel();
JTextField textField = new JTextField(&quot;default input&quot;,20);
//设置初始输入和显示长度
textPanel.add(textField);
frame.add(textPanel,BorderLayout.SOUTH);
textField.setClumns(10);
//设置长度
textPanel.revalidate;
String text = textField.getText.trim();
//trim方法取出前后多余的空格
</code></pre></li>
<li>在监听器中使用getText方法可以获取输入的文本</li>
</ul>
<h3 id="标签-JLabel"><a href="#标签-JLabel" class="headerlink" title="标签 JLabel"></a>标签 JLabel</h3><ul>
<li><p>标签是容纳文本的组件，它没有任何装饰，也不响应用户输入，但可以用来标示各种组件</p>
<pre><code>JLabel label = new JLabel(&quot;user name :&quot;,SwingContants.Right);
</code></pre></li>
<li><p>标签实现了SwingContants接口，接口中定义了几个指定排列方式的常量，因此可以制定标签的对齐方式</p>
</li>
<li>标签支持HTML语法</li>
</ul>
<h3 id="文本区-JTextArea"><a href="#文本区-JTextArea" class="headerlink" title="文本区 JTextArea"></a>文本区 JTextArea</h3><ul>
<li>文本区支持多行输入</li>
<li>文本区不限制输入的行数列数，设置参数只会影响显示的状态</li>
<li><p>如果文本超出显示范围，剩下的文本会被裁掉，通过开启换行可以避免这种状况</p>
<pre><code>JTextArea textArea = new JTextArea(8,40);
//设置显示大小
textArea.setLineWrap(true);
//开启自动换行
//建议将所有文本域放入滚动窗格之中
</code></pre></li>
</ul>
<h3 id="滚动窗格-JScrollPane"><a href="#滚动窗格-JScrollPane" class="headerlink" title="滚动窗格 JScrollPane"></a>滚动窗格 JScrollPane</h3><ul>
<li>这是一种为任意组件添加滚动功能的机制，不是文本区特有</li>
<li><p>滚动条会自动出现自动消失，无需另外编写程序</p>
<pre><code>JScrollPane scrollPane = new JScrollPane(textArea);
frame.add(scrollPane,BorderLayout.CENTER);
</code></pre></li>
</ul>
<h3 id="复选框-JCheckBox"><a href="#复选框-JCheckBox" class="headerlink" title="复选框 JCheckBox"></a>复选框 JCheckBox</h3><ul>
<li>用户点击复选框会激发一个事件</li>
<li>通常为多个复选框选定共同的监听器</li>
<li><p>用isSelected方法获取复选框状态</p>
<pre><code>final JCheckBox checkBox1 = new  JCheckBox(&quot;1&quot;);
final JCheckBox checkBox2 = new  JCheckBox(&quot;2&quot;);
ActionListener boxListener = new ActionListener(){
    public void actionPerformed(ActionEvent event){
        if(checkBox1.isSelected())
            System.out.println(&quot;1&quot;);
        if(checkBox2.isSelected())
            System.out.println(&quot;2&quot;);
    }
};
</code></pre></li>
</ul>
<h3 id="单选钮-JRadioButton"><a href="#单选钮-JRadioButton" class="headerlink" title="单选钮 JRadioButton"></a>单选钮 JRadioButton</h3><ul>
<li>多个关联的单选框中只能有一个被选择</li>
<li>通常为同一组中的每个单选钮设置独立的监听器</li>
</ul>
<pre><code>JPanel radioBoxPanel = new JPanel();
ButtonGroup group = new ButtonGroup();

JRadioButton radioButton1 = new JRadioButton(&quot;1&quot;,false);
JRadioButton radioButton2 = new JRadioButton(&quot;2&quot;,true);
//设置单循钮名字和初始状态

group.add(radioButton1);
group.add(radioButton2);
//将关联的单选钮加入到同一个组中

radioBoxPanel.add(radioButton1);
radioBoxPanel.add(radioButton2);
//ButtonGroup不是一个组件不能直接放入容器
//应该将每个按钮分别放入

frame.add(radioBoxPanel, BorderLayout.WEST);
</code></pre><h3 id="边框-Border"><a href="#边框-Border" class="headerlink" title="边框 Border"></a>边框 Border</h3><ul>
<li>表框在视觉上划分区域范围，面板默认不提供这样的元素</li>
<li>可以在任何继承了JCompoent的组件上应用边框</li>
<li>调用BorderFactory的静态方法创建边框对象</li>
<li><p>某些边框只能通过个别构造器创造，具体情况查看文档</p>
<pre><code>Border etched = BorderFactory.createEtchedBorder();
Border titled = BorderFactory.createTitledBorder(etched,&quot;A Title&quot;);
scrollPane.setBorder(titled);
</code></pre></li>
</ul>
<h3 id="表格-JTable"><a href="#表格-JTable" class="headerlink" title="表格 JTable"></a>表格 JTable</h3><ul>
<li>建议使用容器读取表格</li>
<li>需要以表头和表数据共同创建表格</li>
<li><p>使用DefaultTableModel 可以更改表格状态，系统会自动刷新表格</p>
<pre><code>String[] columnNames = {&quot;letter&quot;,&quot;Dec&quot;,&quot;Hex&quot;};
Object[][] data =
{
{&quot;a&quot;, new Integer(97),&quot;0x61&quot;},
         {&quot;b&quot;, new Integer(98),&quot;0x62&quot;},
         {&quot;c&quot;, new Integer(99),&quot;0x63&quot;},
         {&quot;d&quot;, new Integer(100),&quot;0x64&quot;},
};

JTable table = new JTable(data, columnNames);
frame.add(table, BorderLayout.WEST);
</code></pre></li>
</ul>
<h2 id="十三章-部署Java应用程序"><a href="#十三章-部署Java应用程序" class="headerlink" title="十三章 部署Java应用程序"></a>十三章 部署Java应用程序</h2><p><strong>（待续…）</strong></p>
<h2 id="十四章-并发"><a href="#十四章-并发" class="headerlink" title="十四章 并发"></a>十四章 并发</h2><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p><strong>多线程程序在较低的层次上扩展类多任务的概念：一个程序同时执行多个任务，通常每一个任务称为一个线程</strong></p>
<ul>
<li><p>在一个单独的线程中执行一个简单的任务，需要将任务代码放到一个实现了Runnable接口的类的run方法中，然后用它的实例创建一个Thread对象并调用Thread的start方法启动线程</p>
<pre><code>class MyRunable implements Runable
{
    public void run()
    {
        task code
    }
}
...
Runnable r = new MyRunnable();
Thread t = new Thread(r);
t.start();
</code></pre></li>
<li><p>不要直接调用Thread类或Runnable对象的run方法，直接调用run方法只会执行同一个线程的中任务，而不会启动新线程，应该调用Thread.start</p>
</li>
</ul>
<h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><ul>
<li>新创建 new，用new创建一个新线程时，该线程还没有开始运行，它的状态是new</li>
<li>可运行 Runable，用start启动一个线程后，线程处于runnable状态，一个可运行的线程可能在运行也可能没有运行，这取决于操作系统给线程提供的运行时间</li>
<li>被阻塞 Blocked，一个线程获取一个内部的对象锁时，如果锁被其他线程持有，则进入阻塞状态，当所有其他线程释放该锁且调度器允许时，线程变成非阻塞状态</li>
<li>等待 Waiting，当线程等待另一个线程通知调度器一个条件时，它自己进入等待状态</li>
<li>计时等待 Timed Waiting，有几个方法有一个超时参数时，调用它们导致线程进入计时等待</li>
<li>被终止，Terminated，run方法正常退出自然死亡，一个没有捕获的异常终止了run方法而意外死亡</li>
</ul>
<h3 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h3><ul>
<li>线程优先级，每一个线程有一个优先级，默认情况一个线程继承它父类的优先级</li>
<li>用serPriority方法提高或降低任何一个线程的优先级</li>
<li>线程调度器首先选择优先级高的线程，但是线程的优先级最终依赖于系统，windows有七个优先级，Oracle为linux提供的虚拟机只有一个优先级</li>
<li>几个高优先级线程没有进入非活动状态时，低优先级线程可能永远都不执行</li>
</ul>
<h3 id="未捕获异常处理器"><a href="#未捕获异常处理器" class="headerlink" title="未捕获异常处理器"></a>未捕获异常处理器</h3><p><strong>（待续…）</strong></p>
<h1 id="Core-Java-卷-2"><a href="#Core-Java-卷-2" class="headerlink" title="Core Java 卷 2"></a>Core Java 卷 2</h1><h2 id="第一章-流与文件"><a href="#第一章-流与文件" class="headerlink" title="第一章 流与文件"></a>第一章 流与文件</h2><h3 id="流-Stream"><a href="#流-Stream" class="headerlink" title="流 Stream"></a>流 Stream</h3><ul>
<li>输入流，可以从中读入一个字节序列的对象；输出流，可以向其中写入一个字节序列的对象。这些字节序列的来源地和目的地可以是文件，而且通常是文件，也可以是网络链接，甚至是内存块</li>
<li>操作文件内容的主要有两大类：字节流、字符流，两类都分为输入和输出操作。在字节流中输出数据主要是使用OutputStream完成，输入使的是InputStream，在字符流中输出主要是使用Writer类完成，输入流主要使用Reader类完成</li>
<li>字节流在操作的时候本身是不会用到缓冲区（内存）的，是与文件本身直接操作的，而字符流在操作的时候是使用到缓冲区的</li>
<li>字节流在操作文件时，即使不关闭资源（close方法），文件也能输出，但是如果字符流不使用close方法的话，则不会输出任何内容，说明字符流用的是缓冲区，并且可以使用flush方法强制进行刷新缓冲区，这时才能在不close的情况下输出内容</li>
<li>完成流读写时应该通过调用close方法来关闭它，这个调用会释放掉十分有限的操作系统资源</li>
<li>完整的流家族，与c单一的FILE * 类型不同，java的流家族包含各种流类型，数量超过60个</li>
<li>FileInputStream和FileOutStream可以提供一个附在磁盘上的输入流和输出流，所有提供的相对路径名解释以用户工作目录开始</li>
<li>组合流过滤器，流可自由组合，将希望得到的流置于最外层，中间的流只是提供所需要的功能<pre><code>FileOutputStream fin = new FileOutputStream(&quot;javaFile.txt&quot;);
</code></pre></li>
</ul>
<h3 id="读写二进制数据"><a href="#读写二进制数据" class="headerlink" title="读写二进制数据"></a>读写二进制数据</h3><ul>
<li>以二进制格式写出数据,需要使用 DataOutputStream</li>
</ul>
<p><strong>（待续…）</strong></p>
<h3 id="文本输入与输出"><a href="#文本输入与输出" class="headerlink" title="文本输入与输出"></a>文本输入与输出</h3><ul>
<li><p>创建文件</p>
<pre><code>File file = new File(&quot;./obj.dat&quot;);
try {
    if(!file.exists())
    file.createNewFile();
} catch (IOException e) {
    e.printStackTrace();
}
</code></pre></li>
<li><p>文本输出，可以使用PrintWriter，它可以链接到FileWriter，使用Print，println，printf方法可以打印数字、字符、布尔、字符串和对象</p>
<pre><code>PrintWriter out = new PrintWriter(new FileWriter(&quot;javaFlie3&quot;));
out.println(&quot;测试&quot;);
out.close();
//不要漏了close方法
</code></pre></li>
<li><p>文本读入</p>
<pre><code>try(Scanner file = new Scanner(new FlieReader(&quot;javaFlie3&quot;)))
{
    System.out.println(file.next());
    file.close();
</code></pre></li>
</ul>
<h3 id="文本格式存储对象"><a href="#文本格式存储对象" class="headerlink" title="文本格式存储对象"></a>文本格式存储对象</h3><ul>
<li>接写出所有的字断,每个字 后面跟着一个自定义的分隔符 ,而最后一个字端的后面跟着一个 ‘\n’</li>
<li>每次读入一行,然后分离所有的字 。我们使用一个扫描器来读入每一行,然后用 String.split 方法将这一行断开成一组标记</li>
</ul>
<pre><code>public class Employee {

    String name;
    int salary;
    Date hireDate;

public Employee(String name,int salary){

    this.name = name;
    this.salary = salary;
    this.hireDate = new Date();
    }

    public void writeData(PrintWriter out){

    GregorianCalendar calendar = new GregorianCalendar();
    calendar.setTime(hireDate);

    out.println(name + &quot;|&quot; + salary + &quot;|&quot; 
    + calendar.get(Calendar.YEAR)+&quot;|&quot;
    + calendar.get(Calendar.MONTH)+&quot;|&quot;
    + calendar.get(Calendar.DAY_OF_MONTH));
    }

    public String toString(){

    GregorianCalendar calendar = new GregorianCalendar();
    calendar.setTime(hireDate);

    return name + &quot;|&quot; + salary + &quot;|&quot; 
    + calendar.get(Calendar.YEAR)+&quot;|&quot;
    + calendar.get(Calendar.MONTH)+&quot;|&quot;
    + calendar.get(Calendar.DAY_OF_MONTH);
    }
}
</code></pre><h3 id="对象流与序列化"><a href="#对象流与序列化" class="headerlink" title="对象流与序列化"></a>对象流与序列化</h3><ul>
<li>对象流输出中包含所有对象的类型和数据域</li>
<li>每个对象都被赋予一个序列号</li>
<li>相同对象的重复出现将被存储为对这个对象的序列号的引用</li>
<li>静态域不能被序列化</li>
</ul>
<h3 id="序列化存储对象"><a href="#序列化存储对象" class="headerlink" title="序列化存储对象"></a>序列化存储对象</h3><ul>
<li>保存对象数据需要打开一个 ObjectOutputStream 对象，然后使用writeObject 方法</li>
<li>读回对象数据需要获得一个 ObjectInputStream 对象，然后,用readObject 方法以这些对象被写出时的顺序获得</li>
<li>希望在对象流中存储或恢复的所有类都应进行一下修改,这些类必须实现 Serializable 接口: 该接口没有任何方法,因此不需要对这些类进行任何改动</li>
<li>如果某些数据域是不可以序列化的，将它们标记成transient，如果这些域属于不可序列化的类, 也需要将它们标记成 transient ，瞬时的域在对象被序列化时总是被跳过</li>
</ul>
<pre><code>package objectStreamTest;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import testWrite.Employee;

public class test {
public static void main(String[] args)
{
Employee jack = new Employee(&quot;jack&quot;,7000);
Employee carls = new Employee(&quot;carls&quot;,8000);
Employee tony = new Employee(&quot;tony&quot;,9000);
Employee[] staff = new Employee[3];
staff[0]=jack;
staff[1]=carls;
staff[2]=tony;

    try(ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;/Users/alberthumbert/Desktop/obj.dat&quot;)))
{
    out.writeObject(staff);

}catch(Exception e){}

    try(ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;/Users/alberthumbert/Desktop/obj.dat&quot;)))
{
    Employee[] newStaff = (Employee[])in.readObject();
    System.out.println(newStaff[2]);
}catch(Exception e){}


    }
}
</code></pre><p><strong>（待续…）</strong></p>
<h2 id="可扩展标记语言-XML"><a href="#可扩展标记语言-XML" class="headerlink" title="可扩展标记语言 XML"></a>可扩展标记语言 XML</h2><p>** 大概不会经常用到，只做简要了解**</p>
<h3 id="XML文档简介"><a href="#XML文档简介" class="headerlink" title="XML文档简介"></a>XML文档简介</h3><ul>
<li>XML 被设计为传输和存储数据，其焦点是数据的内容，XML 格式能够表达层次结构,并且重复的元素不会被曲解</li>
<li>XML 文档应当以一个文档开始，虽然它是可选的<pre><code>&lt;? xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
</code></pre></li>
<li>文档头之后通常是文档类型的定义<pre><code>&lt;!DOCTYPE web-app PUBLIC
&quot;-//Sun Microsystem, Ins. //DTD Web Application 2.2//EN&quot;
&quot;http://java.sun.com/j2ee/dtds/web-app_2_2.dtd&quot;&gt;
</code></pre></li>
<li>最后，XML文档的正文包含根元素，根元素包含其他元素<pre><code>&lt;font&gt;
    &lt;name&gt;Helvetica&lt;/name&gt;
    &lt;size&gt;36&lt;/size&gt;
&lt;/font&gt;
</code></pre></li>
<li>元素和文本是 XML 文档“主要的支撑要素”,可能还会遇到的其他一些标记：字符引用  &amp;#233 &amp;#xE9 ；实体引用   &amp;name  ；注释  \&lt; !– –></li>
</ul>
<h3 id="解析XML文档"><a href="#解析XML文档" class="headerlink" title="解析XML文档"></a>解析XML文档</h3><ul>
<li>要处理 XML 文档,就要先解 (parse)它，解析器是这样一个程序:它读入一个文件, 确认这个文件具有正确的格式,然后将其分解成各种元素,使得程序员能够访问这些元素</li>
<li><p>要读入一个 XML 文档,首先需要一个 DocumentBuilder 对象,可以从 DocumentBuilder Factory 中得到这个对象，然后从文件中读入某个文档，或者可以用一个 URL，甚至可以指定一个任意的输入流</p>
<pre><code>DocumentBuilderFactory factory=DocumentBuliderFactory.newInstance();
DocumentBuilder builder = factory.newDocumentBulider();

读入文档
File f= ...
Document doc = builder.parse(f);

或使用URL
URL u = ... 
Document doc = bulider.parse(u);

指定输入流
InputStream in = ...
Document doc = parse(in);
</code></pre></li>
<li><p>可以通过调用 getDocumentElement 方法来启动对文档内容的分析,它将返回根元素</p>
<pre><code>例如
&lt;? xml version = &quot;1.0&quot;?&gt;
&lt;font&gt;
    ...
&lt;/font&gt;

Element root = doc.getDocumentElement();        //返回font元素
String name = root.getTagName();
//返回标签名，此处为font
</code></pre></li>
<li><p>如果要得到该元素的子元素(可能是子元素、文本、注 或其他节点),请使用 getChild Nodes方法,这个方法返回一个类型为NodeList的集合<br>  <strong>(待续)</strong></p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[git学习笔记]]></title>
      <url>/2016/12/06/Git/</url>
      <content type="html"><![CDATA[<p>onDestroy<br><img src="http://p1.bpimg.com/4851/923b28f3dcd37179.jpg" class="img-topic"></p>
<a id="more"></a>
<h2 id="提交版本"><a href="#提交版本" class="headerlink" title="提交版本"></a>提交版本</h2><p>初始Git仓库：</p>
<pre><code>git init
</code></pre><p>   添加文件到Git仓库<br>    git add <file><br>   提交到版本库<br>    git commit -m “ ”<br>   掌握工作区状态<br>    git status<br>   git status告知有文件被修改，查看修改</file></p>
<pre><code>git diff
</code></pre><hr>
<pre><code>git add把文件修改添加到暂存区stage（或叫index）
git commit提交更改，实际上是把暂存区的所有内容提交到当前分支
.git/index 是一个包含文件索引的目录树
.git/master 是master分支所代表的目录树
这里目录树像是一个虚拟的工作区，当中记录了文件名、文件的状态信息（时间戳、文件长度等）
文件内容并不存储其中，而是保存在 Git 对象库（.git/objects）
</code></pre><h2 id="版本穿梭"><a href="#版本穿梭" class="headerlink" title="版本穿梭"></a>版本穿梭</h2><p>  HEAD指向当前版本，在版本的历史之间穿梭，使用命令</p>
<pre><code>git reset --hard commit_id 
</code></pre><hr>
<pre><code>git reset --hard^
</code></pre><hr>
<pre><code>git reset --hard^^
</code></pre><hr>
<pre><code>git reset --hard~100
</code></pre><p>   查看提交历史，确定回退版本 </p>
<pre><code>git log
</code></pre><hr>
<pre><code>＃精简输出 git log —pretty=oneline
</code></pre><p>  查看命令历史，确定未来版本<br>    git reflog</p>
<h2 id="丢弃修改"><a href="#丢弃修改" class="headerlink" title="丢弃修改"></a>丢弃修改</h2><p>   未add，丢弃工作区的修改<br>    git checkout – file</p>
<p>   已add，丢弃修改<br>    git reset HEAD file<br>    git checkout – file</p>
<p>   已commit，撤销提交<br>    git reset —hard^</p>
<h2 id="删除恢复"><a href="#删除恢复" class="headerlink" title="删除恢复"></a>删除恢复</h2><p>   删除文件导致工作区版本库不一致，查看被删除文件</p>
<pre><code>git status
</code></pre><p>   确定要从版本库中删除该文件  </p>
<p>   添加删除信息到暂存区<br>    git rm &lt;&gt;<br>   更新版本库<br>    git commit</p>
<p>   恢复文件<br>    git checkout – file </p>
<h2 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a>克隆仓库</h2><p>   克隆仓库  </p>
<pre><code>git clone
</code></pre><hr>
<pre><code>#Git支持多种协议，包括https
通过ssh支持的原生git协议速度最快
</code></pre><h2 id="控制分支"><a href="#控制分支" class="headerlink" title="控制分支"></a>控制分支</h2><p>   Git鼓励大量使用分支：</p>
<p>   查看分支：<br>    git branch<br>   创建分支：<br>    git branch <name><br>   切换分支：<br>    git checkout <name><br>   创建+切换分支：<br>    git checkout -b <name><br>   合并某分支到当前分支：<br>    git merge <name><br>   删除已合并分支：<br>    git branch -d <name><br>   删除未合并分支：<br>    git branch -D <name><br>   合并分支：<br>   默认Fast forward模式，删除分支后丢掉分支信息<br>   禁用Fast forward模式 —no-ff 生成新commit<br>    git merge –no-ff -m “ ” <branch name=""><br>   查看分支信息<br>    git log</branch></name></name></name></name></name></name></p>
<h2 id="储藏工作区"><a href="#储藏工作区" class="headerlink" title="储藏工作区"></a>储藏工作区</h2><p>   储藏工作现场：<br>    git stash<br>   查看：<br>    git stash list<br>   恢复：<br>    git stash apply<br>  删除：  </p>
<pre><code>git stash drop   
</code></pre><p>  恢复并删除：<br>    git stash pop        </p>
<h2 id="远程库"><a href="#远程库" class="headerlink" title="远程库"></a>远程库</h2><p>   关联远程库<br>    git remote add origin git@server-name:path/repo-name.git</p>
<p>   关联后第一次推送master分支所有内容<br>    git push -u origin master</p>
<p>   推送最新修改<br>    git push origin master</p>
<p>   查看远程库信息:<br>    git remote -v</p>
<p> 从本地推送分支：<br>    git push origin branch-name<br>   推送失败,抓取远程的新提交 </p>
<pre><code>git pull
</code></pre><hr>
<pre><code>＃本地新建的分支不推送到远程，他人不可见
＃如有冲突,先处理冲突
</code></pre><p>   本地创建和远程分支对应的分支<br>    git checkout -b branch-name origin/branch-name<br>   建立本地分支和远程分支的关联</p>
<pre><code>git branch --set-upstream branch-name origin/branch-name
</code></pre><hr>
<pre><code>＃本地和远程分支的名称最好一致
</code></pre><h2 id="使用标签"><a href="#使用标签" class="headerlink" title="使用标签"></a>使用标签</h2><p>   新建标签<br>    git tag <name><br>   查看标签<br>    git tag<br>   默认为HEAD，可以指定commit id</name></p>
<p>   指定标签信息<br>    git tag -a <tagname> -m “ ”</tagname></p>
<p>   PGP签名标签<br>    git tag -s <tagname> -m “ ”</tagname></p>
<p>   推送本地标签<br>    git push origin <tagname></tagname></p>
<p>   推送全部未推送的本地标签<br>    git push origin —tags</p>
<p>   删除本地标签<br>    git tag -d <tagname></tagname></p>
<p>   删除远程标签<br>    git push origin :refs/tags/<tagname></tagname></p>
<h2 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h2><p>   忽略文件编写 .gitignore 放到版本库<br>   强制添加<br>    git add -f <file><br>   检查配置<br>    git check-ignore <file></file></file></p>
<h2 id="设置别名"><a href="#设置别名" class="headerlink" title="设置别名 "></a>设置别名 </h2><p>   配置别名</p>
<pre><code>git config --global alias.&lt;..&gt;  &lt;…….&gt;
</code></pre><hr>
<pre><code>git config --global alias.lg &quot;log --color --graph —pretty=format:&apos;%Cred%h %Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; —abbrev-commit&quot;
</code></pre><h2 id="搭建Git服务器"><a href="#搭建Git服务器" class="headerlink" title="搭建Git服务器"></a>搭建Git服务器</h2><p>   安装git</p>
<pre><code>sudo apt-get install git
</code></pre><p>   创建一个git用户</p>
<pre><code>sudo adduser git
</code></pre><p>   创建证书登录：<br>   收集所有需要登录的用户的公钥id_rsa.pub，把所<br>   有公钥导入到/home/git/.ssh/authorized_keys</p>
<p>   初始化Git仓库：<br>   先选定一个目录作为Git仓库，在目录下输入命令</p>
<pre><code>sudo git init --bare sample.git
</code></pre><p>   禁用shell登录：<br>   编辑/etc/passwd</p>
<pre><code>git:x:1001:1001:,,,:/home/git:/bin/bash
</code></pre><p>   改为</p>
<pre><code>git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell
</code></pre><p>   克隆远程仓库：</p>
<p>   通过git clone命令克隆远程仓库,在各自的电脑上运行<br>    git clone git@server:/srv/sample.git<br><img src="http://p1.bpimg.com/4851/e8b3de05b5049f9e.jpg"></p>
<pre><code>http://www.cnblogs.com/hutaoer/archive/2013/05/07/git_checkout.html?utm_source=tuicool&amp;utm_medium=referral
</code></pre><hr>
<pre><code>http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000
</code></pre>]]></content>
      
        <categories>
            
            <category> 笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[混乱的贪吃蛇C代码]]></title>
      <url>/2016/11/14/SnakeInC/</url>
      <content type="html"><![CDATA[<p>咳咳！</p>
<a id="more"></a>
<p>看懂别人的大致思路之后<br>自己动手用vim写了一个贪吃蛇出来，<br>然后感觉太简陋了，于是改了两个bug，<br>增加了积分、难度、记名排名、储存的功能，<br>改得不成样子了，再过几天估计自己都看不懂，<br>有空再整理了…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include&lt;stdio.h&gt;</div><div class="line">#include&lt;conio.h&gt;</div><div class="line">#include&lt;string.h&gt;</div><div class="line">#include&lt;time.h&gt;</div><div class="line">#include&lt;stdlib.h&gt;</div><div class="line">#define H 6</div><div class="line">#define L 10</div><div class="line">char map[H][L];</div><div class="line">const char head=&apos;@&apos;;</div><div class="line">const char body=&apos;O&apos;;</div><div class="line">const char ground=&apos;.&apos;;</div><div class="line">const char food=&apos;Q&apos;;</div><div class="line">int st=300;</div><div class="line">int sp=0;</div><div class="line">int end=0;</div><div class="line">int point=1;</div><div class="line">int level=1;</div><div class="line">int maxsp=0;</div><div class="line">int key;</div><div class="line"></div><div class="line">struct snake</div><div class="line">&#123;</div><div class="line">int x,y;</div><div class="line">int dir;</div><div class="line">&#125;snake[H*L];</div><div class="line"></div><div class="line">struct player</div><div class="line">&#123;</div><div class="line">char name[10];</div><div class="line">int sp;</div><div class="line">int level;</div><div class="line">&#125;player[11],new;</div><div class="line"></div><div class="line"></div><div class="line">int dx[]=&#123;0,0,-1,1&#125;;</div><div class="line">int dy[]=&#123;-1,1,0,0&#125;;</div><div class="line">void mapcreat();</div><div class="line">void ref();</div><div class="line">void foodcreat();</div><div class="line">void rmove();</div><div class="line">void check(int x,int y);</div><div class="line">void foodcheck();</div><div class="line">void filecreat();</div><div class="line">void fileload();</div><div class="line">void filesave();</div><div class="line">void playerset();</div><div class="line">void sort();</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">playerset();</div><div class="line">filecreat();</div><div class="line">fileload();</div><div class="line">mapcreat();</div><div class="line">getch();</div><div class="line">ref();</div><div class="line">return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void mapcreat()</div><div class="line">&#123;</div><div class="line">int hx,hy;</div><div class="line">int i,j;</div><div class="line">memset(map,ground,sizeof map);</div><div class="line">system(&quot;title 贪吃蛇&quot;);</div><div class="line">system(&quot;cls&quot;);</div><div class="line">srand(time(0));</div><div class="line">hx=rand()%H;</div><div class="line">hy=rand()%L;</div><div class="line">map[hx][hy]=head;</div><div class="line">snake[0].x=hx,snake[0].y=hy,snake[0].dir=0;</div><div class="line">foodcreat();</div><div class="line">printf(&quot;\n\n\t\t请按方向键操作&quot;);</div><div class="line">printf(&quot;\n\n\t\t &quot;);</div><div class="line">for(i=0;i&lt;H;i++)</div><div class="line">&#123;for(j=0;j&lt;L;j++)</div><div class="line">&#123;</div><div class="line">    printf(&quot;%c&quot;,map[i][j]);</div><div class="line">    </div><div class="line">&#125;</div><div class="line">    printf(&quot;\n\t\t &quot;);</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">void foodcreat()</div><div class="line">&#123;</div><div class="line">int fx,fy;</div><div class="line">fx=rand()%H;</div><div class="line">fy=rand()%L;</div><div class="line">while(map[fy][fx]!=ground)</div><div class="line">&#123;</div><div class="line">    fx=rand()%H;</div><div class="line">    fy=rand()%L;</div><div class="line">&#125;</div><div class="line"></div><div class="line">map[fy][fx]=food;</div><div class="line">&#125;</div><div class="line">   </div><div class="line">void ref()</div><div class="line">&#123;</div><div class="line">int i,j;</div><div class="line">while(1)</div><div class="line">&#123;</div><div class="line">    _sleep(st);</div><div class="line">    rmove();</div><div class="line">    if(end==1)</div><div class="line">    &#123;</div><div class="line">        system(&quot;cls&quot;);</div><div class="line">        printf(&quot;\n\n\t\t   游戏结束! &quot;);</div><div class="line">        printf(&quot;\n\n\t\t此局得分 : %d&quot;,sp);</div><div class="line">        printf(&quot;\n\n\t\t最高得分 : %d&quot;,maxsp);</div><div class="line">        printf(&quot;\n\n\n\t\t   留下大名!&quot;);</div><div class="line">        printf(&quot;\n\n\t\t君の名は。:&quot;);</div><div class="line">        filesave();</div><div class="line">        fileload();</div><div class="line">        system(&quot;cls&quot;);</div><div class="line">        printf(&quot;\n\n\t\t    得分排行&quot;);</div><div class="line">        printf(&quot;\n\n\t  玩家:\t\t得分:\t难度:\t\n&quot;);</div><div class="line">        for(i=0;i&lt;10;i++)</div><div class="line">        &#123;</div><div class="line">            printf(&quot;\n\t   %-4s \t %-4d \t %-4d \t\n\</div><div class="line">                   &quot;,player[i].name,player[i].sp,player[i].level);</div><div class="line">        &#125;</div><div class="line">        printf(&quot;\n\t  本次纪录:&quot;);</div><div class="line">        printf(&quot;\n\t   %-4s \t %-4d \t %-4d \t\n\</div><div class="line">               &quot;,new.name,new.sp,new.level);</div><div class="line">        printf(&quot;\n\t   &quot;);</div><div class="line">        getchar();</div><div class="line">        getchar();</div><div class="line">        system(&quot;cls&quot;);</div><div class="line">        mapcreat();</div><div class="line">        getch();</div><div class="line">        point=1;</div><div class="line">        end=0;</div><div class="line">        st=300;</div><div class="line">        sp=0;</div><div class="line">        level=0;</div><div class="line">        system(&quot;cls&quot;);</div><div class="line">        end=0;</div><div class="line">    &#125;</div><div class="line">    else</div><div class="line">        system(&quot;cls&quot;);</div><div class="line">    </div><div class="line">    printf(&quot;\n\n\t\tEp:%-4d&quot;,sp);</div><div class="line">    printf(&quot; Lv:%d&quot;,level);</div><div class="line">    printf(&quot;\n\n\t\t &quot;);</div><div class="line">    foodcheck();</div><div class="line">    for(i=0;i&lt;H;i++)</div><div class="line">    &#123;for(j=0;j&lt;L;j++)</div><div class="line">        </div><div class="line">    &#123;</div><div class="line">        printf(&quot;%c&quot;,map[i][j]);</div><div class="line">        </div><div class="line">        </div><div class="line">    &#125;</div><div class="line">        printf(&quot;\n\t\t &quot;);</div><div class="line">        </div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    </div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">   </div><div class="line">void rmove()</div><div class="line">&#123;</div><div class="line"></div><div class="line">int i,x,y;</div><div class="line">int t=point;</div><div class="line">if(kbhit())</div><div class="line">&#123;</div><div class="line">    while(kbhit())</div><div class="line">        key=getch();</div><div class="line">    switch(key)</div><div class="line">    &#123;</div><div class="line">        case 75: if(snake[0].dir!=1||point==1)snake[0].dir=0;break;</div><div class="line">        case 77: if(snake[0].dir!=0||point==1)snake[0].dir=1;break;</div><div class="line">        case 72: if(snake[0].dir!=3||point==1)snake[0].dir=2;break;</div><div class="line">        case 80: if(snake[0].dir!=2||point==1)snake[0].dir=3;break;</div><div class="line">            </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">x=snake[0].x,y=snake[0].y;</div><div class="line">map[x][y]=ground;</div><div class="line">snake[0].x=snake[0].x+dx[snake[0].dir];</div><div class="line">snake[0].y=snake[0].y+dy[snake[0].dir];</div><div class="line">check(x,y);</div><div class="line">if(point==t)</div><div class="line">    for(i=1;i&lt;point;i++)</div><div class="line">    &#123;</div><div class="line">        if(i==1)</div><div class="line">            map[snake[i].x][snake[i].y]=ground;</div><div class="line">        if(i==point-1)</div><div class="line">        &#123;</div><div class="line">            snake[i].x=x,snake[i].y=y;</div><div class="line">            snake[i].dir=snake[0].dir;</div><div class="line">        &#125;</div><div class="line">        else</div><div class="line">        &#123;</div><div class="line">            snake[i].x=snake[i+1].x;</div><div class="line">            snake[i].y=snake[i+1].y;</div><div class="line">            snake[i].dir=snake[i+1].dir;</div><div class="line">        &#125;</div><div class="line">        map[snake[i].x][snake[i].y]=&apos;O&apos;;</div><div class="line">    &#125;</div><div class="line">    &#125;</div><div class="line">void check(int x,int y)</div><div class="line">&#123;</div><div class="line">if(snake[0].x&lt;0||snake[0].x&gt;H||snake[0].y&lt;0||snake[0].y&gt;L)</div><div class="line">    end=1;</div><div class="line"></div><div class="line">if(map[snake[0].x][snake[0].y]==ground)</div><div class="line">&#123;</div><div class="line">    map[snake[0].x][snake[0].y]=head;</div><div class="line">    </div><div class="line">&#125;</div><div class="line">else if(map[snake[0].x][snake[0].y]==food)</div><div class="line">&#123;</div><div class="line">    map[snake[0].x][snake[0].y]=head;</div><div class="line">    foodcreat();</div><div class="line">    snake[point].x=x;</div><div class="line">    snake[point].y=y;</div><div class="line">    snake[point].dir=snake[0].dir;</div><div class="line">    point++;</div><div class="line">    if(st&gt;=50)</div><div class="line">    &#123;</div><div class="line">        st=st-10;</div><div class="line">        level=level+1;</div><div class="line">        sp=sp+30;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div><div class="line">else</div><div class="line">&#123;   if(sp&gt;maxsp)</div><div class="line">    maxsp=sp;</div><div class="line">    end=1;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">void foodcheck()</div><div class="line">&#123;</div><div class="line">int i,j,check=0;</div><div class="line">for(i=0;i&lt;H;i++)</div><div class="line">    for(j=0;j&lt;L;j++)</div><div class="line">        if(map[i][j]==food)check=1;</div><div class="line">if(check==0)foodcreat();</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">void filecreat()</div><div class="line">&#123;</div><div class="line"></div><div class="line">FILE *fp;</div><div class="line">if((fp=fopen(&quot;player.dat&quot;,&quot;ab&quot;))==NULL)</div><div class="line">&#123;</div><div class="line">    printf(&quot;error,cannot open file player.dat&quot;);&#125;</div><div class="line">fwrite(player,sizeof(struct player),11,fp);</div><div class="line">fclose(fp);</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">void fileload()</div><div class="line">&#123;</div><div class="line">FILE *fp;</div><div class="line">fp=fopen(&quot;player.dat&quot;,&quot;rb&quot;);</div><div class="line">fread(player,sizeof(struct player),11,fp);</div><div class="line">fclose(fp);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">void filesave()</div><div class="line">&#123;</div><div class="line">FILE *fp;</div><div class="line">fp=fopen(&quot;player.dat&quot;,&quot;wb&quot;);</div><div class="line">scanf(&quot;%s&quot;,player[10].name);</div><div class="line">player[10].sp=sp;</div><div class="line">player[10].level=level;</div><div class="line">sort();</div><div class="line">fwrite(player,sizeof(struct player),11,fp);</div><div class="line">fclose(fp);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void playerset()</div><div class="line">&#123;</div><div class="line">int i;</div><div class="line">for(i=0;i&lt;11;i++)</div><div class="line">&#123;</div><div class="line">    strcpy(player[i].name,&quot;空&quot;);</div><div class="line">    player[i].sp=0;</div><div class="line">    player[i].level=0;</div><div class="line">    </div><div class="line">    </div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">void sort()</div><div class="line">&#123;</div><div class="line">struct player temp;</div><div class="line">int i,j,max;</div><div class="line">new.level=player[10].level;</div><div class="line">new.sp=player[10].sp;</div><div class="line">strcpy(new.name,player[10].name);</div><div class="line">for(i=0;i&lt;11;i++)</div><div class="line">&#123;   max=i;</div><div class="line">    for(j=i+1;j&lt;11;j++)</div><div class="line">    &#123;</div><div class="line">        if(player[max].sp&lt;player[j].sp)max=j;</div><div class="line">        &#123;</div><div class="line">            temp.level=player[i].level;</div><div class="line">            temp.sp=player[i].sp;</div><div class="line">            strcpy(temp.name,player[i].name);</div><div class="line">        &#125;</div><div class="line">        player[i].level=player[max].level;</div><div class="line">        player[i].sp=player[max].sp;</div><div class="line">        strcpy(player[i].name,player[max].name);</div><div class="line">        player[max].level=temp.level;</div><div class="line">        player[max].sp=temp.sp;</div><div class="line">        strcpy(player[max].name,temp.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 代码 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[酷炫的终端配置入门指南]]></title>
      <url>/2016/11/13/ITerm2/</url>
      <content type="html"><![CDATA[<p><img src="http://p1.bqimg.com/4851/fa551cd95e4fdbc4.jpg" class="img-topic"><br>记录一些自己的配置，只是入门级别而已<br><a id="more"></a></p>
<h2 id="iTerm2-mac上最好用的终端"><a href="#iTerm2-mac上最好用的终端" class="headerlink" title="iTerm2 : mac上最好用的终端"></a>iTerm2 : mac上最好用的终端</h2><p>有多好用看看快捷键功能就知道了<br>插件都是通用的,linux可以使用tmux </p>
<pre><code>⌘ + —/+/0 : 调整字体大小
⌘ + r : 清屏
⌘ + 数字 : 切换标签页
⌘ + 方向键 : 按方向切换标签页
⌘ + enter : 切换全屏
⌘ + d: 垂直分屏
⌘ + shift + d : 水平分屏
⌘ + ] ⌘ + [ : 在最近使用的分屏直接切换 
⌘ + opt + 方向键 : 切换到指定位置的分屏
⌘ + t : 新的标签页
⌘ + w : 关闭当前标签页
⌘ + ；: 自动补全历史命令
space + opt : 呼出悬浮窗
ctrl + u : 清空当前行
ctrl + a : 到行首
ctrl + e : 行末
ctrl + f/b : 前进后退
ctrl + p : 上一条命令
ctrl + r : 搜索命令历史
ctrl + d : 删除当前字符
ctrl + h : 删除之前的字符
ctrl + w : 删除光标前的单词
ctrl + k : 删除到文本末尾
ctrl + t : 交换光标处文本 
</code></pre><h2 id="zsh-终极-Shell"><a href="#zsh-终极-Shell" class="headerlink" title="zsh : 终极 Shell"></a>zsh : 终极 Shell</h2><p>1.确保已安装git</p>
<p>2.然后安装oh my zsh :</p>
<pre><code>git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh
</code></pre><p>3.创建zsh的配置文件</p>
<pre><code>cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc
</code></pre><p>4.设置默认 </p>
<pre><code>chsh -s /bin/zsh
</code></pre><p>5.选择主题</p>
<pre><code>~/.oh-my-zsh/themes 
</code></pre><p> 这里有上百种主题可供选择</p>
<pre><code>vim ~/.zshrc
</code></pre><p> 修改ZSH_THEME=你的主题</p>
<p> 最后</p>
<pre><code>source ~/.zshrc
</code></pre><h2 id="autojump-智能跳转"><a href="#autojump-智能跳转" class="headerlink" title="autojump : 智能跳转"></a>autojump : 智能跳转</h2><p>1.确保已安装homebrew</p>
<p>2.安装autojump</p>
<pre><code>brew install autojump
</code></pre><p>3.修改zsh配置<br>    vim ~/.zshrc</p>
<p>加入</p>
<pre><code>[[ -s ~/.autojump/etc/profile.d/autojump.sh ]] &amp;&amp; . ~/.autojump/etc/profile.d/autojump.sh
</code></pre><h2 id="pathogen-vim插件管理"><a href="#pathogen-vim插件管理" class="headerlink" title="pathogen : vim插件管理"></a>pathogen : vim插件管理</h2><p>1.安装pathogen</p>
<pre><code>git clone git://github.com/tpope/vim-pathogen
</code></pre><p>2.进入.vim, 没有就建一个<br>    mkdir autoload bundle<br>  以后vim插件最好都在bundle中下载<br>  将下载到的pathogen.vim复制到autoload目录</p>
<p>3.打开.vimrc, 没有也建一个<br>（vim的配置可以实现很多功能，要是觉得麻烦，网上有现成）</p>
<p>加入</p>
<pre><code>call pathogen#infect()
</code></pre><h2 id="NERDTree：树形目录"><a href="#NERDTree：树形目录" class="headerlink" title="NERDTree：树形目录"></a>NERDTree：树形目录</h2><p>1.在.vim/bundle下安装NERDTree</p>
<pre><code>git clone git://github.com/scrooloose/nerdtree.git
</code></pre><p>2.进入目录内的doc，在vim内使用:Helptags</p>
<h2 id="powerline：状态栏插件"><a href="#powerline：状态栏插件" class="headerlink" title="powerline：状态栏插件"></a>powerline：状态栏插件</h2><p>1.安装powerline<br>    git clone git://github.com/Lokaltog/powerline.git<br>2.设置zsh </p>
<pre><code>vim ~/.zshrc
</code></pre><p>添加<br>    . /Users/～/PowerLine/powerline/bindings/zsh/powerline.zsh<br>  以上路径需要自行修改</p>
<p>3.设置vim</p>
<pre><code>vim ~/.vimrc
</code></pre><p>加入</p>
<pre><code>&quot;powerline 
set rtp+=/Users/～/PowerLine/  
powerline/bindings/vim
set guifont=PowerlineSymbols\ for\ Powerline
set laststatus=2
let g:Powerline_symbols = &apos;fancy&apos;
let g:Powerline_symbols = &apos;unicode&apos;
set encoding=utf-8
set t_Co=256
set number
set fillchars+=stl:\ ,stlnc:\
set term=xterm-256color
set termencoding=utf-8
</code></pre><p>路径同样需要自行修改<br>4.在iTerm2的profiles中把字体改为powerline字体</p>
<h2 id="Solarized-完善的配色方案"><a href="#Solarized-完善的配色方案" class="headerlink" title="Solarized : 完善的配色方案"></a>Solarized : 完善的配色方案</h2><p>1.安装Solarized</p>
<pre><code>git clone git://github.com/altercation/solarized.git
</code></pre><p>2.执行下列命令行</p>
<hr>
<pre><code>cd solarized
</code></pre><p>-—<br>    cd vim-colors-solarized/colors<br>-—<br>    mkdir -p ~/.vim/colors<br>-—<br>    cp solarized.vim ~/.vim/colors/<br>-—<br>    vim ~/.vimrc</p>
<hr>
<p>3.修改vim设置，加入<br>    syntax enable<br>    set background=dark<br>    colorscheme solarized</p>
<p>4.在profiles中选择Solarized主题</p>
<h2 id="ctags-生成索引"><a href="#ctags-生成索引" class="headerlink" title="ctags : 生成索引"></a>ctags : 生成索引</h2><p>os x自带了ctags，但是这并没有什么卵用</p>
<p>1.下载ctags</p>
<pre><code>http://ctags.sourceforge.net/
</code></pre><p>并解压<br>    tar zxvf ctags-5.8.tar.gz<br>安装</p>
<pre><code>sudo ./configure &amp;&amp; make all &amp;&amp; sudo make install 
</code></pre><p>2.打开 ~/.profile, 如果没有，还是那句，建一个</p>
<p>加入</p>
<pre><code>export PATH=&quot;/usr/local/bin:/usr/local/sbin:$PATH&quot; 
</code></pre><p>3.修改PATH<br>    vim ~/.zshrc  </p>
<p>添加<br>    PATH=”/usr/local/bin:$PATH”</p>
<h2 id="taglist：代码概览"><a href="#taglist：代码概览" class="headerlink" title="taglist：代码概览"></a>taglist：代码概览</h2><p>1.下载taglist</p>
<pre><code>git clone git://github.com/vim-scripts/taglist.vim
</code></pre><p>2.修改vimrc<br>加入</p>
<pre><code>&quot;taglist{
let Tlist_Show_One_File = 1         
let Tlist_Exit_OnlyWindow = 1          
let Tlist_Use_Right_Window = 1         
let Tlist_GainFocus_On_ToggleOpen = 1  
let Tlist_Ctags_Cmd=&apos;/usr/local/bin/ctags&apos;  
nnoremap &lt;leader&gt;tl : Tlist&lt;CR&gt;        
}  
</code></pre><p>注：taglist需要使用ctags生成的tags    </p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 终端配置 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[搭建hexo＋github博客]]></title>
      <url>/2016/10/15/Hexo/</url>
      <content type="html"><![CDATA[<p><img src="http://p1.bpimg.com/567571/334398904d749981.jpg" class="img-topic"></p>
<p>花一天半的时间搭了hexo博客，<br>整理一下参考链接<br><a id="more"></a></p>
<p><a href="http://lijianchang.xyz/2016/03/16/小白独立搭建博客-Github-Pages和Hexo简明教程/" target="_blank" rel="external">http://lijianchang.xyz/2016/03/16/小白独立搭建博客-Github-Pages和Hexo简明教程/</a></p>
<p>在主题的部分参考下面的jacman，这是一个相当美观的主题<br>有详细的配置指南，注意末尾的常见问题：</p>
<p><a href="http://jacman.wuchong.me/2014/11/20/how-to-use-jacman/#more" target="_blank" rel="external">http://jacman.wuchong.me/2014/11/20/how-to-use-jacman/#more</a></p>
<p>不会使用markdown的请粗略地阅读：</p>
<p><a href="http://wowubuntu.com/markdown/#overview" target="_blank" rel="external">http://wowubuntu.com/markdown/#overview</a></p>
<p>有必要时再来翻阅即可</p>
<p>终端不能保存请set noreadonly 再:wq</p>
<p>关于如何安装rss插件：</p>
<p><a href="http://blog.csdn.net/u011303443/article/details/52333695" target="_blank" rel="external">http://blog.csdn.net/u011303443/article/details/52333695</a></p>
<p>关于图床：<br><a href="http://yotuku.cn" target="_blank" rel="external">http://yotuku.cn</a></p>
<p>关于购买域名：<br>腾讯云有一个适合入门者的 1元=服务器+域名 活动<br>每日12时可抢购（据说以前是不用抢的<br><a href="https://www.qcloud.com/act/campus" target="_blank" rel="external">https://www.qcloud.com/act/campus</a></p>
<p>关于如何将域名关联到Github：<br>返回参考第一个链接 </p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[我的涂鸦]]></title>
      <url>/2016/10/15/MyPaintings/</url>
      <content type="html"><![CDATA[<p>-<br>图已挂，待修复</p>
<p>这是一个存放半成品的地方，线稿居多</p>
<p>也许哪天会想要继续画的东西，大概吧<br><a id="more"></a><br><img src="http://p1.bqimg.com/567571/2b22b63555a8a112.jpg" alt="光影部分没有完成，不肝了:("></p>
<p><img src="http://p1.bpimg.com/567571/49b24aac8aef4874.jpg" alt="自用的logo（并没有用 "></p>
<p><img src="http://p1.bqimg.com/567571/9c34ec604599fff3.jpg" alt="久违的同人"></p>
<p><img src="http://p1.bqimg.com/567571/095305f6498ebb45.jpg" alt="为什么以前总是能画出现在都没办法上色的稿呢:("></p>
<p><img src="http://p1.bqimg.com/567571/e61bab9ccfe04d9d.jpg" alt="维持线描风更好吧！"></p>
<p><img src="http://p1.bqimg.com/567571/96551e32716e8e5c.jpg" alt="看完岚少的夜回，徊，佪，廻..hui字有几种写法，本来打算做生贺图的，但是sai文件丢了"></p>
<p><img src="http://p1.bqimg.com/567571/006ca391246954a4.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> paintings </category>
            
        </categories>
        
        
        <tags>
            
            <tag> paintings </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hello world]]></title>
      <url>/2016/10/14/HowLowWorld/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p>缘起</p>
<p>欢迎来到我的小窝</p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
