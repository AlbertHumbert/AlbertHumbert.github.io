<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[kotlin 语法详解]]></title>
      <url>/2019/04/19/Langkotlin/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><a href="https://try.kotlinlang.org/" target="_blank" rel="external">你可以在这个网站中在线编译并运行kotlin代码</a></p>
<p><br></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>kotlin是一门野心非常大的语言，它不但能与能与现有的java框架并存，向人证明它可以以更加简洁的方式代替java，还不断向着更多的领域发展。android开发者可以结合anko编写应用，永久告别xml，前端开发者可以编写kotlin代码然后编译成JavaScript，Kotlin_Native更是支持直接编译机器码在linux，ios，mac os上运行</li>
</ul>
<ul>
<li>kotlin最大的特点是简洁的语法，自动类型推断，互操作性，成吨语法糖</li>
</ul>
<ul>
<li>java中已有并且在kotlin中相同的特性不会拿出来讲</li>
</ul>
<p><br></p>
<h2 id="函数和变量"><a href="#函数和变量" class="headerlink" title="函数和变量"></a>函数和变量</h2><p><br></p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p><br></p>
<h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><p><strong>构成kotlin程序的基本要素是函数和变量，这即是某些语言以及函数式编程中强调的“函数是第一等公民”的概念的体现</strong></p>
<pre><code>fun main(args:Array&lt;String&gt;){
    println(&quot;hello world&quot;)
}
</code></pre><ul>
<li>上面是一个hello world的kotlin实现，从这个简单的例子中我们已经可以看到kotlin与java有很多不同</li>
</ul>
<pre><code>1.使用关键字 fun 声明一个函数，也就是方法
2.参数类型写在名称的后面，与go语言如出一辙，对于能够自动推断类型的语言来说，我们总是更关注变量的名名称所表达的抽象含义而不是它的类型
3.函数可以定义在文件的最外层，而不是类里面，你可以直接把这个函数放到任何一个kt文件中运行，不需要找到一个合适的花括号然后把它塞进去
4.println代替了system.out.println，kotlin简化了很多这样啰嗦的代码
5.可以省略代码结尾的分号，这点和python很像，你不用担心你的代码会被go编译器那样胡乱的添加上分号
</code></pre><p><br></p>
<h4 id="主函数-main"><a href="#主函数-main" class="headerlink" title="主函数 main"></a>主函数 main</h4><ul>
<li>两种写法</li>
</ul>
<pre><code>fun main(){
//...
}
fun main(Array&lt;String&gt;){
//...
}
</code></pre><p><br></p>
<h4 id="代码块体"><a href="#代码块体" class="headerlink" title="代码块体 {}"></a>代码块体 {}</h4><pre><code>fun max(a: Int, b: Int): Int {
    return if (a &gt; b) a else b
}
</code></pre><ul>
<li>函数以fun开头，然后是函数名和参数列表，参数类型写在参数名后，以冒号隔开，最后是冒号和返回类型</li>
</ul>
<ul>
<li>注意在kotlin中大多数控制结果都是表达式，而不是语句，语句与表达式的最大区别在于表达式有值，允许直接嵌套使用</li>
</ul>
<p><br></p>
<h4 id="表达式体"><a href="#表达式体" class="headerlink" title="表达式体 ="></a>表达式体 =</h4><pre><code>fun max(a: Int, b: Int): Int = if (a &gt; b) a else b
</code></pre><ul>
<li><p>表达式也可以作为一个完整的函数体，现在你知道为什么kotlin要把返回类型放在函数头的最后面了</p>
</li>
<li><p>我们说过kotlin支持自动类型推断，因此上面的代码还可以简洁一下</p>
</li>
</ul>
<pre><code>fun max(a: Int, b: Int) = if (a \&gt; b) a else b
</code></pre><ul>
<li>在函数中支持表达式体的意义在于，向kotlin这种支持闭包的语言可以在任何地方将代码重用的粒度降到最细</li>
</ul>
<p><br></p>
<h3 id="变量-var-val"><a href="#变量-var-val" class="headerlink" title="变量 var val"></a>变量 var val</h3><p><br></p>
<h4 id="省略类型"><a href="#省略类型" class="headerlink" title="省略类型"></a>省略类型</h4><pre><code>val aString = &quot;I am String&quot;
val aInt = 1;
var aDouble = 2e6
var aFloat:Float
</code></pre><ul>
<li>在Java(jdk 10之前)中，声明变量时必须在最前面写出变量类型，在kotlin中，你甚至都不需要给出类型，编译器根据初始化的值可以知道你要的是什么，如果你不想那么快赋值，那就必须给出变量类型了</li>
</ul>
<ul>
<li>上面我们用到了var和val来声明变量，var表示可变引用，val表示不可变引用（final），并且val仅仅保证引用的不可变性，它指向的对象仍然是可变的</li>
</ul>
<pre><code>val aList = arrayListOf(&quot;java&quot;)
aList.add(&quot;kotlin&quot;)
</code></pre><ul>
<li>你应该尽可能地使用val来声明所有的变量，这会让代码更安全，也更接近函数式编程的风格</li>
</ul>
<p><br></p>
<h4 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板 ${}"></a>字符串模板 ${}</h4><pre><code>val he = &quot;Albert&quot;
val languages = arrayListOf(&quot;java&quot;)
languages.add(&quot;kotlin&quot;)
println(&quot;$he said, ${languages[1]} is the best language in the world &quot;)

//猜猜输出什么？
</code></pre><ul>
<li><p>字符串模板的作用是允许字符串字面量中存在变量和表达式，这显然让字符串拼接显得更加简洁紧凑，易于理解</p>
</li>
<li><p>可以使用$中支持变量，使用${}支持表达式</p>
</li>
</ul>
<p><br></p>
<h2 id="类基础和属性"><a href="#类基础和属性" class="headerlink" title="类基础和属性"></a>类基础和属性</h2><p><strong>Java常为人诟病的一点就是创建一个类需要非常多的样板代码（特别是对于bean类而言），为此不少ide或插件都提供了自动生成getter，setter，构造器，代码模板，万能tab的功能</strong></p>
<p><strong>但就像很多人认为的那样，某种程度上Java逐渐变成了一门“依赖ide”的语言</strong></p>
<p><strong>kotlin的开发者们为了解决这些问题可谓下足了功夫</strong></p>
<p><br></p>
<h3 id="属性-field"><a href="#属性-field" class="headerlink" title="属性 field"></a>属性 field</h3><pre><code>class Person(var name:String)
</code></pre><ul>
<li>上面这行kotlin代码展开成Java代码之后如下，你一定见过很多这样的Java代码，尽管从语法的角度来讲它们处处都有意义，但实际上你需要的关键词真的只有 class，Person，var，name ，String，这就是kotlin所谓的简洁，在kotlin当中，类通常很小</li>
</ul>
<pre><code>public class Person{
    private String name;

    public Person(String name){
        this.name = name;
    }

    public String getName(){
        return name;
    }

    public void setName(String name){
        this.name = name;
    }
}
</code></pre><ul>
<li>对于使用var修饰的属性，kotlin编译器会自动为其生成getter，setter，对于使用val修饰的属性，编译器则只生成getter，同时在访问和修改任何属性时，你不需要显式地调用它们的访问方法，对于构造方法而言，你也不用再写关键字new了</li>
</ul>
<pre><code>val albert = Person(&quot;Albert&quot;)
albert.name = &quot;Albert Lin&quot;
println(albert.name)
</code></pre><ul>
<li>所有属性都像Java中访问公有属性那样访问，但实际上走的是内部的getter和setter方法,当然这也包括了你所编写的getter和setter方法</li>
</ul>
<pre><code>class Rectangle(val height: Int, val width: Int) {
    val isSquare: Boolean
        get() {
            return height == width
        }

    //也可以简化为val isSquare: Boolean get() = height == width
}
</code></pre><ul>
<li>对于val属性，只允许有get方法而不允许设置set方法，同时val属性本身不允许修改。然而由于get方法本身并非需要与关联的属性有实际关系，所以get方法返回值不一定是固定的</li>
</ul>
<pre><code>class Rectangle(var height:Int, var width:Int){
    val isSquare: Boolean
        get() {
            return width == height
        }
}
fun main() {
    val p = Rectangle(1,1)
    assert(p.isSquare)
    p.width = 2
    assert(!p.isSquare)
}
</code></pre><ul>
<li>对于var属性，同时支持get和set方法，var属性的需要设置初始值，可以借助构造函数提供的属性。还要注意不管是get还是set方法，需要访问关联的属性时最好都使用关键字field，而不是变量名，否则容易因为自动调用的get和set方法造成循环递归导致栈溢出</li>
</ul>
<pre><code>class Rectangle(var height: Int, var width: Int) {
    var isSquare: Boolean = width == height &amp;&amp; width * height != 0
        get() {
            return width == height
        }

    set(value){
        field = value
    }
}
</code></pre><ul>
<li>具体来说，原因是在get和set方法中，get和set的自动调用依然是开启的，所以容易出现以下情况。注意有的情况lint无法检测出来，同时只有运行时访问到该属性时才会抛出StackOverflowError。本来get和set方法中就不应该有过多复杂的操作，尽量使用fiel关键字，谨慎调用其他方法即可</li>
</ul>
<pre><code>//无限递归get，ide有提示  
var isSquare: Boolean = false
        get() {
            if (isSquare) return true
            return false
        }
//无限递归set，ide有提示
var isSquare: Boolean = false
        set(value) {
            isSquare = value
        }
//get与set循环造成栈溢出，ide无提示
var isSquare: Boolean =false
        get() {
            isSquare = false
            return field
        }

            set(value){
            if(isSquare){
                field = true
            }else{
                field = value
            }
        }
//get与普通方法循环造成栈溢出，ide无提示
    var isSquare: Boolean =false
        get() {
            test()
            isSquare = false
            return field
        }

    private fun test(){
        var a = isSquare
    }
</code></pre><ul>
<li>如果需要限制访问权限，可以使用在get和set方法前使用修饰符，注意get的修饰符需要与属性前的修饰符一直，而set的修饰符访问权限需要小于或等于属性前的修饰符</li>
</ul>
<pre><code>var isSquare: Boolean = width == height &amp;&amp; width * height != 0
    get() {
        return width == height
    }
 private set(value) {
        field = value
    }
</code></pre><p><br></p>
<h3 id="包-import-package"><a href="#包-import-package" class="headerlink" title="包 import package"></a>包 import package</h3><ul>
<li>kotlin当中依然使用import和package关键字来组织代码结构，不同的是，在Java中，包结构需要与实际上的文件目录结构一致，kotlin则不做这种要求，你可以把所有文件都放到一个目录，只在package关键字后面声明它们所在的包</li>
</ul>
<ul>
<li>在通常情况下，程序员依然应该使用Java那样去管理文件，但是对于那些短小的类而言,你应该按照具体职责将它们放到同一个文件中</li>
</ul>
<pre><code>package  com.linjiamin.kt.play
class Rectangle(val height: Int, val width: Int) {
    val isSquare: Boolean get() = height == width
}
class Person(var name:String)
</code></pre><p><br></p>
<h3 id="枚举-enum"><a href="#枚举-enum" class="headerlink" title="枚举 enum"></a>枚举 enum</h3><ul>
<li>在kotlin当中，声明一个枚举类，需要 enum class 两个关键字</li>
</ul>
<pre><code>enum class Color{
    RED,ORANGE,YELLOW,GREEN,BLUE,INDIGO,VIOLET
}
</code></pre><ul>
<li>更常规的用法,为其添加构造方法和其他特定的方法，注意枚举列表必须与其他方法用分号隔开，这是kotlin中唯一一个必须使用分号结尾的地方。虽然使用val属性可以让其看起来更像枚举，但var属性也是可以的，这里和java没什么区别</li>
</ul>
<pre><code>enum class Color(val r: Int, val g: Int, val b: Int) {
    RED(255, 9, 9), ORANGE(255, 165, 0),
    GREEN(0, 255, 0), YELLOW(255, 255, 0),
    BLUE(0, 0, 255), INDIGO(75, 0, 130), VIOLET(238, 130, 238);

    fun rgb() = (r * 256 + g) * 256 + b
}
fun main(args:Array&lt;String&gt;){
    println(Color.BLUE.rgb())
}
</code></pre><p><br></p>
<h2 id="条件和分支"><a href="#条件和分支" class="headerlink" title="条件和分支"></a>条件和分支</h2><p><br></p>
<h3 id="分支-when"><a href="#分支-when" class="headerlink" title="分支 when"></a>分支 when</h3><ul>
<li>when 是 switch 的高级替代品</li>
</ul>
<ul>
<li>when 不但是分支控制语句，还是一个表达式，因此它具有返回值,并且不需要使用break语句，同时这个例子也体现了kotlin可以在函数中声明函数</li>
</ul>
<pre><code>fun main(args: Array&lt;String&gt;) {
    fun getColorName(color: Color) =
            when (color) {
                Color.RED -&gt; &quot;Red&quot;
                Color.ORANGE -&gt; &quot;Orange&quot;
                Color.GREEN -&gt; &quot;Green&quot;
                Color.BLUE -&gt; &quot;Blue&quot;
                Color.YELLOW -&gt; &quot;Yellow&quot;
                Color.INDIGO -&gt; &quot;Indigo&quot;
                Color.VIOLET -&gt; &quot;Violet&quot;
            }

    println(getColorName(Color.BLUE))
}
</code></pre><ul>
<li>你可以使用列表的形式合并分支减少重复代码,使用import语句可以导入枚举类的所有常量，不再需要使用类名来引用</li>
</ul>
<pre><code>import com.linjiamin.kt.play.Color.\*
fun main(args: Array&lt;String&gt;) {
    fun getWarmth(color: Color) =
            when (color) {
                RED,
                ORANGE,
                YELLOW -&gt; &quot;warm&quot;

                BLUE,
                INDIGO,
                VIOLET -&gt; &quot;cold&quot;

                GREEN -&gt; &quot;neutral&quot;
            }

    println(getWarmth(Color.ORANGE))
}
</code></pre><ul>
<li>在java 12(预览版，需使用参数开启)当中已经在switch中提供了上面这两个例子中一模一样的特性，下面为java暂时不会提供的特性，估计以后也不太可能提供这样的语法糖</li>
</ul>
<p><br></p>
<h3 id="when-支持任意对象"><a href="#when-支持任意对象" class="headerlink" title="when 支持任意对象"></a>when 支持任意对象</h3><ul>
<li>在java中，case标签只支持枚举常量，字符串和数字字面量，而在 kotlin中，when支持所有对象,在下面这个例子当中，我们传入两个Color并使用setOf函数将他们合成为一个set对象，编译器能够推断出这种set共有多少种可能的情况，但注意当前版本中下面的else不是必须的，也就是说不必列出所有可能的情况</li>
</ul>
<pre><code>fun mix(c1: Color, c2: Color) =
        when (setOf(c1, c2)) {
            setOf(RED, YELLOW) -&gt; ORANGE
            setOf(YELLOW, BLUE) -&gt; GREEN
            setOf(BLUE, VIOLET) -&gt; INDIGO
            else -&gt; throw Exception(&quot;Dirty Color&quot;)
        }
fun main(args: Array&lt;String&gt;) {
    println(mix(RED,YELLOW))
}
</code></pre><p><br></p>
<h3 id="when-不带参数"><a href="#when-不带参数" class="headerlink" title="when 不带参数"></a>when 不带参数</h3><ul>
<li>在 when 当中 构造 setOf 会带来性能上的损耗，使用不带参数的when可以解决这种问题，但是可读性会下降，else同样不是必须的</li>
</ul>
<pre><code>fun mixOptimized(c1: Color, c2: Color) = when {
    (c1 == RED &amp;&amp; c2 == YELLOW) || (c1 == YELLOW &amp;&amp; c2 == RED) -&gt;
        ORANGE

    (c1 == YELLOW &amp;&amp; c2 == BLUE) || (c1 == BLUE &amp;&amp; c2 == YELLOW) -&gt;
        GREEN

    (c1 == BLUE &amp;&amp; c2 == VIOLET) || (c1 == VIOLET &amp;&amp; c2 == BLUE) -&gt;
        INDIGO

    else -&gt; throw Exception(&quot;dirty color&quot;)
}
fun main(args: Array&lt;String&gt;) {
    println(mixOptimized(RED, YELLOW))
}
</code></pre><p><br></p>
<h3 id="类型检查-is"><a href="#类型检查-is" class="headerlink" title="类型检查 is"></a>类型检查 is</h3><ul>
<li>使用 is 关键字可以进行类型检查和自动转换类型，类似java中的instanceOf，但 is 显然更加简洁</li>
</ul>
<pre><code>class Dog {
    fun bark() {
        println(&quot;bark&quot;)
    }
}
class Duck {
    fun swim() {
        println(&quot;swim&quot;)
    }
}
fun test(animal: Any) = when (animal) {
    is Dog -&gt; {
        print(&quot;I am a dog,I can &quot;)
        animal.bark()
        &quot;wan !&quot;
    }

    is Duck -&gt; {
        print(&quot;I am a duck,I can &quot;)
        animal.swim()
        &quot;ga !&quot;
    }
    else -&gt; throw IllegalArgumentException()
}
fun main(args: Array&lt;String&gt;) {
    println(test(Dog()))
    println(test(Duck()))
}
//输出
//I am a dog,I can bark
//wan !
//I am a duck,I can swim
//ga !
</code></pre><ul>
<li>注意在kotlin中，分支可以是代码块，这个时候代码块中的最后一个表达式会作为when或其他表达式的值，实际上在局部定义域中可以放入下面这样的代码，除了最后一行有可能作为表达式值利用以外，其他都是无意义的</li>
</ul>
<pre><code>1
1.0
&quot;1&quot;
true
</code></pre><p><br></p>
<h2 id="迭代和区间"><a href="#迭代和区间" class="headerlink" title="迭代和区间"></a>迭代和区间</h2><p><br></p>
<h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><ul>
<li>在 kotlin 中的 while 和 do while 结构和 java 没有任何区别，这里就不讲解了</li>
</ul>
<p><br></p>
<h3 id="区间-in"><a href="#区间-in" class="headerlink" title="区间 in"></a>区间 in</h3><ul>
<li>使用 in 可以使用在for中指示一个区间，在kotlin中区间是包含的，或者说闭合的</li>
</ul>
<pre><code>fun main(args: Array&lt;String&gt;) {
    for(i in 1..100){
        print(&quot; $i&quot;)
    }
}
</code></pre><ul>
<li>上面的操作没什么新意，看看下面这几行，kotlin 中的迭代区间不仅支持数字还支持字符，在区间可以使用downto指定方向，使用step指定步长</li>
</ul>
<pre><code>fun main(args: Array&lt;String&gt;) {
    for(c in &apos;A&apos;..&apos;Z&apos; step 3 )
        print(&quot;$c&quot;)
}
fun main(args: Array&lt;String&gt;) {
    for(i in 100 downTo 1 step 3 )
        print(&quot;$i&quot;)
}
</code></pre><ul>
<li>更多时候我们需要的是半闭合的区间，这种时候可以使用 until 关键字,下面这个例子中100不会被输出</li>
</ul>
<pre><code>fun main(args: Array&lt;String&gt;) {
    for(i in 0 until 100 )
        print(&quot; $i&quot;)
}
</code></pre><p><br></p>
<h3 id="map-迭代"><a href="#map-迭代" class="headerlink" title="map 迭代"></a>map 迭代</h3><ul>
<li>for 循环允许展开迭代中的集合的元素，例如下面这个例子中将map的键值对存储到两个独立的变量当中，在这个例子中集合看起来更像数组，是的，kotlin中可以使用中括号来代替get和put方法</li>
</ul>
<pre><code>val binReps = TreeMap&lt;Char,String&gt;()
fun test() {
    for(c in &apos;a&apos; .. &apos;f&apos;){
        val bin = Integer.toBinaryString(c.toInt())
        binReps[c] = bin
    }
    for ((letter,binary) in binReps){
        println(&quot;$letter = $binary&quot;)
    }
}
val list = arrayListOf(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;)
fun test() {
    for ((index,element) in list.withIndex()){
            println(&quot;$index = $element&quot;)
    }
}
</code></pre><p><br></p>
<h3 id="in-检查区间"><a href="#in-检查区间" class="headerlink" title="in 检查区间"></a>in 检查区间</h3><ul>
<li>使用in和!in可以检查区间中的成员，即检查某个值是否在区间当中</li>
</ul>
<pre><code>fun isLetter(c: Char) = c in &apos;a&apos;..&apos;z&apos; || c in &apos;A&apos;..&apos;z&apos;
fun isNotDigit(c: Char) = c !in &apos;0&apos;..&apos;9&apos;
fun main(args: Array&lt;String&gt;) {
    print(isLetter(&apos;c&apos;))
    print(isNotDigit(&apos;c&apos;))
}
</code></pre><p><br></p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ul>
<li>kotlin中异常与java相似，不过不必使用new关键字来创建一个异常的实例，同时throw结构是一个表达式</li>
</ul>
<pre><code>val percentage = if (number in 0..100)
    number
else throw IllegalArgumentException(&quot;a percentage value must be between 0 and 100:$number&quot;)
</code></pre><p><br></p>
<h3 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try catch finally"></a>try catch finally</h3><ul>
<li>kotlin不区分受检异常和未受检异常，因此不需要使用throw关键字来声明方法可能抛出的异常</li>
</ul>
<pre><code>fun readNumber(reader: BufferedReader) :Int? {
    try {
        val line = reader.readLine()
        return Integer.parseInt(line)

    }catch (e:NumberFormatException){
        return null
    }finally {
        reader.close()
    }
}
</code></pre><p><br></p>
<h3 id="try-表达式"><a href="#try-表达式" class="headerlink" title="try 表达式"></a>try 表达式</h3><ul>
<li>在kotlin中try和when以及if一样，引入了表达式，如果语句中包括多个表达式，那么最后一个表达式的值就是try表达式的值，如果中间抛出了异常，那么catch表达式的值就是最终的值</li>
</ul>
<pre><code>fun readNumber(reader: BufferedReader) {
    val number = try {
        Integer.parseInt(reader.readLine())
    }catch (e:NumberFormatException){
        null
    }
    print(number)
</code></pre><p><br></p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><ul>
<li>使用 xxxOf 可以直接创建集合实例，对于map这种基于键值对的集合，使用to关键字</li>
</ul>
<pre><code>var arrayList = arrayListOf(1, 2, 3)
var hashSet = hashSetOf(1, 2, 3)
var hashmap = hashMapOf(1 to &quot;one&quot;, 2 to &quot;two&quot;, 3 to &quot;3&quot;)

var list = listOf(1,2,3)
var set = setOf(1,2,3)
var map = mapOf(1 to &quot;one&quot;, 2 to &quot;two&quot;, 3 to &quot;3&quot;)
</code></pre><ul>
<li>kotlin没有使用自己的集合类，而是直接使用了java的集合类，比如arrayList，hashSet这种指定了明确类型的就对应到指定的类，list，set，map则对应到，arraylist，linkedHashSet，linkedHashMap</li>
</ul>
<pre><code>println(list.javaClass)
</code></pre><ul>
<li>除了java集合中本来提供的方法外，kotlin还添加了许多很方便的方法以供调用</li>
</ul>
<pre><code>println(list.first())
println(list.last())
println(list.max())
println(list.asReversed())
</code></pre><p><br></p>
<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p><br></p>
<h3 id="命名参数"><a href="#命名参数" class="headerlink" title="命名参数"></a>命名参数</h3><ul>
<li>使用 参数名 = 参数值 可以显式指定参数名称，让代码可读性更强，一旦一个参数使用了命名，随后的参数都需要命名，开始命名之后，参数的位置就不重要了，不需要按函数声明的顺序一样传入</li>
</ul>
<pre><code>fun main() {
    println(joinToString(
            listOf(1, 2, 3)
            , separator = &quot;,&quot;
            , postfix = &quot;]&quot;
            , prefix = &quot;[&quot;
        )
    )
}
fun &lt;T&gt; joinToString(
    collection: Collection&lt;T&gt;,
    separator: String,
    prefix: String,
    postfix: String
): String {
    val result = StringBuilder(prefix)
    for ((index, element) in collection.withIndex()) {
        if (index &gt; 0) result.append(separator)
        result.append(element)
    }
    result.append(postfix)
    return result.toString()
}
</code></pre><p><br></p>
<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><ul>
<li>使用 xxx:xxx = 默认值 可以指定参数的默认值，某参数指定默认值之后就可以不传入其值了</li>
</ul>
<pre><code>fun main() {
    println(joinToString(listOf(1, 2, 3)))
}
fun &lt;T&gt; joinToString(
    collection: Collection&lt;T&gt;,
    separator: String = &quot;,&quot;,
    prefix: String = &quot;[&quot;,
    postfix: String = &quot;]&quot;
): String {
    val result = StringBuilder(prefix)
    for ((index, element) in collection.withIndex()) {
        if (index &gt; 0) result.append(separator)
        result.append(element)
    }
    result.append(postfix)
    return result.toString()
}
</code></pre><ul>
<li>但是引入默认值之后时的函数的动态绑定会更加复杂，比如再上面的例子中我们再加入名称相同的函数，但添加一个具有默认值的参数，这个时候如果不知道内部调用规则我们无法判断哪个函数会被执行。实际上简单的函数的优先级更高，所以下面这个函数不会被调用</li>
</ul>
<pre><code>fun &lt;T&gt; joinToString(
    collection: Collection&lt;T&gt;,
    separator: String = &quot;,&quot;,
    prefix: String = &quot;[&quot;,
    postfix: String = &quot;]&quot;,
    test: Boolean = false
): String {
    return &quot;&quot;
}
</code></pre><ul>
<li>假如现在我们给原来的 joinToString 函数也添加一个带默认值的参数，这个时候编译会不通过，因为无法判断需要调用那个函数，但值得注意的是如果这个时候没有任何地方调用了这（两）个函数，那么编译是不会报错的，因为没有地方需要进行静态类型检查</li>
</ul>
<pre><code>fun main() {
    println(joinToString(listOf(1, 2, 3),prefix = &quot;[&quot;))
}
fun &lt;T&gt; joinToString(
    collection: Collection&lt;T&gt;,
    separator: String = &quot;,&quot;,
    prefix: String,
    postfix: String = &quot;]&quot;,
    test:Int = 0
): String {
    val result = StringBuilder(prefix)
    for ((index, element) in collection.withIndex()) {
        if (index &gt; 0) result.append(separator)
        result.append(element)
    }
    result.append(postfix)
    return result.toString()
}
fun &lt;T&gt; joinToString(
    collection: Collection&lt;T&gt;,
    separator: String = &quot;,&quot;,
    prefix: String = &quot;[&quot;,
    test: Boolean = false,
    postfix: String = &quot;]&quot;
): String {
    return &quot;&quot;
}
</code></pre><p><br></p>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><ul>
<li>kotlin提供java类似的可变参数，但是使用起来比java更具有弹性。使用可变参数，需要指定关键字vararg，可变参数既可以传入不定个数量的指定类型参数，也可以传入数组，传入数组时需要使用展开运算符*，展开运算符的意义是将数组中的对象展开为参数列表，因此数组的前后依然可以添加参数，比java方便 </li>
</ul>
<pre><code>fun test(vararg values:Int){
}
fun main(){
    test(1,2,3)

    var array = intArrayOf(1,2,3)
    test(0,*array,4)
}
</code></pre><p><br></p>
<h2 id="扩展功能"><a href="#扩展功能" class="headerlink" title="扩展功能"></a>扩展功能</h2><p><br></p>
<h3 id="包扩展"><a href="#包扩展" class="headerlink" title="包扩展"></a>包扩展</h3><ul>
<li>给已有的包提供扩展的函数，在一个独立的文件中将package指定为需要扩展的包即可，这时候函数不属于任何类，在需要调用时直接import即可，比起java中常见的util类，由于不用使用类名，相对简洁，同时也减少了重复功能的函数，因为这样的函数相对容易查找。</li>
</ul>
<pre><code>package strings
fun &lt;T&gt; joinToString ...
import strings.\*
//或者
import strings.joinToString
fun test() {
    joinToString()
}
</code></pre><ul>
<li>包扩展函数的实现原理是生成将函数编译为带对应静态方法的java类，类名默认为首字母大写的文件名+Kt，也可以使用 @file:JvmName(\“类名\”)进行自定义</li>
</ul>
<pre><code>//in join.kt  
JoinKt.joinToString();
</code></pre><ul>
<li>同样可以给已有的包提供扩展的属性，可以指定为val或var，get set特性的在这里依然支持，如果需要指定常量（java中的public static final）可以使用const val，const val不支持get set特性</li>
</ul>
<pre><code>package strings
var test:Int = 0
get() {
    return field
}
</code></pre><p><br></p>
<h3 id="类扩展"><a href="#类扩展" class="headerlink" title="类扩展"></a>类扩展</h3><ul>
<li>给已有的类提供扩展的函数，只是在普通的函数声明中的名称之前加上 类名. 即可，在方法体中使用this来访问对象，但依然受访问权限的限制，比如可能无法访问prviate或protected成员和函数</li>
</ul>
<pre><code>fun String.lastChar():Char = this.get(this.length-1)
//...
fun main(){
    println(&quot;a&quot;.lastChar())
}
</code></pre><ul>
<li>扩展函数和成员函数之间都可以互相调用</li>
</ul>
<pre><code>fun AAA.aTest(){
}
fun AAA.BTest(){
    this.aTest()
}
</code></pre><ul>
<li>类的扩展函数同样被编译为静态函数，只是第一个参数是类的实例，其他规则和包扩展函数一致，这里不重复</li>
</ul>
<ul>
<li>同样也可以对属性进行扩展，由于并不能实际给类添加属性，因此内部并没有实际的空间来存储这个属性的值，所以扩展属性不能初始化，也不能使用field关键字。kotlin实战中的例子不是很好，书中说不可变类型不能使用var，这非常容易让人误解，实际上不管什么类型，从语法上都是可以使用var和val的，只是对于不可变类型，一般没有可以修改属性的方法，同时内部属性通常为final，所以常规实现中我们在set函数中没有途径修改对象的属性，对于可变类型，就没有这种约束，我们可以修改它的属性。以上只针对不借用其他对象来手动存储的情况。</li>
</ul>
<pre><code>//不可变类
//val.
val String.lastChar: Char
get() = get(length-1)
//var
var String.lastChar: Char
get() = get(length-1)
set(value:Char){
//nothing we can do here
}
fun main(){
    println(&quot;a&quot;.lastChar)
}
//可变类
var StringBuilder.lastChar: Char
get() = get(length-1)
set(value:Char){
    this.setCharAt(length-1,value)
}
</code></pre><p><br></p>
<h3 id="局部函数"><a href="#局部函数" class="headerlink" title="局部函数"></a>局部函数</h3><ul>
<li>相比java，kotlin支持真正的闭包，在函数当中可以定义局部函数，局部函数可以调用外部函数中的局部变量，局部函数在扩展函数，get set函数中都适用</li>
</ul>
<pre><code>fun checkUser(user:User) {
    val throwEx = true
    fun checkEmpty(str:String){
        if(str.isEmpty()){
           if(throwEx)throw IllegalArgumentException()
        }
    }
    checkEmpty(user.name)
    checkEmpty(user.address)
}
</code></pre><p><br></p>
<h3 id="中缀和解构"><a href="#中缀和解构" class="headerlink" title="中缀和解构"></a>中缀和解构</h3><ul>
<li>infix：我们在使用map时遇到过to来构造键值对，实际上to不是一个关键字，而是一个特殊的函数，只不过需要使用中缀调用，中缀函数和类扩展函数的声明类似，只是需要在前面加入infix关键字</li>
</ul>
<pre><code>fun main() {
    val array = 1 fillTo 100
    println(array[2])
}
infix fun Int.fillTo(other: Int): Array&lt;Int&gt; {
    val result = Array(init = {0}, size = other - this)

    for (i in this until other) {
        result[i - this] = i
    }
    return result
}
</code></pre><ul>
<li>to函数的实现如下</li>
</ul>
<pre><code>infix fun Any.to(other: Int) = Pair(this,other)
</code></pre><ul>
<li>对于pair和其他key value的地方我们可以使用类似js中的解构声明来创建类实例</li>
</ul>
<pre><code>val(number,name) = 1 to &quot;one&quot;
</code></pre><p><br></p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p><br></p>
<h3 id="正则扩展"><a href="#正则扩展" class="headerlink" title="正则扩展"></a>正则扩展</h3><ul>
<li>split：string 支持和java相同的正则功能，不过对于常用的split函数，kotlin更加人性化，类似 . | 等在正则中使用的符号会被当做普通的字符来使用，同时支持可变参数</li>
</ul>
<pre><code>println(&quot;a.b.c-d|e&quot;.split(&quot;.&quot;,&quot;-&quot;,&quot;|&quot;))
</code></pre><ul>
<li>Regex：相对的如果想要使用正则字符串，则可以通过string的扩展函数toRegex，转化为正则对应的类</li>
</ul>
<pre><code>println(&quot;a.b.c-d-e&quot;.split(&quot;\\.|-&quot;.toRegex()))
</code></pre><p><br></p>
<h3 id="三重引号"><a href="#三重引号" class="headerlink" title="三重引号"></a>三重引号</h3><ul>
<li>三重引号可以用于避免转义字符，并且三重字符串中包括了缩进，可以包括换行</li>
</ul>
<pre><code>var str =
    &quot;&quot;&quot;
    .
    &quot;&quot;
    \AAAA
    [BBBBB
    ////
    ///
    //
    /
    /
    &quot;&quot;
</code></pre><ul>
<li>trimMargin：string还提供了一个很方便的trimMargin扩展函数，可以将三重字符串中的字符用空格和特殊字符串将整体内容移动到合适的位置，在需要使用的时候调用该函数进行还原</li>
</ul>
<pre><code>var str =
    &quot;&quot;&quot;
    |.
    |&quot;&quot;
    |\AAAA
    |[BBBBB
    |////
    |///
    |//
    |/
    |/
    &quot;&quot;&quot;

println(str.trimMargin(&quot;|&quot;))
</code></pre><p><br></p>
<h2 id="类和接口"><a href="#类和接口" class="headerlink" title="类和接口"></a>类和接口</h2><p><strong>kotlin的类和接口和java中的类和接口具有一定的区别，比如接口可以包含属性，嵌套类默认不是内部类，类同时提供默认了</strong></p>
<p><br></p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul>
<li>kotlin和java中接口类似，只是用冒号替代了implements和extends关键字，同时提供了override关键字，override关键字是强制要求的，如果缺少将不能通过编译</li>
</ul>
<pre><code>interface  Clickable{
    fun click()
}
class Button:Clickable{
    override fun click() = println(&quot;click&quot;)
}
</code></pre><ul>
<li>接口中支持默认函数，不同于java8的默认方法，它不需要default关键字，注意不管是在kotlin还是在java当中，如果类或接口相关联的多个接口中有相同的函数（方法），则该类或接口必须对该函数（方法）进行重写，否则编译不通过</li>
</ul>
<pre><code>interface  Clickable{
    fun click() = println(&quot;default&quot;)
}
</code></pre><p><br></p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul>
<li>open &amp; final：kotlin使用open和final关键字来表面类是否允许继承以及函数是否允许重写，若不声明则默认为final，这是基于如果没有为继承做好准备就不应该提供继承功能这种思想而设计的，子类默认还是final的，但子类中重写子父类的函数默认是open的，除非显式指定为final</li>
</ul>
<pre><code>open class Button: Clickable{
    override fun click(){}
    open fun disable(){}
}
class SubButton: Button() {
    override fun disable(){}
}
</code></pre><ul>
<li>abstract：kotlin支持和java类似的abstract关键字，没有需要特别注意的地方</li>
</ul>
<pre><code>abstract class Button: Clickable{ 
    override fun click(){}
    abstract fun animate()
}
</code></pre><p><br></p>
<h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><ul>
<li>protected：kotlin支持 public protected private 修饰符，作用与java中的类似，需要关注的是默认的修饰符是public而不是protected，并且protected的行为与java有差异，protected只提供类自身和子类范围的可见性而不提供包级别的可见性，同时限制于之前提到的protected的实现机制，扩展函数也不允许访问private和protected属性</li>
</ul>
<pre><code>open class Button : Clickable {
     protected val aProtectedField: Int = 0
}
class Test {
    fun test() {
        var obj = Button()
        //报错
        obj.aProtectedField
    }
}
</code></pre><ul>
<li>internal：另外kotlin还支持internal关键字，用于将类型限制在模块范围内，类似dart提供的特性，模块也就是idea或android studio中的module，本质是一组一起编译的文件，可以在函数或类级别上使用internal关键字</li>
</ul>
<pre><code>internal class ClassInAnotherMoudle{
    internal fun test(){
        println()
    }
}
</code></pre><p><br></p>
<h3 id="内部类-inner"><a href="#内部类-inner" class="headerlink" title="内部类 inner"></a>内部类 inner</h3><ul>
<li>inner：kotlin支持类似java中的内部类和静态内部类，但kotlin中并没有static关键字，因为在kotlin中定义在一个class中的class默认是嵌套类（类比java中的静态内部类），如果需要指定为内部类则需要使用inner关键字，嵌套类不会持有外部类的引用，因此更加有利于实现序列化和反序列化</li>
</ul>
<pre><code>class Button : Clickable {
    var aField: Int = 0

    inner class Test {

        fun test{ aField = 1 }

        fun getOuter():Button = this@Button
    }
}
</code></pre><ul>
<li>this@：在内部类获取外部类的引用不是使用java中的 类型.this 而是使用 this@ 类型</li>
</ul>
<p><br></p>
<h3 id="封装类-sealed"><a href="#封装类-sealed" class="headerlink" title="封装类 sealed"></a>封装类 sealed</h3><ul>
<li>在使用when控制分支时，如果使用了when的返回值，则需要覆盖所有分支情况，因此通常需要使用else关键字处理省缺的情况，这样在软件迭代过程中很出现漏判的情况，kotlin提供了解决这种问题的方法</li>
</ul>
<pre><code>interface Expr
class Num(val value: Int) : Expr
class Sum(val left: Expr, val right: Expr) : Expr
fun eval(e: Expr): Int = when (e) {
    is Num -&gt; e.value
    is Sum -&gt; eval(e.right) + eval(e.left)
    else -&gt; throw IllegalArgumentException()
}
</code></pre><ul>
<li>sealed：使用封装类将需要的类型全部定义为嵌套类，则不需要指定所有分支，但注意前提条件是指定为sealed的类型没有其嵌套类以外的子类，sealed可以使添加新类型之后，未经过处理的when语句报错，而不是像上一段代码一样正常通过。注意sealed修饰的类默认是open的</li>
</ul>
<pre><code>sealed class Expr{
class Num(val value: Int) : Expr()
class Sum(val left: Expr, val right: Expr) : Expr()
}
fun eval(e: Expr): Int = when (e) {
    is Expr.Num -&gt; e.value
    is Expr.Sum -&gt; eval(e.right) + eval(e.left)
}
</code></pre><p><br></p>
<h3 id="主构造函数"><a href="#主构造函数" class="headerlink" title="主构造函数"></a>主构造函数</h3><ul>
<li>在kotlin中可以使用非常简短的代码生成一个构造完整的类，下面的代码其实是主构造函数的简略形式，所有类都包含一个主构造函数</li>
</ul>
<pre><code>class User(val nickname:String)
</code></pre><ul>
<li>constructor &amp; init：上面的代码展开之后其实是这样子的，constructor用于声明一个构造函数，当用在类声明的行中说明是主构造函数，当用在类内部时则是从构造函数。init关键字类似java中的初始化块，因为在class的代码块体内只能做属性的声明和初始化语句，以及函数的声明和定义，而init闭包中可以有普通的逻辑代码，可以处理复杂的初始化情况，当然对于简单的情况则完全可以省略</li>
</ul>
<pre><code>class User constructor(nickname:String){
    val nickname:String 

    init {
        this.nickname = nickname
    }
}
//等价于
class User constructor(nickname:String){
    val nickname:String = nickname
}
//等价于
class User constructor(val nickname: String)
//等价于
class User (val nickname: String)
</code></pre><ul>
<li>和普通函数一样，构造函数也支持使用默认参数</li>
</ul>
<pre><code>class User (val nickname: String = &quot;&quot;)
</code></pre><ul>
<li>如果子类的主构造函数需要调用父类的主构造函数，则可以直接在父类声明之后调用，如果子类没有提供任何构造函数或只声明了主构造函数，则需要显示调用父类的构造函数，当一个基类没有声明任何构造函数，编译器将会自动生成一个没有参数的构造函数，即()</li>
</ul>
<pre><code>open class Person (val nickname: String){
    //...
}
class User (nickname:String): Person(nickname)
</code></pre><ul>
<li>如果希望类不能被外部实例化（用于静态工具或单例）则可以使用private关键字</li>
</ul>
<pre><code>class User private constructor() : Person()
//报错
val usr = User()
</code></pre><p><br></p>
<h3 id="从构造函数"><a href="#从构造函数" class="headerlink" title="从构造函数"></a>从构造函数</h3><ul>
<li>为了给一个类提供更多的构造函数，可以使用从构造函数，不像主构造函数，从构造函数可以定义多个，需要调用同一类的其他构造函数可以使用this关键字，同时init关键字依然可以使用</li>
</ul>
<pre><code>class User{
    init{
        //...
    }

    constructor(aInt:Int){
        //...
    }

    constructor(aInt:Int,aStr:String):this(aInt,aStr,false){
        //...
    }

    constructor(aInt:Int,aString:String,aBoolean:Boolean){
        //...
    }
}
</code></pre><ul>
<li>如果一个类具有主构造函数，则从构造函数必须调用主构造函数</li>
</ul>
<pre><code>class User(){
    constructor(aInt:Int) : this() {
        //...
    }
}
</code></pre><ul>
<li>另外一个特殊的限制是，如果父类没有无参的构造函数，则子类的从构造函数必须调用super或者this，这里的无参构造函数即可以是父类的主构造函数又可以是从构造函数</li>
</ul>
<pre><code>class NewUser: User {
    constructor(aInt:Int,aBoolean:Boolean) : super(aInt) {

        //...
    }
}
</code></pre><p><br></p>
<h3 id="接口属性"><a href="#接口属性" class="headerlink" title="接口属性"></a>接口属性</h3><ul>
<li>kotlin的接口中允许声明属性，但这种属性声明是抽象的，需要由实现类来实现，实现的方法由三种，通过主构造函数，通过属性覆盖，通过get函数，注意其中get函数的实现，不会为属性创建空间</li>
</ul>
<pre><code>interface User{
    val nickname:String
}
class User1(override var nickname:String):User
class User3 :User{
    override val nickname = &quot;&quot;
}
class User2 :User{
    override val nickname:String
    get() = &quot;&quot;
}
</code></pre><p><br></p>
<h3 id="object-函数"><a href="#object-函数" class="headerlink" title="object 函数"></a>object 函数</h3><ul>
<li>在kotlin中所有类的根类型都是Any，Any类只提供了和java中object类相似的几个方法，包括 equals，hashcode，toString，any类如下</li>
</ul>
<pre><code>package kotlin

/\*\*
 * The root of the Kotlin class hierarchy. Every Kotlin class has [Any] as a superclass.
 \*/
public open class Any {
    /**
     * Indicates whether some other object is &quot;equal to&quot; this one. Implementations must fulfil the following
     * requirements:
     *
     * * Reflexive: for any non-null value `x`, `x.equals(x)` should return true.
     * * Symmetric: for any non-null values `x` and `y`, `x.equals(y)` should return true if and only if `y.equals(x)` returns true.
     * * Transitive:  for any non-null values `x`, `y`, and `z`, if `x.equals(y)` returns true and `y.equals(z)` returns true, then `x.equals(z)` should return true.
     * * Consistent:  for any non-null values `x` and `y`, multiple invocations of `x.equals(y)` consistently return true or consistently return false, provided no information used in `equals` comparisons on the objects is modified.
     * * Never equal to null: for any non-null value `x`, `x.equals(null)` should return false.
     *
     * Read more about [equality](https://kotlinlang.org/docs/reference/equality.html) in Kotlin.
     */
    public open operator fun equals(other: Any?): Boolean

    /**
     * Returns a hash code value for the object.  The general contract of `hashCode` is:
     *
     * * Whenever it is invoked on the same object more than once, the `hashCode` method must consistently return the same integer, provided no information used in `equals` comparisons on the object is modified.
     * * If two objects are equal according to the `equals()` method, then calling the `hashCode` method on each of the two objects must produce the same integer result.
     */
    public open fun hashCode(): Int

    /**
     * Returns a string representation of the object.
     */
    public open fun toString(): String
}
</code></pre><ul>
<li>any类的方法都支持重写，同时在java中的经验同样也适用于kotlin</li>
</ul>
<pre><code>class User(val name:String){
    override fun toString():String = name
}

val a = &quot;&quot; + User(&quot;a&quot;)
</code></pre><ul>
<li>特别需要注意的是，equals和 == 在 kotlin当中是等价的，equals返回true则 == 表达式的值也是 true</li>
</ul>
<pre><code>fun main() {
    println(User(&quot;&quot;) == User(&quot;&quot;))
}

class User(val name:String){

    override fun equals(other: Any?): Boolean {
        if(other == null || other !is User){
            return false
        }
        return this.name.equals(other.name)
    }
}
</code></pre><p><br></p>
<h3 id="数据类-data"><a href="#数据类-data" class="headerlink" title="数据类 data"></a>数据类 data</h3><ul>
<li>data：java的idea通常都提供快捷生成toString，equals方法的功能，但在kotlin当中则直接提供了语言层面上的支持，使用data关键字声明为数据类即可，数据类非常适合用于我们java中的bean（pojo）类</li>
</ul>
<pre><code>fun main() {
    println(Client(&quot;&quot;,1).toString())
    println(Client(&quot;&quot;,1).hashCode())
    println(Client(&quot;&quot;,1) == Client(&quot;&quot;,1))
}

data class Client(val name:String,val postalCode:Int)
</code></pre><p><br></p>
<h3 id="类委托-by"><a href="#类委托-by" class="headerlink" title="类委托 by"></a>类委托 by</h3><ul>
<li>如果不依赖语言特性，在kotlin使用装饰器模式是想下面这个样子的，非常繁琐</li>
</ul>
<pre><code>class DelegatingCollection&lt;T&gt; : Collection&lt;T&gt; {

    private val innerList = arrayListOf&lt;T&gt;()

    override val size: Int get() = innerList.size
    override fun contains(element: T) = innerList.contains(element)
    override fun containsAll(elements: Collection&lt;T&gt;) = innerList.containsAll(elements)
    override fun isEmpty() = innerList.isEmpty()
    override fun iterator() = innerList.iterator()
}
</code></pre><ul>
<li>by：kotlin为委托提供了语言层面上的支持，需要在主构造函数中声明被委托的实例，然后使用by关键字，委托类中的函数会自动生成，如有需要可以自己重写</li>
</ul>
<pre><code>class DelegatingCollection&lt;T&gt; (
    innerList:Collection&lt;T&gt; = ArrayList()
) : Collection&lt;T&gt; by innerList{

    override fun isEmpty(): Boolean {
        // ...
    }
}
</code></pre><p><br></p>
<h3 id="对象类声明-object"><a href="#对象类声明-object" class="headerlink" title="对象类声明 object"></a>对象类声明 object</h3><ul>
<li>object：object关键字用于在声明类的同时创建唯一实例，原本在class内部中的语法都适用，在顶层object声明对象可以像其他顶层对象一样访问</li>
</ul>
<pre><code>fun main() {
    Singleleton.meth()
    Singleleton.aInt = 1
}

object Singleleton {
    var aInt: Int = 1

    fun meth(){
        println(aInt)
    }
}
</code></pre><ul>
<li>object声明也支持嵌套类，访问时需要加上类名</li>
</ul>
<pre><code>fun main() {
    val persons = listOf(Person(&quot;bob&quot;),Person(&quot;Alice&quot;))
    persons.sortedWith(Person.NameComparator)
}

data class Person(val name:String){

    object NameComparator : Comparator&lt;Person&gt;{
        override fun compare(o1: Person?, o2: Person?) 
                = o1.name.compareTo(o2.name)
    }
}
</code></pre><p><br></p>
<h3 id="伴生对象-companion"><a href="#伴生对象-companion" class="headerlink" title="伴生对象 companion"></a>伴生对象 companion</h3><ul>
<li>引用嵌套类对象声明，看起来像在引用一个类的静态成员，但是kotlin中类并不能拥有静态成员，实际上kotlin也没有static关键字，但可以使用伴生对象实现类似的语法功能</li>
</ul>
<pre><code>fun main() {
    Person.fromJson(&quot;{ ... }&quot;)
}

class Person(val name:String){
    companion object{
        fun fromJson(jsonText:String) : Person = 
    }
}
</code></pre><ul>
<li>伴生对象可以有可选的命名，默认命名为Companion，调用时命名也是可选的</li>
</ul>
<pre><code>class Person(val name:String){
    companion object Loader{
        var aInt:Int = 1
        fun fromJson(jsonText:String) : Person = Person(&quot;&quot;)
    }
}
</code></pre><ul>
<li>伴生对象可以有父类或实现接口，同时可以使用其命名添加扩展函数</li>
</ul>
<pre><code>class Person(val name:String){
    companion object: Test() {
        var aInt:Int = 1
        fun fromJson(jsonText:String) : Person = Person(&quot;&quot;)
    }
}

fun Person.Companion.meth(){
}
</code></pre><ul>
<li>object还可以用于声明匿名内部类，与java不同函数中的局部变量可以被匿名内部类访问和修改，不需要被final限制</li>
</ul>
<pre><code>window.addMouseListener(object : MouseAdapter(){
    override fun mouseClicked(e: MouseEvent?) {

    }

    override fun mouseEntered(e: MouseEvent?) {

    }
})

var count = 0
val listener = object : MouseAdapter(){
    override fun mouseClicked(e: MouseEvent?) {
        count ++
    }

    override fun mouseEntered(e: MouseEvent?) {

    }
}

window.addMouseListener(listener)
</code></pre><p><br></p>
<h2 id="lambda和序列"><a href="#lambda和序列" class="headerlink" title="lambda和序列"></a>lambda和序列</h2><p><br></p>
<h3 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h3><ul>
<li>lambda表达式一般由 花括号 参数声明 箭头 一般表达式 组成，在kotlin当中lambda表达式可以作为变量存储和传递</li>
</ul>
<pre><code>fun main() {

    var lambda = { x:Int, y:Int -&gt; x + y}
}
</code></pre><ul>
<li>调用值：lambda表达式可以使用括号调用，也可以使用run函数调用，后者只支持无参的lambda表达式，当lambda表达式被调用时，花括号中最后一个表达式的值就是整个lambda表达式的值</li>
</ul>
<pre><code>fun main() {

    val result = { x:Int, y:Int -&gt; x + y}(1,1)
    //或
    val lambda = { x:Int, y:Int -&gt; x + y}
    lambda(1,1)

    run { println(1) }

}
</code></pre><ul>
<li>简化：kotlin中使用lambda时支持一定的简化，表达式是最后一个参数，花括号可以移动到小括号的后面，当表达式是唯一参数时小括号可以省略，同时lambda支持类型推断，无需指明类型，而且如果表达式是唯一参数那么可以直接使用默认的参数命名it。注意如果表达式是用变量存储的话，类型声明就不可以省略，因为无法推断</li>
</ul>
<pre><code>//最完整的写法  
var oldest = people.maxBy({ p: Person -\&gt; p.age })

//1.因为表达式是最后一个参数
var oldest = people.maxBy(){ p: Person -\&gt; p.age }

//2.因为表达式是唯一的参数
var oldest = people.maxBy{ p: Person -\&gt; p.age }

//3.因为可以进行类型推断
var oldest = people.maxBy{ p -\&gt; p.age }

//4.编译器提供默认命名参数it，因此命名也不需要
var oldest = people.maxBy{ it.age }
</code></pre><ul>
<li>lambda表达式中可以访问函数中的非final变量，实现的机制是将变量封装到包装器中，而包装器是final的，注意在异步调用的情况下，局部变量的修改只会在lambda执行时被修改，此时函数可能已经返回，不可能返回一个未来的值</li>
</ul>
<pre><code>fun printProblemCounts(response: Collection&lt;String&gt;){
    var clientErrors =0
    var serverErrors =0
    response.forEach{
        if(it.startsWith(&quot;4&quot;)){
            clientErrors++
        }else if(it.startsWith(&quot;5&quot;)){
            serverErrors++
        }
    }

    println(&quot;$clientErrors $serverErrors&quot;)
}
</code></pre><p><br></p>
<h3 id="成员引用"><a href="#成员引用" class="headerlink" title="成员引用 ::"></a>成员引用 ::</h3><ul>
<li>kotlin可以像java一样使用 :: 将函数转换为lambda表达式，如果使用的是顶层函数，则 :: 前面不需要类名</li>
</ul>
<pre><code>data class Person(val name: String, val age: Int)

var getAge = Person::age
fun main() {

    val people = listOf(Person(&quot;Alice&quot;, 29), Person(&quot;Bob&quot;, 31))

    var oldest = people.maxBy(getAge)
}
</code></pre><ul>
<li>如果需要将构造函数转换为lambda表达式，则使用 ::类名</li>
</ul>
<pre><code>var creator = ::Person
var obj = creator(&quot;&quot;,0)
</code></pre><p><br></p>
<h3 id="SAM-构造方法"><a href="#SAM-构造方法" class="headerlink" title="SAM 构造方法"></a>SAM 构造方法</h3><ul>
<li>SAM构造方法允许我们使用lambda表达式来实现函数式接口，也就是Runnable和OnClickListener这样的接口，这样可以实现实例重用</li>
</ul>
<pre><code>fun main() {
    runnable.run()
}

val runnable = Runnable {
    println(&quot;run&quot;)
}
</code></pre><ul>
<li>需要注意的是SAM构造方法创建对象和使用object声明创建对象是有区别的，因为普通lambda本质上被视为代码块，因此普通lambda表达式内部不允许使用this关键字，做不到传出自身的引用，如果需要使用this，请改用object声明。另外在扩展函数时使用的lambda是一种特殊的情况，被称为带接受者的lambda，我们将在后面讲解这种情况</li>
</ul>
<p><br></p>
<h3 id="带接受者的lambda"><a href="#带接受者的lambda" class="headerlink" title="带接受者的lambda"></a>带接受者的lambda</h3><ul>
<li>之前我们看过如何静态地声明类扩展函数，也可以动态地实现这种效果，下面动态声明了一个类的扩展函数并调用，该扩展函数的声明使用到了一种特殊的lambda，它是带接受者（也就是this）的，表达式中的this与静态声明的扩展函数中的this一致，指向的是被扩展的类的实例，可以省略。这个特性看起来有点多余，但它可以实现一些很重要的功能</li>
</ul>
<pre><code>fun main() {

    val newMeth:AClass.()-&gt;Boolean = {
        this.oldMeth()
        println(&quot;newMeth&quot;)
        true
    }
    val t = AClass().newMeth()
}

class AClass{

    fun oldMeth(){
        println(&quot;oldMeth&quot;)
    }
}
</code></pre><p><br></p>
<h3 id="with"><a href="#with" class="headerlink" title="with"></a>with</h3><ul>
<li>有时候我们会经常对同一个对象进行操作，这个时候需要不但重复变量的名称，这时代码显得臃肿，不直观，特别是在变量名比较长的情况下</li>
</ul>
<pre><code>fun main() {

    println(alphabet())
}

fun alphabet():String{

    val result = StringBuilder()
    for(letter in &apos;A&apos; .. &apos;Z&apos;){
        result.append(letter)
    }

    result.append(&quot;\n now i know the alphabet&quot;)
    return result.toString()
}
</code></pre><ul>
<li>with：使用with可以对上述情况进行简化，with是一个顶层函数，而不是内置在语法中的特性</li>
</ul>
<pre><code>fun alphabet():String = with(StringBuilder()){
    for(letter in &apos;A&apos; .. &apos;Z&apos;){
        append(letter)
    }

    append(&quot;\n now I know the alphabet&quot;)
    toString()
}
</code></pre><ul>
<li>with的实现基于带接受者的lambda，从函数声明可以看出这一点</li>
</ul>
<pre><code>public inline fun \&lt;T, R\&gt; with(receiver: T, block: T.() -\&gt; R): R 
</code></pre><p><br></p>
<h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><ul>
<li>apply与with类似，只是apply返回的是被用于函数扩展的实例，这对于初始化对象的情况非常合适</li>
</ul>
<pre><code>fun alphabet()=StringBuilder().apply { 
    for (letter in &apos;A&apos; .. &apos;Z&apos;){
        append(letter)
    }
    append(&quot;\n now I know the alphabet&quot;)
}.toString()
</code></pre><p><br></p>
<h3 id="集合函数式api"><a href="#集合函数式api" class="headerlink" title="集合函数式api"></a>集合函数式api</h3><ul>
<li>filter，对集合中满足判断式的元素进行过滤得到新集合</li>
</ul>
<pre><code>val numbers = listOf(1,2,3,4,5,6,7,8,9)
println(numbers.filter { it % 2 == 0 })

val people = listOf(Person(&quot;Alice&quot;, 29), Person(&quot;Bob&quot;, 31))
println(people.filter{ it.age&gt;30 })
</code></pre><ul>
<li>map，将集合的元素进行转换得到新集合，元素类型可以改变</li>
</ul>
<pre><code>val numbers = listOf(1, 2, 3, 4, 5, 6, 7, 8, 9)
println(numbers.map { it * it })

val people = listOf(Person(&quot;Alice&quot;, 29), Person(&quot;Bob&quot;, 31))
println(people.map(Person::name))
println(
    people
        .filter { it.age &gt; 30 }
        .map(Person::name)
)
</code></pre><ul>
<li>all，判断是否所有元素都满足某个条件</li>
</ul>
<pre><code>val people = listOf(Person(&quot;Alice&quot;, 27), Person(&quot;bob&quot;, 31))
println(people.all { it.age &gt; 30 })
</code></pre><ul>
<li>any，判断是否存在符合条件的元素</li>
</ul>
<pre><code>val people = listOf(Person(&quot;Alice&quot;, 27), Person(&quot;bob&quot;, 31))
println(people.any { it.age &gt; 30 })
</code></pre><ul>
<li>count，计算符合条件的元素个数</li>
</ul>
<pre><code>val people = listOf(Person(&quot;Alice&quot;, 27), Person(&quot;bob&quot;, 31))
println(people.count { it.age &gt; 30 })
</code></pre><ul>
<li>find，查找符合条件的第一个元素</li>
</ul>
<pre><code>val people = listOf(Person(&quot;Alice&quot;, 27), Person(&quot;bob&quot;, 31))
val person = people.find { it.age &gt; 30 }
</code></pre><ul>
<li>groupBy，将符合元素的条件进行分组，返回一个map，元素依然还是集合</li>
</ul>
<pre><code>val people = listOf(
    Person(&quot;Alice&quot;, 27)
    , Person(&quot;bob&quot;, 31)
    , Person(&quot;Carol&quot;, 31)
)
val map = people.groupBy(getAge)
println(map)
</code></pre><ul>
<li>flatten，用于将多个集合合并成为一个</li>
</ul>
<pre><code>    val listOfList = listOf(
        listOf(1, 2, 3)
        , listOf(4, 5, 6)
        , listOf(7, 8, 9)
    )

    println(listOfList.flatten())
//输出 [1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre><ul>
<li>flatMap，用于将集合中的元素通过某种方式构造集合，然后将每个元素得到的新结合合并，通常用于将一个集合装换为其他内容的集合</li>
</ul>
<pre><code>val list = listOf(&quot;123&quot;,&quot;45&quot;,&quot;6789&quot;)
println(list.flatMap { it.toList() })
</code></pre><p><br></p>
<h3 id="序列-sequence"><a href="#序列-sequence" class="headerlink" title="序列 sequence"></a>序列 sequence</h3><ul>
<li>类似filter和map的操作都会返回一个新的集合，如果较多或者操作或者元素较多，则会带来不必要的消耗</li>
</ul>
<pre><code>people.map(Person::name)
    .filter { it.startsWith(&quot;A&quot;) }
</code></pre><ul>
<li>asSequence：可以使用asSequence将操作变成序列，对序列进行链式操作不会创建额外的集合来保存过程中产生的中间结果，序列的操作分为中间操作和末端操作，中间操作返回的是另一个序列，末端操作返回的是一个结果，中间操作都是惰性的。如下面的map和filter就是中间操作，而toList就是末端操作</li>
</ul>
<pre><code>people.asSequence()
    .map(Person::name)
    .filter { it.startsWith(&quot;A&quot;) }
    .toList()
</code></pre><ul>
<li>在不调用末端操作时中间操作是不会执行的</li>
</ul>
<pre><code>//没有输出  
listOf(1, 2, 3, 4).asSequence()
        .map { println(&quot;do map&quot;);it * it }
        .filter { println(&quot;do filter&quot;);it % 2 == 0 }
</code></pre><ul>
<li>惰性还有一个好处是，序列会依次对每个元素进行所有的操作，对于find这样并非需要访问所有元素的末端操作，则可以忽略不需要访问的元素，另外一些中间操作可以作为后续操作的先决条件，比如filter这样的操作优先执行可以减少操作的总次数</li>
</ul>
<pre><code>listOf(1, 2, 3, 4).asSequence()
    .map { println(&quot;do map&quot;);it * it }
    .filter { println(&quot;do filter&quot;);it % 2 == 0 }
    .find { it == 4 }
</code></pre><ul>
<li>generateSequence：使用generateSequence可以不依赖集合类来创建一个序列，创建一个序列需要一个称谓seed的起始值（可以直接传入其值，也可以传入一个lambda表达式），还需要一个用于获取下一个元素的lambda表达式</li>
</ul>
<pre><code>println(
        //或者generateSequence({0}, { it + 1 })
    generateSequence(0) { it + 1 }
        .takeWhile { it &lt; 100 }
        .sum()
)
</code></pre><p><br></p>
<h2 id="可空性"><a href="#可空性" class="headerlink" title="可空性"></a>可空性</h2><p><br></p>
<h3 id="非空类型"><a href="#非空类型" class="headerlink" title="非空类型"></a>非空类型</h3><ul>
<li>kotlin当中null也作为类型检查的一部分，默认情况下，所有类型都是非空的，所以当显式赋值为null时会报错</li>
</ul>
<pre><code>    var a:String
//Error:(14, 9) Kotlin: Null can not be a value of a non-null type String
a = null 
</code></pre><ul>
<li>对于函数调用也是如此，无法将null传给普通声明的参数</li>
</ul>
<pre><code>fun main() {
    strLen(null)
    //Error:(9, 12) Kotlin: Null can not be a value of a non-null type String
}

fun strLen(s:String) = s.length
</code></pre><p><br></p>
<h3 id="可空类型"><a href="#可空类型" class="headerlink" title="可空类型"></a>可空类型</h3><ul>
<li>可空类型：如果需要赋值null时，可以使用 ？进行可空类型声明</li>
</ul>
<pre><code>var a:String?
fun main() {
    strLen(null)
}
fun strLen(s:String?) = s?.length
</code></pre><ul>
<li>可空类型并不是简单地可以存储null值而已，因为编译器已经知道了变量很可能为空，因此可以做更严格的编译检查</li>
</ul>
<ul>
<li>不能直接调用其函数</li>
</ul>
<pre><code>fun strLenSafe(s:String?) = s.length
</code></pre><ul>
<li>不能直接赋值给非空类型</li>
</ul>
<pre><code>val x: String? = null
val y: String = x
</code></pre><ul>
<li>不能直接传给非空参数</li>
</ul>
<pre><code>fun main() {

    val x: String? = null
    strLen(x)
}

fun strLen(s:String)=s.length
</code></pre><p><br></p>
<h3 id="安全调用运算符"><a href="#安全调用运算符" class="headerlink" title="安全调用运算符 ?."></a>安全调用运算符 ?.</h3><ul>
<li>我们需要一些特定的操作来使得上面对可空类型的调用可以工作，最直接的是添加判空，但这样的语句非常啰嗦，kotlin中可以使用安全调用运算符来简化这种语句</li>
</ul>
<pre><code>val x: String? = null
if (x != null) {
    strLen(x)
}
</code></pre><ul>
<li>?.: 安全调用运算符，用于调用可空类型的函数（虽然非空类型也可以使用），可以理解为上面判空形式的简写，但注意安全调用在对象为null时，表达式的值也为null</li>
</ul>
<pre><code>fun main() {
    printAllCaps(&quot;abc&quot;)
    printAllCaps(null)
}

fun printAllCaps(s:String?){
    val allCaps: String? = s?.toUpperCase()
    println(allCaps)
}
</code></pre><p><br></p>
<h2 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h2><ul>
<li>kotlin中的文档注释和java中的文档注释一样以/和两个星号开头，差别在于kotlin中的文档注释使用markdown语法而不是html，另外引用声明使用中括号表示</li>
</ul>
<p><br><br><strong>本篇未完</strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Flutter 踩坑记录]]></title>
      <url>/2019/04/17/BugFlutter/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><br></p>
<h3 id="AS-创建-flutter-project-卡死"><a href="#AS-创建-flutter-project-卡死" class="headerlink" title="AS 创建 flutter project 卡死"></a>AS 创建 flutter project 卡死</h3><ul>
<li>这是在升级AS和flutter sdk之后遇到的</li>
</ul>
<ul>
<li>第一次创建项目建议使用命令行</li>
</ul>
<pre><code>flutter create \&lt;project\_name\&gt;
</code></pre><ul>
<li>然后运行，发现是package get卡住了，被墙了</li>
</ul>
<pre><code>flutter run
</code></pre><ul>
<li>配置镜像可以解决，这个在 etc/profile 里面配过了，但是没有效果，因为zsh默认不加载etc/profile，可以 echo ${pub_hosted_url} 测一下，建议还是在默认的shell的配置文件里面设置，比如我使用的是.zshrc</li>
</ul>
<pre><code>export pub_hosted_url=https://pub.flutter-io.cn
export flutter_storage_base_url=https://storage.flutter-io.cn
</code></pre><ul>
<li>如果需要终端走代理可以尝试下面，同时curl ip.sb 检测当前ip</li>
</ul>
<pre><code>export ALL_PROXY=socks5://账号:密码@127.0.0.1:1080
</code></pre><p><br></p>
<h3 id="Initializing-gradle"><a href="#Initializing-gradle" class="headerlink" title="Initializing gradle"></a>Initializing gradle</h3><ul>
<li>永久停留在这一步，其实是在下载新版本的gradle，查看.gradle的dist目录会发现不论等多久大小都是 0 k，直接去官网下载对应版本，建议使用迅雷</li>
</ul>
<pre><code>https://services.gradle.org/distributions/
</code></pre><ul>
<li>然后将zip放进dist的对应文件夹中一个名称是乱码的子文件夹内，不需要解压，删除原有的xx.part文件（大概是这个，不记得了），重新build</li>
</ul>
<ul>
<li>如果需要使用dist没有的gradle都可以这么做，比如升级gradle的时候</li>
</ul>
<p><br></p>
<h3 id="Could-not-resolve-com-android-tools-build-gradle-3-1-2"><a href="#Could-not-resolve-com-android-tools-build-gradle-3-1-2" class="headerlink" title="Could not resolve com.android.tools.build:gradle:3.1.2"></a>Could not resolve com.android.tools.build:gradle:3.1.2</h3><ul>
<li>这也是在升级AS和flutter sdk之后遇到的，我的情况，不论是在idea，as还是命令行编译都是这样</li>
</ul>
<ul>
<li>github有这个issue，很多人都遇到这个问题，解决方法五花八门，估计很多因素都可以导致这个，所以建议都尝试一下，官方现在也没找到办法</li>
</ul>
<pre><code>https://github.com/flutter/flutter/issues/22470
</code></pre><ul>
<li>下面是一些可参考的解决办法，注意有一些做法是完全相反的</li>
</ul>
<pre><code>1.as配置 build tools-\&gt;gradle-\&gt;android stuido-\&gt; 勾选 enable ... maven repo
2.设代理
3.关代理，并清除与google相关的host，以及关闭as中与代理相关的配置
4.gradle 中添加 google()，适用于版本比较旧的AS，新版默认是有的
5.gradle 中添加 mavenCentral()，在flutter sdk中进行用样的配置 路径为 /packages/flutter\_tools/gradle/flutter.gradle
6.升级gradle，见上文
7.降级gradle，见下文
8.降级flutter sdk(官网上有所有版本的下载链接)
9.卸载AS重装（代价挺大的，但确实csdn上确实有人这样解决类似问题）
</code></pre><ul>
<li>我是通过7.解决的，将项目的gradle配置设置为.gradle的dist中缓存的gradle版本，一个个尝试，同时gradle的classpath可能也需要更改，建议使用以前使用过的版本</li>
</ul>
<p><br></p>
<h3 id="使用colors类时AS卡死"><a href="#使用colors类时AS卡死" class="headerlink" title="使用colors类时AS卡死"></a>使用colors类时AS卡死</h3><ul>
<li><p>文档中的图片会导致联网下载，这个时候很容易卡死</p>
</li>
<li><p>这个bug在3.3才会出现，3.4已经修复，3.4修复了30多个bug，并且更新侧重于使用体验和稳定性，个人觉得可以大胆更新，实在不想更新的也可以参看下面的解决办法</p>
</li>
<li><p>设置 editor->general->code completion->show the documentation popup in xxx ms ,取消勾选，这个意思是自动补全时不要弹出右侧的文档窗口</p>
</li>
<li><p>取消勾选之后，光标放在类名处一段时间还是可以弹出文档的，所以不会有什么影响，不过弹出的时候该卡死还是会卡死，这样的类并不多，其他的比如rx里面有一些也会，不手贱就行，或者选择直接关闭这个功能</p>
</li>
</ul>
<p><br><br><strong>持续更新</strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[近期计划 & 学习资料]]></title>
      <url>/2019/04/12/OtherPlan/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><strong>最近又转组了，下面的技术应该用不太到，可能主要还是c++，不过这篇还是保留吧</strong></p>
<p><strong>整理一下学习资料，方便自己和后来人学习</strong></p>
<p><strong>5月份（或之前）去腾讯mxg实习，所在组主要做微信的业务功能和新技术的预研，似乎要了解的新技术比较多，需要提前学一下flutter，组件化，kotlin，除了组件化以外基本只学了一点没有深入过，这段时间捡回来</strong></p>
<p><br></p>
<h3 id="flutter"><a href="#flutter" class="headerlink" title="flutter"></a>flutter</h3><p><strong> 之前学过dart，flutter没有怎么学：<a href="https://tocreate.app/2018/10/27/EnvDartFlutter/" target="_blank" rel="external">Dart &amp; Flutter 环境搭建</a>，<a href="https://tocreate.app/2018/11/03/LangDart/" target="_blank" rel="external">dart语言</a></strong> </p>
<p><strong>相对来说，flutter比较系统的教程还是比较少的</strong></p>
<ul>
<li><p>了解flutter的全貌：<a href="https://www.youtube.com/watch?v=9FA3brRCz2Q" target="_blank" rel="external">dart</a>，<a href="https://www.youtube.com/watch?v=Mx-AllVZ1VY" target="_blank" rel="external">flutter</a>，<a href="https://www.youtube.com/watch?v=iPlPk43RbpA" target="_blank" rel="external">hotReload</a>，<a href="https://www.youtube.com/watch?v=zKXz3pUkw9A" target="_blank" rel="external">state</a></p>
</li>
<li><p>dart的官方<a href="http://dart.goodev.org/guides/language/language-tour" target="_blank" rel="external">教程</a>，<a href="http://dart.goodev.org/guides/language/effective-dart" target="_blank" rel="external">Effective Dart</a></p>
</li>
<li><p>wendux，国内flutter领域最知名的大牛，<a href="https://book.flutterchina.club" target="_blank" rel="external">flutter中文网</a>的创建和维护者，<a href="https://github.com/flutterchina/dio" target="_blank" rel="external">dio</a>的作者，他写的<a href="https://book.flutterchina.club/" target="_blank" rel="external">flutter实战</a>很适合入门</p>
</li>
<li><p>何小有，<a href="https://blog.csdn.net/hekaiyou/column/info/dart" target="_blank" rel="external">dart实例教程</a>，<a href="https://blog.csdn.net/hekaiyou/column/info/13593" target="_blank" rel="external">flutter教程</a>，写得非常详细，15年就开始实践dart和flutter，系统写教程，佩服</p>
</li>
<li><p>掘金，目前国内的flutter开发者主要聚集在掘金，<a href="https://juejin.im/welcome/android/Flutter?sort=newest" target="_blank" rel="external">掘金flutter社区</a>，<a href="https://juejin.im/welcome/android/Flutter?sort=newest" target="_blank" rel="external">相关文章</a></p>
</li>
<li><p><a href="%20https://medium.com/flutter-io">medium</a>，国外的文章可以看这里</p>
</li>
</ul>
<ul>
<li>阿里的<a href="https://github.com/alibaba/flutter-go" target="_blank" rel="external">flutter go</a></li>
</ul>
<p><br></p>
<h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><p><strong>组件化在工作室的项目已经实践了，不过其实用得很常规，没有什么黑科技</strong></p>
<ul>
<li><a href="https://book.douban.com/subject/30190188/" target="_blank" rel="external">《Android 组件化架构》</a>，入门其实很好，没有豆瓣上说得那么差，不过只适合入门，对已经上手的人基本没有新东西或者深入的内容</li>
</ul>
<ul>
<li>路由这块可以看下 <a href="https://github.com/alibaba/ARouter" target="_blank" rel="external">Arouter</a> 和 <a href="https://github.com/mzule/ActivityRouter" target="_blank" rel="external">ActivityRouter</a> 实现，有时间的话补几篇源码分析和对比</li>
</ul>
<ul>
<li><a href="https://tech.meituan.com/2018/03/16/meituan-food-delivery-android-architecture-evolution.html" target="_blank" rel="external">美团外卖Android平台化架构演进实践</a>， <a href="https://mp.weixin.qq.com/s/6Q818XA5FaHd7jJMFBG60w" target="_blank" rel="external">微信Android模块化架构重构实践</a></li>
</ul>
<p><br></p>
<h3 id="kotlin"><a href="#kotlin" class="headerlink" title="kotlin"></a>kotlin</h3><p><strong>很久以前kotlin语法只看到一半就放下了，最近会捡起来：<a href="https://tocreate.app/2018/03/29/kotlin/" target="_blank" rel="external">kotlin 系列 - 语法与特性</a></strong></p>
<ul>
<li>kotlin中文网的 <a href="https://www.kotlincn.net/docs/tutorials/" target="_blank" rel="external">教程</a></li>
</ul>
<ul>
<li><a href="https://book.douban.com/subject/27093660/" target="_blank" rel="external">《Kotlin实战》</a> ，JetBrains团队参与的教程</li>
</ul>
<ul>
<li><a href="https://wangjiegulu.gitbooks.io/kotlin-for-android-developers-zh/content/" target="_blank" rel="external">《Kotlin for android developers》</a> ，也是官网推荐的书，已有中文翻译</li>
</ul>
<ul>
<li>目前Android方面的实践还不太了解，<a href="https://juejin.im/welcome/android/Kotlin" target="_blank" rel="external">掘金</a>上的文章倒是挺多的，不好评价</li>
</ul>
<p><br></p>
<h3 id="gradle"><a href="#gradle" class="headerlink" title="gradle"></a>gradle</h3><p><strong>一直想系统学习gradle，但一直都没有行动起来，很久以前买了gradle实战，老实说，从入门到懵逼</strong></p>
<ul>
<li><a href="">官方tutorials</a></li>
</ul>
<ul>
<li><a href="https://dongchuan.gitbooks.io/gradle-user-guide-/" target="_blank" rel="external">中文版</a>，版本比较旧</li>
</ul>
<p><br></p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>总结一下性能优化</li>
</ul>
<ul>
<li>复习一下自定义view</li>
</ul>
<p><br><br><strong> 完 </strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[UniversalImageLoader 详解]]></title>
      <url>/2019/03/18/UILAN/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><br></p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p><strong>ImageLoaderConfiguration中Builder的全部配置方法</strong></p>
<h4 id="ImageLoaderConfiguration"><a href="#ImageLoaderConfiguration" class="headerlink" title="ImageLoaderConfiguration"></a>ImageLoaderConfiguration</h4><ul>
<li>memoryCacheExtraOptions(int maxImageWidthForMemoryCache, int maxImageHeightForMemoryCache)</li>
</ul>
<pre><code>内存缓存的图片最大宽高
</code></pre><ul>
<li>discCacheExtraOptions(int maxImageWidthForDiskCache, int maxImageHeightForDiskCache,<br>  BitmapProcessor processorForDiskCache)</li>
</ul>
<pre><code>已弃用，建议使用下一个方法。设置磁盘缓存的图片最大宽高
BitmapProcessor包含一个Bitmap process(Bitmap bitmap)方法，在缓存前处理Bitmap
</code></pre><ul>
<li>diskCacheExtraOptions(int maxImageWidthForDiskCache, int maxImageHeightForDiskCache,<br>  BitmapProcessor processorForDiskCache) </li>
</ul>
<pre><code>同上，替代方案
</code></pre><ul>
<li>taskExecutor(Executor executor)</li>
</ul>
<pre><code>自定义线程池
</code></pre><ul>
<li>taskExecutorForCachedImages(Executor executorForCachedImages) </li>
</ul>
<pre><code>自定义加载已缓存在磁盘上的图片的线程池，因为这样的任务处理较快
如果也使用前一个方法的线程池的话可能会导致因等待而延长执行时间
</code></pre><ul>
<li>threadPoolSize(int threadPoolSize)</li>
</ul>
<pre><code>设置线程池
</code></pre><ul>
<li>threadPriority(int threadPriority)</li>
</ul>
<pre><code>设置线程优先级
</code></pre><ul>
<li>denyCacheImageMultipleSizesInMemory()</li>
</ul>
<pre><code>设置同一张图片在不同尺寸下是否创建多分缓存
</code></pre><ul>
<li>tasksProcessingOrder(QueueProcessingType tasksProcessingType) </li>
</ul>
<pre><code>设置处理顺序，LIFO或FIFO
</code></pre><ul>
<li>memoryCacheSize(int memoryCacheSize)</li>
</ul>
<pre><code>设置内存缓存的大小
</code></pre><ul>
<li>memoryCacheSizePercentage(int availableMemoryPercent)</li>
</ul>
<pre><code>设置内存缓存的大小，使用百分比
</code></pre><ul>
<li>memoryCache(MemoryCache memoryCache)</li>
</ul>
<pre><code>设置缓存管理对象，默认使用LruMemoryCache
</code></pre><ul>
<li>discCacheSize(int maxCacheSize)</li>
</ul>
<pre><code>设置磁盘缓存大小，已弃用
</code></pre><ul>
<li>diskCacheSize(int maxCacheSize) </li>
</ul>
<pre><code>同上，替代方案
</code></pre><ul>
<li>discCacheFileCount(int maxFileCount)</li>
</ul>
<pre><code>设置磁盘缓存文件最大数量，已弃用
</code></pre><ul>
<li>diskCacheFileCount(int maxFileCount)</li>
</ul>
<pre><code>同上，替代方案
</code></pre><ul>
<li>discCacheFileNameGenerator(FileNameGenerator fileNameGenerator)</li>
</ul>
<pre><code>设置缓存文件的名称生成工具，已弃用
</code></pre><ul>
<li>diskCacheFileNameGenerator</li>
</ul>
<pre><code>同上，替代方案
</code></pre><ul>
<li>discCache(DiskCache diskCache)</li>
</ul>
<pre><code>设置磁盘缓存管理对象，已弃用
</code></pre><ul>
<li>diskCache(DiskCache diskCache)</li>
</ul>
<pre><code>同上，替代方案
</code></pre><ul>
<li>imageDownloader(ImageDownloader imageDownloader) </li>
</ul>
<pre><code>设置图片下载对象
</code></pre><ul>
<li>imageDecoder(ImageDecoder imageDecoder) </li>
</ul>
<pre><code>设置图片解码对象
</code></pre><ul>
<li>defaultDisplayImageOptions(DisplayImageOptions defaultDisplayImageOptions)</li>
</ul>
<pre><code>设置显示图片的策略
</code></pre><ul>
<li>writeDebugLogs()</li>
</ul>
<pre><code>设置是否输出调试日志
</code></pre><h4 id="DisplayImageOptions"><a href="#DisplayImageOptions" class="headerlink" title="DisplayImageOptions"></a>DisplayImageOptions</h4><ul>
<li>showStubImage(int imageRes)</li>
</ul>
<pre><code>显示占位图，已弃用
</code></pre><ul>
<li>showImageOnLoading(int imageRes) </li>
</ul>
<pre><code>同上，替代方案
</code></pre><ul>
<li>showImageOnLoading(Drawable drawable) </li>
</ul>
<pre><code>同上，替代方案
</code></pre><ul>
<li>showImageForEmptyUri(int imageRes)</li>
</ul>
<pre><code>空或null的url使用的图片
</code></pre><ul>
<li>showImageForEmptyUri(Drawable drawable) </li>
</ul>
<pre><code>同上，替代方案
</code></pre><ul>
<li>showImageOnFail(int imageRes)</li>
</ul>
<pre><code>加载失败时使用的图片
</code></pre><ul>
<li>showImageOnFail(Drawable drawable) </li>
</ul>
<pre><code>同上，替代方案
</code></pre><ul>
<li>cacheInMemory()</li>
</ul>
<pre><code>设置是否使用内存缓存
</code></pre><ul>
<li>cacheOnDisc()</li>
</ul>
<pre><code>设置是否使用磁盘缓存
</code></pre><ul>
<li>imageScaleType(ImageScaleType imageScaleType)</li>
</ul>
<pre><code>设置图片缩放类型
</code></pre><ul>
<li>bitmapConfig(Bitmap.Config bitmapConfig)</li>
</ul>
<pre><code>设置bitmapConfig
</code></pre><ul>
<li>decodingOptions(Options decodingOptions)</li>
</ul>
<pre><code>设置图片解码类型
</code></pre><ul>
<li>delayBeforeLoading(int delayInMillis)</li>
</ul>
<pre><code>设置延迟加载的时间
</code></pre><ul>
<li>considerExifParams</li>
</ul>
<pre><code>设置是否处理EXIF信息
</code></pre><ul>
<li>preProcessor(BitmapProcessor preProcessor)</li>
</ul>
<pre><code>设置预处理器实例
</code></pre><ul>
<li>postProcessor(BitmapProcessor postProcessor)</li>
</ul>
<pre><code>设置后处理器实例
</code></pre><ul>
<li>displayer(BitmapDisplayer displayer)</li>
</ul>
<pre><code>设置图片现实管理对象实例
</code></pre><ul>
<li>Builder handler(Handler handler)</li>
</ul>
<pre><code>设置handler
</code></pre><p><br></p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li>uil中加载图片的方法分为三类，displayImage，参数中包含ImageView或ImageAware这样的图片直接接受者，loadImage，参数不包含直接接受者，但包含回调接口，也就是只负责加载不负责显示，loadImageSync，同步，直接返回bitmap</li>
</ul>
<ul>
<li>涉及到的参数主要包括</li>
</ul>
<pre><code>ImageAware：显示图片的对象，包装ImageView等
ImageLoadingListener：包含开始失败完成取消的回调接口
ImageLoadingProgressListener：加载进度回调
</code></pre><p><br></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><br></p>
<h4 id="主要模块"><a href="#主要模块" class="headerlink" title="主要模块"></a>主要模块</h4><ul>
<li>uil的分包还是很清晰的，主要包括了</li>
</ul>
<pre><code>utils：包括一些工具类
cache包：包括disc和memory两部分，负责磁盘和内存缓存
core包：核心功能包括以下部分
assist：主要包括一些枚举和队列的实现
decode：图片解码，将流转换为Bitmap，主要实现为BaseImageDecoder
BitmapDisplayer：图片展示，所有类继承自BitmapDisplayer，负责图片处理如圆角，动画，然后设置图片到imageAware上
download：负责网络，文件或资源图片的加载
imageaware：代表显示图片的类，如ImageView或普通View等
listener：回调接口
process：对Bitmap进行预处理或后处理
DefaultConfigurationFactory：生成默认option，如线程池，缓存管理实例等
DisplayBitmapTask：展示图片的runnable
LoadAndDisplayImageTask：加载并显示图片的runnable
ProcessAndDisplayImageTask：处理并显示图片的runnable
ImageLoaderEngine：任务分发器，负责分发各类task给具体的线程池去执行
</code></pre><p><br></p>
<h4 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h4><ul>
<li>图片加载按顺序包含以下流程，注意并不是全部都会执行</li>
</ul>
<pre><code>1.ImageDownloader 下载图片（没有缓存，从这里开始）
2.DiskCache 磁盘缓存
3.ImageDecoder 解码流为Bitmap（只有磁盘缓存，从这里开始）
4.BitmapProcessor 预处理
5.MemoryCache 内存缓存
6.BitmapProcessor 后处理（有内存缓存，从这里开始）
7.BitmapDisplayer 显示图片
</code></pre><p><br></p>
<h4 id="加载实现"><a href="#加载实现" class="headerlink" title="加载实现"></a>加载实现</h4><ul>
<li>加载方法包括loadImageSync，loadImage和displayImage，loadImageSync通过loadImage实现，loadImage通过displayImage来实现，只不过前两者使用的imageAware对象为NonViewAware类实例，它的相关显示方法为空实现</li>
</ul>
<pre><code>public void loadImage(String uri, ImageSize targetImageSize, DisplayImageOptions options,
        ImageLoadingListener listener, ImageLoadingProgressListener progressListener) {
    checkConfiguration();
    if (targetImageSize == null) {
        targetImageSize = configuration.getMaxImageSize();
    }
    if (options == null) {
        options = configuration.defaultDisplayImageOptions;
    }

    NonViewAware imageAware = new NonViewAware(uri, targetImageSize, ViewScaleType.CROP);
    displayImage(uri, imageAware, options, listener, progressListener);
}
</code></pre><ul>
<li>核心方法displayImage实现如下</li>
</ul>
<pre><code>public void displayImage(String uri, ImageAware imageAware, DisplayImageOptions options,ImageSize targetSize, ImageLoadingListener listener, ImageLoadingProgressListener progressListener) {
    //1.检查配置和回调
    checkConfiguration();
    if (imageAware == null) {
        throw new IllegalArgumentException(ERROR_WRONG_ARGUMENTS);
    }
    if (listener == null) {
        listener = defaultListener;
    }
    if (options == null) {
        options = configuration.defaultDisplayImageOptions;
    }

    //2. uri判空，为空则选择性显示占位图，这个过程中加载和完成的回调会被调用
    if (TextUtils.isEmpty(uri)) {
        engine.cancelDisplayTaskFor(imageAware);
        listener.onLoadingStarted(uri, imageAware.getWrappedView());
        if (options.shouldShowImageForEmptyUri()) {
            imageAware.setImageDrawable(options.getImageForEmptyUri(configuration.resources));
        } else {
            imageAware.setImageDrawable(null);
        }
        listener.onLoadingComplete(uri, imageAware.getWrappedView(), null);
        return;
    }

    //3.获取显示目标的大小
    if (targetSize == null) {
        targetSize = ImageSizeUtils.defineTargetSizeForView(imageAware, configuration.getMaxImageSize());
    }
    //4.根据uri生成内存缓存的key
    String memoryCacheKey = MemoryCacheUtils.generateKey(uri, targetSize);

    //5.将imageAware的id和key的键值对放入缓存
    engine.prepareDisplayTaskFor(imageAware, memoryCacheKey);

    //6.调用开始加载回调
    listener.onLoadingStarted(uri, imageAware.getWrappedView());

    //7.从内存缓存获取bitmap，获取成功开始后处理
    Bitmap bmp = configuration.memoryCache.get(memoryCacheKey);
    if (bmp != null &amp;&amp; !bmp.isRecycled()) {
        L.d(LOG_LOAD_IMAGE_FROM_MEMORY_CACHE, memoryCacheKey);

        //使用ProcessAndDisplayImageTask，同步则直接调用run，否则提交线程池
        if (options.shouldPostProcess()) {
            ImageLoadingInfo imageLoadingInfo = new ImageLoadingInfo(uri, imageAware, targetSize, memoryCacheKey,
                    options, listener, progressListener, engine.getLockForUri(uri));
            ProcessAndDisplayImageTask displayTask = new ProcessAndDisplayImageTask(engine, bmp, imageLoadingInfo,
                    defineHandler(options));
            if (options.isSyncLoading()) {
                displayTask.run();
            } else {
                engine.submit(displayTask);
            }

        //不需要后处理直接调用Displayer显示，默认实现是直接setBitmap
        } else {
            options.getDisplayer().display(bmp, imageAware, LoadedFrom.MEMORY_CACHE);
            listener.onLoadingComplete(uri, imageAware.getWrappedView(), bmp);
        }

    //8.内存没有，从磁盘或网络获取，使用LoadAndDisplayImageTask，同步则直接调用run，否则提交线程池
    } else {
        if (options.shouldShowImageOnLoading()) {
            imageAware.setImageDrawable(options.getImageOnLoading(configuration.resources));
        } else if (options.isResetViewBeforeLoading()) {
            imageAware.setImageDrawable(null);
        }

        ImageLoadingInfo imageLoadingInfo = new ImageLoadingInfo(uri, imageAware, targetSize, memoryCacheKey,
                options, listener, progressListener, engine.getLockForUri(uri));
        LoadAndDisplayImageTask displayTask = new LoadAndDisplayImageTask(engine, imageLoadingInfo,
                defineHandler(options));
        if (options.isSyncLoading()) {
            displayTask.run();
        } else {
            engine.submit(displayTask);
        }
    }
}
</code></pre><ul>
<li>ProcessAndDisplayImageTask的run方法，先调用BitmapProcessor处理，然后使用DisplayBitmapTask投递runnable到handler</li>
</ul>
<pre><code>@Override
public void run() {
    L.d(LOG_POSTPROCESS_IMAGE, imageLoadingInfo.memoryCacheKey);

    BitmapProcessor processor = imageLoadingInfo.options.getPostProcessor();
    Bitmap processedBitmap = processor.process(bitmap);
    DisplayBitmapTask displayBitmapTask = new DisplayBitmapTask(processedBitmap, imageLoadingInfo, engine,
            LoadedFrom.MEMORY_CACHE);
    LoadAndDisplayImageTask.runTask(displayBitmapTask, imageLoadingInfo.options.isSyncLoading(), handler, engine);
}
</code></pre><ul>
<li>LoadAndDisplayImageTask的run方法，在次从内存缓存中去读取 bitmap 对象，若 bitmap 对象不存在，则调用 tryLoadBitmap() 从磁盘或网络获取 bitmap 对象，获取成功后若在 DisplayImageOptions.Builder 中设置了 cacheInMemory(true), 同时将 bitmap 对象缓存到内存中，最后新建DisplayBitmapTask使用handler显示图片</li>
</ul>
<pre><code>@Override
public void run() {
    if (waitIfPaused()) return;
    if (delayIfNeed()) return;

    ReentrantLock loadFromUriLock = imageLoadingInfo.loadFromUriLock;
    L.d(LOG_START_DISPLAY_IMAGE_TASK, memoryCacheKey);
    if (loadFromUriLock.isLocked()) {
        L.d(LOG_WAITING_FOR_IMAGE_LOADED, memoryCacheKey);
    }

    loadFromUriLock.lock();
    Bitmap bmp;
    try {
        checkTaskNotActual();

        bmp = configuration.memoryCache.get(memoryCacheKey);
        if (bmp == null || bmp.isRecycled()) {
            bmp = tryLoadBitmap();
            if (bmp == null) return; // listener callback already was fired

            checkTaskNotActual();
            checkTaskInterrupted();

            if (options.shouldPreProcess()) {
                L.d(LOG_PREPROCESS_IMAGE, memoryCacheKey);
                bmp = options.getPreProcessor().process(bmp);
                if (bmp == null) {
                    L.e(ERROR_PRE_PROCESSOR_NULL, memoryCacheKey);
                }
            }

            if (bmp != null &amp;&amp; options.isCacheInMemory()) {
                L.d(LOG_CACHE_IMAGE_IN_MEMORY, memoryCacheKey);
                configuration.memoryCache.put(memoryCacheKey, bmp);
            }
        } else {
            loadedFrom = LoadedFrom.MEMORY_CACHE;
            L.d(LOG_GET_IMAGE_FROM_MEMORY_CACHE_AFTER_WAITING, memoryCacheKey);
        }

        if (bmp != null &amp;&amp; options.shouldPostProcess()) {
            L.d(LOG_POSTPROCESS_IMAGE, memoryCacheKey);
            bmp = options.getPostProcessor().process(bmp);
            if (bmp == null) {
                L.e(ERROR_POST_PROCESSOR_NULL, memoryCacheKey);
            }
        }
        checkTaskNotActual();
        checkTaskInterrupted();
    } catch (TaskCancelledException e) {
        fireCancelEvent();
        return;
    } finally {
        loadFromUriLock.unlock();
    }

    DisplayBitmapTask displayBitmapTask = new DisplayBitmapTask(bmp, imageLoadingInfo, engine, loadedFrom);
    runTask(displayBitmapTask, syncLoading, handler, engine);
}
</code></pre><ul>
<li>tryLoadBitmap，如果磁盘中存在文件，则decodeImage解码为bitmap，否则使用tryCacheImageOnDisk从网络获取并保存到磁盘，这里的ImageDownloader分几种，正常的，网络状况不好的，无网络的，正常情况下使用BaseImageDownloader，基于HttpURLConnection实现，后两者这都是包装了BaseImageDownloader，其中SlowNetworkDownloader主要特性是使用的InputStream重写了skip方法，NetworkDeniedImageDownloader则是在获取流时抛出IllegalStateException，因为网络不可用</li>
</ul>
<pre><code>private Bitmap tryLoadBitmap() throws TaskCancelledException {
    Bitmap bitmap = null;
    try {
        File imageFile = configuration.diskCache.get(uri);
        if (imageFile != null &amp;&amp; imageFile.exists() &amp;&amp; imageFile.length() &gt; 0) {
            L.d(LOG_LOAD_IMAGE_FROM_DISK_CACHE, memoryCacheKey);
            loadedFrom = LoadedFrom.DISC_CACHE;

            checkTaskNotActual();
            bitmap = decodeImage(Scheme.FILE.wrap(imageFile.getAbsolutePath()));
        }
        if (bitmap == null || bitmap.getWidth() &lt;= 0 || bitmap.getHeight() &lt;= 0) {
            L.d(LOG_LOAD_IMAGE_FROM_NETWORK, memoryCacheKey);
            loadedFrom = LoadedFrom.NETWORK;

            String imageUriForDecoding = uri;
            if (options.isCacheOnDisk() &amp;&amp; tryCacheImageOnDisk()) {
                imageFile = configuration.diskCache.get(uri);
                if (imageFile != null) {
                    imageUriForDecoding = Scheme.FILE.wrap(imageFile.getAbsolutePath());
                }
            }

            checkTaskNotActual();
            bitmap = decodeImage(imageUriForDecoding);

            if (bitmap == null || bitmap.getWidth() &lt;= 0 || bitmap.getHeight() &lt;= 0) {
                fireFailEvent(FailType.DECODING_ERROR, null);
            }
        }
    } catch (IllegalStateException e) {
        fireFailEvent(FailType.NETWORK_DENIED, null);
    } catch (TaskCancelledException e) {
        throw e;
    } catch (IOException e) {
        L.e(e);
        fireFailEvent(FailType.IO_ERROR, e);
    } catch (OutOfMemoryError e) {
        L.e(e);
        fireFailEvent(FailType.OUT_OF_MEMORY, e);
    } catch (Throwable e) {
        L.e(e);
        fireFailEvent(FailType.UNKNOWN, e);
    }
    return bitmap;
}

private ImageDownloader getDownloader() {
    ImageDownloader d;
    if (engine.isNetworkDenied()) {
        d = networkDeniedDownloader;
    } else if (engine.isSlowNetwork()) {
        d = slowNetworkDownloader;
    } else {
        d = downloader;
    }
    return d;
}
</code></pre><ul>
<li>注意BaseImageDownloader实现上不止负责网络图片的获取，具体获取什么图片由Uri决定，只不过它都封装为stream</li>
</ul>
<pre><code>public class BaseImageDownloader implements ImageDownloader {
    @Override
    public InputStream getStream(String imageUri, Object extra) throws IOException {
        switch (Scheme.ofUri(imageUri)) {
            case HTTP:
            case HTTPS:
                return getStreamFromNetwork(imageUri, extra);
            case FILE:
                return getStreamFromFile(imageUri, extra);
            case CONTENT:
                return getStreamFromContent(imageUri, extra);
            case ASSETS:
                return getStreamFromAssets(imageUri, extra);
            case DRAWABLE:
                return getStreamFromDrawable(imageUri, extra);
            case UNKNOWN:
            default:
                return getStreamFromOtherSource(imageUri, extra);
        }
    }
}
</code></pre><p><br></p>
<h4 id="MemoryCache"><a href="#MemoryCache" class="headerlink" title="MemoryCache"></a>MemoryCache</h4><ul>
<li>不是所有缓存策略都有最大容量的限制，在有限制的情况下，默认为最大可用内存的8分之1，可设置</li>
</ul>
<ul>
<li>内存策略，8种，但常用的不多，一般情况下其实只有LruMemoryCache是合适的，其他大多数是LimitedMemoryCache的子类，LimitedMemoryCache内部的强引用map使得子类返回的弱引用无意义，有的子类满容删除时是锁住和遍历map的entry，对于图片较多的应用效率很低，以下介绍这8种，注意MemoryCache是uil中的缓存类的接口，BaseMemoryCache是抽象基类，其子类LimitedMemoryCache也是抽象基类，但不是所有策略都由基类实现，因为这些基类实现得不是很好，只是保留着而已，我们使用的默认策略就是直接实现MemoryCache接口的，效果会好一些</li>
</ul>
<ul>
<li>1.LimitedAgeMemoryCache：MemoryCache接口直接实现，使用HashMap记录存入的时间，get的时候，判断时间是否大于maxAge，如果是，那么就删掉这个缓存</li>
</ul>
<ul>
<li>2.LruMemoryCache：MemoryCache接口直接实现，自己实现的LruCache，准确的说是删除了sdk中LruCache中的一些统计缓存信息的方法，这里体现了和picasso的抉择不同，其实这一块虽然有用，但真的没什么人用</li>
</ul>
<ul>
<li>3.FuzzyKeyMemoryCache：MemoryCache接口直接实现，不过是个包装类，内部还有一个MemoryCache引用，这个类接收一个Comparator对象，在put时比较是否已经存在Comparator认为相同的key，如果存在，删除旧的，提供一种减少无用缓存的机制，使用场景只适合原来key的图片不再使用的情况，因为get时依然是通过key获取的，如果，被删除了，还需要去重新获取</li>
</ul>
<ul>
<li>4.WeakMemoryCache：一个BaseMemoryCache的实现类，BaseMemoryCache中使用Reference管理bitmap，没有容量限制，WeakMemoryCache将其限制为使用弱引用</li>
</ul>
<ul>
<li>5.FIFOLimitedMemoryCache：一个LimitedMemoryCache的实现类，LimitedMemoryCache是BaseMemoryCache的另一个实现，限制了容量大小，但容量满时如何删除则没有实现，FIFOLimitedMemoryCache就将其时间为FIFO的，通过LinkedList，这个cache返回弱引用</li>
</ul>
<ul>
<li>6.LRULimitedMemoryCache：同理，实现了LimitedMemoryCache，使用LinkedHashMap实现LRU机制，这个cache返回弱引用</li>
</ul>
<ul>
<li>7.UsingFreqLimitedMemoryCache：同理，实现了LimitedMemoryCache，删除时会删除使用频率最小的bitmap，使用hashmap实现，hashmap记录了使用次数，所以所谓频率只是使用次数，并没有这么智能，减容效率也不高需要遍历entry查找应该丢弃的bitmap，这个cache返回弱引用</li>
</ul>
<ul>
<li>8.LargestLimitedMemoryCache：同理，实现了LimitedMemoryCache，使用hashmap记录大小，删除时遍历找出最大的bitmap删除，这个cache返回弱引用</li>
</ul>
<p><br></p>
<h4 id="DiskCache"><a href="#DiskCache" class="headerlink" title="DiskCache"></a>DiskCache</h4><ul>
<li>BaseDiskCache: 抽象基类，实现了一些文件读写的逻辑，对缓存不设限</li>
</ul>
<ul>
<li>可用的磁盘缓存策略有三种</li>
</ul>
<ul>
<li>1.UnlimitedDiskCache：其实就是BaseDiskCache，继承之后什么都没干，也就不设限了</li>
</ul>
<ul>
<li>2.LimitedAgeDiskCache：在get时获取文件的最后修改时间，记录到map中，并且如果和当前时间相差较大，则删除缓存，个人觉得在获取图片时删除缓存是本末倒置的，但是由于没有像DiskLruCache那样实现一个journal文件，所以也干不了别的事情</li>
</ul>
<ul>
<li>3.LruDiskCache：限制总字节大小的内存缓存，会在缓存满时优先删除最近最少使用的元素。DiskLruCache，限制总字节大小的内存缓存，会在缓存满时优先删除最近最少使用的元素。通过缓存目录下名为journal的文件记录缓存的所有操作，并在缓存open时读取journal的文件内容存储到LinkedHashMap\ lruEntries中，后面get(String key)获取缓存内容时，会先从lruEntries中得到图片文件名返回文件。LRU 的实现跟上面内存缓存类似，lruEntries为new LinkedHashMap(0, 0.75f, true)，LinkedHashMap 第三个参数表示是否需要根据访问顺序(accessOrder)排序，true 表示根据accessOrder排序，最近访问的跟最新加入的一样放到最后面，false 表示根据插入顺序排序。这里为 true 且缓存满时trimToSize()函数始终删除第一个元素，即始终删除最近最少访问的文件</li>
</ul>
<p><br><br><strong>本篇完，另外看到一篇比较使用的零碎问题整理，<a href="https://www.jianshu.com/p/53d267d782f9" target="_blank" rel="external">详见</a></strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 系统系列 Service启动流程]]></title>
      <url>/2019/01/28/AOSServiceInit/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><a href="https://tocreate.app/2018/09/05/androidSource/" target="_blank" rel="external">本文为Android 系统相关系列的一部分</a></p>
<p><strong>使用service的方法要么是startService要么是bindService，要么混合使用，这里分别讲解两个方法的流程</strong></p>
<p><br></p>
<h4 id="startService-启动"><a href="#startService-启动" class="headerlink" title="startService 启动"></a>startService 启动</h4><ul>
<li>我们平时调用的startService方法，来自ContextWrapper，它是Activity和Service的父类，android中的Context是包装模式的一个实例，这里不讲解设计模式，还是直接看代码，该方法中使用的mBase，在上一篇中讲到是ContextImpl的实例</li>
</ul>
<pre><code>public class ContextWrapper extends Context{

Context mBase;

//...
@Override
    public ComponentName startService(Intent service) {
        return mBase.startService(service);
    }
//...
}
</code></pre><ul>
<li>这里ActivityManager.getService()获取到的是AMS的代理类IActivityManager，因此这里会调用到AMS的startService方法</li>
</ul>
<pre><code>/frameworks/base/core/java/android/app/ContextImpl.java
    @Override
    public ComponentName startService(Intent service) {
        warnIfCallingFromSystemProcess();
        return startServiceCommon(service, false, mUser);
    }

private ComponentName startServiceCommon(Intent service, boolean requireForeground,
            UserHandle user) {
        try {
            validateServiceIntent(service);
            service.prepareToLeaveProcess(this);
            ComponentName cn = ActivityManager.getService().startService(
                mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(
                            getContentResolver()), requireForeground,
                            getOpPackageName(), user.getIdentifier());

//...           
          return cn;
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
</code></pre><ul>
<li>AMS的startService方法调用的是ActiveServices类的startServiceLocked方法，后者负责查找service的描述类ServiceRecord并启动service，ServiceRecord的作用和之前看到的ActivityRecord，TaskRecord，ProcessRecord类是类似的</li>
</ul>
<pre><code>@Override
public ComponentName startService(IApplicationThread caller, Intent service,
        String resolvedType, boolean requireForeground, String callingPackage, int userId)
        throws TransactionTooLargeException {

    //…
    synchronized(this) {
        final int callingPid = Binder.getCallingPid();
        final int callingUid = Binder.getCallingUid();
        final long origId = Binder.clearCallingIdentity();
        ComponentName res;
        try {
            res = mServices.startServiceLocked(caller, service,
                    resolvedType, callingPid, callingUid,
                    requireForeground, callingPackage, userId);
        } finally {
            Binder.restoreCallingIdentity(origId);
        }
        return res;
    }
}
</code></pre><ul>
<li>startServiceLocked的流程大致是，先从缓存中查找serviceRecord，这里的缓存是一个类型为ServiceMap的稀疏数组，数组的键为userId，ServiceMap则是一个handler，内部持有存放serviceRecord的ArrayMap，如果在缓存中找不到service，则会通过PackageManagerService去获取对应的参数，然后封装为serviceRecord。查找到service后会调用到bringUpServiceLocked</li>
</ul>
<pre><code>  final SparseArray&lt;ServiceMap&gt; mServiceMap = new SparseArray&lt;&gt;();

ServiceRecord getServiceByNameLocked(ComponentName name, int callingUser) {

        //…

        ServiceLookupResult res =
            retrieveServiceLocked(service, resolvedType, callingPackage,
                    callingPid, callingUid, userId, true, callerFg, false);
        if (res == null) {
            return null;
        }
        if (res.record == null) {
            return new ComponentName(&quot;!&quot;, res.permission != null
                    ? res.permission : &quot;private to package&quot;);
        }

        ServiceRecord r = res.record;
        //…
   ComponentName cmp = startServiceInnerLocked(smap, service, r, callerFg, addToStarting);
        return cmp;
    }
</code></pre><ul>
<li>bringUpServiceLocked方法会查找service需要运行在的进程，这里和启动Activity过程的startSpecificActivityLocked方法类似，获取进程的方法是AMS的getProcessRecordLocked，如果进程存在则通过realStartServiceLocked来启动service，如果需要的进程不存在则会调用AMS.startProcessLocked来创建进程，方法的参数则简单地从serviceRecord中获取，service的进程可以使用android:process来指定，我们前面分析过startProcessLocked会导AMS向Zygote发送请求fork一个子进程，并阻塞直到其被创建完成并写回一个pid，程已经fork完毕，注意这里并不是说应用进程就创建完毕了，因为这里是多进程的环境，我们不能在startProcessLocked返回时去处理启动或绑定service的逻辑，而是应该放到应用进程执行ActivityThread的attach方法绑定到AMS之后。这里我们只关注应用进程以及启动的情况，在bindService中我们会去看需要启动应用进程的情况</li>
</ul>
<pre><code>private String bringUpServiceLocked(ServiceRecord r, int intentFlags, boolean execInFg,
          boolean whileRestarting, boolean permissionsReviewRequired)
          throws TransactionTooLargeException {

      //...
      final String procName = r.processName;
      String hostingType = &quot;service&quot;;
      ProcessRecord app;

      if (!isolated) {
          app = mAm.getProcessRecordLocked(procName, r.appInfo.uid, false);
          if (DEBUG_MU) Slog.v(TAG_MU, &quot;bringUpServiceLocked: appInfo.uid=&quot; + r.appInfo.uid
                      + &quot; app=&quot; + app);
          if (app != null &amp;&amp; app.thread != null) {
              try {
                  app.addPackage(r.appInfo.packageName, r.appInfo.versionCode, mAm.mProcessStats);
                  realStartServiceLocked(r, app, execInFg);
                  return null;
              } catch (TransactionTooLargeException e) {
                  throw e;
              } catch (RemoteException e) {
                  Slog.w(TAG, &quot;Exception when starting service &quot; + r.shortName, e);
              }

              // If a dead object exception was thrown -- fall through to
              // restart the application.
          }
      } else {
          app = r.isolatedProc;
          if (WebViewZygote.isMultiprocessEnabled()
                  &amp;&amp; r.serviceInfo.packageName.equals(WebViewZygote.getPackageName())) {
              hostingType = &quot;webview_service&quot;;
          }
      }

      // Not running -- get it started, and enqueue this service record
      // to be executed when the app comes up.
      if (app == null &amp;&amp; !permissionsReviewRequired) {
          if ((app=mAm.startProcessLocked(procName, r.appInfo, true, intentFlags,
                  hostingType, r.name, false, isolated, false)) == null) {
              String msg = &quot;Unable to launch app &quot;
                      + r.appInfo.packageName + &quot;/&quot;
                      + r.appInfo.uid + &quot; for service &quot;
                      + r.intent.getIntent() + &quot;: process is bad&quot;;
              Slog.w(TAG, msg);
              bringDownServiceLocked(r);
              return msg;
          }
          if (isolated) {
              r.isolatedProc = app;
          }
      }

  //…
      return null;
  }
</code></pre><ul>
<li>这里只考虑应用进程存在的情况，不管在哪个进程启动什么activity或service都需要跨进程，因为AMS运行在system server进程当中，这里直接调用的是realStartServiceLocked方法，这个方法不只是在startService时会调用，而是会视情况导致onCreate，onStart和onBind被执行，它调用app.thread的scheduleCreateService方法，上一篇讲过这个app.thread就是为IApplicationThread的binder对象，scheduleCreateService方法会导致service的onCreate被调用，再往后看出现了sendServiceArgsLocked，这个方法则会导致onStartCommand被调用，这里都是通过app.thread的scheduleXXX进行的，由于再ActivityThread中最终是用handler来实现生命周期方法的调用，按照sendMessage的先后顺序onCreate和onStartcommand也先后执行</li>
</ul>
<pre><code>private final void realStartServiceLocked(ServiceRecord r, ProcessRecord app, boolean execInFg) throws RemoteException {
    //…
    try {
    //…
        app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);
        app.thread.scheduleCreateService(r, r.serviceInfo,
                mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),
                app.repProcState);
        r.postNotification();
        created = true;
    } catch (DeadObjectException e) {
        Slog.w(TAG, &quot;Application dead when creating service &quot; + r);
        mAm.appDiedLocked(app);
        throw e;
    } finally {
    //…           
    }

    if (r.whitelistManager) {
        app.whitelistManager = true;
    }

    requestServiceBindingsLocked(r, execInFg);

    updateServiceClientActivitiesLocked(app, null, true);

    if (r.startRequested &amp;&amp; r.callStart &amp;&amp; r.pendingStarts.size() == 0) {
        r.pendingStarts.add(new ServiceRecord.StartItem(r, false, r.makeNextStartId(),
                null, null, 0));
    }

    sendServiceArgsLocked(r, execInFg, true);

    if (r.delayed) {
        if (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, &quot;REM FR DELAY LIST (new proc): &quot; + r);
        getServiceMapLocked(r.userId).mDelayedStartList.remove(r);
        r.delayed = false;
    }

    if (r.delayedStop) {
        r.delayedStop = false;
        if (r.startRequested) {
            if (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE,
                    &quot;Applying delayed stop (from start): &quot; + r);
            stopServiceLocked(r);
        }
    }
}
</code></pre><ul>
<li>ActivityThread中的handler处理消息的部分没有什么特别的地方，我们直接看处理创建service的请求的方法handleCreateService，这里和Activity的创建也有很多类似的地方，主要流程是，获取loadedApk，使用classloader创建service，创建ContextImpl并绑定到service的mbase成员，调用service的onCreate方法，将service放入ActivityThread的成员mServices中，到这里startservice的流程就结束了</li>
</ul>
<pre><code>private void handleCreateService(CreateServiceData data) {
    // If we are getting ready to gc after going to the background, well
    // we are back active so skip it.
    unscheduleGcIdler();

    LoadedApk packageInfo = getPackageInfoNoCheck(
            data.info.applicationInfo, data.compatInfo);
    Service service = null;
    try {
        java.lang.ClassLoader cl = packageInfo.getClassLoader();
        service = (Service) cl.loadClass(data.info.name).newInstance();
    } catch (Exception e) {
        if (!mInstrumentation.onException(service, e)) {
            throw new RuntimeException(
                &quot;Unable to instantiate service &quot; + data.info.name
                + &quot;: &quot; + e.toString(), e);
        }
    }

    try {
        if (localLOGV) Slog.v(TAG, &quot;Creating service &quot; + data.info.name);

        ContextImpl context = ContextImpl.createAppContext(this, packageInfo);
        context.setOuterContext(service);

        Application app = packageInfo.makeApplication(false, mInstrumentation);
        service.attach(context, this, data.info.name, data.token, app,
                ActivityManager.getService());
        service.onCreate();
        mServices.put(data.token, service);
        try {
            ActivityManager.getService().serviceDoneExecuting(
                    data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    } catch (Exception e) {
        if (!mInstrumentation.onException(service, e)) {
            throw new RuntimeException(
                &quot;Unable to create service &quot; + data.info.name
                + &quot;: &quot; + e.toString(), e);
        }
    }
}
</code></pre><p><br></p>
<h4 id="bindService-绑定"><a href="#bindService-绑定" class="headerlink" title="bindService 绑定"></a>bindService 绑定</h4><ul>
<li>我们调用的bindService同样由ContextWrapper实现，同样由contextImpl实现</li>
</ul>
<pre><code>@Override
public boolean bindService(Intent service, ServiceConnection conn,
        int flags) {
    return mBase.bindService(service, conn, flags);
}

@Override
public boolean bindService(Intent service, ServiceConnection conn,
        int flags) {
    warnIfCallingFromSystemProcess();
    return bindServiceCommon(service, conn, flags, mMainThread.getHandler(),
            Process.myUserHandle());
}
</code></pre><ul>
<li>这里的bindServiceCommon主要是通过LoadedApk对象的getServiceDispatcher方法来获取一个binder对象，之前的源码解析中AMS和ActivityThread的通信主要是依赖IApplicationThread，但这里还多了一个IServiceConnection，实现类为ServiceDispatcher.InnerConnection(方法名不是很直观，getServiceDispatcher返回这个对象)，它主要封装了ServiceConnection对象，用来在AMS中跨进程调用onServiceConnected。获取完binder对象之后通过ActivityManager获取到AMS并调用bindService，和startService是一个模式了</li>
</ul>
<pre><code>    private boolean bindServiceCommon(Intent service, ServiceConnection conn, int flags, Handler
            handler, UserHandle user) {
        // Keep this in sync with DevicePolicyManager.bindDeviceAdminServiceAsUser.
        IServiceConnection sd;
        if (conn == null) {
            throw new IllegalArgumentException(&quot;connection is null&quot;);
        }
        if (mPackageInfo != null) {
            sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), handler, flags);
        } else {
            throw new RuntimeException(&quot;Not supported in system context&quot;);
        }
        validateServiceIntent(service);
        try {
//...
            int res = ActivityManager.getService().bindService(
                mMainThread.getApplicationThread(), getActivityToken(), service,
                service.resolveTypeIfNeeded(getContentResolver()),
                sd, flags, getOpPackageName(), user.getIdentifier());
            if (res &lt; 0) {
                throw new SecurityException(
                        &quot;Not allowed to bind to service &quot; + service);
            }
            return res != 0;
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
</code></pre><ul>
<li>AMS的bindService方法比较简单，只是进行了异常判断然后调用了ActiveService的bindServiceLocked，说一下文件描述符这点，这里不允许向AMS传递fd是因为多进程共享fd时容易导致fd leaks，因为binder是可以传递文件描述符的，binder多进程共享fd实质上是由parcel去管理fd，接受未知的fd是毫无必要的，容易导致太多文件未关闭而抛出异常(一个进程一般最多只能用于1024个fd)</li>
</ul>
<pre><code>public int bindService(IApplicationThread caller, IBinder token, Intent service,
        String resolvedType, IServiceConnection connection, int flags, String callingPackage,
        int userId) throws TransactionTooLargeException {
    enforceNotIsolatedCaller(&quot;bindService&quot;);

    // Refuse possible leaked file descriptors
    if (service != null &amp;&amp; service.hasFileDescriptors() == true) {
        throw new IllegalArgumentException(&quot;File descriptors passed in Intent&quot;);
    }

    if (callingPackage == null) {
        throw new IllegalArgumentException(&quot;callingPackage cannot be null&quot;);
    }

    synchronized(this) {
        return mServices.bindServiceLocked(caller, token, service,
                resolvedType, connection, flags, callingPackage, userId);
    }
}
</code></pre><ul>
<li>bindServiceLocked这是一个非常重要的方法，bindService的核心步骤在这里展开，因此该方法中调用的几个方法我们都需要关注，先来讲一下这个方法里发生了什么，这个方法里首先会调用retrieveServiceLocked来获取serviceRecord对象，这一步之前讲过了所以略去，之后的retrieveAppBindingLocked用于来获取一个AppBindRecord，AppBindRecord负责维护service与应用进程，然后调用bringUpServiceLocked来启动一个service，如果应用进程存在，直接调用IServviceConnection对象的connected实现onConnected的调用，最后调用requestServiceBindingLocked来实现onBind方法的调用，如果进程不存在则会走创建应用进程的流程，这里的s.app都为null，后面的大部分操作都不会执行</li>
</ul>
<pre><code>int bindServiceLocked(IApplicationThread caller, IBinder token, Intent service,
    try {
      //…
        AppBindRecord b = s.retrieveAppBindingLocked(service, callerApp);
        ConnectionRecord c = new ConnectionRecord(b, activity, connection, flags, clientLabel, clientIntent);
        IBinder binder = connection.asBinder();
        ArrayList&lt;ConnectionRecord&gt; clist = s.connections.get(binder);
        if (clist == null) {
            clist = new ArrayList&lt;ConnectionRecord&gt;();
            s.connections.put(binder, clist);
        }
        clist.add(c);
        b.connections.add(c);
        if (activity != null) {
            if (activity.connections == null) {
                activity.connections = new HashSet&lt;ConnectionRecord&gt;();
            }
            activity.connections.add(c);
        }
        b.client.connections.add(c);
        if ((c.flags&amp;Context.BIND_ABOVE_CLIENT) != 0) {
            b.client.hasAboveClient = true;
        }
        if ((c.flags&amp;Context.BIND_ALLOW_WHITELIST_MANAGEMENT) != 0) {
            s.whitelistManager = true;
        }
        if (s.app != null) {
            updateServiceClientActivitiesLocked(s.app, c, true);
        }
        clist = mServiceConnections.get(binder);
        if (clist == null) {
            clist = new ArrayList&lt;ConnectionRecord&gt;();
            mServiceConnections.put(binder, clist);
        }
        clist.add(c);

        if ((flags&amp;Context.BIND_AUTO_CREATE) != 0) {
            s.lastActivity = SystemClock.uptimeMillis();
            if (bringUpServiceLocked(s, service.getFlags(), callerFg, false,
                    permissionsReviewRequired) != null) {
                return 0;
            }
        }
        if (s.app != null) {
            if ((flags&amp;Context.BIND_TREAT_LIKE_ACTIVITY) != 0) {
                s.app.treatLikeActivity = true;
            }
            if (s.whitelistManager) {
                s.app.whitelistManager = true;
            }
            // This could have made the service more important.
            mAm.updateLruProcessLocked(s.app, s.app.hasClientActivities
                    || s.app.treatLikeActivity, b.client);
            mAm.updateOomAdjLocked(s.app, true);
        }

        if (s.app != null &amp;&amp; b.intent.received) {
            // Service is already running, so we can immediately
            // publish the connection.
            try {
                c.conn.connected(s.name, b.intent.binder, false);
            } catch (Exception e) {
                Slog.w(TAG, &quot;Failure sending service &quot; + s.shortName
                        + &quot; to connection &quot; + c.conn.asBinder()
                        + &quot; (in &quot; + c.binding.client.processName + &quot;)&quot;, e);
            }

            // If this is the first app connected back to this binding,
            // and the service had previously asked to be told when
            // rebound, then do so.
            if (b.intent.apps.size() == 1 &amp;&amp; b.intent.doRebind) {
                requestServiceBindingLocked(s, b.intent, callerFg, true);
            }
        } else if (!b.intent.requested) {
            requestServiceBindingLocked(s, b.intent, callerFg, false);
        }
        getServiceMapLocked(s.userId).ensureNotStartingBackgroundLocked(s);

    } finally {
        Binder.restoreCallingIdentity(origId);
    }
    return 1;
}
</code></pre><ul>
<li>先来看retrieveAppBindingLocked，AppBindRecord内部存储了绑定service的应用进程，被绑定的service，绑定时使用的intent，所有相关的connection，retrieveAppBindingLocked只负责获取已存在的AppBindRecord或创建新AppBindRecord并放入缓存，还是比较简单明了的</li>
</ul>
<pre><code>public AppBindRecord retrieveAppBindingLocked(Intent intent,
            ProcessRecord app) {
        Intent.FilterComparison filter = new Intent.FilterComparison(intent);
        IntentBindRecord i = bindings.get(filter);
        if (i == null) {
            i = new IntentBindRecord(this, filter);
            bindings.put(filter, i);
        }
        AppBindRecord a = i.apps.get(app);
        if (a != null) {
            return a;
        }
        a = new AppBindRecord(this, i, app);
        i.apps.put(app, a);
        return a;
    }


final class AppBindRecord {
    final ServiceRecord service;    // The running service.
    final IntentBindRecord intent;  // The intent we are bound to.
    final ProcessRecord client;     // Who has started/bound the service.

    final ArraySet&lt;ConnectionRecord&gt; connections = new ArraySet&lt;&gt;();
                                    // All ConnectionRecord for this client.
</code></pre><ul>
<li>bringUpServiceLocked用于拉起一个service，如果是service所在进程已经启动，这里会调用realStartServiceLocked来启动service，这个方法我们上一节也讲过，他会导致onCreate被调用，onStartCommand视情况被调用(这里是bindService，所以不会调用)</li>
</ul>
<pre><code>private String bringUpServiceLocked(ServiceRecord r, int intentFlags, boolean execInFg,
        boolean whileRestarting, boolean permissionsReviewRequired)
        throws TransactionTooLargeException {
    //Slog.i(TAG, &quot;Bring up service:&quot;);
    //r.dump(&quot;  &quot;);

    if (r.app != null &amp;&amp; r.app.thread != null) {
        sendServiceArgsLocked(r, execInFg, false);
        return null;
    }

    if (!whileRestarting &amp;&amp; mRestartingServices.contains(r)) {
        // If waiting for a restart, then do nothing.
        return null;
    }

    if (DEBUG_SERVICE) {
        Slog.v(TAG_SERVICE, &quot;Bringing up &quot; + r + &quot; &quot; + r.intent + &quot; fg=&quot; + r.fgRequired);
    }

    // We are now bringing the service up, so no longer in the
    // restarting state.
    if (mRestartingServices.remove(r)) {
        clearRestartingIfNeededLocked(r);
    }

    // Make sure this service is no longer considered delayed, we are starting it now.
    if (r.delayed) {
        if (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, &quot;REM FR DELAY LIST (bring up): &quot; + r);
        getServiceMapLocked(r.userId).mDelayedStartList.remove(r);
        r.delayed = false;
    }

    // Make sure that the user who owns this service is started.  If not,
    // we don&apos;t want to allow it to run.
    if (!mAm.mUserController.hasStartedUserState(r.userId)) {
        String msg = &quot;Unable to launch app &quot;
                + r.appInfo.packageName + &quot;/&quot;
                + r.appInfo.uid + &quot; for service &quot;
                + r.intent.getIntent() + &quot;: user &quot; + r.userId + &quot; is stopped&quot;;
        Slog.w(TAG, msg);
        bringDownServiceLocked(r);
        return msg;
    }

    // Service is now being launched, its package can&apos;t be stopped.
    try {
        AppGlobals.getPackageManager().setPackageStoppedState(
                r.packageName, false, r.userId);
    } catch (RemoteException e) {
    } catch (IllegalArgumentException e) {
        Slog.w(TAG, &quot;Failed trying to unstop package &quot;
                + r.packageName + &quot;: &quot; + e);
    }

    final boolean isolated = (r.serviceInfo.flags&amp;ServiceInfo.FLAG_ISOLATED_PROCESS) != 0;
    final String procName = r.processName;
    String hostingType = &quot;service&quot;;
    ProcessRecord app;

    if (!isolated) {
        app = mAm.getProcessRecordLocked(procName, r.appInfo.uid, false);
        if (DEBUG_MU) Slog.v(TAG_MU, &quot;bringUpServiceLocked: appInfo.uid=&quot; + r.appInfo.uid
                    + &quot; app=&quot; + app);
        if (app != null &amp;&amp; app.thread != null) {
            try {
                app.addPackage(r.appInfo.packageName, r.appInfo.versionCode, mAm.mProcessStats);
                realStartServiceLocked(r, app, execInFg);
                return null;
            } catch (TransactionTooLargeException e) {
                throw e;
            } catch (RemoteException e) {
                Slog.w(TAG, &quot;Exception when starting service &quot; + r.shortName, e);
            }

            // If a dead object exception was thrown -- fall through to
            // restart the application.
        }
    } else {
        // If this service runs in an isolated process, then each time
        // we call startProcessLocked() we will get a new isolated
        // process, starting another process if we are currently waiting
        // for a previous process to come up.  To deal with this, we store
        // in the service any current isolated process it is running in or
        // waiting to have come up.
        app = r.isolatedProc;
        if (WebViewZygote.isMultiprocessEnabled()
                &amp;&amp; r.serviceInfo.packageName.equals(WebViewZygote.getPackageName())) {
            hostingType = &quot;webview_service&quot;;
        }
    }

    // Not running -- get it started, and enqueue this service record
    // to be executed when the app comes up.
    if (app == null &amp;&amp; !permissionsReviewRequired) {
        if ((app=mAm.startProcessLocked(procName, r.appInfo, true, intentFlags,
                hostingType, r.name, false, isolated, false)) == null) {
            String msg = &quot;Unable to launch app &quot;
                    + r.appInfo.packageName + &quot;/&quot;
                    + r.appInfo.uid + &quot; for service &quot;
                    + r.intent.getIntent() + &quot;: process is bad&quot;;
            Slog.w(TAG, msg);
            bringDownServiceLocked(r);
            return msg;
        }
        if (isolated) {
            r.isolatedProc = app;
        }
    }

    if (!mPendingServices.contains(r)) {
        mPendingServices.add(r);
    }

    if (r.delayedStop) {
        // Oh and hey we&apos;ve already been asked to stop!
        r.delayedStop = false;
        if (r.startRequested) {
            if (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE,
                    &quot;Applying delayed stop (in bring up): &quot; + r);
            stopServiceLocked(r);
        }
    }

    return null;
}
</code></pre><ul>
<li>我们现在来看需要启动应用进程的情况是怎么实现的，在系统启动一篇中的应用进程启动中我们提到attachApplicationLocked(它是由ActivityThread的main方法间接调用的)使用mServices.attachApplicationLocked来关联service，这个mServices就是我们本文出现得最多的ActiveServices</li>
</ul>
<pre><code>if (!badApp) {
      try {
          didSomething |= mServices.attachApplicationLocked(app, processName);
          checkTime(startTime, &quot;attachApplicationLocked: after mServices.attachApplicationLocked&quot;);
      } catch (Exception e) {
          Slog.wtf(TAG, &quot;Exception thrown starting services in &quot; + app, e);
          badApp = true;
      }
  }
</code></pre><ul>
<li>attachApplicationLocked方法，这里获取了mPendingServices中的serviceRecord，这些serviceRecord是在bringUpServiceLocked是发现应用进程没有创建时加进去的，现在就一个个取出来调用   realStartServiceLocked来启动service</li>
</ul>
<pre><code>boolean attachApplicationLocked(ProcessRecord proc, String processName)
            throws RemoteException {
        boolean didSomething = false;
        // Collect any services that are waiting for this process to come up.
        if (mPendingServices.size() &gt; 0) {
            ServiceRecord sr = null;
            try {
                for (int i=0; i&lt;mPendingServices.size(); i++) {
                    sr = mPendingServices.get(i);
                    if (proc != sr.isolatedProc &amp;&amp; (proc.uid != sr.appInfo.uid
                            || !processName.equals(sr.processName))) {
                        continue;
                    }

                    mPendingServices.remove(i);
                    i--;
                    proc.addPackage(sr.appInfo.packageName, sr.appInfo.versionCode,
                            mAm.mProcessStats);
                    realStartServiceLocked(sr, proc, sr.createdFromFg);
                    didSomething = true;
                    if (!isServiceNeededLocked(sr, false, false)) {
                        // We were waiting for this service to start, but it is actually no
                        // longer needed.  This could happen because bringDownServiceIfNeeded
                        // won&apos;t bring down a service that is pending...  so now the pending
                        // is done, so let&apos;s drop it.
                        bringDownServiceLocked(sr);
                    }
                }
            } catch (RemoteException e) {
                Slog.w(TAG, &quot;Exception in new application when starting service &quot;
                        + sr.shortName, e);
                throw e;
            }
        }
        // Also, if there are any services that are waiting to restart and
        // would run in this process, now is a good time to start them.  It would
        // be weird to bring up the process but arbitrarily not let the services
        // run at this point just because their restart time hasn&apos;t come up.
        if (mRestartingServices.size() &gt; 0) {
            ServiceRecord sr;
            for (int i=0; i&lt;mRestartingServices.size(); i++) {
                sr = mRestartingServices.get(i);
                if (proc != sr.isolatedProc &amp;&amp; (proc.uid != sr.appInfo.uid
                        || !processName.equals(sr.processName))) {
                    continue;
                }
                mAm.mHandler.removeCallbacks(sr.restarter);
                mAm.mHandler.post(sr.restarter);
            }
        }
        return didSomething;
    }
</code></pre><ul>
<li>realStartServiceLocked中onCreate的调用我们已经分析过了，现在来分析onBind，在realStartServiceLocked间接调用的requestServiceBindingLocked方法中i.requested表示该service是否被绑定过，rebind表示是否需要调用重新绑定，rebind会在unbind调用过之后被设置为真，然后它调用ActivityThread的scheduleBindService，注意这个时候Looper的loop方法可能还没有调用，不过由于消息队列的机制，onCreate总会在onBind之前调用</li>
</ul>
<pre><code>  private final boolean requestServiceBindingLocked(ServiceRecord r, IntentBindRecord i,
            boolean execInFg, boolean rebind) throws TransactionTooLargeException {


        if ((!i.requested || rebind) &amp;&amp; i.apps.size() &gt; 0) {
            try {
                bumpServiceExecutingLocked(r, execInFg, &quot;bind&quot;);
                r.app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);
                r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind,
                        r.app.repProcState);
                if (!rebind) {
                    i.requested = true;
                }
                i.hasBound = true;
                i.doRebind = false;
            } catch (TransactionTooLargeException e) {
                // Keep the executeNesting count accurate.
                if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, &quot;Crashed while binding &quot; + r, e);
                final boolean inDestroying = mDestroyingServices.contains(r);
                serviceDoneExecutingLocked(r, inDestroying, inDestroying);
                throw e;
            } catch (RemoteException e) {
//...
            }
        }
        return true;
    }
</code></pre><ul>
<li>ActivityThread的handleBindService中调用了service的onBind方法，然后再一下connected方法是在哪里被调用的，一个是在bindServiceLocked中，我们已经知道了，对应应用进程已启动的情况，在未启动的情况下，则由在AMS的publishService</li>
</ul>
<pre><code>private void handleBindService(BindServiceData data) {
       Service s = mServices.get(data.token);
       if (DEBUG_SERVICE)
           Slog.v(TAG, &quot;handleBindService s=&quot; + s + &quot; rebind=&quot; + data.rebind);
       if (s != null) {
           try {
               data.intent.setExtrasClassLoader(s.getClassLoader());
               data.intent.prepareToEnterProcess();
               try {
                   if (!data.rebind) {
                       IBinder binder = s.onBind(data.intent);
                       ActivityManager.getService().publishService(
                               data.token, data.intent, binder);
                   } else {
                       s.onRebind(data.intent);
                       ActivityManager.getService().serviceDoneExecuting(
                               data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0);
                   }
                   ensureJitEnabled();
               } catch (RemoteException ex) {
                   throw ex.rethrowFromSystemServer();
               }
           } catch (Exception e) {
               if (!mInstrumentation.onException(s, e)) {
                   throw new RuntimeException(
                           &quot;Unable to bind to service &quot; + s
                           + &quot; with &quot; + data.intent + &quot;: &quot; + e.toString(), e);
               }
           }
       }
   }
</code></pre><ul>
<li>AMS会调用ActivityServices的publishServiceLocked方法，这个方法的缩进比较迷，但我们还是可以清楚的看到c.conn.connected被调用了</li>
</ul>
<pre><code>void publishServiceLocked(ServiceRecord r, Intent intent, IBinder service) {
       final long origId = Binder.clearCallingIdentity();
       try {
           if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, &quot;PUBLISHING &quot; + r
                   + &quot; &quot; + intent + &quot;: &quot; + service);
           if (r != null) {
               Intent.FilterComparison filter
                       = new Intent.FilterComparison(intent);
               IntentBindRecord b = r.bindings.get(filter);
               if (b != null &amp;&amp; !b.received) {
                   b.binder = service;
                   b.requested = true;
                   b.received = true;
                   for (int conni=r.connections.size()-1; conni&gt;=0; conni--) {
                       ArrayList&lt;ConnectionRecord&gt; clist = r.connections.valueAt(conni);
                       for (int i=0; i&lt;clist.size(); i++) {
                           ConnectionRecord c = clist.get(i);
                           if (!filter.equals(c.binding.intent.intent)) {
                               if (DEBUG_SERVICE) Slog.v(
                                       TAG_SERVICE, &quot;Not publishing to: &quot; + c);
                               if (DEBUG_SERVICE) Slog.v(
                                       TAG_SERVICE, &quot;Bound intent: &quot; + c.binding.intent.intent);
                               if (DEBUG_SERVICE) Slog.v(
                                       TAG_SERVICE, &quot;Published intent: &quot; + intent);
                               continue;
                           }
                           if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, &quot;Publishing to: &quot; + c);
                           try {
                               c.conn.connected(r.name, service, false);
                           } catch (Exception e) {
                               Slog.w(TAG, &quot;Failure sending service &quot; + r.name +
                                     &quot; to connection &quot; + c.conn.asBinder() +
                                     &quot; (in &quot; + c.binding.client.processName + &quot;)&quot;, e);
                           }
                       }
                   }
               }

               serviceDoneExecutingLocked(r, mDestroyingServices.contains(r), false);
           }
       } finally {
           Binder.restoreCallingIdentity(origId);
       }
   }
</code></pre><p><br><br><strong>到这里service的两种启动流程就介绍完了，startService和bindService根据应用进程是否已经启动可以分为四个流程，但其实大部分用到的方法都是相同的，和Activity的启动也有相似的地方，总得来说还是比较好理解的</strong></p>
<p><br><br><strong>本篇完</strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 系统系列 Looper & handler 机制 回顾]]></title>
      <url>/2019/01/21/AOSHandler/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><a href="https://tocreate.app/2018/09/05/androidSource/" target="_blank" rel="external">本文为Android 系统相关系列的一部分</a></p>
<p><strong>刚学android的时候也写过一篇handler机制的<a href="https://tocreate.app/2017/07/13/Handler/" target="_blank" rel="external">文章</a>，现在倒回去看觉得当时不是很懂原理，现在再过一遍</strong></p>
<p><strong>由于读源码时，我们见到的50%到80%都是没有营养的东西，所以我不会一点一点像单步调试一样地写下来，记要点就可以了</strong></p>
<p><br></p>
<h3 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h3><ul>
<li>应用编程发展到现在这个阶段，事件循环机制基本已经成为绝大多数GUI及相关框架必备的特性（更多时候其实作为一种限制条件出现），比如 AWT/Swing 的 <a href="https://www.cnblogs.com/ChrisWang/archive/2009/09/16/Swing-Single-Thread-Queue-Mode-And-Event-Dispatch-Thread.html" target="_blank" rel="external">EDT</a>，JS 的 <a href="https://www.cnblogs.com/MasterYao/p/5563725.html" target="_blank" rel="external">Event Loop</a>，QT 的 <a href="http://blog.51cto.com/9291927/1868744" target="_blank" rel="external">QEventLoop</a>, javaFX 的 Application Thread</li>
</ul>
<ul>
<li>线程事件循环机制的本质是使用多线程和某种事件通信机制，让耗时操作不在UI线程中执行，UI线程通常只处理绘制相关的操作，这样就可以一直维持界面的高响应灵敏度</li>
</ul>
<ul>
<li>Android的事件循环机制的构成元素主要有，一个生产者消费者模型(looper，message，queue,handler)，ThreadLocal，pipe/epoll，第一个是提得比较多的，多到做android的人会觉得恶心的程度，ThreadLocal稍微少点，因为不是很重要，至于epoll，这个就更少，不过其实挺重要的，面试也可能问。handler机制里面还有一个SyncBarrier模型，最近见到有人用这个实现预加载，也可以了解一下，不过如果依赖了rx，就没必要用这个了</li>
</ul>
<ul>
<li>下面会具体讲解实现，由于handler机制本身也是android面试中常问的一点，因此也会补充一下相关的问题</li>
</ul>
<p><br></p>
<h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><ul>
<li>我们看Handler的注释，从注释中总结出其要点是，Handler用于发送和处理消息(Message)和Runnable对象，使用Handler机制的线程都有一个消息队列(MessageQueue)，当Handler被创建时，它会与当前线程的MessageQueue绑定，并且基于该MessageQueue 发送/取出处理 Message 和 Runnable。这里里面没有提到，Looper是真正执行消息循环的对象，负责维护一个MessageQueue</li>
</ul>
<pre><code>/\*\*
 * A Handler allows you to send and process {@link Message} and Runnable
 * objects associated with a thread&apos;s {@link MessageQueue}.  Each Handler
 * instance is associated with a single thread and that thread&apos;s message
 * queue.  When you create a new Handler, it is bound to the thread /
 * message queue of the thread that is creating it -- from that point on,
 * it will deliver messages and runnables to that message queue and execute
 * them as they come out of the message queue.
 \* 
 * &lt;p&gt;There are two main uses for a Handler: (1) to schedule messages and
 * runnables to be executed as some point in the future; and (2) to enqueue
 * an action to be performed on a different thread than your own.
 \* 
 * &lt;p&gt;Scheduling messages is accomplished with the
 * {@link #post}, {@link #postAtTime(Runnable, long)},
 * {@link #postDelayed}, {@link #sendEmptyMessage},
 * {@link #sendMessage}, {@link #sendMessageAtTime}, and
 * {@link #sendMessageDelayed} methods.  The &lt;em&gt;post&lt;/em&gt; versions allow
 * you to enqueue Runnable objects to be called by the message queue when
 * they are received; the &lt;em&gt;sendMessage&lt;/em&gt; versions allow you to enqueue
 * a {@link Message} object containing a bundle of data that will be
 * processed by the Handler&apos;s {@link #handleMessage} method (requiring that
 * you implement a subclass of Handler).
 \* 
 * &lt;p&gt;When posting or sending to a Handler, you can either
 * allow the item to be processed as soon as the message queue is ready
 * to do so, or specify a delay before it gets processed or absolute time for
 * it to be processed.  The latter two allow you to implement timeouts,
 * ticks, and other timing-based behavior.
 \* 
 * &lt;p&gt;When a
 * process is created for your application, its main thread is dedicated to
 * running a message queue that takes care of managing the top-level
 * application objects (activities, broadcast receivers, etc) and any windows
 * they create.  You can create your own threads, and communicate back with
 * the main application thread through a Handler.  This is done by calling
 * the same &lt;em&gt;post&lt;/em&gt; or &lt;em&gt;sendMessage&lt;/em&gt; methods as before, but from
 * your new thread.  The given Runnable or Message will then be scheduled
 * in the Handler&apos;s message queue and processed when appropriate.
 \*/
public class Handler {
</code></pre><p><br></p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul>
<li>从实际经验得知，我们使用handler时，当前线程必须要有Looper，主线程中的 Looper，是android框架提供好的，而子线程中的Looper就需要自己创建了，流程固定都是调用Looper.prepare，创建handler，调用Looper.loop</li>
</ul>
<pre><code>//子线程上下文
Looper.prepare();
//并不是所有handler都要放这里
//但至少要让需要的handler有机会创建
//而不是让Looper空转
xxx = new XXXHandler(); 
Looper.loop();
</code></pre><ul>
<li>那么主线程的Looper是怎么来的呢，其实前几篇有讲到，它是在ActivityThread的main方法里面创建的，需要注意ActivityThread本身并不是个线程，而且它也不负责创建主线程（不过倒是main倒是会创建binder线程），这个main方法也不是普通java应用里的main class的main方法，从我们之前分析的流程可以知道ActivityThread的main方法是Zygote进程fork之后执行的，这之前使用抛出异常的方式清理了堆栈，让它看起来像我们平时见到的main方法</li>
</ul>
<ul>
<li>不过main方法乍看之下还是很单纯的，Looper.prepareMainLooper创建looper，new ActivityThread() 导致其成员变量的handler(就是mH)也被创建，最后调用Looper.loop这样就把主线程的Looper创建好了，之后我们的生命周期方法都是在mH处理消息时调用的</li>
</ul>
<pre><code>public static void main(String[] args) {
    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ActivityThreadMain&quot;);
    SamplingProfilerIntegration.start();

    // CloseGuard defaults to true and can be quite spammy.  We
    // disable it here, but selectively enable it later (via
    // StrictMode) on debug builds, but using DropBox, not logs.
    CloseGuard.setEnabled(false);

    Environment.initForCurrentUser();

    // Set the reporter for event logging in libcore
    EventLogger.setReporter(new EventLoggingReporter());

    // Make sure TrustedCertificateStore looks in the right place for CA certificates
    final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());
    TrustedCertificateStore.setDefaultUserDirectory(configDir);

    Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);

    Looper.prepareMainLooper();

    ActivityThread thread = new ActivityThread();
    thread.attach(false);

    if (sMainThreadHandler == null) {
        sMainThreadHandler = thread.getHandler();
    }

    if (false) {
        Looper.myLooper().setMessageLogging(new
                LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));
    }

    // End of event ActivityThreadMain.
    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
    Looper.loop();

    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);
}
</code></pre><ul>
<li>顺便提一下 ActivityThread的attach方法，这个方法导致的操作非常非常多，之前看源码时漏了一点，它会把AppThread传递给AMS，因为AMS需要它来跨进程调度ActivityThread，AMS获取它之后反过来调用其bindApplication方法，即回到ActivityThread的进程创建Application，这里和本文主题无关，之后会移到Activity创建一篇当中</li>
</ul>
<pre><code>private void attach(boolean system) {
        sCurrentActivityThread = this;
        mSystemThread = system;
        if (!system) {
            ViewRootImpl.addFirstDrawHandler(new Runnable() {
                @Override
                public void run() {
                    ensureJitEnabled();
                }
            });
            android.ddm.DdmHandleAppName.setAppName(&quot;&lt;pre-initialized&gt;&quot;,
            UserHandle.myUserId());
            RuntimeInit.setApplicationObject(mAppThread.asBinder());
            final IActivityManager mgr = ActivityManager.getService();
            try {
                mgr.attachApplication(mAppThread);
            } catch (RemoteException ex) {
                throw ex.rethrowFromSystemServer();
            }
            BinderInternal.addGcWatcher(new Runnable() {
                @Override public void run() {
                    if (!mSomeActivitiesChanged) {
                        return;
                    }
                    Runtime runtime = Runtime.getRuntime();
                    long dalvikMax = runtime.maxMemory();
                    long dalvikUsed = runtime.totalMemory() - runtime.freeMemory();
                        mSomeActivitiesChanged = false;
                        try {
                            mgr.releaseSomeActivities(mAppThread);
                        } catch (RemoteException e) {
                            throw e.rethrowFromSystemServer();
                        }
                    }
                }
            });
        } 
//...
</code></pre><p><br></p>
<h3 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h3><ul>
<li>按顺序来看prepare，入口要么是prepare()，要么是prepareMainLooper()，过程都会创建Looper对象，并且设置到ThreadLoal当中，区别在于prepareMainLooper需要保存sMainLooper，这个就是我们调用getMainLooper能拿到主线程的looper的原因（另外，这里加锁的原因不是很明白，虽然sMainLooper是共享变量，但是这里是刚fork出来的Zygote子进程，即使其他地方能同时走到main方法里的prepareMainLooper，也应该不在同一进程里面，因为走到这里的前提是执行了ZygoteInit，不过Android框架里面确实有很多很迷的同步操作，这里就不管了）</li>
</ul>
<pre><code> /** Initialize the current thread as a looper.
  * This gives you a chance to create handlers that then reference
  * this looper, before actually starting the loop. Be sure to call
  * {@link #loop()} after calling this method, and end it by calling
  * {@link #quit()}.
  */
public static void prepare() {
    prepare(true);
}

private static void prepare(boolean quitAllowed) {
    if (sThreadLocal.get() != null) {
        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);
    }
    sThreadLocal.set(new Looper(quitAllowed));
}

/**
 * Initialize the current thread as a looper, marking it as an
 * application&apos;s main looper. The main looper for your application
 * is created by the Android environment, so you should never need
 * to call this function yourself.  See also: {@link #prepare()}
 */
public static void prepareMainLooper() {
    prepare(false);
    synchronized (Looper.class) {
        if (sMainLooper != null) {
            throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);
        }
        sMainLooper = myLooper();
    }
}
</code></pre><ul>
<li>创建Looper，构造方法会同时创建MessageQueue并设置当前线程</li>
</ul>
<pre><code>private Looper(boolean quitAllowed) {
    mQueue = new MessageQueue(quitAllowed);
    mThread = Thread.currentThread();
}
</code></pre><ul>
<li>loop 方法，开启消息处理循环，由于底层使用epoll，所以不会引发很高的cpu占用率，退出条件是从消息队列MessageQueue中使用next获取的消息对象Message对象为null，next只会在Looper(quit方法被执行，这个方法会导致MessageQueue被标记为退出状态)被终止时返回null，如果能够获取掉消息对象,就会通过Message持有的handler对象(target)的dispatchMessage方法来分发消息</li>
</ul>
<pre><code>/\*\*
 * Run the message queue in this thread. Be sure to call
 * {@link #quit()} to end the loop.
 \*/
public static void loop() {
    final Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);
    }
    final MessageQueue queue = me.mQueue;
    // Make sure the identity of this thread is that of the local process,
    // and keep track of what that identity token actually is.
    Binder.clearCallingIdentity();
    final long ident = Binder.clearCallingIdentity();

    for (;;) {
        Message msg = queue.next(); // might block
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }
        final long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;

        final long traceTag = me.mTraceTag;
        if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) {
            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));
        }
        final long start = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();
        final long end;
        try {
                msg.target.dispatchMessage(msg);
            end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();
        } finally {
            if (traceTag != 0) {
                Trace.traceEnd(traceTag);
            }
        msg.recycleUnchecked();
    }
}
</code></pre><p><br></p>
<h3 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h3><ul>
<li>MessageQueue 涉及比较多的native方法，我们之后再看，先来看Handler</li>
</ul>
<ul>
<li>Handler用来发送和处理事件，由于Handler创建时绑定了looper，也就绑定了MessageQueue，因此handler可以往looper对应的线程的消息队列发送事件，这些事件被该线程的looper处理，因此事件处理的时机和发送时所在的线程无关，所以事件总是在执行loop方法的线程里处理</li>
</ul>
<ul>
<li>Handler的构造参数有三个，looper，指定looper也就指定的消息处理的线程，callBack，这个callBack的回调方法也叫handleMessage，它会在handler的handleMessage之前执行并且可以根据返回值来实现消息拦截，async，这个名字其实不是很贴切，它和后面提到的同步屏障(SyncBarrier)有关，具体作用就是，设置为true时，可以在消息队列中加入同步屏障，在同步屏障之后的消息，如果是同步的话，不会被取出处理，如果是异步的话则能正常取出，具体实现可以看后面的MessageQueue部分，系统只打算用这个机制来优化UI绘制，所以设置同步屏障的方法都是@hide的，因此只能通过反射调用，这篇<a href="https://blog.csdn.net/cdecde111/article/details/54670136" target="_blank" rel="external">文章</a>中结合了handlerThread来实现预加载，不过老实说预加载其实和handler没什么关系，基本只要有一套缓存和通知机制就可以实现了，如果使用rx，建议通过BehaviorSubject实现</li>
</ul>
<pre><code>public Handler(Looper looper, Callback callback, boolean async) {
        mLooper = looper;
        mQueue = looper.mQueue;
        mCallback = callback;
        mAsynchronous = async;
}
</code></pre><ul>
<li>发送事件时不管是调用post系列的方法还是调用send系列的方法，最终都会调用sendMessageAtTime这个接口，post发送的Runnable对象会被封装为message的callBack成员</li>
</ul>
<pre><code>/**
 * Enqueue a message into the message queue after all pending messages
 * before the absolute time (in milliseconds) &lt;var&gt;uptimeMillis&lt;/var&gt;.
 * &lt;b&gt;The time-base is {@link android.os.SystemClock#uptimeMillis}.&lt;/b&gt;
 * Time spent in deep sleep will add an additional delay to execution.
 * You will receive it in {@link #handleMessage}, in the thread attached
 * to this handler.
 * 
 * @param uptimeMillis The absolute time at which the message should be
 *         delivered, using the
 *         {@link android.os.SystemClock#uptimeMillis} time-base.
 *         
 * @return Returns true if the message was successfully placed in to the 
 *         message queue.  Returns false on failure, usually because the
 *         looper processing the message queue is exiting.  Note that a
 *         result of true does not mean the message will be processed -- if
 *         the looper is quit before the delivery time of the message
 *         occurs then the message will be dropped.
 */
public boolean sendMessageAtTime(Message msg, long uptimeMillis) {
    MessageQueue queue = mQueue;
    if (queue == null) {
        RuntimeException e = new RuntimeException(
                this + &quot; sendMessageAtTime() called with no mQueue&quot;);
        Log.w(&quot;Looper&quot;, e.getMessage(), e);
        return false;
    }
    return enqueueMessage(queue, msg, uptimeMillis);
}
</code></pre><ul>
<li>handler内部发送消息的实现则是enqueueMessage方法，该方法将msg<br>对象的target成员设置为当前handler(就是this)，这样looper在拿到msg的时候就可以同时得到处理它的handler了，这里还设置了msg的flags成员用它来标记是否启用(async是否为true)同步屏障</li>
</ul>
<pre><code>private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {
    msg.target = this;
    if (mAsynchronous) {
        msg.setAsynchronous(true);
    }
    return queue.enqueueMessage(msg, uptimeMillis);
}
</code></pre><ul>
<li>至于处理消息，之前looper部分已经提到了，looper拿到msg后调用其成员target(就是刚刚设置的handler)，调用dispatchMessage方法进行消息的分发，消息分发也有两种情况，一种是处理post发送的Runnable对象，毫不犹豫地调用run方法即可，一种是send发送的message对象，这里我们刚刚提到可以在handler设置的具有拦截功能的callBack就出现了，如果重写这个方法返回了true则消息不再处理，否则就交由handler进行二次处理，也就是我们平时常用的那个handleMessage方法</li>
</ul>
<pre><code>/**
 * Handle system messages here.
 */
public void dispatchMessage(Message msg) {
    if (msg.callback != null) {
        handleCallback(msg);
    } else {
        if (mCallback != null) {
            if (mCallback.handleMessage(msg)) {
                return;
            }
        }
        handleMessage(msg);
    }
}

private static void handleCallback(Message message) {
    message.callback.run();
}
</code></pre><p><br></p>
<h3 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h3><pre><code>/**
 *
 * Defines a message containing a description and arbitrary data object that can be
 * sent to a {@link Handler}.  This object contains two extra int fields and an
 * extra object field that allow you to not do allocations in many cases.
 *
 * &lt;p class=&quot;note&quot;&gt;While the constructor of Message is public, the best way to get
 * one of these is to call {@link #obtain Message.obtain()} or one of the
 * {@link Handler#obtainMessage Handler.obtainMessage()} methods, which will pull
 * them from a pool of recycled objects.&lt;/p&gt;
 */
public final class Message implements Parcelable {
    /**
     * User-defined message code so that the recipient can identify
     * what this message is about. Each {@link Handler} has its own name-space
     * for message codes, so you do not need to worry about yours conflicting
     * with other handlers.
     */
    public int what;

    /**
     * arg1 and arg2 are lower-cost alternatives to using
     * {@link #setData(Bundle) setData()} if you only need to store a
     * few integer values.
     */
    public int arg1;

    /**
     * arg1 and arg2 are lower-cost alternatives to using
     * {@link #setData(Bundle) setData()} if you only need to store a
     * few integer values.
     */
    public int arg2;

    /**
     * An arbitrary object to send to the recipient.  When using
     * {@link Messenger} to send the message across processes this can only
     * be non-null if it contains a Parcelable of a framework class (not one
     * implemented by the application).   For other data transfer use
     * {@link #setData}.
     *
     * &lt;p&gt;Note that Parcelable objects here are not supported prior to
     * the {@link android.os.Build.VERSION_CODES#FROYO} release.
     */
    public Object obj;

    /**
     * Optional Messenger where replies to this message can be sent.  The
     * semantics of exactly how this is used are up to the sender and
     * receiver.
     */
    public Messenger replyTo;

    /**
     * Optional field indicating the uid that sent the message.  This is
     * only valid for messages posted by a {@link Messenger}; otherwise,
     * it will be -1.
     */
    public int sendingUid = -1;

    /** If set message is in use.
     * This flag is set when the message is enqueued and remains set while it
     * is delivered and afterwards when it is recycled.  The flag is only cleared
     * when a new message is created or obtained since that is the only time that
     * applications are allowed to modify the contents of the message.
     *
     * It is an error to attempt to enqueue or recycle a message that is already in use.
     */
    /*package*/ static final int FLAG_IN_USE = 1 &lt;&lt; 0;

    /** If set message is asynchronous */
    /*package*/ static final int FLAG_ASYNCHRONOUS = 1 &lt;&lt; 1;

    /*package*/ int flags;

    /*package*/ long when;

    /*package*/ Bundle data;

    /*package*/ Handler target;

    /*package*/ Runnable callback;

    /*package*/ Message next;
</code></pre><ul>
<li>MessageQueue故名思议，消息队列，其节点数据结构为message。message比较重要的成员有 what，arg1，arg2，obj，data, target, callback，when，next，flags，replyTo，前面的，有用过handler的都知道是什么，说下最后三个</li>
</ul>
<pre><code>next: 下个节点的message，所以可以说MessageQueue其实是个单向链表

replyTo：客户端的Messager，在Messager机制中用到

flags: message状态的标志位，目前只有下面两种标记

FLAG\_IN\_USE：正在使用，刚创建或获取的Message都是未使用的，一旦提交给handler，直到被重新分配(obtain)或者可回收前都算使用中

FLAG\_ASYNCHRONOUS：是否为异步消息，可以联系前面的内容理解
</code></pre><ul>
<li>创建Message，要么直接new，要么调用obtain，Message中缓存了一个静态的链表，称为消息池sPool，实际上是个栈，每次都从表头摘下一个节点回收复用，sPool为空，才new一个Message</li>
</ul>
<pre><code>/**
 * Return a new Message instance from the global pool. Allows us to
 * avoid allocating new objects in many cases.
 */
public static Message obtain() {
    synchronized (sPoolSync) {
        if (sPool != null) {
            Message m = sPool;
            sPool = m.next;
            m.next = null;
            m.flags = 0; // clear in-use flag
            sPoolSize--;
            return m;
        }
    }
    return new Message();
}
</code></pre><ul>
<li>回收Message，检查Message是否在使用，否则放入表头(栈顶)</li>
</ul>
<pre><code>/**
 * Return a Message instance to the global pool.
 * &lt;p&gt;
 * You MUST NOT touch the Message after calling this function because it has
 * effectively been freed.  It is an error to recycle a message that is currently
 * enqueued or that is in the process of being delivered to a Handler.
 * &lt;/p&gt;
 */
public void recycle() {
    if (isInUse()) {
        if (gCheckRecycle) {
            throw new IllegalStateException(&quot;This message cannot be recycled because it &quot;
                    + &quot;is still in use.&quot;);
        }
        return;
    }
    recycleUnchecked();
}

/**
 * Recycles a Message that may be in-use.
 * Used internally by the MessageQueue and Looper when disposing of queued Messages.
 */
void recycleUnchecked() {
    // Mark the message as in use while it remains in the recycled object pool.
    // Clear out all other details.
    flags = FLAG_IN_USE;
    what = 0;
    arg1 = 0;
    arg2 = 0;
    obj = null;
    replyTo = null;
    sendingUid = -1;
    when = 0;
    target = null;
    callback = null;
    data = null;

    synchronized (sPoolSync) {
        if (sPoolSize &lt; MAX_POOL_SIZE) {
            next = sPool;
            sPool = this;
            sPoolSize++;
        }
    }
}
</code></pre><p><br></p>
<h3 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h3><p><br></p>
<h4 id="IdleHandler"><a href="#IdleHandler" class="headerlink" title="IdleHandler"></a>IdleHandler</h4><ul>
<li>MessageQueue的成员，我们只需要关注两个. mMessages，队列，一个单纯的Message对象，mIdleHandlers，闲置handler</li>
</ul>
<pre><code>Message mMessages;
private final ArrayList&lt;IdleHandler&gt; mIdleHandlers = new ArrayList&lt;IdleHandler&gt;();
</code></pre><ul>
<li>闲置handler，闲置不是什么都不干的意思，而是当MessageQueue里的消息都被处理完之后用来接收MessageQueue的这个idle状态的，idleHandler有一个queueIdle方法需要重写，在mMessages被looper掏空或者第一个消息指定的处理时间还没到达时调用，这种特殊的handler可以实现一些很酷的事情，比如，ActivityThread中的GC和非前台Activity的生命周期管理，分别由ActivityThread的GcIdler和Idler实现，这里我不分析源码，只给结论，有兴趣的可以自己去看</li>
</ul>
<pre><code>1.GC:
AMS会在某些情况下将会调用scheduleAppGcsLocked，这个方法将会可能会引发ActivityThread进行两种场景的gc
一种是低内存，一种是进程运行在后台
低内存时会回调进程中的Activity的onLowMemory，然后gc
运行在后台时相对没有那么严重，这个时候就使用到idleHandler，MessageQueue闲置后再gc
注意这里的gc指的都是手动调用runtime.gc()
基于ActivityThread中的GCWatcher机制，ActivityThread能感知到gc
不管哪种gc，ActivityThread都能在gc的同时选择释放一些Activity

2.非前台Activity的生命周期管理：
这里指的是
对pause的Activity进行stop或destroy
对Finishing的Activity进行destroy
例如前者，我们知道启动Activity时目标Activity的resume总是先于前一个Activity的stop
ActivitThread当resume完指定的Activity后也会进入idle状态，
因此这时就可以通过idleHanler去调用AMS的activityIdle方法，
activityIdle会对整个系统进行检查，大多数stop和destroy操作都由这里引发
</code></pre><ul>
<li>idleHandler在业务上也有作用，比如glide中用来在idle的时机清除已经被回收的弱引用，另外我们也可以使用它来在界面绘制完成(注意这个时机晚于onResume)之后做一些操作，比如这篇<a href="https://blog.csdn.net/tencent_bugly/article/details/78395717" target="_blank" rel="external">文章</a>中将复杂的界面设置放在绘制完成之后，这样可以先把简单的部分先显示给用户，而不会因为一部分的界面原因导致整个界面长时间处于空白状态</li>
</ul>
<ul>
<li>接下来正式看MessageQueue的方法，需要关注的有enqueueMessage，插入消息，next，获取消息，quit，退出</li>
</ul>
<p><br></p>
<h4 id="enqueueMessage"><a href="#enqueueMessage" class="headerlink" title="enqueueMessage"></a>enqueueMessage</h4><ul>
<li>enqueueMessage，插入消息，插入有两种情况，插入队头，对应情况为队列为空或消息的目标时间最早，反之则插入队中</li>
</ul>
<ul>
<li>插入后队列当然已经被更新了，但执行next的线程目前可能处于阻塞状态无法处理消息。导致阻塞的原因有两种，进入idle状态（无消息，或所有消息处理时机未到），或者队头为SyncBarrier并且后面全是同步消息。因为在阻塞前设置的唤醒机制所能做的有限，所以要么设置需要被外界主动唤醒，要么设置为在达到目前队列里第一个可处理的消息的处理时机自动唤醒</li>
</ul>
<ul>
<li>因此enqueueMessage还要负责唤醒next的线程，总的来说有两种情况需要唤醒，一是插入队头，因为需要直接处理这个新来的消息或者更新唤醒实际并重新阻塞，二是插入队头为SyncBarrier的队中，且这个消息比SyncBarrier后的所有异步消息处理时机都要早(队头不是SyncBarrier不需要唤醒是因为还轮不到这个消息，只要不是队头，随便插都行)，注意这些判断条件不是在enqueueMessage里全部做完的</li>
</ul>
<pre><code>boolean enqueueMessage(Message msg, long when) {
    if (msg.target == null) {
        throw new IllegalArgumentException(&quot;Message must have a target.&quot;);
    }
    if (msg.isInUse()) {
        throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);
    }

    synchronized (this) {
        if (mQuitting) {
            IllegalStateException e = new IllegalStateException(
                    msg.target + &quot; sending message to a Handler on a dead thread&quot;);
            Log.w(TAG, e.getMessage(), e);
            msg.recycle();
            return false;
        }

        msg.markInUse();
        msg.when = when;
        Message p = mMessages;
        boolean needWake;
        if (p == null || when == 0 || when &lt; p.when) {
            // New head, wake up the event queue if blocked.
            msg.next = p;
            mMessages = msg;
            needWake = mBlocked;
        } else {
            // Inserted within the middle of the queue.  Usually we don&apos;t have to wake
            // up the event queue unless there is a barrier at the head of the queue
            // and the message is the earliest asynchronous message in the queue.
            needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();
            Message prev;
            for (;;) {
                prev = p;
                p = p.next;
                if (p == null || when &lt; p.when) {
                    break;
                }
                if (needWake &amp;&amp; p.isAsynchronous()) {
                    needWake = false;
                }
            }
            msg.next = p; // invariant: p == prev.next
            prev.next = msg;
        }

        // We can assume mPtr != 0 because mQuitting is false.
        if (needWake) {
            nativeWake(mPtr);
        }
    }
    return true;
}
</code></pre><p><br></p>
<h4 id="next"><a href="#next" class="headerlink" title="next"></a>next</h4><ul>
<li>next，由looper调用的，这个方法的作用不是单纯的把消息从队列头里拿出来，整体效果应该是，待到第一个可处理的消息的处理时机返回这个消息，这两者差别是非常大的，可以自行体会一下</li>
</ul>
<ul>
<li>这个效果可以分为两个组成部分，一个是查找第一个可处理的消息，另一个是阻塞到这个消息的处理时机，我们分开来看，因为源码比较直观我就不分析了，只记录要点</li>
</ul>
<pre><code>Message next() {
    // Return here if the message loop has already quit and been disposed.
    // This can happen if the application tries to restart a looper after quit
    // which is not supported.
    final long ptr = mPtr;
    if (ptr == 0) {
        return null;
    }

    int pendingIdleHandlerCount = -1; // -1 only during first iteration
    int nextPollTimeoutMillis = 0;
    for (;;) {
        if (nextPollTimeoutMillis != 0) {
            Binder.flushPendingCommands();
        }

        nativePollOnce(ptr, nextPollTimeoutMillis);

        synchronized (this) {
            // Try to retrieve the next message.  Return if found.
            final long now = SystemClock.uptimeMillis();
            Message prevMsg = null;
            Message msg = mMessages;
            if (msg != null &amp;&amp; msg.target == null) {
                // Stalled by a barrier.  Find the next asynchronous message in the queue.
                do {
                    prevMsg = msg;
                    msg = msg.next;
                } while (msg != null &amp;&amp; !msg.isAsynchronous());
            }
            if (msg != null) {
                if (now &lt; msg.when) {
                    // Next message is not ready.  Set a timeout to wake up when it is ready.
                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
                } else {
                    // Got a message.
                    mBlocked = false;
                    if (prevMsg != null) {
                        prevMsg.next = msg.next;
                    } else {
                        mMessages = msg.next;
                    }
                    msg.next = null;
                    if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);
                    msg.markInUse();
                    return msg;
                }
            } else {
                // No more messages.
                nextPollTimeoutMillis = -1;
            }

            // Process the quit message now that all pending messages have been handled.
            if (mQuitting) {
                dispose();
                return null;
            }

            // If first time idle, then get the number of idlers to run.
            // Idle handles only run if the queue is empty or if the first message
            // in the queue (possibly a barrier) is due to be handled in the future.
            if (pendingIdleHandlerCount &lt; 0
                    &amp;&amp; (mMessages == null || now &lt; mMessages.when)) {
                pendingIdleHandlerCount = mIdleHandlers.size();
            }
            if (pendingIdleHandlerCount &lt;= 0) {
                // No idle handlers to run.  Loop and wait some more.
                mBlocked = true;
                continue;
            }

            if (mPendingIdleHandlers == null) {
                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];
            }
            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);
        }

        // Run the idle handlers.
        // We only ever reach this code block during the first iteration.
        for (int i = 0; i &lt; pendingIdleHandlerCount; i++) {
            final IdleHandler idler = mPendingIdleHandlers[i];
            mPendingIdleHandlers[i] = null; // release the reference to the handler

            boolean keep = false;
            try {
                keep = idler.queueIdle();
            } catch (Throwable t) {
                Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t);
            }

            if (!keep) {
                synchronized (this) {
                    mIdleHandlers.remove(idler);
                }
            }
        }

        // Reset the idle handler count to 0 so we do not run them again.
        pendingIdleHandlerCount = 0;

        // While calling an idle handler, a new message could have been delivered
        // so go back and look again for a pending message without waiting.
        nextPollTimeoutMillis = 0;
    }
}
</code></pre><ul>
<li>可处理的消息指消息队列没有被退出时，SyncBarrier前的消息或SyncBarrier后的异步消息，SyncBarrier在实现上只是一个target为null的消息，消息本来就是按处理时机从前往后排的，如果MessageQueue被退出了，返回null，否则按条件取排在最前面的即可,</li>
</ul>
<ul>
<li>处理时机，则是使用nativePollOnce的native方法这个方法由两个参数，一个是MessageQueue的指针，一个是阻塞的时间，阻塞时间为-1时只能由外界唤醒，next方法如果能拿到可以的消息就基于SystemClock.uptimeMillis()计算还差多少时间来设置这个参数，如果拿不到那就设为-1, 等enqueueMessage去唤醒它</li>
</ul>
<ul>
<li>注意IdleHandler的调用也是在next方法里实现的，因为拿得到消息的话就可以直接return的，所以循环体的最后即处于idle状态，idle状态处理完后进入下一次迭代</li>
</ul>
<pre><code>    // If first time idle, then get the number of idlers to run.
    // Idle handles only run if the queue is empty or if the first message
    // in the queue (possibly a barrier) is due to be handled in the future.
    if (pendingIdleHandlerCount &lt; 0
            &amp;&amp; (mMessages == null || now &lt; mMessages.when)) {
        pendingIdleHandlerCount = mIdleHandlers.size();
    }
    if (pendingIdleHandlerCount &lt;= 0) {
        // No idle handlers to run.  Loop and wait some more.
        mBlocked = true;
        continue;
    }

    if (mPendingIdleHandlers == null) {
        mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];
    }
    mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);
}

// Run the idle handlers.
// We only ever reach this code block during the first iteration.
for (int i = 0; i &lt; pendingIdleHandlerCount; i++) {
    final IdleHandler idler = mPendingIdleHandlers[i];
    mPendingIdleHandlers[i] = null; // release the reference to the handler

    boolean keep = false;
    try {
        keep = idler.queueIdle();
    } catch (Throwable t) {
        Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t);
    }

    if (!keep) {
        synchronized (this) {
            mIdleHandlers.remove(idler);
        }
    }
}
</code></pre><ul>
<li>quit, 这个方法设置一个mQuitting标志位，然后移除消息(参数safe为true时移除未处理的，否则移除全部)，然后唤醒next，这个时候next继续执行的话将会返回null，looper接受到这个null就知道要退出循环了</li>
</ul>
<pre><code>void quit(boolean safe) {
    if (!mQuitAllowed) {
        throw new IllegalStateException(&quot;Main thread not allowed to quit.&quot;);
    }

    synchronized (this) {
        if (mQuitting) {
            return;
        }
        mQuitting = true;

        if (safe) {
            removeAllFutureMessagesLocked();
        } else {
            removeAllMessagesLocked();
        }

        // We can assume mPtr != 0 because mQuitting was previously false.
        nativeWake(mPtr);
    }
}
</code></pre><p><br></p>
<h3 id="native"><a href="#native" class="headerlink" title="native"></a>native</h3><p><br></p>
<h4 id="Linux-pipe-epoll"><a href="#Linux-pipe-epoll" class="headerlink" title="Linux pipe/epoll"></a>Linux pipe/epoll</h4><ul>
<li>主要涉及 pipe poll epoll</li>
</ul>
<p><br></p>
<h4 id="Looper-amp-MessageQueue"><a href="#Looper-amp-MessageQueue" class="headerlink" title="Looper &amp; MessageQueue"></a>Looper &amp; MessageQueue</h4><ul>
<li>我们主要关注这两个文件</li>
</ul>
<pre><code>/system/core/libutils/Looper.cpp
/frameworks/base/core/jni/android\_os\_MessageQueue.cpp
</code></pre><p><br><br><strong>未完待续</strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 系统系列 Binder源码解析]]></title>
      <url>/2019/01/18/AOSBinder/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><a href="https://tocreate.app/2018/09/05/androidSource/" target="_blank" rel="external">本文为Android 系统相关系列的一部分</a></p>
<ul>
<li>想要深入理解Binder机制，推荐按顺序阅读下面三篇文章，然后挑着阅读老罗的源码分析</li>
</ul>
<ul>
<li><a href="https://blog.csdn.net/freekiteyu/article/details/70082302" target="_blank" rel="external">Android Binder 进程间通讯机制</a></li>
</ul>
<ul>
<li><a href="https://www.cnblogs.com/qingchen1984/p/5212755.html" target="_blank" rel="external">Android Binder 机制原理</a></li>
</ul>
<ul>
<li><a href="https://www.jianshu.com/p/adaa1a39a274" target="_blank" rel="external">Android Binder 面试题</a></li>
</ul>
<p><img src="http://wx2.sinaimg.cn/mw690/007vHOvngy1fzti7na4lrj30k20ak3yl.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 系统系列 Activity启动流程]]></title>
      <url>/2019/01/18/AOSActivityInit/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><a href="https://tocreate.app/2018/09/05/androidSource/" target="_blank" rel="external">本文为Android 系统相关系列的一部分</a></p>
<p><strong>Activity的启动流程分为两种，一种是根Activity，这是应用启动的第一个Activity，一般即为LauncherActivity，另一种为普通的Activity，本文只讲解根Activity的启动流程，基本上会覆盖到普通Activity的流程的重要的部分，因此就不单独再讲的普通Activity的了</strong></p>
<p><strong>本文参考</strong><br><strong>《Android 进阶解密》</strong><br><strong>《Android 系统源码情景分析》</strong><br><strong><a href="https://blog.csdn.net/yao_zhanlie/article/details/80771316" target="_blank" rel="external">Activity启动流程解析-基于安卓8.0系统源码</a></strong></p>
<p><br></p>
<h4 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h4><ul>
<li>由于Zygote，Launcher，AMS，ActivityThread运行在四个不同的进程当中，因此启动Activity的过程涉及的binder通信较为复杂</li>
</ul>
<ul>
<li>当用户点击Launcher界面的应用图标，Launcher进程会向SystemServer进程中的AMS发送创建根Activity的请求</li>
</ul>
<ul>
<li>AMS判断Activity的进程还未创建那么就会向Zygote进程请求创建想要的进程，因为这里讨论的是根Activity，那么这个进程当然就是没有创建的，这个过程上一篇已经过了一遍了</li>
</ul>
<ul>
<li>当应用进程创建完毕之后AMS会向应用进程当中的ApplicationThread请求创建根Activity，ApplicationThread，ApplicationThread最终通过ActivityThread创建Activity，并且调用preformCreate方法，这个方法会调用我们熟悉的onCreate方法</li>
</ul>
<p><br></p>
<h4 id="Launcher请求过程"><a href="#Launcher请求过程" class="headerlink" title="Launcher请求过程"></a>Launcher请求过程</h4><p><br></p>
<h5 id="构造intent"><a href="#构造intent" class="headerlink" title="构造intent"></a>构造intent</h5><ul>
<li>该过程由Launcher向AMS发送启动根Activity请求</li>
</ul>
<ul>
<li>当用户点击应用图标时，Launcher将构造intent，并调用startActivity方法，该intent的启动模式为newTask,因此它会在新的任务栈中启动</li>
</ul>
<pre><code>public boolean startActivitySafely(View v, Intent intent, ItemInfo item) {

//…
    // Prepare intent
    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    if (v != null) {
        intent.setSourceBounds(getViewBounds(v));
    }
    try {
        if (Utilities.ATLEAST_MARSHMALLOW
                &amp;&amp; (item instanceof ShortcutInfo)
                &amp;&amp; (item.itemType == Favorites.ITEM_TYPE_SHORTCUT
                 || item.itemType == Favorites.ITEM_TYPE_DEEP_SHORTCUT)
                &amp;&amp; !((ShortcutInfo) item).isPromise()) {
            // Shortcuts need some special checks due to legacy reasons.
            startShortcutIntentSafely(intent, optsBundle, item);
        } else if (user == null || user.equals(Process.myUserHandle())) {
            // Could be launching some bookkeeping activity
            startActivity(intent, optsBundle);
        } else {
            LauncherAppsCompat.getInstance(this).startActivityForProfile(
                    intent.getComponent(), user, intent.getSourceBounds(), optsBundle);
        }
        return true;
    } catch (ActivityNotFoundException|SecurityException e) {
        Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();
        Log.e(TAG, &quot;Unable to launch. tag=&quot; + item + &quot; intent=&quot; + intent, e);
    }
    return false;
}
</code></pre><p><br></p>
<h5 id="Instrumentation"><a href="#Instrumentation" class="headerlink" title="Instrumentation"></a>Instrumentation</h5><ul>
<li>Instrumentation类会在应用的任何代码执行前被实列化,用来监控系统与应用的交互。Instrumentation另一个重要作用是提供Android组件自动化测试，可在以应用的AndroidManifest.xml中\<instrumentation\>标签来注册一个Instrumentation的实现，<a href="http://www.cnblogs.com/keke-xiaoxiami/p/4307571.html" target="_blank" rel="external">详见</a></instrumentation\></li>
</ul>
<ul>
<li>startActivity方法会调用Instrumentation的execStartActivity方法</li>
</ul>
<pre><code>public ActivityResult execStartActivity(Context who, IBinder contextThread, IBinder token, Activity target,Intent intent, int requestCode, Bundle options) {

    //…
    try {
        intent.migrateExtraStreamToClipData();
        intent.prepareToLeaveProcess(who);
        int result = ActivityManager.getService()
            .startActivity(whoThread, who.getBasePackageName(), intent,
                    intent.resolveTypeIfNeeded(who.getContentResolver()),
                    token, target != null ? target.mEmbeddedID : null,
                    requestCode, 0, null, options);
        checkStartActivityResult(result, intent);
    } catch (RemoteException e) {
        throw new RuntimeException(&quot;Failure from system&quot;, e);
    }
    return null;
}
</code></pre><ul>
<li>execStartActivity会调用到ActivityManager的getService方法来获取AMS的代理对象并调用startActivity方法。这个代理对象也是从ServiceManager中的getService中获取的，这里不是很重要，因此略过</li>
</ul>
<p><br></p>
<h4 id="AMS处理请求"><a href="#AMS处理请求" class="headerlink" title="AMS处理请求"></a>AMS处理请求</h4><p><strong>这部分可能和上文创建应用进程有重复的地方，不过上篇只是大致讲了请求zygote的过程，这部分关注Activity和栈</strong></p>
<ul>
<li>AMS的startActivity方法，他会调用startActivityAsUser，这个方法判断进程是否被隔离，关于进程隔离可以看<a href="https://tocreate.app/2019/01/16/AndroidID/" target="_blank" rel="external">这篇</a>，在handleIncomingUser方法中还会检查用户权限</li>
</ul>
<pre><code>@Override
public final int startActivityAsUser(IApplicationThread caller, String callingPackage,
        Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,
        int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) {
    enforceNotIsolatedCaller(&quot;startActivity&quot;);
    userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(),
            userId, false, ALLOW_FULL_ONLY, &quot;startActivity&quot;, null);
    // TODO: Switch to user app stacks here.
    return mActivityStarter.startActivityMayWait(caller, -1, callingPackage, intent,
            resolvedType, null, null, resultTo, resultWho, requestCode, startFlags,
            profilerInfo, null, null, bOptions, false, userId, null, null,
            &quot;startActivityAsUser&quot;);
}
</code></pre><ul>
<li>startActivity会调用ActivityStarter的startActivityMayWait方法，ActivityStarter是7.0里的一个架构优化，负责Activity的启动，它会收集所有的逻辑，来决定如何将intent和flag转换为Activity，这里的业务逻辑比较复杂，不过我们不用太关心这部分内容，只要知道startActivityMayWait收集完这些信息之后会调用到startActivity方法</li>
</ul>
<ul>
<li>startActivity当中我们需要注意的是，这个方法有一个类型为ApplicationThread类型的caller，这个ApplicationThread正是launcher(或者其他启动者)进程的ApplicationThread，通过这个caller，可以获取一个ProcessRecord实例，这个实例描述了一个应用程序的进程，然后这个方法里创建了一个ActivityRecord实例，用来描述将要启动的Activity，把收集到的Activity信息都塞进去</li>
</ul>
<pre><code>    private int startActivity(IApplicationThread caller, Intent intent, Intent ephemeralIntent,
            String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,
            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,
            IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid,
            String callingPackage, int realCallingPid, int realCallingUid, int startFlags,
            ActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified,
            ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container,
            TaskRecord inTask) {
        int err = ActivityManager.START_SUCCESS;
        // Pull the optional Ephemeral Installer-only bundle out of the options early.
        final Bundle verificationBundle
                = options != null ? options.popAppVerificationBundle() : null;

        ProcessRecord callerApp = null;
        if (caller != null) {
            callerApp = mService.getRecordForAppLocked(caller);
            if (callerApp != null) {
                callingPid = callerApp.pid;
                callingUid = callerApp.info.uid;
            } else {
                Slog.w(TAG, &quot;Unable to find app for caller &quot; + caller
                        + &quot; (pid=&quot; + callingPid + &quot;) when starting: &quot;
                        + intent.toString());
                err = ActivityManager.START_PERMISSION_DENIED;
            }
        }

//...
        ActivityRecord r = new ActivityRecord(mService, callerApp, callingPid, callingUid,
                callingPackage, intent, resolvedType, aInfo, mService.getGlobalConfiguration(),
                resultRecord, resultWho, requestCode, componentSpecified, voiceSession != null,
                mSupervisor, container, options, sourceRecord);
        if (outActivity != null) {
            outActivity[0] = r;
        }

//…

        doPendingActivityLaunchesLocked(false);

        return startActivity(r, sourceRecord, voiceSession, voiceInteractor, startFlags, true,
                options, inTask, outActivity);
    }
</code></pre><ul>
<li>startActivity会调用到startActivityUnchecked，这个方法主要负责管理任务栈，由于是启动根Activity，这里因此mLaunchFlags就会包含FLAG_ACTIVITY_NEW_TASK，所以接下来会创建一个TaskRecord实例，该实例用来描述一个Activity任务栈，也就是说这里创建了一个新的任务栈，复合我们的预期</li>
</ul>
<pre><code>    private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord,
            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,
            int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask,
            ActivityRecord[] outActivity) {

//…
        if (mStartActivity.resultTo == null &amp;&amp; mInTask == null &amp;&amp; !mAddingToTask
                &amp;&amp; (mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) != 0) {
            newTask = true;
            result = setTaskFromReuseOrCreateNewTask(
                    taskToAffiliate, preferredLaunchStackId, topStack);
        } else if (mSourceRecord != null) {
            result = setTaskFromSourceRecord();
        } else if (mInTask != null) {
            result = setTaskFromInTask();
        } else {
            // This not being started from an existing activity, and not part of a new task...
            // just put it in the top task, though these days this case should never happen.
            setTaskToCurrentTopOrCreateNewTask();
        }
//…
        if (mDoResume) {
            final ActivityRecord topTaskActivity =
                    mStartActivity.getTask().topRunningActivityLocked();
            if (!mTargetStack.isFocusable()
                    || (topTaskActivity != null &amp;&amp; topTaskActivity.mTaskOverlay
                    &amp;&amp; mStartActivity != topTaskActivity)) {
                if (mTargetStack.isFocusable() &amp;&amp; !mSupervisor.isFocusedStack(mTargetStack)) {
                    mTargetStack.moveToFront(&quot;startActivityUnchecked&quot;);
                }
                mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity,
                        mOptions);
            }
        } else {
            mTargetStack.addRecentActivityLocked(mStartActivity);
        }
    //…
    }
</code></pre><ul>
<li>之后调用到ActivityStackSupervisor，这个类是专门用来处理系统中所有任务栈的逻辑的，系统中可以同时存在着多个活跃进程，多个不同进程的任务栈之间如何跳转，在这个类里面进行处理，它内部调用ActivityStack，ActivityStack则单独管理一个任务栈的逻辑，我们需要关注的是最后ActivityStackSupervisor的startSpecificActivityLocked将被调用</li>
</ul>
<ul>
<li>startSpecificActivityLocked中根Activity和普通Activity的流程才有了较大的分支，它会调用ActivityManagerService的getProcessRecordLocked来获取需要启动的Activity的进程，对于根Activity，一般得到null，对于普通的Activity，如果进程存活将得到ProcessRecord实例。拿不到进程的情况下，就会调用startProcessLocked来启动一个进程，否则直接调用realStartActivityLocked</li>
</ul>
<pre><code>void startSpecificActivityLocked(ActivityRecord r,
        boolean andResume, boolean checkConfig) {
    // Is this activity&apos;s application already running?
    ProcessRecord app = mService.getProcessRecordLocked(r.processName,
            r.info.applicationInfo.uid, true);

    r.getStack().setLaunchTime(r);

    if (app != null &amp;&amp; app.thread != null) {
        try {
            if ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == 0
                    || !&quot;android&quot;.equals(r.info.packageName)) {
                // Don&apos;t add this if it is a platform component that is marked
                // to run in multiple processes, because this is actually
                // part of the framework so doesn&apos;t make sense to track as a
                // separate apk in the process.
                app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode,
                        mService.mProcessStats);
            }
            realStartActivityLocked(r, app, andResume, checkConfig);
            return;
        } catch (RemoteException e) {
            Slog.w(TAG, &quot;Exception when starting activity &quot;
                    + r.intent.getComponent().flattenToShortString(), e);
        }

        // If a dead object exception was thrown -- fall through to
        // restart the application.
    }

    mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,
            &quot;activity&quot;, r.intent.getComponent(), false, false, true);
}
</code></pre><ul>
<li>创建应用进程的部分上一篇已经讲过了，Zygote监听socket，AMS请求被接受时Zygote就会fork并找到ActivityThread的main方法并执行，所以我们接下来只要看ActivityThread的main方法就好了</li>
</ul>
<pre><code>public static void main(String[] args) {
    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ActivityThreadMain&quot;);

    // CloseGuard defaults to true and can be quite spammy.  We
    // disable it here, but selectively enable it later (via
    // StrictMode) on debug builds, but using DropBox, not logs.
    CloseGuard.setEnabled(false);

    Environment.initForCurrentUser();

    // Set the reporter for event logging in libcore
    EventLogger.setReporter(new EventLoggingReporter());

    // Make sure TrustedCertificateStore looks in the right place for CA certificates
    final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());
    TrustedCertificateStore.setDefaultUserDirectory(configDir);

    Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);
    // TODO: 18-6-20 主线程的looper
    Looper.prepareMainLooper();
    //创建ActivityThread之后调用attach
    ActivityThread thread = new ActivityThread();
    thread.attach(false);

    if (sMainThreadHandler == null) {
        sMainThreadHandler = thread.getHandler();
    }

    if (false) {
        Looper.myLooper().setMessageLogging(new
                LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));
    }

    // End of event ActivityThreadMain.
    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
    Looper.loop();

    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);
</code></pre><ul>
<li>main方法创建完ActivityThread的实例后调用它的attach方法将其交回给AMS管理，这个流程上篇已经分析过了</li>
</ul>
<pre><code>private void attach(boolean system) {
        //...
            final IActivityManager mgr = ActivityManager.getService();
            try {
                mgr.attachApplication(mAppThread);
            } catch (RemoteException ex) {
                throw ex.rethrowFromSystemServer();
            }
        //...
    }
</code></pre><ul>
<li>AMS接受带ActivityThread之后，最终回到ActivityStackSupervisor的realStartActivityLocked，这里就回到普通Activity启动的过程了，注意网上很多人阅读源码参考的是刘望舒的进阶解密中根Activity启动的内容，但书中的流程直接是走getProcessRecordLocked得到进程后调用realStartActivityLocked方法的过程</li>
</ul>
<pre><code>boolean attachApplicationLocked(ProcessRecord app) throws RemoteException {
        final String processName = app.processName;
        boolean didSomething = false;
        for (int displayNdx = mActivityDisplays.size() - 1; displayNdx &gt;= 0; --displayNdx) {
            ArrayList&lt;ActivityStack&gt; stacks = mActivityDisplays.valueAt(displayNdx).mStacks;
            for (int stackNdx = stacks.size() - 1; stackNdx &gt;= 0; --stackNdx) {
                final ActivityStack stack = stacks.get(stackNdx);
                if (!isFocusedStack(stack)) {
                    continue;
                }
                stack.getAllRunningVisibleActivitiesLocked(mTmpActivityList);
                final ActivityRecord top = stack.topRunningActivityLocked();
                final int size = mTmpActivityList.size();
                for (int i = 0; i &lt; size; i++) {
                    final ActivityRecord activity = mTmpActivityList.get(i);
                    if (activity.app == null &amp;&amp; app.uid == activity.info.applicationInfo.uid
                            &amp;&amp; processName.equals(activity.processName)) {
                        try {
                            if (realStartActivityLocked(activity, app,
                                    top == activity /* andResume */, true /* checkConfig */)) {
                                didSomething = true;
                            }
                        } catch (RemoteException e) {
                            Slog.w(TAG, &quot;Exception in new application when starting activity &quot;
                                    + top.intent.getComponent().flattenToShortString(), e);
                            throw e;
                        }
                    }
                }
            }
        }
        if (!didSomething) {
            ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS);
        }
        return didSomething;
    }
</code></pre><p><br></p>
<h4 id="ActivityThread处理请求"><a href="#ActivityThread处理请求" class="headerlink" title="ActivityThread处理请求"></a>ActivityThread处理请求</h4><ul>
<li>该过程由AMS向ApplicationThread发送启动根Activity请求，我们先来看上面的realStartActivityLocked做了什么,它会调用app.thread.scheduleLaunchActivity，app即是ProcessRecord对象，thread则是ApplicationThread对象，ApplicationThread是ActivityThread的内部类，是一个binder对象，因此这里就进到了应用进程</li>
</ul>
<pre><code>final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app,
        boolean andResume, boolean checkConfig) throws RemoteException {

    //...
            logIfTransactionTooLarge(r.intent, r.icicle);
            app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken,
                    System.identityHashCode(r), r.info,
                    // TODO: Have this take the merged configuration instead of separate global
                    // and override configs.
                    mergedConfiguration.getGlobalConfiguration(),
                    mergedConfiguration.getOverrideConfiguration(), r.compat,
                    r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle,
                    r.persistentState, results, newIntents, !andResume,
                    mService.isNextTransitionForward(), profilerInfo);
            //...
        } catch (RemoteException e) {
            if (r.launchFailed) {
                // This is the second time we failed -- finish activity
                // and give up.
                Slog.e(TAG, &quot;Second failure launching &quot;
                        + r.intent.getComponent().flattenToShortString()
                        + &quot;, giving up&quot;, e);
                mService.appDiedLocked(app);
                stack.requestFinishActivityLocked(r.appToken, Activity.RESULT_CANCELED, null,
                        &quot;2nd-crash&quot;, false);
                return false;
            }

            //...
    return true;
}
</code></pre><ul>
<li>scheduleLaunchActivity后通信机制就变成了handler，使用的handler实现类为ActivityThread的内部类 H （没错，就是这个骚命名）</li>
</ul>
<pre><code>        @Override
        public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident,
                ActivityInfo info, Configuration curConfig, Configuration overrideConfig,
                CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor,
                int procState, Bundle state, PersistableBundle persistentState,
                List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents,
                boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) {

            updateProcessState(procState, false);

            ActivityClientRecord r = new ActivityClientRecord();

            r.token = token;
            r.ident = ident;
            r.intent = intent;
            r.referrer = referrer;
            r.voiceInteractor = voiceInteractor;
            r.activityInfo = info;
            r.compatInfo = compatInfo;
            r.state = state;
            r.persistentState = persistentState;

            r.pendingResults = pendingResults;
            r.pendingIntents = pendingNewIntents;

            r.startsNotResumed = notResumed;
            r.isForward = isForward;

            r.profilerInfo = profilerInfo;

            r.overrideConfig = overrideConfig;
            updatePendingConfiguration(curConfig);

            sendMessage(H.LAUNCH_ACTIVITY, r);
        }

    private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) {
        if (DEBUG_MESSAGES) Slog.v(
            TAG, &quot;SCHEDULE &quot; + what + &quot; &quot; + mH.codeToString(what)
            + &quot;: &quot; + arg1 + &quot; / &quot; + obj);
        Message msg = Message.obtain();
        msg.what = what;
        msg.obj = obj;
        msg.arg1 = arg1;
        msg.arg2 = arg2;
        if (async) {
            msg.setAsynchronous(true);
        }
        mH.sendMessage(msg);
    }

private class H extends Handler {
//...
        case LAUNCH_ACTIVITY: {
                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;);
                    final ActivityClientRecord r = (ActivityClientRecord) msg.obj;

                    r.packageInfo = getPackageInfoNoCheck(
                            r.activityInfo.applicationInfo, r.compatInfo);
                    handleLaunchActivity(r, null, &quot;LAUNCH_ACTIVITY&quot;);
                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                } break;
//...
}
</code></pre><ul>
<li>处理启动消息的方法是 handleLaunchActivity，这方法主要作用是通过performLaunchActivity启动Activity，然后将其状态设置为Resume</li>
</ul>
<pre><code>private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) {
    // If we are getting ready to gc after going to the background, well
    // we are back active so skip it.
    unscheduleGcIdler();
    mSomeActivitiesChanged = true;

    if (r.profilerInfo != null) {
        mProfiler.setProfiler(r.profilerInfo);
        mProfiler.startProfiling();
    }

    // Make sure we are running with the most recent config.
    handleConfigurationChanged(null, null);

    if (localLOGV) Slog.v(
        TAG, &quot;Handling launch of &quot; + r);

    // Initialize before creating the activity
    WindowManagerGlobal.initialize();

    Activity a = performLaunchActivity(r, customIntent);

    if (a != null) {
        r.createdConfig = new Configuration(mConfiguration);
        reportSizeConfigurations(r);
        Bundle oldState = r.state;
        handleResumeActivity(r.token, false, r.isForward,
                !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);

        if (!r.activity.mFinished &amp;&amp; r.startsNotResumed) {
            // The activity manager actually wants this one to start out paused, because it
            // needs to be visible but isn&apos;t in the foreground. We accomplish this by going
            // through the normal startup (because activities expect to go through onResume()
            // the first time they run, before their window is displayed), and then pausing it.
            // However, in this case we do -not- need to do the full pause cycle (of freezing
            // and such) because the activity manager assumes it can just retain the current
            // state it has.
            performPauseActivityIfNeeded(r, reason);

            // We need to keep around the original state, in case we need to be created again.
            // But we only do this for pre-Honeycomb apps, which always save their state when
            // pausing, so we can not have them save their state when restarting from a paused
            // state. For HC and later, we want to (and can) let the state be saved as the
            // normal part of stopping the activity.
            if (r.isPreHoneycomb()) {
                r.state = oldState;
            }
        }
    } else {
        // If there was an error, for any reason, tell the activity manager to stop us.
        try {
            ActivityManager.getService()
                .finishActivity(r.token, Activity.RESULT_CANCELED, null,
                        Activity.DONT_FINISH_TASK_WITH_ACTIVITY);
        } catch (RemoteException ex) {
            throw ex.rethrowFromSystemServer();
        }
    }
}
</code></pre><ul>
<li>performLaunchActivity则负责获取ActivityInfo类，这个类中可以的到Activity中的theme，launchmode等信息以及Apk文件描述类LoadedApk的实例，然后是创建appContext，Activity, Application, 注意appContext的类型为ContextImpl，是Context的实现类，之后调用了Activity的attach方法绑定到Activity当中，这个就是我们在ContextWrapper(Activity父类)中看到的mBase成员变量，Activit实例的创建是使用classloader实现的，之后初始化Activity的过程中会创建window对象并与Activity进行关联，然后调用Instrumentation的callActivityOncreate方法来启动Activity，最终由Activity的perform来调用它的onCreate，这样就达到我们熟悉的运行环境了</li>
</ul>
<pre><code>private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {
        ActivityInfo aInfo = r.activityInfo;
        if (r.packageInfo == null) {
            r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,
                    Context.CONTEXT_INCLUDE_CODE);
        }
        ComponentName component = r.intent.getComponent();
        if (component == null) {
            component = r.intent.resolveActivity(
                mInitialApplication.getPackageManager());
            r.intent.setComponent(component);
        }
        if (r.activityInfo.targetActivity != null) {
            component = new ComponentName(r.activityInfo.packageName,
                    r.activityInfo.targetActivity);
        }
        ContextImpl appContext = createBaseContextForActivity(r);
        Activity activity = null;
        try {
            java.lang.ClassLoader cl = appContext.getClassLoader();
            activity = mInstrumentation.newActivity(
                    cl, component.getClassName(), r.intent);
            StrictMode.incrementExpectedActivityCount(activity.getClass());
            r.intent.setExtrasClassLoader(cl);
            r.intent.prepareToEnterProcess();
            if (r.state != null) {
                r.state.setClassLoader(cl);
            }
        } catch (Exception e) {
          //...
             }
        }
        try {
            Application app = r.packageInfo.makeApplication(false, mInstrumentation);
//...
            if (activity != null) {
                CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());
                Configuration config = new Configuration(mCompatConfiguration);
                if (r.overrideConfig != null) {
                    config.updateFrom(r.overrideConfig);
                }
                if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Launching activity &quot;
                        + r.activityInfo.name + &quot; with config &quot; + config);
                Window window = null;
                if (r.mPendingRemoveWindow != null &amp;&amp; r.mPreserveWindow) {
                    window = r.mPendingRemoveWindow;
                    r.mPendingRemoveWindow = null;
                    r.mPendingRemoveWindowManager = null;
                }
                appContext.setOuterContext(activity);
                activity.attach(appContext, this, getInstrumentation(), r.token,
                        r.ident, app, r.intent, r.activityInfo, title, r.parent,
                        r.embeddedID, r.lastNonConfigurationInstances, config,
                        r.referrer, r.voiceInteractor, window, r.configCallback);

                if (customIntent != null) {
                    activity.mIntent = customIntent;
                }
                r.lastNonConfigurationInstances = null;
                checkAndBlockForNetworkAccess();
                activity.mStartedActivity = false;
                int theme = r.activityInfo.getThemeResource();
                if (theme != 0) {
                    activity.setTheme(theme);
                }
                activity.mCalled = false;
                if (r.isPersistable()) {
                    mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);
                } else {
                    mInstrumentation.callActivityOnCreate(activity, r.state);
                }
//...
            }
            r.paused = true;

            mActivities.put(r.token, r);
        } catch (SuperNotCalledException e) {
            throw e;

        } catch (Exception e) {
      //...
        }
        return activity;
    }
</code></pre><ul>
<li>到这里整个根Activity的启动流程就结束了，根Activity涉及的跨进程主要包括</li>
</ul>
<pre><code>根Activity：Launcher---&gt;System Server---&gt;APP---&gt;System Server---&gt;APP
普通Activity：APP--- &gt;System Server---&gt;APP
</code></pre><p><br><br><strong>本篇完</strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入JVM系列 9 - hotspot 7 & 8 运行时数据区]]></title>
      <url>/2019/01/18/JVMRuntime/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><a href="https://tocreate.app/2018/09/05/jvm/" target="_blank" rel="external">本文为深入JVM系列的一部分</a></p>
<p><a href="https://tocreate.app/2019/01/02/JVMHotspotRuntime/" target="_blank" rel="external">可能需要阅读前文</a></p>
<p><strong>主要内容为7的spec中的运行时数据区，这部分和hotspot 6也是比较贴近的，最后会记录hotspot8中的变化，主要是metaspace带来的一些改动</strong></p>
<p><br></p>
<h3 id="虚拟机规范"><a href="#虚拟机规范" class="headerlink" title="虚拟机规范"></a>虚拟机规范</h3><p><strong>以下内容来自java虚拟机规范 se 8</strong></p>
<p><br></p>
<h4 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h4><p><strong>灵魂画图</strong></p>
<pre><code>堆 heap
--------------------------------
|                                |
|  新生代 youngGen                |
|   ------------------------     |
|  |   eden     | from | to |    |
|   ------------------------     | 
|                                |
|  老年代 oldgen                  |
|   -------------------------    |
|  |          oldgen         |   |
|   -------------------------    |
--------------------------------

本地内存 native memory
--------------------------------------
|                                    |
|      线程1     线程2   ...  线程n    |
|    --------                        |
|   |   pc   |    ...                |
|    --------                        |
|       栈                           |
|    --------                        |
|   |   帧1  |                       |
|    --------                        |
|   |   ...  |                       |          
|    --------                        |
|   |   帧n  |                       |
|    --------                        |
|                                    |
--------------------------------------


方法区 method area
 ----------------------------------
|        class1           classN    |
|    --------------                 |
|   | 运行时常量池 |                  |
|    --------------                 |
|    --------------                 |  
|   |     字段     |                 |
|    --------------      ...        |
|    --------------                 |
|   |     方法     |                 |
|    --------------                 |
|    --------------                 |
|   |     代码     |                 |
|    --------------                 |
 -----------------------------------
</code></pre><p><br> </p>
<h4 id="PC寄存器"><a href="#PC寄存器" class="headerlink" title="PC寄存器"></a>PC寄存器</h4><ul>
<li>java虚拟机支持多条线程同时执行，每一条java线程都有自己的pc寄存器，在任意时刻，一条java线程只会执行一个方法的代码，称为当前方法，对于非native方法，pc寄存器保存正在执行的字节码指令地址，如果方法是native的，那么pc寄存器的值为undefined，pc寄存器至少能保存一个returnAddress类型的数据或一个平台相关的本地指针的值</li>
</ul>
<p><br> </p>
<h4 id="java堆"><a href="#java堆" class="headerlink" title="java堆"></a>java堆</h4><ul>
<li>java堆是供各个线程共享的运行时内存区域，也供所有类实例和数组对象分配内存区域</li>
</ul>
<ul>
<li>java堆在虚拟机启动时被创建，它存储了被垃圾收集器管理的各种对象，堆空间可以是固定的也可以是动态扩展和收缩的，内存也不要求是连续的</li>
</ul>
<p><br> </p>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><ul>
<li>它存储了每一个类的结构信息，如运行时常量池，字段，方法数据，构造函数和普通方法的字节码内容，还包含一些在类，实例，接口初始化时用到的特殊方法</li>
</ul>
<ul>
<li>方法区是供各个线程共享的运行时内存区域。方法区与传统语言中的编译代码存储区，或操作系统的正文段作用类似。方法区在虚拟机启动时创建，虽然是堆的逻辑组成部分，但简单的虚拟机可以选择在这个区域不实现垃圾收集与压缩。java 8 版本的虚拟机规范也不限定方法区的内存位置和编译代码的管理策略。</li>
</ul>
<ul>
<li>方法区空间可以是固定的也可以是动态扩展和收缩的，内存也不要求是连续的</li>
</ul>
<p><br> </p>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><ul>
<li>运行时常量池是每个class文件中的一个类或者接口的常量池表的运行时表现形式，类似于传统语言中的符号表，但数据范围更加广泛</li>
</ul>
<ul>
<li>每个运行时常量池都在java虚拟机的方法区中分配，在类和接口加载时创建</li>
</ul>
<p><br> </p>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><ul>
<li>本地方法栈，使用传统的栈支持native方法或使用其他语言支持指令集解释器时可以使用本地方法栈，本地方法栈不是必须的，如果本身不依赖传统栈，那么就不需要实现它，如果支持本地方法栈，一般在线程创建时按线程分配</li>
</ul>
<p><br> </p>
<h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><p><br> </p>
<h5 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h5><ul>
<li>每一个线程都有自己私有的虚拟机栈，它与线程同时创建，用于存储栈帧，栈帧可以在堆中分配</li>
</ul>
<ul>
<li>虚拟机规范允许栈设置为固定大小或动态增长或收缩</li>
</ul>
<p><br> </p>
<h5 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h5><ul>
<li>栈帧用来存储数据和部分过程结果的数据结构，同时用来处理动态链接，方法返回值和异常分配</li>
</ul>
<ul>
<li>栈帧由局部变量表，操作数栈，当前方法所属类的运行时常量池的引用构成，还允许携带实现相关的一些信息</li>
</ul>
<ul>
<li>栈帧随方法的调用创建，随方法的结束而销毁（无论正常还是异常结束），本地变量表和操作数栈的容量在编译时确定，并且同code属性保存及提供给栈帧使用，栈帧整体的大小则取决于实现，如果当前方法调用了其他方法，或者当前方法结束，这个方法的栈帧都不在是当前栈帧，方法返回时虚拟机将丢弃当前栈帧，使用前一个栈帧作为当前栈帧</li>
</ul>
<p><br> </p>
<h5 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h5><ul>
<li>每个栈帧内部包含一组称为局部变量表的变量列表。栈帧中的局部变量表的长度由编译时确定，并且存储于类或或接口的二进制表示之中，即通过方法的code属性保存及提供给栈帧使用</li>
</ul>
<ul>
<li>一个局部变量可以保存一个类型为boolean，byte，char，short，int，float，reference或returnAddress的数据，两个局部变量可以保存为一个类型为long或double的数据，首个局部变量的索引值为0，局部变量的索引值是整数，大小等于0，且小于局部变量表的长度</li>
</ul>
<ul>
<li>long和double类型的数据占用两个连续的局部变量，采用两个局部変量中较小的索引值来定位。將一个double类型的值存储在索引值为n的局部変量中，实际上的意思是索引值カn和n+1的兩个局部变量都用来存储这个值，索引值为n+1的局部変量是无法直接获取的，但可能会被写入，这种操作將会导致局部变量n的内容失效。n不一定需要是偶数，也不要求所有long和double采用64位对齐的方式连续存储</li>
</ul>
<ul>
<li>虚拟机使用局部变量表来完成方法调用时的参数传递。当调用静态的方法时，参数会一次传递到局部变量表中从0开始的连续位置上，当调用实例方法时，第0个参数为this，后续的其他参数将会传递到局部变量表中从1开始的位置</li>
</ul>
<p><br> </p>
<h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><ul>
<li>操作数栈上的每个位置都可以保存一个java虚拟机定义的任意数据类型，包括long和double，在任何时刻，操作数栈都有一个确定的栈深度，long和double栈两个单位的深度，其他数据类型占用一个深度</li>
</ul>
<ul>
<li>每个栈帧内部都包含一个称为操作数栈的先进后出栈，栈帧中操作数栈的最大深度由编译期决定，并且通过code属性保存及提供给栈帧使用，在上下文明确不会产生误解的前提下，当前栈帧的操作数栈直接称为操作数栈</li>
</ul>
<ul>
<li>栈帧在刚创建时，操作数栈是空的，java虚拟机提供一些字节码指令来从局部变量表或对象实例中复制常量或变量值到操作数栈中，从操作数栈中取走数据，操作数据以及把数据结果重新入栈。在调用方法时，操作数栈也用来准备调用方法的参数以及接受方法返回的结果</li>
</ul>
<ul>
<li>例如，iadd字节码指令的作用是将两个int类型的数值相加，它要求在执行iadd指令时，两个int类型数值从操作栈中出栈，相加求和，然后将求和的结果重新入栈，在操作数栈中，一项运算由多个子运算嵌套进行，一个子运算的结果可以被其他外围运算所使用</li>
</ul>
<ul>
<li>操作数栈中的数据必须正常操作，例如，不可以入栈连个int类型的数据，然后当做long类型去操作，有一小部分指令可以无视数据类型当做裸类型来操作，但他们不可以修改数据，也不可以拆散数据，这些操作的正确性由class文件的校验过程来保证</li>
</ul>
<p><br></p>
<h4 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h4><ul>
<li>每个栈帧内部都包含一个指向当前方法所在类的运行常量池的引用，以便对当前方法的代码实现动态链接，在class文件里面，一个方法若要调用其他方法，或者访问成员变量，则需要通过符号引用来表示，动态链接的作用就是将这些符号引用转换为对实际方法的直接引用。类加载的过程中将要解析未被解析的符号引用，并将对变量的访问转换为在运行时在存储结构中的正确偏移量</li>
</ul>
<ul>
<li>对其他类的方法和变量进行了晚期绑定，所以即使那些类发生了变化，也不会影响调用它们的方法</li>
</ul>
<p><br></p>
<h3 id="hotspot-实现"><a href="#hotspot-实现" class="headerlink" title="hotspot 实现"></a>hotspot 实现</h3><p><strong>虚拟机按用途将内存区域分为堆和非堆</strong></p>
<p><br></p>
<h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p><br></p>
<h5 id="分代"><a href="#分代" class="headerlink" title="分代"></a>分代</h5><ul>
<li>由于堆用于对象的分配，按对象年龄又再一步划分为新生代和老年代区域，注意虽然permGen属于分代范畴，但它位于非堆空间</li>
</ul>
<ul>
<li>分代基于jvm中大量对象死得快，少量对象死得慢的观点，对于不同的最新，采取不同的收集策略，分配不同的内存空间分别存储不同年龄的对象，对象可以分为三代</li>
</ul>
<pre><code>youngGen: 位于堆，包括 Eden 和 From/To Survivor 区
oldGen：   位于堆
permGen:  位于非堆
</code></pre><p><br></p>
<h5 id="堆的实现"><a href="#堆的实现" class="headerlink" title="堆的实现"></a>堆的实现</h5><ul>
<li>hotspot中使用什么样的堆实际是由使用什么样的垃圾收集策略决定的，直接使用的堆实现有三种 ParallelScavengeHeap，GenCollectedHeap，G1CollectedHeap，继承关系如下</li>
</ul>
<pre><code>              CollectedHeap
     --------------|-------------
     |                           |
ParallelScavengeHeap        SharedHeap
                              ———|———
                             |       |
                  GenCollectedHeap  G1CollectedHeap
</code></pre><ul>
<li>所谓使用什么样的策略，体现到实践中就是设什么参数启动什么gc收集器，体现到代码中就是使用什么policy，堆相关的代码实现在hotspot的内存管理模块 memory，参数上，UseParallelGC 对应 ParallelScavengeHeap，UseG1GC 对应G1CollectedHeap, G1CollectorPolicy，默认为 GenCollectedHeap，GenCollectedHeap对应的policy如下</li>
</ul>
<pre><code>默认：MarkSweepPolicy
UseSerialGC: MarkSweepPolicy
UseConcMarkSweepGC &amp; UseAdaptiveSizePolicy : ASConcurrentMarkSweepPolicy
UseConcMarkSweepGC: ConcurrentMarkSweepPolicy
</code></pre><p><br></p>
<h4 id="非堆"><a href="#非堆" class="headerlink" title="非堆"></a>非堆</h4><ul>
<li>非堆：包括方法区和code cache</li>
</ul>
<pre><code>注意，永久代和方法区是两个不同的概念
分代是属于gc范畴的概念，并且是基于hotspot的设计思想
方法区属于jvm设计规范的内容，方法区是否在堆中这点依赖于实现，至少hotpot就没有这么做
</code></pre><p><br></p>
<h3 id="hotspot8-变迁"><a href="#hotspot8-变迁" class="headerlink" title="hotspot8 变迁"></a>hotspot8 变迁</h3><p><strong>下面是r大给出的数据结构迁移，原文链接找不到了，有空补上</strong></p>
<ul>
<li><p>JDK7</p>
<p>  symbolOop (PermGen) -&gt; Symbol* (native\ heap 但不是Metaspace)<br>  interned String，包括interned String对象以及其背后的char[] (PermGen) -&gt; (普通Java heap)<br>  Java类的静态变量原本位于instanceKlass末尾 (PermGen) -&gt; java.lang.Class对象末尾 (普通Java heap）<br>  应对上一条，新增instanceMirrorKlass来描述java.lang.Class对象实例 </p>
</li>
</ul>
<ul>
<li>JDK8，从7移动到8的metaspace的结构，主要是与spec方法区相关的oop</li>
</ul>
<pre><code>受GC管理的非Java对象的基类跟Java对象一样是oopDesc -&gt; 非Java对象（元数据对象）的基类改为MetaspaceObj 
klassOop -&gt; Klass* 
xxxKlassKlass -&gt; 没了，不需要了 
methodOop -&gt; Method* 
methodDataOop -&gt; MethodData* 
constMethodOop -&gt; ConstMethod* 
constantPoolOop -&gt; ConstantPool* 
constantPoolCacheOop -&gt; ConstantPoolCache* 
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android - 系统中的各种id]]></title>
      <url>/2019/01/16/AndroidID/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><strong>看系统源码的时候遇到了 uid gid userId appId，当时不是很了解这些id的作用，这里记录一下</strong></p>
<p><strong><a href="https://blog.csdn.net/vshuang/article/details/43639211" target="_blank" rel="external">参考</a></strong></p>
<p><br></p>
<h3 id="Linux-UID-GID"><a href="#Linux-UID-GID" class="headerlink" title="Linux UID GID"></a>Linux UID GID</h3><ul>
<li>Android中的安全机制同样基于linux，Linux中使用ID来标识用户，每个登录的用户都会取得两个ID，UID和GID，Linux利用它们进行权限判断，每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理，Linux系统中的用户(UID)分为3类，即普通用户、root用户、系统用户</li>
</ul>
<ul>
<li>普通用户（uid 500-60000）是指所有使用Linux系统的真实用户，这类用户可以使用用户名及密码登录系统。一般来说普通用户只能在其家目录、系统临时目录或其他经过授权的目录中操作，以及操作属于该用户的文件。通常普通用户的UID大于500，因为在添加普通用户时，系统默认用户ID从500开始编号</li>
</ul>
<ul>
<li>root用户（ID 0），也被称为超级用户，root账户拥有对系统的完全控制权：可以修改、删除任何文件，运行任何命令</li>
</ul>
<ul>
<li>系统用户（UID 1-499）也叫伪用户，与系统和程序服务相关，因为并不是真实的使用者，所以叫伪用户，如bin、daemon、shutdown、halt等，任何Linux系统都默认有这些伪用户；mail、ftp、sshd等，与Linux系统的进程相关</li>
</ul>
<p><br></p>
<h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><p><br></p>
<h4 id="uid"><a href="#uid" class="headerlink" title="uid"></a>uid</h4><ul>
<li>在 Android 上，一个用户 UID 标示一个应用程序。应用程序在安装时被分配用户 UID，应用程序在设备上的存续期间内，用户 UID 保持不变。uid由userid和appid共同组成</li>
</ul>
<ul>
<li>在多用户的情况下，每个用户对应一个userid，同一用户启动的应用userid都是一致的</li>
</ul>
<ul>
<li>appid，每个应用都有一个appid，appid是由PackageManagerService在安装应用时分配的，同一应用的多个进程一般都拥有相同appid，只是pid不一样，appId的范围一定在10000到19999 </li>
</ul>
<p><br></p>
<h4 id="gid"><a href="#gid" class="headerlink" title="gid"></a>gid</h4><ul>
<li>对于普通的应用程序，GID即等于UID，值得一提的是，gid和权限组是相映射的，一个权限一般会属于一个gid，android中将权限分组，系统的每个权限都属于某个组，如果申请了一个组的一个权限，同时也会获取组中的其他权限（不过在8.0当中依然需要申请，只不过系统还是自动授权，不经过用户）</li>
</ul>
<p><br></p>
<h4 id="进程隔离"><a href="#进程隔离" class="headerlink" title="进程隔离"></a>进程隔离</h4><ul>
<li>隔离进程是4.1之后加入的安全机制，一般用于对系统有风险的代码，我们很少会用到</li>
</ul>
<ul>
<li>每个appID会属于某个用户组。同属于一个用户组的appid有些权限是共享的，在manifest中加入android:isolatedProcess=”true”参数，可以使service运行与应用userid不同的新进程当中，这样这个service就不会获取到当前应用的权限，并且也不允许启动Activity</li>
</ul>
<ul>
<li>系统判断一个进程是否为的条件为Process.FIRST_ISOLATED_UID &amp;&amp; appId \&lt;= Process.LAST_ISOLATED_UID，这些常量一般是编译时定好的</li>
</ul>
<p><br><br><strong>本篇完</strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 系统系列 进程优先级 & 保活]]></title>
      <url>/2019/01/10/AOSProcessPrio/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><br></p>
<h3 id="优先级类别"><a href="#优先级类别" class="headerlink" title="优先级类别"></a>优先级类别</h3><p><strong><a href="https://developer.android.com/guide/components/processes-and-threads" target="_blank" rel="external">来自</a></strong></p>
<ul>
<li>前台进程，用户当前操作所必需的进程。通常，在任意给定时间前台进程都为数不多。只有在内存不足以支持它们同时继续运行的情况下，才终止它们。前台进程的条件包括：</li>
</ul>
<pre><code>托管用户正在交互的 Activity（已调用 Activity 的 onResume() 方法）

托管某个 Service，后者绑定到用户正在交互的 Activity

托管正在“前台”运行的 Service（服务已调用 startForeground()）

托管正执行一个生命周期回调的 Service（onCreate()、onStart() 或 onDestroy()）

托管正执行其 onReceive() 方法的 BroadcastReceiver
</code></pre><ul>
<li>可见进程，没有任何前台组件、但仍会影响用户在屏幕上所见内容的进程，可见进程被视为是极其重要的进程，除非为了维持所有前台进程同时运行而必须终止，否则系统不会终止这些进程。 如果一个进程满足以下任一条件，即视为可见进程</li>
</ul>
<pre><code>托管不在前台、但仍对用户可见的 Activity（已调用其 onPause() 方法）
例如，如果前台 Activity 启动了一个对话框，允许在其后显示的Activity

托管绑定到可见（或前台）Activity 的 Service
</code></pre><ul>
<li>服务进程，正在运行已使用 startService() 方法启动的服务且不属于上述两个更高类别进程的进程。尽管服务进程与用户所见内容没有直接关联，但是它们通常在执行一些用户关心的操作（例如，在后台播放音乐或从网络下载数据）。因此，除非内存不足以维持所有前台进程和可见进程同时运行，否则系统会让服务进程保持运行状态</li>
</ul>
<ul>
<li>后台进程，包含目前对用户不可见的 Activity 的进程（已调用 Activity 的 onStop() 方法）。对用户体验没有直接影响，可以随时终止，回收内存。通常会有很多后台进程在运行，因此它们会保存在 LRU列表中，确保包含用户最近查看的 Activity 进程最后被终止。如果Activity 正确实现了生命周期方法，保存其当前状态，则终止其进程不会对用户产生明显影响</li>
</ul>
<ul>
<li>空进程，不含任何活动应用组件的进程。用作缓存，以缩短组件所需的启动时间。为使总体系统资源在进程缓存和底层内核缓存之间保持平衡，系统往往会终止这些进程</li>
</ul>
<p><br></p>
<h3 id="系统中的优先级"><a href="#系统中的优先级" class="headerlink" title="系统中的优先级"></a>系统中的优先级</h3><ul>
<li>进程中四大组件的状态就是决定进程优先级的根本依据，AMS持有的ProcessRecord，ProcessRecord持有了在其代表的进程中运行或绑定的组件信息，并且还有一些与oom_score_adj相关的域，用来实际指示进程的优先级，oom_score_adj来自linux内核中的oom killer机制</li>
</ul>
<pre><code>    int maxAdj;                 // Maximum OOM adjustment for this process
    int curRawAdj;              // Current OOM unlimited adjustment for this process
    int setRawAdj;              // Last set OOM unlimited adjustment for this process
    int curAdj;                 // Current OOM adjustment for this process
    int setAdj;                 // Last set OOM adjustment for this process
    int verifiedAdj;            // The last adjustment that was verified as actually being set

// all activities running in the process
    final ArrayList&lt;ActivityRecord&gt; activities = new ArrayList&lt;&gt;();
    // all ServiceRecord running in this process
    final ArraySet&lt;ServiceRecord&gt; services = new ArraySet&lt;&gt;();
    // services that are currently executing code (need to remain foreground).
    final ArraySet&lt;ServiceRecord&gt; executingServices = new ArraySet&lt;&gt;();
    // All ConnectionRecord this process holds
    final ArraySet&lt;ConnectionRecord&gt; connections = new ArraySet&lt;&gt;();
    // all IIntentReceivers that are registered from this process.
    final ArraySet&lt;ReceiverList&gt; receivers = new ArraySet&lt;&gt;();
    // class (String) -&gt; ContentProviderRecord
    final ArrayMap&lt;String, ContentProviderRecord&gt; pubProviders = new ArrayMap&lt;&gt;();
    // All ContentProviderRecord process is using
    final ArrayList&lt;ContentProviderConnection&gt; conProviders = new ArrayList&lt;&gt;();
</code></pre><ul>
<li>对于每一个运行中的进程，Linux内核都通过proc文件系统暴露/proc/[pid]/oom_score_adj文件允许其他程序修改指定进程的优先级，这个文件允许的值的范围是：-1000 到 +1000之间，值越小，表示进程越重要</li>
</ul>
<pre><code>在Linux 2.6.36之前的版本中，Linux 提供调整优先级的文件是/proc/[pid]/oom\_adj
允许的值的范围是-17 到 +15之间。数值越小表示进程越重要
在后面的版本中转换为oom\_score\_adj来使用
</code></pre><ul>
<li>下面是优先级的级别，注意这里的优先级都是区间，因此系统可以做更细粒度的控制</li>
</ul>
<table>
<thead>
<tr>
<th>ADJ 级别</th>
<th>取值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>NATIVE_ADJ</td>
<td>-1000</td>
<td>native进程</td>
</tr>
<tr>
<td>SYSTEM_ADJ</td>
<td>-900</td>
<td>仅指system_server进程</td>
</tr>
<tr>
<td>PERSISTENT_PROC_ADJ</td>
<td>-800</td>
<td>系统persistent进程</td>
</tr>
<tr>
<td>PERSISTENT_SERVICE_ADJ</td>
<td>-700</td>
<td>关联着系统或persistent进程</td>
</tr>
<tr>
<td>FOREGROUND_APP_ADJ</td>
<td>0</td>
<td>前台进程</td>
</tr>
<tr>
<td>VISIBLE_APP_ADJ</td>
<td>100</td>
<td>可见进程</td>
</tr>
<tr>
<td>PERCEPTIBLE_APP_ADJ</td>
<td>200</td>
<td>可感知进程，比如后台音乐播放</td>
</tr>
<tr>
<td>BACKUP_APP_ADJ</td>
<td>300</td>
<td>备份进程</td>
</tr>
<tr>
<td>HEAVY_WEIGHT_APP_ADJ</td>
<td>400</td>
<td>重量级进程</td>
</tr>
<tr>
<td>SERVICE_ADJ</td>
<td>500</td>
<td>服务进程</td>
</tr>
<tr>
<td>HOME_APP_ADJ</td>
<td>600</td>
<td>Home进程</td>
</tr>
<tr>
<td>PREVIOUS_APP_ADJ</td>
<td>700</td>
<td>上一个进程</td>
</tr>
<tr>
<td>SERVICE_B_ADJ</td>
<td>800</td>
<td>B List中的Service</td>
</tr>
<tr>
<td>CACHED_APP_MIN_ADJ</td>
<td>900</td>
<td>不可见进程的adj最小值</td>
</tr>
<tr>
<td>CACHED_APP_MAX_ADJ</td>
<td>906</td>
<td>不可见进程的adj最大值</td>
<td>_</td>
</tr>
</tbody>
</table>
<p><br></p>
<h3 id="进程保活"><a href="#进程保活" class="headerlink" title="进程保活"></a>进程保活</h3><h4 id="前台service"><a href="#前台service" class="headerlink" title="前台service"></a>前台service</h4><ul>
<li>开启前台Service，即Notification，如果不想让通知被显示出来，一般可以使用这两种手段</li>
</ul>
<pre><code>API \&lt; 18，启动前台Service时直接传入new Notification()

API \&gt;= 18，同时启动两个id相同的前台Service，然后再将后启动的Service做stop处理
</code></pre><h4 id="双进程"><a href="#双进程" class="headerlink" title="双进程"></a>双进程</h4><ul>
<li>双进程保护，使用一个业务进程和一个守护进程，在双方的onStartCommand中绑定另一个进程，在onServiceDisconnected中同时对另一个进程使用startService和bindService。这样可以时其中一个服务即将被销毁被另一个进程拉起</li>
</ul>
<h4 id="JobService"><a href="#JobService" class="headerlink" title="JobService"></a>JobService</h4><ul>
<li>使用JobService来实现应用退出后重启Service，即用JobService来轮询检查service是否被杀死，如果被杀死则重新启动，可以通过ActivityManager 的getRunningServices来判断service是否存活</li>
</ul>
<pre><code>/\*\*
 * 用于判断Service是否被杀死
 * Created by db on 2018/1/11.
 \*/
@TargetApi(Build.VERSION\_CODES.LOLLIPOP)//5.0以后可用
public class JobWakeUpService extends JobService{
    private int JobWakeUpId = 1;
    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        //开启轮寻
        JobInfo.Builder mJobBulider = new JobInfo.Builder(
                JobWakeUpId,new ComponentName(this,JobWakeUpService.class));
        //设置轮寻时间
        mJobBulider.setPeriodic(2000);
        JobScheduler mJobScheduler = (JobScheduler) getSystemService(Context.JOB_SCHEDULER_SERVICE);
        mJobScheduler.schedule(mJobBulider.build());
        return START_STICKY;
    }

    @Override
    public boolean onStartJob(JobParameters jobParameters) {
        //开启定时任务 定时轮寻 判断应用Service是否被杀死
        //如果被杀死则重启Service
        boolean messageServiceAlive = serviceAlive(StepService.class.getName());
        if(!messageServiceAlive){
            startService(new Intent(this,StepService.class));
        }

        return false;
    }

    @Override
    public boolean onStopJob(JobParameters jobParameters) {

        return false;
    }

    /**
     * 判断某个服务是否正在运行的方法
     * @param serviceName
     *            是包名+服务的类名（例如：net.loonggg.testbackstage.TestService）
     * @return true代表正在运行，false代表服务没有正在运行
     */
    private boolean serviceAlive(String serviceName) {
        boolean isWork = false;
        ActivityManager myAM = (ActivityManager)getSystemService(Context.ACTIVITY_SERVICE);
        List&lt;ActivityManager.RunningServiceInfo&gt; myList = myAM.getRunningServices(100);
        if (myList.size() &lt;= 0) {
            return false;
        }
        for (int i = 0; i &lt; myList.size(); i++) {
            String mName = myList.get(i).service.getClassName().toString();
            if (mName.equals(serviceName)) {
                isWork = true;
                break;
            }
        }
        return isWork;
    }
}
</code></pre><h4 id="开机广播"><a href="#开机广播" class="headerlink" title="开机广播"></a>开机广播</h4><ul>
<li>使用广播保证Service在开机后自动启动，注册BOOT_COMPLETED事件的广播，在onReceive方法中启动service</li>
</ul>
<h4 id="WakeLock"><a href="#WakeLock" class="headerlink" title="WakeLock"></a>WakeLock</h4><ul>
<li>使用WakeLock，当手机灭屏状态下保持一段时间后，系统会进入休眠，一些后台运行的任务就可能得不到正常执行，应用只要申请了WakeLock，那么在释放WakeLock之前，系统不会进入休眠，即使在灭屏的状态下，应用要执行的任务依旧不会被系统打断</li>
</ul>
<pre><code>owerManager pm = (PowerManager)mContext.getSystemService(
                                          Context.POWER_SERVICE);
PowerManager.WakeLock wl = pm.newWakeLock(
                                      PowerManager.PARTIAL_WAKE_LOCK
                                      | PowerManager.ON_AFTER_RELEASE,
                                      TAG);
wl.acquire();//为了保证任务不被系统休眠打断，申请WakeLock
// 开始我们的任务
wl.release();//任务结束后释放，如果不写该句。则可以用wl.acquire(timeout)的方式把释放的工作交给系统。
</code></pre><h4 id="1像素-Activity"><a href="#1像素-Activity" class="headerlink" title="1像素 Activity"></a>1像素 Activity</h4><ul>
<li>1像素Activity进程保活，其整个逻辑就是注册监听屏幕的广播，在手机屏幕黑屏时，启动一个1像素的Activity，在亮屏时关闭该Activity，该Activity需要是透明的</li>
</ul>
<pre><code>/\*\*
 * Created by Administrator on 2017/7/10.
 * 监听屏幕状态的广播
 \*/
public class OnePixelReceiver extends BroadcastReceiver {
    @Override
    public void onReceive(Context context, Intent intent) {
        if (intent.getAction().equals(Intent.ACTION_SCREEN_OFF)) {    //屏幕关闭启动1像素Activity
            Intent it = new Intent(context, OnePiexlActivity.class);
            it.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            context.startActivity(it);
        } else if (intent.getAction().equals(Intent.ACTION_SCREEN_ON)) {   //屏幕打开 结束1像素
            context.sendBroadcast(new Intent(&quot;finish&quot;));
            Intent main = new Intent(Intent.ACTION_MAIN);
            main.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
            main.addCategory(Intent.CATEGORY_HOME);
            context.startActivity(main);
        }
    }
}
</code></pre><h4 id="账号同步"><a href="#账号同步" class="headerlink" title="账号同步"></a>账号同步</h4><ul>
<li>账号同步，android系统里有一个账户系统，设置一个自己的账户，android会定期唤醒账户更新服务，我们可以自己设定同步的事件间隔。同步数据时会把已退出或完全结束的APP再次拉活起来，且发起更新的是系统，不会受到任何限制。缺点是用户会在系统设置的账户列表里面看到一个不认识的账户；同步的时间间隔是有限制，最短1分钟；某些手机比如note3需要手动设置账户；必须联网。账号同步的使用 <a href="https://blog.csdn.net/lyz_zyx/article/details/73571927" target="_blank" rel="external">详见</a></li>
</ul>
<h4 id="native"><a href="#native" class="headerlink" title="native"></a>native</h4><ul>
<li>native保活，<a href="https://blog.csdn.net/xixinmu/article/details/78993463" target="_blank" rel="external">详见</a></li>
</ul>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li>还有一些参考价值不大的方法，比如android:persistent=“true”(需要系统签名)，或STATR_STICK，意义不大</li>
</ul>
<p><br><br><strong>本篇完</strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 系统系列 Android 系统启动流程]]></title>
      <url>/2019/01/10/AOSInit/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><a href="https://tocreate.app/2018/09/05/androidSource/" target="_blank" rel="external">本文为Android 系统相关系列的一部分</a></p>
<p><br></p>
<h3 id="BootLoader"><a href="#BootLoader" class="headerlink" title="BootLoader"></a>BootLoader</h3><p><strong>CPU加电之后会执行rom中的BootLoader（uboot）引导linux内核，关于BootLoader，可以参考操作系统系列中的<a href="https://tocreate.app/2019/01/03/OSBiosBootLoader/" target="_blank" rel="external">引导内核</a>一篇</strong></p>
<p><br></p>
<h3 id="init进程"><a href="#init进程" class="headerlink" title="init进程"></a>init进程</h3><p><strong>关于init进程，<a href="https://tocreate.app/2018/12/02/OSProcess/" target="_blank" rel="external">进程与线程</a>一篇之前没写完，最近会补一下</strong></p>
<p><br></p>
<h3 id="Zygote进程"><a href="#Zygote进程" class="headerlink" title="Zygote进程"></a>Zygote进程</h3><p><br></p>
<h4 id="init-rc"><a href="#init-rc" class="headerlink" title="init.rc"></a>init.rc</h4><ul>
<li>init.rc是一种使用特殊语法的脚本文件，init进程从中解析和读取参数以及命令，将它们实现，init.rc 使用安卓初始化脚本语言（Android Init Language）编写，初始化脚本语言包括了4种基本的类型声明：行为，命令, 服务和选项</li>
</ul>
<ul>
<li>Action，命名的命令序列。每个action都有一个触发器trigger，触发器决定了行为什么时候执行。当一个符合Action触发条件的事件发生了，这个行为会加入到待执行队列</li>
</ul>
<pre><code>on &lt;trigger&gt;

  &lt;command&gt;

  &lt;command&gt;

  &lt;command&gt;
    ...
</code></pre><ul>
<li>Service，后台的程序，这个程序在init进程中被启动，如果退出了可以由系统重新启动（可选择）</li>
</ul>
<pre><code>service &lt;name&gt; &lt;pathname&gt; [&lt;argument&gt; ]\*

  &lt;option&gt;

  &lt;option&gt;
   ...
</code></pre><ul>
<li>Trigger，一个用于匹配某种事件类型的字符串，它将使对于的Action执行。Option，服务的修订项，他们决定了一个服务什么时候执行以及是如何去执行</li>
</ul>
<ul>
<li>android 8.0中对zygote的初始化配置从init.rc独立出来，根据体系命名为init.zygoteXX.rc，其中init.zygote64.rc如下，主要的作用是让init创建zygote，进程的路径为/system/bin/app_process64，classname为main，同时在zygote启动过程中，要在其内部创建一个名为zygote的socket</li>
</ul>
<pre><code>service zygote /system/bin/app\_process64 -Xzygote /system/bin --zygote --start-system-server
    class main
    priority -20
    user root
    group root readproc
    socket zygote stream 660 root system
    onrestart write /sys/android_power/request_state wake
    onrestart write /sys/power/state on
    onrestart restart audioserver
    onrestart restart cameraserver
    onrestart restart media
    onrestart restart netd
    onrestart restart wificond
    writepid /dev/cpuset/foreground/tasks
</code></pre><ul>
<li>在init.rc中包含启动classname为main的service的命令，这样就在init进程中启动了zygote</li>
</ul>
<pre><code>on nonencrypted
    class_start main
    class_start late_start
</code></pre><p><br></p>
<h4 id="abi"><a href="#abi" class="headerlink" title="abi"></a>abi</h4><ul>
<li>5.0以后,Android支持64位程序, 因此zygote也就有多种初始化脚本，可以在配置中选择其中一种，对于纯32模式和纯64位模式，只会启动一个zygote进程，如果兼容两种模式，则会创建两个zygote，则根据哪种模式为主模式，分为两种情况</li>
</ul>
<pre><code>init.zygote32.rc(对应app\_process32)
init.zygote64.rc(对应app\_process64)
init.zygote32\_64.rc(app\_process32为主模式，app\_process64为次模式)
init.zygote64\_32.rc(app\_process64为主模式，app\_process32为次模式)
</code></pre><ul>
<li>对于一个apk运行在32位还是在64位上，是由所使用的abi决定的，具体来说PackageManagerService会根据应用使用的native库进行判断，如果apk中的native库中含有64位的abi（如arm64-v8a）则选择64位的，否则若有32位的abi（如armeabi-v7a），选择32位的，若没有使用so，则以系统support的第一个abi，通常来说64位abi在前，当启动应用时会首先查看主模式的zygote是否支持该abi，否则在次模式中查看是否支持</li>
</ul>
<pre><code># getprop ro.product.cpu.abilist
arm64-v8a,armeabi-v7a,armeabi
</code></pre><p><br></p>
<h4 id="启动虚拟机"><a href="#启动虚拟机" class="headerlink" title="启动虚拟机"></a>启动虚拟机</h4><ul>
<li>在app_process，也就是zygote中，进行了虚拟机的启动，调用了AndroidRuntime（art）的start方法，然后为虚拟机注册jni方法，并通过jni调用ZygoteInit类的main方法，由此Zygote进入java层，在java层中进行初始化</li>
</ul>
<pre><code>/\*
 * Start the Android runtime.  This involves starting the virtual machine
 * and calling the &quot;static void main(String[] args)&quot; method in the class
 * named by &quot;className&quot;.
 \*
 * Passes the main function two arguments, the class name and the specified
 * options string.
 \*/
void AndroidRuntime::start(const char\* className, const Vector&lt;String8&gt;&amp; options, bool zygote)
{

    ...
    /* start the virtual machine */
    JniInvocation jni_invocation;
    jni_invocation.Init(NULL);
    JNIEnv* env;
    if (startVm(&amp;mJavaVM, &amp;env, zygote) != 0) {
        return;
    }
    onVmCreated(env);

    /*
     * Register android functions.
     */
    if (startReg(env) &lt; 0) {
        ALOGE(&quot;Unable to register all android natives\n&quot;);
        return;
    }

    /*
     * We want to call main() with a String array with arguments in it.
     * At present we have two arguments, the class name and an option string.
     * Create an array to hold them.
     */
    jclass stringClass;
    jobjectArray strArray;
    jstring classNameStr;

    stringClass = env-&gt;FindClass(&quot;java/lang/String&quot;);
    assert(stringClass != NULL);
    strArray = env-&gt;NewObjectArray(options.size() + 1, stringClass, NULL);
    assert(strArray != NULL);
    classNameStr = env-&gt;NewStringUTF(className);
    assert(classNameStr != NULL);
    env-&gt;SetObjectArrayElement(strArray, 0, classNameStr);

    for (size_t i = 0; i &lt; options.size(); ++i) {
        jstring optionsStr = env-&gt;NewStringUTF(options.itemAt(i).string());
        assert(optionsStr != NULL);
        env-&gt;SetObjectArrayElement(strArray, i + 1, optionsStr);
    }

    /*
     * Start VM.  This thread becomes the main thread of the VM, and will
     * not return until the VM exits.
     */
    char* slashClassName = toSlashClassName(className);
    jclass startClass = env-&gt;FindClass(slashClassName);
    if (startClass == NULL) {
        ALOGE(&quot;JavaVM unable to locate class &apos;%s&apos;\n&quot;, slashClassName);
        /* keep going */
    } else {
        jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, &quot;main&quot;,
            &quot;([Ljava/lang/String;)V&quot;);
        if (startMeth == NULL) {
            ALOGE(&quot;JavaVM unable to find main() in &apos;%s&apos;\n&quot;, className);
            /* keep going */
        } else {
            env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);

# if 0
            if (env-&gt;ExceptionCheck())
                threadExitUncaughtException(env);
# endif
        }
    }
    ...
}
</code></pre><p><br></p>
<h4 id="创建Socket"><a href="#创建Socket" class="headerlink" title="创建Socket"></a>创建Socket</h4><ul>
<li>zygote使用c/s模式，由AMS发送孵化请求，zygote接受到请求之后就进行fork，ZygoteInit的main方法主要流程是，创建LocalServerSocket，预加载类和资源，启动SystemServer，等待AMS请求</li>
</ul>
<pre><code>public static void main(String argv[]) {
        ...
        try {
            // Report Zygote start time to tron unless it is a runtime restart
            if (!&quot;1&quot;.equals(SystemProperties.get(&quot;sys.boot_completed&quot;))) {
                MetricsLogger.histogram(null, &quot;boot_zygote_init&quot;,
                        (int) SystemClock.elapsedRealtime());
            }

            String bootTimeTag = Process.is64Bit() ? &quot;Zygote64Timing&quot; : &quot;Zygote32Timing&quot;;
            BootTimingsTraceLog bootTimingsTraceLog = new BootTimingsTraceLog(bootTimeTag,
                    Trace.TRACE_TAG_DALVIK);
            bootTimingsTraceLog.traceBegin(&quot;ZygoteInit&quot;);
            RuntimeInit.enableDdms();
            // Start profiling the zygote initialization.
            SamplingProfilerIntegration.start();

            boolean startSystemServer = false;
            String socketName = &quot;zygote&quot;;
            String abiList = null;
            boolean enableLazyPreload = false;
            for (int i = 1; i &lt; argv.length; i++) {
                if (&quot;start-system-server&quot;.equals(argv[i])) {
                    startSystemServer = true;
                } else if (&quot;--enable-lazy-preload&quot;.equals(argv[i])) {
                    enableLazyPreload = true;
                } else if (argv[i].startsWith(ABI_LIST_ARG)) {
                    abiList = argv[i].substring(ABI_LIST_ARG.length());
                } else if (argv[i].startsWith(SOCKET_NAME_ARG)) {
                    socketName = argv[i].substring(SOCKET_NAME_ARG.length());
                } else {
                    throw new RuntimeException(&quot;Unknown command line argument: &quot; + argv[i]);
                }
            }

            if (abiList == null) {
                throw new RuntimeException(&quot;No ABI list supplied.&quot;);
            }

            zygoteServer.registerServerSocket(socketName);
            // In some configurations, we avoid preloading resources and classes eagerly.
            // In such cases, we will preload things prior to our first fork.
            if (!enableLazyPreload) {
                bootTimingsTraceLog.traceBegin(&quot;ZygotePreload&quot;);
                EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START,
                    SystemClock.uptimeMillis());
                preload(bootTimingsTraceLog);
                EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END,
                    SystemClock.uptimeMillis());
                bootTimingsTraceLog.traceEnd(); // ZygotePreload
            } else {
                Zygote.resetNicePriority();
            }

            // Finish profiling the zygote initialization.
            SamplingProfilerIntegration.writeZygoteSnapshot();

            // Do an initial gc to clean up after startup
            bootTimingsTraceLog.traceBegin(&quot;PostZygoteInitGC&quot;);
            gcAndFinalize();
            bootTimingsTraceLog.traceEnd(); // PostZygoteInitGC

            bootTimingsTraceLog.traceEnd(); // ZygoteInit
            // Disable tracing so that forked processes do not inherit stale tracing tags from
            // Zygote.
            Trace.setTracingEnabled(false);

            // Zygote process unmounts root storage spaces.
            Zygote.nativeUnmountStorageOnInit();

            // Set seccomp policy
            Seccomp.setPolicy();

            ZygoteHooks.stopZygoteNoThreadCreation();

            if (startSystemServer) {
                startSystemServer(abiList, socketName, zygoteServer);
            }

            Log.i(TAG, &quot;Accepting command socket connections&quot;);
            zygoteServer.runSelectLoop(abiList);

            zygoteServer.closeServerSocket();
        } catch (Zygote.MethodAndArgsCaller caller) {
            caller.run();
        } catch (Throwable ex) {
            Log.e(TAG, &quot;System zygote died with exception&quot;, ex);
            zygoteServer.closeServerSocket();
            throw ex;
        }
    }
</code></pre><ul>
<li>在linux中常用的ipc机制为，管道(pipe)，消息队列(message queue)，信号(signal)，信号量(Semaphore)，共享内存(share memory),套接字(socket)，在Android系统内部常用的ipc机制为 binder，匿名共享内存(ashmem)，LocalSocket。LocalSocket本身也不是一种原始的机制，它是Android中对Linux Socket的封装，能够bind到一个本地的文件描述符(fd)而不是某个IP地址和端口号，在系统内部大量使用</li>
</ul>
<pre><code>socket adbd stream 660 system system
    socket vold stream 0660 root mount
    socket netd stream 0660 root system
    socket dnsproxyd stream 0660 root inet
    socket mdns stream 0660 root system
    socket rild stream 660 root radio
    socket rild-debug stream 660 radio system
    socket zygote stream 660 root system
    socket installd stream 600 system system
    socket racoon stream 600 system system
    socket mtpd stream 600 system system
    socket dumpstate stream 0660 shell log
    socket mdnsd stream 0660 mdnsr inet
</code></pre><p><br></p>
<h3 id="SystemServer进程"><a href="#SystemServer进程" class="headerlink" title="SystemServer进程"></a>SystemServer进程</h3><p><br></p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><ul>
<li>SystemServer是zygote进程fork出来的第一个进程，主要用于创建系统服务</li>
</ul>
<pre><code>    /* Request to fork the system server process */
    pid = Zygote.forkSystemServer(
            parsedArgs.uid, parsedArgs.gid,
            parsedArgs.gids,
            parsedArgs.debugFlags,
            null,
            parsedArgs.permittedCapabilities,
            parsedArgs.effectiveCapabilities);
} catch (IllegalArgumentException ex) {
    throw new RuntimeException(ex);
}

/* For child process */
if (pid == 0) {
    if (hasSecondZygote(abiList)) {
        waitForSecondaryZygote(socketName);
    }

    zygoteServer.closeServerSocket();
    handleSystemServerProcess(parsedArgs);
}
</code></pre><ul>
<li>因为SystemServer复制了zygote的进程空间，因此需要做一些清理工作，主要是关闭之前开启的socket，之后会调用nativeZygoteInit在native层完成初始化工作，然后的RuntimeInit.applicationInit方法会通过传入的全限定名（这里是SystemServer类的main方法）找到main方法并通过异常的方式将该Method对象抛出来，这个异常会在ZygoteInit的main方法中接受并取出方法进行反射调用，这样做可以清理之前初始化工作堆栈帧，使SystemServer的main方法更像进程入口</li>
</ul>
<pre><code>public static final void zygoteInit(int targetSdkVersion, String[] argv,
        ClassLoader classLoader) throws Zygote.MethodAndArgsCaller {
    if (RuntimeInit.DEBUG) {
        Slog.d(RuntimeInit.TAG, &quot;RuntimeInit: Starting application from zygote&quot;);
    }

    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ZygoteInit&quot;);
    RuntimeInit.redirectLogStreams();

    RuntimeInit.commonInit();
    ZygoteInit.nativeZygoteInit();
    RuntimeInit.applicationInit(targetSdkVersion, argv, classLoader); //此处抛出异常
}
</code></pre><p><br></p>
<h4 id="启动Binder"><a href="#启动Binder" class="headerlink" title="启动Binder"></a>启动Binder</h4><ul>
<li>SystemServer的nativeZygoteInit最终会初始化一个binder连接池，用于与其他进程进行通信</li>
</ul>
<pre><code>virtual void onZygoteInit()
  {
      sp&lt;ProcessState&gt; proc = ProcessState::self();
      ALOGV(&quot;App process: starting thread pool.\n&quot;);
      proc-&gt;startThreadPool();
  }
</code></pre><p><br></p>
<h4 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h4><ul>
<li>SystemServer的java层，也就是SystemServer类，main方法执行run，主要流程为，初始化looper，加载so库（libandroid_servers.so，系统服务组件），创建context，启动系统服务</li>
</ul>
<ul>
<li>SystemServiceManager负责对系统服务进行创建，启动，生命周期管理</li>
</ul>
<ul>
<li>系统服务，android把服务分为3类，引导服务，核心服务，其他服务，引导服务包括Installers，DisplayManagerService等需要最先启动的服务，核心服务包括BatteryService，WebViewUpdateService等重要的服务，其他服务则是非紧要或不需要立即启动的服务，注意所有这些服务都创建在 SystemServer进程的线程当中，和我们平时业务中创建的服务不一样，我们平时在manifest中指定了进程的service，会通过socket发送给zygote来开启新进程</li>
</ul>
<pre><code>    public static void main(String[] args) {
        new SystemServer().run();
    }

    private void run() {
        try {
            ...
            Looper.prepareMainLooper();

            // Initialize native services.
            System.loadLibrary(&quot;android_servers&quot;);

            // Check whether we failed to shut down last time we tried.
            // This call may not return.
            performPendingShutdown();

            // Initialize the system context.
            createSystemContext();

            // Create the system service manager.
            mSystemServiceManager = new SystemServiceManager(mSystemContext);
            mSystemServiceManager.setRuntimeRestarted(mRuntimeRestart);
            LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);
            // Prepare the thread pool for init tasks that can be parallelized
            SystemServerInitThreadPool.get();
        } finally {
            traceEnd();  // InitBeforeStartServices
        }

        // Start services.
        try {
            traceBeginAndSlog(&quot;StartServices&quot;);
            startBootstrapServices();
            startCoreServices();
            startOtherServices();
            SystemServerInitThreadPool.shutdown();
        } catch (Throwable ex) {
            throw ex;
        } finally {
            traceEnd();
        }
}
</code></pre><p><br></p>
<h4 id="注册服务"><a href="#注册服务" class="headerlink" title="注册服务"></a>注册服务</h4><ul>
<li>SystemServiceManager虽然负责对service的生命周期管理，但是对于这些公用的service，不管是系统创建的，还是我们<a href="https://my.oschina.net/u/262208/blog/379584" target="_blank" rel="external">添加的service</a>，都需要一种机制进行获取，这个时候就涉及binder通信，这个时候使用的是另一个类叫ServiceManager，这个类的主要方法有addService（），getService（），listServices（），主要职责是控制用户访问服务，控制服务是否可以使用这一接口（通过注册时的检查权限），管理Service</li>
</ul>
<ul>
<li>如PackageManagerService的main方法，就将自己添加到ServiceManager当中</li>
</ul>
<pre><code>public static PackageManagerService main(Context context, Installer installer,
          boolean factoryTest, boolean onlyCore) {
      // Self-check for initial settings.
      PackageManagerServiceCompilerMapping.checkProperties();

      PackageManagerService m = new PackageManagerService(context, installer,
              factoryTest, onlyCore);
      m.enableSystemUserPackages();
      ServiceManager.addService(&quot;package&quot;, m);
      return m;
  }
</code></pre><p><br></p>
<h3 id="AMS"><a href="#AMS" class="headerlink" title="AMS"></a>AMS</h3><p><br></p>
<h5 id="应用进程启动"><a href="#应用进程启动" class="headerlink" title="应用进程启动"></a>应用进程启动</h5><ul>
<li>SystemServiceManager中创建的ActivityManagerService的用来统一接受启动组件的请求，如果组件所在的应用的进程不存在就会使用LocalSocket来向zygote请求创建新的应用进程，同时它还负责创建binder池，AMS中创建应用进程时都是调用startProcessLocked，其主要流程为以下几步</li>
</ul>
<pre><code>private final void startProcessLocked(ProcessRecord app, String hostingType,String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) {
       //...
        try {
            try {
                final int userId = UserHandle.getUserId(app.uid);
                AppGlobals.getPackageManager().checkPackageStartable(app.info.packageName, userId);
            } catch (RemoteException e) {
                throw e.rethrowAsRuntimeException();
            }

            int uid = app.uid;
            int[] gids = null;
            int mountExternal = Zygote.MOUNT_EXTERNAL_NONE;
            if (!app.isolated) {
                int[] permGids = null;
                try {
                    checkTime(startTime, &quot;startProcess: getting gids from package manager&quot;);
                    final IPackageManager pm = AppGlobals.getPackageManager();
                    permGids = pm.getPackageGids(app.info.packageName,
                            MATCH_DEBUG_TRIAGED_MISSING, app.userId);
                    StorageManagerInternal storageManagerInternal = LocalServices.getService(
                            StorageManagerInternal.class);
                    mountExternal = storageManagerInternal.getExternalStorageMountMode(uid,
                            app.info.packageName);
                } catch (RemoteException e) {
                    throw e.rethrowAsRuntimeException();
                }

                /*
                 * Add shared application and profile GIDs so applications can share some
                 * resources like shared libraries and access user-wide resources
                 */
                if (ArrayUtils.isEmpty(permGids)) {
                    gids = new int[3];
                } else {
                    gids = new int[permGids.length + 3];
                    System.arraycopy(permGids, 0, gids, 3, permGids.length);
                }
                gids[0] = UserHandle.getSharedAppGid(UserHandle.getAppId(uid));
                gids[1] = UserHandle.getCacheAppGid(UserHandle.getAppId(uid));
                gids[2] = UserHandle.getUserGid(UserHandle.getUserId(uid));
            }
     //...
            if (entryPoint == null) entryPoint = &quot;android.app.ActivityThread&quot;;
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;Start proc: &quot; +
                    app.processName);
            checkTime(startTime, &quot;startProcess: asking zygote to start proc&quot;);
            ProcessStartResult startResult;
            if (hostingType.equals(&quot;webview_service&quot;)) {
                startResult = startWebView(entryPoint,
                        app.processName, uid, uid, gids, debugFlags, mountExternal,
                        app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,
                        app.info.dataDir, null, entryPointArgs);
            } else {
                startResult = Process.start(entryPoint,
                        app.processName, uid, uid, gids, debugFlags, mountExternal,
                        app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,
                        app.info.dataDir, invokeWith, entryPointArgs);
            }
    //...
    }
</code></pre><ul>
<li>首先是设置 uid 和 gid(代码在上面)，uid和gid相关内容可以看这篇<a href="https://blog.csdn.net/vshuang/article/details/43639211" target="_blank" rel="external">文章</a>，简单来说（只讨论单用户的android机），系统会为每个应用赋予一个uid，如果多个应用没有在manifest中指定相同的uid的话，uid就是唯一的，应用独占一个进程，否则他们共享uid，并且运行在同一进程，android中将权限分组，系统的每个权限都属于某个组，如果申请了一个组的一个权限，同时也会获取组中的其他权限（不过在8.0当中依然需要申请，只不过系统还是自动授权，不经过用户），设置完id后调用的是Process.start方法</li>
</ul>
<ul>
<li>Process.start方法最终调用到ZygoteProcess的startViaZygote方法，前面还有一些参数解析的过程我们不需要关心，我们关注的是openZygoteSocketIfNeeded和zygoteSendArgsAndGetResult这两个方法，前者用于建立socket连接，后者用于向zygote发送创建进程的请求</li>
</ul>
<pre><code>synchronized(mLock) {
        return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);
    }
</code></pre><ul>
<li>openZygoteSocketIfNeeded方法，建立socket连接，之前说到zygote可能同时存在两个，所以这里会先尝试链接主模式的zygote，查看是否匹配，否则链接辅模式的zygote，这里是否匹配的标准是根据ZygoteState返回的abi是否支持传入的abi，前者是从ro.product.cpu.abilist64，ro.product.cpu.abilist32这两个属性得来的，后者在前面abi一节已经提过了</li>
</ul>
<pre><code>private ZygoteState openZygoteSocketIfNeeded(String abi) throws ZygoteStartFailedEx {
      Preconditions.checkState(Thread.holdsLock(mLock), &quot;ZygoteProcess lock not held&quot;);

      if (primaryZygoteState == null || primaryZygoteState.isClosed()) {
          try {
              primaryZygoteState = ZygoteState.connect(mSocket);
          } catch (IOException ioe) {
              throw new ZygoteStartFailedEx(&quot;Error connecting to primary zygote&quot;, ioe);
          }
      }

      if (primaryZygoteState.matches(abi)) {
          return primaryZygoteState;
      }

      // The primary zygote didn&apos;t match. Try the secondary.
      if (secondaryZygoteState == null || secondaryZygoteState.isClosed()) {
          try {
              secondaryZygoteState = ZygoteState.connect(mSecondarySocket);
          } catch (IOException ioe) {
              throw new ZygoteStartFailedEx(&quot;Error connecting to secondary zygote&quot;, ioe);
          }
      }

      if (secondaryZygoteState.matches(abi)) {
          return secondaryZygoteState;
      }

      throw new ZygoteStartFailedEx(&quot;Unsupported zygote ABI: &quot; + abi);
  }
</code></pre><ul>
<li>zygoteSendArgsAndGetResult，这里发送了创建进程的请求，创建成功之后会写回进程的pid，这里的读是阻塞的，因此会等到SystemServer进程处理完请求，要么fork成功，要么fork失败</li>
</ul>
<pre><code>/**
 * Sends an argument list to the zygote process, which starts a new child
 * and returns the child&apos;s pid. Please note: the present implementation
 * replaces newlines in the argument list with spaces.
 *
 * @throws ZygoteStartFailedEx if process start failed for any reason
 */
@GuardedBy(&quot;mLock&quot;)
private static Process.ProcessStartResult zygoteSendArgsAndGetResult(
        ZygoteState zygoteState, ArrayList&lt;String&gt; args)
        throws ZygoteStartFailedEx {
    try {
        // Throw early if any of the arguments are malformed. This means we can
        // avoid writing a partial response to the zygote.
        int sz = args.size();
        for (int i = 0; i &lt; sz; i++) {
            if (args.get(i).indexOf(&apos;\n&apos;) &gt;= 0) {
                throw new ZygoteStartFailedEx(&quot;embedded newlines not allowed&quot;);
            }
        }

        /**
         * See com.android.internal.os.SystemZygoteInit.readArgumentList()
         * Presently the wire format to the zygote process is:
         * a) a count of arguments (argc, in essence)
         * b) a number of newline-separated argument strings equal to count
         *
         * After the zygote process reads these it will write the pid of
         * the child or -1 on failure, followed by boolean to
         * indicate whether a wrapper process was used.
         */
        final BufferedWriter writer = zygoteState.writer;
        final DataInputStream inputStream = zygoteState.inputStream;

        writer.write(Integer.toString(args.size()));
        writer.newLine();

        for (int i = 0; i &lt; sz; i++) {
            String arg = args.get(i);
            writer.write(arg);
            writer.newLine();
        }

        writer.flush();

        // Should there be a timeout on this?
        Process.ProcessStartResult result = new Process.ProcessStartResult();

        // Always read the entire result from the input stream to avoid leaving
        // bytes in the stream for future process starts to accidentally stumble
        // upon.
        result.pid = inputStream.readInt();
        result.usingWrapper = inputStream.readBoolean();

        if (result.pid &lt; 0) {
            throw new ZygoteStartFailedEx(&quot;fork() failed&quot;);
        }
        return result;
    } catch (IOException ex) {
        zygoteState.close();
        throw new ZygoteStartFailedEx(ex);
    }
}
</code></pre><ul>
<li>ZygoteServer中执行了runSelectLoop进行循环监听，刚刚发送的请求就在这里处理，具体执行其中一个请求的方法是ZygoteConnection的runOnce方法，关键的一步在于Zygote.forkAndSpecialize，使用fork来创建一个进程</li>
</ul>
<pre><code>boolean runOnce(ZygoteServer zygoteServer) throws Zygote.MethodAndArgsCaller {

    String args[];
    Arguments parsedArgs = null;
    FileDescriptor[] descriptors;

    try {
        args = readArgumentList();
        descriptors = mSocket.getAncillaryFileDescriptors();
    } catch (IOException ex) {
        Log.w(TAG, &quot;IOException on command socket &quot; + ex.getMessage());
        closeSocket();
        return true;
    }

    if (args == null) {
        // EOF reached.
        closeSocket();
        return true;
    }

   //...

    try {
        parsedArgs = new Arguments(args);

       //...
        pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,
                parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,
                parsedArgs.niceName, fdsToClose, fdsToIgnore, parsedArgs.instructionSet,
                parsedArgs.appDataDir);
    } catch (ErrnoException ex) {
        logAndPrintError(newStderr, &quot;Exception creating pipe&quot;, ex);
    } catch (IllegalArgumentException ex) {
        logAndPrintError(newStderr, &quot;Invalid zygote arguments&quot;, ex);
    } catch (ZygoteSecurityException ex) {
        logAndPrintError(newStderr,
                &quot;Zygote security policy prevents request: &quot;, ex);
    }

    try {
        if (pid == 0) {
            // in child
            zygoteServer.closeServerSocket();
            IoUtils.closeQuietly(serverPipeFd);
            serverPipeFd = null;
            handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);

            // should never get here, the child is expected to either
            // throw Zygote.MethodAndArgsCaller or exec().
            return true;
        } else {
            // in parent...pid of &lt; 0 means failure
            IoUtils.closeQuietly(childPipeFd);
            childPipeFd = null;
            return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);
        }
    } finally {
        IoUtils.closeQuietly(childPipeFd);
        IoUtils.closeQuietly(serverPipeFd);
    }
}
</code></pre><ul>
<li>上面最后的handleChildProc会调用ZygoteInit的zygoteInit，这之后的流程就和SystemServer的启动流程一致了，同样会创建binder池，查找main方法，区别只在传入的参数不同，我们需要关注的是传入的main方法签名，这个情况下是ActivityThread的main方法，找到它后同样是抛出异常由ZygoteInit的main捕获并调用，这样进程就创建完毕并且进入ActivityThread管理主线程了， Process.setArgV0(“\<pre-initialized\>“) 设置进程名，Looper.prepareMainLooper创建looper，new ActivityThread() 导致其成员变量的handler(就是mH)也被创建， thread.attach(false)将进程绑定到AMS，最后调用Looper.loop这样就把主线程的Looper创建好了，之后我们的生命周期方法都是在mH处理消息时调用的，并且attach导致AMS发送的一些消息可以开始处理了(在这之前他们只是入队列而得不到处理)</pre-initialized\></li>
</ul>
<pre><code>public static void main(String[] args) {
    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ActivityThreadMain&quot;);
    SamplingProfilerIntegration.start();

    // CloseGuard defaults to true and can be quite spammy.  We
    // disable it here, but selectively enable it later (via
    // StrictMode) on debug builds, but using DropBox, not logs.
    CloseGuard.setEnabled(false);

    Environment.initForCurrentUser();

    // Set the reporter for event logging in libcore
    EventLogger.setReporter(new EventLoggingReporter());

    // Make sure TrustedCertificateStore looks in the right place for CA certificates
    final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());
    TrustedCertificateStore.setDefaultUserDirectory(configDir);

    Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);

    Looper.prepareMainLooper();

    ActivityThread thread = new ActivityThread();
    thread.attach(false);

    if (sMainThreadHandler == null) {
        sMainThreadHandler = thread.getHandler();
    }

    if (false) {
        Looper.myLooper().setMessageLogging(new
                LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));
    }

    // End of event ActivityThreadMain.
    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
    Looper.loop();

    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);
}
</code></pre><ul>
<li>ActivityThread的attach方法调用的是AMS的attachApplication方法它有调用attachApplicationLocked方法，这个方法比较长我们拆开来看</li>
</ul>
<pre><code>@Override
public final void attachApplication(IApplicationThread thread) {
    synchronized (this) {
        int callingPid = Binder.getCallingPid();
        final long origId = Binder.clearCallingIdentity();
        attachApplicationLocked(thread, callingPid);
        Binder.restoreCallingIdentity(origId);
    }
}
</code></pre><ul>
<li>attachApplication首先会查找ProcessRecord并将其ApplicationThread以及package信息绑定起来，这样的结果是ProcessRecord可以真正代表一个以创建的应用进程</li>
</ul>
<pre><code>private final boolean attachApplicationLocked(IApplicationThread thread,
        int pid) {

    // Find the application record that is being attached...  either via
    // the pid if we are running in multiple processes, or just pull the
    // next app record if we are emulating process with anonymous threads.
    ProcessRecord app;
    long startTime = SystemClock.uptimeMillis();
    if (pid != MY_PID &amp;&amp; pid &gt;= 0) {
        synchronized (mPidsSelfLocked) {
            app = mPidsSelfLocked.get(pid);
        }
    } else {
        app = null;
    }

    //…

    app.makeActive(thread, mProcessStats);
    app.curAdj = app.setAdj = app.verifiedAdj = ProcessList.INVALID_ADJ;
    app.curSchedGroup = app.setSchedGroup = ProcessList.SCHED_GROUP_DEFAULT;
    app.forcingToImportant = null;
    updateProcessForegroundLocked(app, false, false);
    app.hasShownUi = false;
    app.debugging = false;
    app.cached = false;
    app.killedByAm = false;
    app.killed = false;


    // We carefully use the same state that PackageManager uses for
    // filtering, since we use this flag to decide if we need to install
    // providers when user is unlocked later
    app.unlocked = StorageManager.isUserKeyUnlocked(app.userId);
</code></pre><ul>
<li>关联provider，调用generateApplicationProvidersLocked来创建所有的provider，这也就说明了provider其实会在Application的onCreate之前被创建，我们可以利用provider在Library中来做一些初始化操作，具体可以参考Activity中Lifecycle的实现</li>
</ul>
<pre><code>List&lt;ProviderInfo&gt; providers = normalMode ? generateApplicationProvidersLocked(app) : null;

if (providers != null &amp;&amp; checkAppInLaunchingProvidersLocked(app)) {
    Message msg = mHandler.obtainMessage(CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG);
    msg.obj = app;
    mHandler.sendMessageDelayed(msg, CONTENT_PROVIDER_PUBLISH_TIMEOUT);
}

checkTime(startTime, &quot;attachApplicationLocked: before bindApplication&quot;);
</code></pre><ul>
<li>之后调回ActivityThread.bindApplication，这个方法我们之后再看，因为这里的ActivityThread的Looper还没有启动，所以不会带来什么影响</li>
</ul>
<pre><code>thread.bindApplication(processName, appInfo, providers,
                    app.instr.mClass,
                    profilerInfo, app.instr.mArguments,
                    app.instr.mWatcher,
                    app.instr.mUiAutomationConnection, testMode,
                    mBinderTransactionTrackingEnabled, enableTrackAllocation,
                    isRestrictedBackupMode || !normalMode, app.persistent,
                    new Configuration(getGlobalConfiguration()), app.compat,
                    getCommonServicesLocked(app.isolated),
                    mCoreSettingsObserver.getCoreSettingsLocked(),
                    buildSerial);
</code></pre><ul>
<li>关联ActivityStackSupervisor，调用其attachApplicationLocked，ActivityStackSupervisor用来管理Activity的任务栈，当我们使用startActivity时可能应用进程还没有初始化，所以会先创建应用进程，将Activity的创建延迟到这里执行，我们在Activity的启动中去讨论这些内容</li>
</ul>
<pre><code>if (normalMode) {
        try {
            if (mStackSupervisor.attachApplicationLocked(app)) {
                didSomething = true;
            }
        } catch (Exception e) {
            Slog.wtf(TAG, &quot;Exception thrown launching activities in &quot; + app, e);
            badApp = true;
        }
    }
</code></pre><ul>
<li>关联service，和上面一样，当我们使用startService或bindService时应用进程可能没有创建，这里负责启动这些service，并视情况调用其onStartCommand或onBind，我们在Service的启动中去讨论这些内容</li>
</ul>
<pre><code>if (!badApp) {
      try {
          didSomething |= mServices.attachApplicationLocked(app, processName);
          checkTime(startTime, &quot;attachApplicationLocked: after mServices.attachApplicationLocked&quot;);
      } catch (Exception e) {
          Slog.wtf(TAG, &quot;Exception thrown starting services in &quot; + app, e);
          badApp = true;
      }
  }
</code></pre><ul>
<li>现在回到ActivityThread的bindApplication方法，发送一个BIND_APPLICATION消息，当Main方法调用了Looper的loop方法后，该消息最终由handleBindApplication处理，这个方法很长，我们关注的是它创建了Application对象，并且使用callApplicationOnCreate调用了Application的onCreate方法，到这里我们的应用进程就创建完毕了</li>
</ul>
<pre><code>private void handleBindApplication(AppBindData data) {

 try {

            Application app = data.info.makeApplication(data.restrictedBackupMode, null);
            mInitialApplication = app;


            try {
                mInstrumentation.onCreate(data.instrumentationArgs);
            }
            catch (Exception e) {
            }
            try {
                mInstrumentation.callApplicationOnCreate(app);
            } catch (Exception e) {            }
        } finally {
            StrictMode.setThreadPolicy(savedPolicy);
        }
 }
</code></pre><p><br><br><strong>系统的启动流程就到这里，之后的文章继续组件的启动流程</strong></p>
<p><br><br><strong>本篇完</strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入Java并发 3 原子 可见 有序]]></title>
      <url>/2019/01/07/ConcurVisibilityOrder/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><a href="https://tocreate.app/2018/12/11/concurrent/" target="_blank" rel="external">本文为深入Java并发系列的一部分</a></p>
<p><strong>重提无数遍</strong></p>
<p><br></p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p><br></p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul>
<li>原子性，即不可分割，其中一个含义是对一个线程对共享变量的读写不会被其他线程看到其执行的中间部分，另一个含义是对共享变量的操作是不可以交错的</li>
</ul>
<p><br></p>
<h4 id="long-amp-double"><a href="#long-amp-double" class="headerlink" title="long &amp; double"></a>long &amp; double</h4><ul>
<li>在java语言规范中，对long和double以外基本类型变量的单次读写都是原子性的</li>
</ul>
<ul>
<li>对long和double，根据虚拟机规范，在JSR-133之前的规范中，读和写都分成了两个32位的操作，从JSR-133规范开始读操作也都具有原子性，实现JVM时可以自由选择是否把读写long和double作为原子操作，包括64位虚拟机，只不过一般都支持，而32位就不一定，比如32位的hotspot，在32位上保证long和double的原子性需要使用volatile关键字，<a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7" target="_blank" rel="external">详见 JLS</a></li>
</ul>
<pre><code>和之前深入操作系统系列中提到的一样，32位架构基本上都能提供对一个字节读写的原子性
但是64位数据则不一定（不过arm对双字有相应的LDREXD和STREXD来直接保证独占性）
</code></pre><ul>
<li>我们通常说 volatile 关键字不能保证原子性，吊诡的是volatile就用来保证了long和double的原子性，原因是我们一般认为简单的读写操作都是原子性的，所以 volatile 关键字不能保证原子性指的是更加复杂的操作的原子性，比如自增和自减，是不能保证的，而简单类型的读写用不用volatile都有jmm保证</li>
</ul>
<ul>
<li>volatile 保证long和double的原子性的实现，在 hotspot 中虚拟机处理被volatile修饰的变量时会特殊对待long和double（似乎并不是一个lock前缀就能搞定的事情，不然就没有必要特别处理了？），在<a href="https://gvsmirnov.ru/blog/tech/2014/02/10/jmm-under-the-hood.html" target="_blank" rel="external">这篇文章</a>中有提及，但没有细讲，只说是Dark Magics，具体是什么骚操作我也没有搞明白，有需要的可以去阅读 c1 的<a href="http://hg.openjdk.java.net/jdk7u/jdk7u/hotspot/file/e087a2088970/src/share/vm/c1/c1_LIRGenerator.cpp" target="_blank" rel="external">源码</a>，我就不研究了</li>
</ul>
<p><br></p>
<h3 id="处理器的内存模型"><a href="#处理器的内存模型" class="headerlink" title="处理器的内存模型"></a>处理器的内存模型</h3><ul>
<li>特定的处理器存在特定的内存模型，这是一种非常底层的内存模型，主要分为强内存模型和弱内存模型，现代处理器一般倾向于使用弱内存模型</li>
</ul>
<ul>
<li>强内存模型，所有处理器读到的同一内存地址的数据都是一致的，使用者不需要做特别的操作就能保证内存的一致性</li>
</ul>
<ul>
<li>弱内存模型，需要调用一些机制来保证处理器读写的数据一致性，如限制编译器重排序，将当前处理器缓存的数据刷入主存，或则将当前处理器缓存置为无效。内存屏障通常在lock和unlock指令发生时自动执行，java程序员不需要知道太多内存屏障的细节</li>
</ul>
<p><br></p>
<h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens before"></a>happens before</h3><ul>
<li>如果一个动作在另一个动作之前发生，那么第一个动作对第二个动作就是可视的，并且在第二动作之前发生，这里强调的是执行的顺序，只要执行结果符合这个模型，重排序也是允许的，jmm中一定符合该原则的情况包括如下</li>
</ul>
<ul>
<li>监视器上的解锁动作在每个后续在该监视器上的锁定操作之前发生</li>
</ul>
<ul>
<li>对 Volatile 域的写操作在每个后续对该域的读操作之前发生</li>
</ul>
<ul>
<li>在线程上对start的调用在被启动的线程的所有动作之前发生</li>
</ul>
<ul>
<li>一个线程中的所有动作在任何其他线程成功的在该线程的join中返回之前发生</li>
</ul>
<ul>
<li>任何对象的省缺初始化在程序中其他任何动作（除了省缺的写操作）之前发生</li>
</ul>
<p><br></p>
<h3 id="jmm"><a href="#jmm" class="headerlink" title="jmm"></a>jmm</h3><ul>
<li>jmm，java内存模型是<a href="https://www.jcp.org/en/jsr/detail?id=133" target="_blank" rel="external">jsr133</a>中提出的主要是为了解决不同平台上的并发一致性，有些人会把寄存器，堆栈，方法区，常量池也混进来讲，这些是java虚拟规范里的东西（主要是包括在运行时数据区里面），虽然字面上是看是没什么错，但这样很容易混淆问题的中心，jmm是java语言规范里的东西，并不在同一个层次上，更关注的是行为表现</li>
</ul>
<ul>
<li>JMM的目的是提供一个在多种存储架构都能提供一致性语义的内存模型，包括线程间如何通过主存相互通信，一个程序中变量之间的相互影响，在真实的计算机中，变量在主存中或者寄存器中的读写访问细节。这里的存储架构主要指的是cpu和多级缓存，缓存的特点以及带来的问题写在后面，主要需要知道JMM将寄存器，缓存等细节抽象为本地内存</li>
</ul>
<p><br></p>
<h4 id="8-种原子操作"><a href="#8-种原子操作" class="headerlink" title="8 种原子操作"></a>8 种原子操作</h4><ul>
<li>jmm中定义了 8 种内存交互的操作，虚拟机必须保证其原子性，注意这里的原子操作都是一种概念抽象，并不是真的有指令叫做assign，use等等，只是jvm在设计到这些对应的操作时会予以保证</li>
</ul>
<pre><code>lock:锁主存的变量，将一个变量标识为被一个线程独占状态

unclock:释放主存的变量，将一个变量从独占状态释放出来，释放后的变量才可以被其他线程锁定

read:读主存的变量，把一个变量的值从主内存传输到工作内存中

load:把read操作从主内存中得到的变量值放入工作内存的变量的副本中

store:把工作内存中的一个变量的值传递给主存，以便随后的write操作

write:写主存的变量，store的值写到主内存中

use:把工作内存中的一个变量的值传给执行引擎，每当虚拟机遇到一个使用到变量的指令时都会使用该指令

assign:把一个从执行引擎接收到的值赋给工作内存中的变量，每当虚拟机遇到一个给变量赋值的指令时，都要使用该操作
</code></pre><ul>
<li>关于 load/store 和 read/write 简单一点的理解就是</li>
</ul>
<pre><code>read把变量从内存读入CPU缓存，write反之
load是把变量从CPU缓存读入栈中，store反之
</code></pre><ul>
<li>这些操作还需要遵循一些基本规则</li>
</ul>
<pre><code>1、不允许read和load、store和write操作之一单独出现，以上两个操作必须按顺序执行，但没有保证必须连续执行，
  也就是说，read与load之间、store与write之间是可插入其他指令的

2、不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存

3、不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中

4、一个新的变量只能从主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，
  换句话说就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作

5、一个变量在同一个时刻只允许一条线程对其执行lock操作，但lock操作可以被同一个条线程重复执行多次，
  多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁

6、如果对一个变量执行lock操作，将会清空工作内存中此变量的值，
  在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。

7、如果一个变量实现没有被lock操作锁定，则不允许对它执行unlock操作，
  也不允许去unlock一个被其他线程锁定的变量。

8、对一个变量执行unlock操作之前，必须先把此变量同步回主内存（执行store和write操作）
</code></pre><p><br></p>
<h4 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h4><ul>
<li>重排序是一种重要优化而不是一件坏事，但JSR-133之前的旧jmm大多数情况下是不允许重排序的，为了克服这个缺点，JSR-133强化了as-if-serial语义，使程序员可以观察不到重排序的影响</li>
</ul>
<ul>
<li>重排序（reordering）是指编译器，jit，指令集并行处理，缓存等因素为了优化程序的执行效率，可以自由的改变指令的实际执行顺序，从而出现实际指令执行顺序与程序员在代码中编写的顺序不一致的情况</li>
</ul>
<ul>
<li>其中指令集并行处理主要是为了时cpu中的部件能够不中断的被使用而产生的，指令的执行一般包括取指（IF)、译码（ID)、执行（EX)、回写（WR)，在并行化处理的时候，一条指令进入下一个步骤（如ID）之后之前的步骤（如IF）使用的硬件不会暂停下来等待，而是可以继续为另一条指令服务，现代CISC和RISC处理器都具有这样的特性，特别是微处理器尤为看重这一点</li>
</ul>
<p><br></p>
<h4 id="禁止重排序"><a href="#禁止重排序" class="headerlink" title="禁止重排序"></a>禁止重排序</h4><ul>
<li>重排序会带来一些问题，特别是一些本来就允许乱序执行的cpu，JVM帮java程序员解决这些麻烦，JMM模型表现出来的禁止重排序的情况主要有下面几种</li>
</ul>
<table>
<thead>
<tr>
<th>允许重排序</th>
<th>第二个操作</th>
<th>第二个操作</th>
<th>第二个操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>第一个操作</td>
<td>Normal Load / Normal Store</td>
<td>Volatile load / MonitorEnter</td>
<td>Volatile store / MonitorExit</td>
</tr>
<tr>
<td>Normal Load / Normal Store</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>Volatile load / MonitorEnter</td>
<td>N</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>Volatile store / MonitorExit</td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
</tbody>
</table>
<pre><code>Normal Load：对非volatile字段的读取，getfield，getstatic和array load；

Normal Store：对非volatile字段的存储，putfield，putstatic和array store；

Volatile load：对多线程环境的volatile变量的读取，getfield，getstatic；

Volatile store：对多线程环境的volatile变量的存储，putfield，putstatic；

MonitorEnters: 用于多线程环境的锁对象，见上一篇

MonitorExits: 用于多线程环境的锁对象，见上一篇
</code></pre><p><br></p>
<h4 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h4><ul>
<li>几乎所有的处理器至少支持一种粗粒度的屏障指令，通常被称为“栅栏（Fence）”，它保证在栅栏前初始化的load和store指令，能够严格有序的在栅栏后的load和store指令之前执行。但这几乎都是最耗时的操作之一（与原子指令差不多，甚至更消耗资源），所以大部分处理器支持更细粒度的屏障指令，按load和store的组合可以分为四类</li>
</ul>
<pre><code>LoadLoad 屏障
序列：Load1,Loadload,Load2
确保Load1所要读入的数据能够在被Load2和后续的load指令访问前读入
通常能执行预加载指令或/和支持乱序处理的处理器中需要显式声Loadload屏障
因为在这些处理器中正在等待的加载指令能够绕过正在等待存储的指令
对于总是能保证处理顺序的处理器上，设置该屏障相当于无操作

StoreStore 屏障
序列：Store1，StoreStore，Store2
确保Store1的数据在Store2以及后续Store指令操作相关数据之前对其它处理器可见（例如向主存刷新数据）
如果处理器不能保证从写缓冲和缓存向其它处理器和主存中按顺序刷新数据，那么它需要使用这个屏障。

LoadStore 屏障
序列： Load1; LoadStore; Store2
确保Load1的数据在Store2和后续Store指令被刷新之前读取
在等待Store指令可以越过loads指令的乱序处理器上需要使用LoadStore屏障

StoreLoad 屏障
序列: Store1; StoreLoad; Load2
确保Store1的数据在被Load2和后续的Load指令读取之前对其他处理器可见
StoreLoad屏障可以防止一个后续的load指令不正确的使用了Store1的数据，而不是另一个处理器在相同内存位置写入一个新数据
所以为了在屏障前读取同样内存位置存过的数据必须使用一个StoreLoad屏障将存储指令和后续的加载指令分开
Storeload屏障在几乎所有的现代多处理器中都需要使用，但通常它的开销也是最昂贵的
它们昂贵的部分原因是它们必须关闭通常的略过缓存直接从写缓冲区读取数据的机制
这可能通过让一个缓冲区进行充分刷新（flush）,以及其他延迟的方式来实现。
</code></pre><p><br></p>
<h4 id="被省略的屏障"><a href="#被省略的屏障" class="headerlink" title="被省略的屏障"></a>被省略的屏障</h4><ul>
<li>处理器禁止重排序：并不是所有类型的重排序都会出现，一些架构的处理器本身会禁止某种类型的重排序（如下），</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Load-Load</th>
<th>Load-Store</th>
<th>Store-Store</th>
<th>Store-Load</th>
<th>数据依赖</th>
</tr>
</thead>
<tbody>
<tr>
<td>sparc-TSO</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>x86</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>ia64</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>PowerPC</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
</tbody>
</table>
<p>‘</p>
<p><br></p>
<ul>
<li>数据依赖禁止重排序：在一些处理器中有时可以忽略loadload和loadstore屏障，前提是load和store对前一个load指令具有数据依赖性，数据依赖性一般来说发生在两种情况之下，间接取值和条件控制</li>
</ul>
<pre><code>//间接取值
Load x;Load x.field 
//条件控制
Load x;if(predicate(x))Load or Store y 
</code></pre><p><br></p>
<ul>
<li>原子语义覆盖：MonitorEnter和MonitorExit原本可以分别对应load和store，所以需要使用LoadLoad和StoreStore进行保障，但有些架构上面的MonitorEnter，MonitorExit的加锁和解锁本身使用的cas(x86的lock cmpxchg，arm的LL/SC)已经至少能够提供LoadLoad和StoreStore屏障相同的语义，这种情况下其后的LoadLoad和StoreStore就显得多余，因此对于这两个指令采取特殊对待，在Load和Store指令以外再额外添加Enter和Exit指令，那么就又多出几种情况（EnterLoad，EnterStore ..），对于前面提到的还有原子语义覆盖的架构，由于EnterLoad，StoreExit和ExitEnter本身是和MonitorEnter/MonitorExit同时出现的，所以它们是无意义的，实现为无操作</li>
</ul>
<p><img src="http://wx3.sinaimg.cn/mw690/007vHOvngy1fz193cj3a4j30la0ycq7h.jpg" alt=""></p>
<p><br></p>
<ul>
<li>最终我们得到的内存屏障表如下</li>
</ul>
<table>
<thead>
<tr>
<th>第一操作/ 第二操作</th>
<th>Normal Load</th>
<th>Normal Store</th>
<th>Volatile Load</th>
<th>Volatile Store</th>
<th>MonitorEnter</th>
<th>MonitorExit</th>
</tr>
</thead>
<tbody>
<tr>
<td>Normal Load</td>
<td></td>
<td></td>
<td></td>
<td>LoadStore</td>
<td></td>
<td>LoadStore</td>
</tr>
<tr>
<td>Normal Store</td>
<td></td>
<td></td>
<td></td>
<td>StoreStore</td>
<td></td>
<td>StoreExit</td>
</tr>
<tr>
<td>Volatile Load</td>
<td>LoadLoad</td>
<td>LoadStore</td>
<td>LoadLoad</td>
<td>LoadStore</td>
<td>LoadEnter</td>
<td>LoadExit</td>
</tr>
<tr>
<td>Volatile Store</td>
<td></td>
<td></td>
<td>StoreLoad</td>
<td>StoreStore</td>
<td>StoreEnter</td>
<td>StoreExit</td>
</tr>
<tr>
<td>MonitorEnter</td>
<td>EnterLoad</td>
<td>EnterStore</td>
<td>EnterLoad</td>
<td>EnterStore</td>
<td>EnterEnter</td>
<td>EnterExit</td>
</tr>
<tr>
<td>MonitorExit</td>
<td></td>
<td></td>
<td>ExitLoad</td>
<td>ExitStore</td>
<td>ExitEnter</td>
<td>ExitExit</td>
</tr>
</tbody>
</table>
<p><br></p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><ul>
<li>hotspot中内存屏障实现在os_cpu的orderAccess当中，具体可以用作内存屏障的指令与架构相关，在x86上可以参考orderAccess_linux_x86，x86 上只允许Store-Load重排序，因此只实现了storeload屏障，手段是lock前缀，lock前缀的特性写在后面</li>
</ul>
<pre><code>///hotspot/src/os_cpu/linux_x86/vm/orderAccess_linux_x86.inline.hpp
// Implementation of class OrderAccess.

inline void OrderAccess::loadload()   { acquire(); }
inline void OrderAccess::storestore() { release(); }
inline void OrderAccess::loadstore()  { acquire(); }
inline void OrderAccess::storeload()  { fence(); }

inline void OrderAccess::acquire() {
  volatile intptr_t local_dummy;
#ifdef AMD64
  __asm__ volatile (&quot;movq 0(%%rsp), %0&quot; : &quot;=r&quot; (local_dummy) : : &quot;memory&quot;);
#else
  __asm__ volatile (&quot;movl 0(%%esp),%0&quot; : &quot;=r&quot; (local_dummy) : : &quot;memory&quot;);
#endif // AMD64
}

inline void OrderAccess::release() {
  // Avoid hitting the same cache-line from
  // different threads.
  volatile jint local_dummy = 0;
}

inline void OrderAccess::fence() {
  if (os::is_MP()) {
    // always use locked addl since mfence is sometimes expensive
#ifdef AMD64
    __asm__ volatile (&quot;lock; addl $0,0(%%rsp)&quot; : : : &quot;cc&quot;, &quot;memory&quot;);
#else
    __asm__ volatile (&quot;lock; addl $0,0(%%esp)&quot; : : : &quot;cc&quot;, &quot;memory&quot;);
#endif
  }
}
</code></pre><ul>
<li>Doug Lea给出了各体系上的<a href="http://g.oswego.edu/dl/jmm/cookbook.html" target="_blank" rel="external">内存屏障指令</a>如下</li>
</ul>
<p><img src="http://wx2.sinaimg.cn/mw690/007vHOvngy1fz0e0o1er6j31aj0u0akq.jpg" alt=""></p>
<p><br></p>
<h3 id="内存体系"><a href="#内存体系" class="headerlink" title="内存体系"></a>内存体系</h3><p><strong>可以参考这篇<a href="http://ifeve.com/cpu-cache-flushing-fallacy-cn/" target="_blank" rel="external">文章</a>中Sandy Bridge架构的讲解，这里做一些摘录</strong></p>
<p><br></p>
<h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><ul>
<li>寄存器：在每个核心上，有160个用于整数和144个用于浮点的寄存器单元。访问这些寄存器只需要一个时钟周期，这构成了对执行核心来说最快的内存。编译器会将本地变量和函数参数分配到这些寄存器上。当使用超线程技术（ hyperthreading ）时，这些寄存器可以在超线程协同下共享。</li>
</ul>
<p><br></p>
<h4 id="内存排序缓冲"><a href="#内存排序缓冲" class="headerlink" title="内存排序缓冲"></a>内存排序缓冲</h4><ul>
<li>内存排序缓冲：Memory Ordering Buffers (MOB)，MOB由一个64长度的load缓冲和36长度的store缓冲组成。这些缓冲用于记录等待缓存子系统时正在执行的操作。store缓冲是一个完全的相关性队列，可以用于搜索已经存在store操作，这些store操作在等待L1缓存的时候被队列化。在数据与缓存子系统传输时， 缓冲可以让处理器异步运转。当处理器异步读或者异步写的时候，结果可以乱序返回。为了使之与已发布的内存模型（ memory model ）一致，MOB用于消除load和store的顺序</li>
</ul>
<p><br></p>
<h4 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h4><ul>
<li>L1缓存：L1是一个本地核心内的缓存，被分成独立的32K数据缓存和32K指令缓存。访问需要3个时钟周期，并且当指令被核心流水化时， 如果数据已经在L1缓存中的话，访问时间可以忽略</li>
</ul>
<ul>
<li>L2缓存：L2缓存是一个本地核心内的缓存，被设计为L1缓存与共享的L3缓存之间的缓冲。L2缓存大小为256K，主要作用是作为L1和L3之间的高效内存访问队列。L2缓存同时包含数据和指令。L2缓存的延迟为12个时钟周期</li>
</ul>
<ul>
<li>L3缓存： 在同插槽的所有核心都共享L3缓存。L3缓存被分为数个2MB的段，每一个段都连接到槽上的环形网络。每一个核心也连接到这个环形网络上。地址通过hash的方式映射到段上以达到更大的吞吐量。根据缓存大小，延迟有可能高达38个时钟周期。在环上每增加一个节点将消耗一个额外的时钟周期。缓存大小根据段的数量最大可以达到20MB。L3缓存包括了在同一个槽上的所有L1和L2缓存中的数据。这种设计消耗了空间，但是使L3缓存可以拦截对L1和L2缓存的请求，减轻了各核心私有的L1和L2缓存的负担</li>
</ul>
<ul>
<li>关联度：Associativity Levels，缓存是一个依赖于hash表的高效硬件。使用hash函数常常只是将地址中低位bit进行映射 ，以实现缓存索引。hash表需要有解决对于同一位置冲突的机制。 关联度就是hash表中槽（slot）的数量，也被称为组（ways）和集合（sets），可以用来存储一个内存地址的hash版本。关联度的多少需要在存储数据的容量，耗电量和查询时间之间寻找平衡。（校对注：关联度越高，槽的数量越多，hash冲突越小，查询速度越快）</li>
</ul>
<ul>
<li>对于Sandy Bridge，L1和L2是8路组相连 ，L3是12路组相连 。（For Sandy Bridge the L1D and L2 are 8-way associative, the L3 is 12-way associative.）</li>
</ul>
<p><br></p>
<h4 id="主内存"><a href="#主内存" class="headerlink" title="主内存"></a>主内存</h4><ul>
<li>主内存：在缓存完全没命中的情况下，DRAM通道到每个槽的延迟平均为65ns。具体延迟多少取决于很多因素，比如，下一次对同一缓存行中数据的访问将极大降低延迟，而当队列化效果和内存刷新周期冲突时将显著增加延迟。每个槽使用4个内存通道聚合起来增加吞吐量，并通过在独立内存通道上流水线化（ pipelining ）将隐藏这种延迟。</li>
</ul>
<p><br></p>
<h3 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h3><ul>
<li>在多处理器环境下，缓存一致性用于保证内存中的数据副本可以存在于多个缓存中，但各处理器仍可以读取到正确的数据，在java当中使用Volatile保证一致性</li>
</ul>
<ul>
<li>在intel cpu中缓存一致性一般使用lock前缀实现，lock前缀引发的机制可以分为两种，要么锁总线，要么使用MESI协议锁内存区域</li>
</ul>
<p><br></p>
<h4 id="锁总线"><a href="#锁总线" class="headerlink" title="锁总线"></a>锁总线</h4><ul>
<li>Lock前缀指令的实现最终都会引起处理器缓存回写到内存，但在实现数据一致方面却可能有一定差异</li>
</ul>
<ul>
<li>Lock前缀指令导致在执行指令期间，声言处理器的 LOCK# 信号。多处理器环境中，LOCK# 信号确保声言期间，处理器可独占使用任何共享内存。它会锁住总线，导致其他CPU不能访问总线，不能访问总线就意味着不能访问系统内存，但是在最近的处理器里，LOCK＃信号一般不锁总线，而是锁缓存，毕竟锁总线开销比较大</li>
</ul>
<ul>
<li>对于Intel486和Pentium处理器，在锁操作时，总是在总线上声言LOCK#信号。</li>
</ul>
<p><br></p>
<h4 id="MESI缓存一致协议"><a href="#MESI缓存一致协议" class="headerlink" title="MESI缓存一致协议"></a>MESI缓存一致协议</h4><ul>
<li>在P6和最近的处理器中，如果访问的内存区域已经缓存在处理器内部，则不会声言LOCK#信号。相反地，它会使用缓存一致性机制来确保修改的原子性，此操作被称为“缓存锁定”，缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据</li>
</ul>
<p><br></p>
<h5 id="缓存行状态"><a href="#缓存行状态" class="headerlink" title="缓存行状态"></a>缓存行状态</h5><ul>
<li>x86架构的每个缓存块的大小为64 bytes，称为缓存行（ cache-line）。其它种类的处理器的缓存行大小可能不同。更大的缓存行容量降低延迟，但是需要更大的带宽</li>
</ul>
<ul>
<li>MESI 是指4中状态的首字母。每个缓存行有4个状态，可用2个字节表示，它们分别是：</li>
</ul>
<table>
<thead>
<tr>
<th>状态</th>
<th>描述</th>
<th>监听任务</th>
</tr>
</thead>
<tbody>
<tr>
<td>M 修改 (Modified)</td>
<td>该缓存行有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中</td>
<td>缓存行必须时刻监听所有试图读该缓存行相对就主存的操作，这种操作必须在缓存将该缓存行写回主存并将状态变成S（共享）状态之前被延迟执行</td>
</tr>
<tr>
<td>E 独享、互斥 (Exclusive)</td>
<td>该缓存行有效，数据和内存中的数据一致，数据只存在于本Cache中</td>
<td>缓存行也必须监听其它缓存读主存中该缓存行的操作，一旦有这种操作，该缓存行需要变成S（共享）状态</td>
</tr>
<tr>
<td>S 共享 (Shared)</td>
<td>该缓存行有效，数据和内存中的数据一致，数据存在于很多Cache中</td>
<td>缓存行也必须监听其它缓存使该缓存行无效或者独享该缓存行的请求，并将该缓存行变成无效（Invalid）</td>
</tr>
<tr>
<td>I 无效 (Invalid)</td>
<td>该缓存行无效</td>
<td>无</td>
</tr>
</tbody>
</table>
<pre><code>如果一个缓存将处于S状态的缓存行作废了，而另一个缓存实际上可能已经独享了该缓存行，
但是该缓存却不会将该缓存行升迁为E状态，
这是因为其它缓存不会广播他们作废掉该缓存行的通知以及缓存并没有记录缓存行的copy的数量
</code></pre><ul>
<li>MESI要求cpu间协同工作，关键在于一个处理器写缓存时可以让另一个cpu的缓存无效，缓存写入内存后还可以进行数据同步</li>
</ul>
<ul>
<li>例，假设有三个CPU A、B、C，对应三个缓存分别是cache a、b、 c。在主内存中定义了x的引用值为0</li>
</ul>
<pre><code>读取缓存：
CPU A发出了一条指令，从主内存中读取x。
CPU A从主内存通过bus读取到 cache a中并将该cache line 设置为E状态。
CPU B发出了一条指令，从主内存中读取x。
CPU B试图从主内存中读取x时，CPU A检测到了地址冲突。这时CPU A对相关数据做出响应。此时x 存储于cache a和cache b中，x在chche a和cache b中都被设置为S状态(共享)

修改数据：
CPU A 计算完成后发指令需要修改x.
CPU A 将x设置为M状态（修改）并通知缓存了x的CPU B, CPU B将本地cache b中的x设置为I状态(无效)
CPU A 对x进行赋值

同步数据
CPU B 发出了要读取x的指令。
CPU B 通知CPU A,CPU A将修改后的数据同步到主内存时cache a 修改为E（独享）
CPU A同步CPU B的x,将cache a和同步后cache b中的x设置为S状态（共享）
</code></pre><p><br></p>
<h5 id="内存排序缓冲-1"><a href="#内存排序缓冲-1" class="headerlink" title="内存排序缓冲"></a>内存排序缓冲</h5><ul>
<li>CPU在cache line状态的转化期间是阻塞的，经过长时间的优化，在寄存器和L1缓存之间添加了LoadBuffer、StoreBuffer来降低阻塞时间，LoadBuffer、StoreBuffer，合称排序缓冲(Memoryordering Buffers (MOB))，Load缓冲64长度，store缓冲36长度，Buffer与L1进行数据传输时，CPU无须等待</li>
</ul>
<ul>
<li>CPU执行load读数据时，把读请求放到LoadBuffer，这样就不用等待其它CPU响应，先进行下面操作，稍后再处理这个读请求的结果</li>
</ul>
<ul>
<li>CPU执行store写数据时，把数据写到StoreBuffer中，待到某个适合的时间点，把StoreBuffer的数据刷到主存中</li>
</ul>
<ul>
<li>因为StoreBuffer的存在，CPU在写数据时，真实数据并不会立即表现到内存中，所以对于其它CPU是不可见的；同样的道理，LoadBuffer中的请求也无法拿到其它CPU设置的最新数据；由于StoreBuffer和LoadBuffer是异步执行的，所以在外面看来，先写后读，还是先读后写，没有严格的固定顺序</li>
</ul>
<p><br></p>
<h4 id="低效行为"><a href="#低效行为" class="headerlink" title="低效行为"></a>低效行为</h4><ul>
<li>CPU通过store buffer和invalid queue(用来实现LoadBuffer)来降低延时，MESI协议中有两个行为效率会比较低，当cache line状态为Invalid时，需要写入数据，以及把cache line的状态变为invalid</li>
</ul>
<ul>
<li>invalid状态进行写入时，首先会给其它CPU核发送invalid消息，然后把当前写入的数据写入到store buffer中。在某个时刻再真正的写入到cache line中。所以当前核如果要读cache line中的数据，需要先扫描store buffer，同时其它CPU核是看不到当前核store buffer中的数据的，除非store buffer中的数据被刷到cache中</li>
</ul>
<ul>
<li>对于invalid queue，当收到invalid消息时，cache line不会马上变成invalid状态，而是把消息写入invalid queue中。和store buffer不同的是当前cpu是无法扫描invalid queue的。为了保证数据的一致性，这就需要memory barrier了。store barrier（对应sfence或mfence指令）会把store buffer中的数据刷到cache中，read barrier（对应lfence或mfence指令）会执行invalid queue中的消息</li>
</ul>
<p><br><br><strong>本篇完</strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入Java并发 2 monitor]]></title>
      <url>/2019/01/07/concurMonitor/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><a href="https://tocreate.app/2018/12/11/concurrent/" target="_blank" rel="external">本文为深入Java并发系列的一部分</a></p>
<p><br></p>
<h3 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h3><p><br></p>
<h4 id="synchronization-amp-monitor"><a href="#synchronization-amp-monitor" class="headerlink" title="synchronization &amp; monitor"></a>synchronization &amp; monitor</h4><p><strong> monitor是Per Brich Hansen和Tony Hoare提出的概念，Java以不精确的方式采用了它</strong></p>
<ul>
<li>monitor机制本质是让线程互斥地获取指定对象持有的监视器对象，对监视器进行等待，锁定和解锁，从而实现多个进程上的同步，synchronized是monitor的应用，本质是互斥量，重量级锁</li>
</ul>
<ul>
<li>java中的每个对象都持有一个监视器，只有一个线程可以持有某个监视器上的锁，其他线程视图锁定该锁时将阻塞，synchronized语句将会计算对象的引用，锁定动作成功之后才会执行同步代码块，无论代码块执行成功还是失败，最终都会执行解锁操作，这些操作自动完成</li>
</ul>
<ul>
<li>锁定操作是可重入的，每个解锁操作都会抵消一次锁定操作</li>
</ul>
<p><br></p>
<h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><ul>
<li>synchronized关键字通过两种形式触发monitor机制，锁代码块和锁方法，可以使用 javap -verbose 命令解析class文件来分析</li>
</ul>
<ul>
<li>锁代码块，synchronized (xxx){} 的形式，将编译为以下字节码，线程执行到monitorenter指令会去获取对应的monitor，每一个monitor维护一个计数器，空闲时为0，当一个线程获得monitor时计数器自增，解锁时自减，其他线程获取时则导致阻塞直到计数器从新为0</li>
</ul>
<pre><code>monitorenter
...
monitorexit
</code></pre><ul>
<li>锁方法，synchronized xxx xxx()的形式，将导致method_info中存在ACC_SYNCHRONIZED标识，它是一种隐式的monitor机制，不会产生monitorenter和monitorexit指令，但是jvm将以类似的流程来进行monitor的操作</li>
</ul>
<pre><code>flags: ACC_SYNCHRONIZED
</code></pre><p><br></p>
<h4 id="阻塞队列-amp-等待集"><a href="#阻塞队列-amp-等待集" class="headerlink" title="阻塞队列 &amp; 等待集"></a>阻塞队列 &amp; 等待集</h4><ul>
<li>每个对象除了相关的monitor以外还有一个阻塞队列和一个等待集，阻塞队列是获取monitor时被阻塞的线程的队列，等待集是使用object.wait导致的等待monitor的线程的集合</li>
</ul>
<ul>
<li>之前说过，java对象头的markword中存储着重量锁的指针，在hotspot中这个重量级锁的指针指向的是ObjectMonitor对象，其中的_EntryList和_WaitSet就是阻塞队列和等待集</li>
</ul>
<pre><code>// initialize the monitor, exception the semaphore, all other fields
 // are simple integers or pointers
 ObjectMonitor() {
   _header       = NULL;
   _count        = 0;
   _waiters      = 0,
   _recursions   = 0;
   _object       = NULL;
   _owner        = NULL;
   _WaitSet      = NULL;
   _WaitSetLock  = 0 ;
   _Responsible  = NULL ;
   _succ         = NULL ;
   _cxq          = NULL ;
   FreeNext      = NULL ;
   _EntryList    = NULL ;
   _SpinFreq     = 0 ;
   _SpinClock    = 0 ;
   OwnerIsThread = 0 ;
   _previous_owner_tid = 0;
 }
</code></pre><p><br></p>
<h4 id="等待-amp-通知"><a href="#等待-amp-通知" class="headerlink" title="等待 &amp; 通知"></a>等待 &amp; 通知</h4><ul>
<li>使用wait方法将导致线程被放入WaitSet当中，wait会释放当前的monitor并阻塞当前线程，前提是已经获取到了该monitor</li>
</ul>
<ul>
<li>notify将唤醒WaitSet当中的线程，但并不会释放锁，它仅将WaitSet中的线程标记为Runnable状态，为了避免WaitSet当中的线程互相等待产生死锁，一般使用notifyAll</li>
</ul>
<p><br><br><strong>本篇完</strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[面试题汇总]]></title>
      <url>/2019/01/04/Whatever/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><strong>贴了链接的问题，只是摘要，可能直接看会看不大懂，建议先浏览一下原文</strong></p>
<p><br></p>
<h2 id="c"><a href="#c" class="headerlink" title="c"></a>c</h2><h4 id="各基本类型占用字节数"><a href="#各基本类型占用字节数" class="headerlink" title="各基本类型占用字节数"></a>各基本类型占用字节数</h4><ul>
<li>只记录32位和64位</li>
<li>char 1</li>
<li>short 2</li>
<li>int 4</li>
<li>float 4</li>
<li>double 8</li>
<li>long long 8</li>
<li>long 32位为4 64位为8</li>
<li>指针 32位为4 64位为8</li>
</ul>
<h4 id="struct-union-占用字节数"><a href="#struct-union-占用字节数" class="headerlink" title="struct union 占用字节数"></a>struct union 占用字节数</h4><ul>
<li>win32 struct内存对齐策略</li>
</ul>
<pre><code>1.结构体成员相对于结构体首地址的偏移量都是成员大小的整数倍，需要在成员间加上填充字节，数组看做多个成员
2.结构体变量首地址能够被其最宽基本类型成员的大小所整除
3.结构体总大小为结构体最宽基本类型成员大小的整数倍，需要在最后加上填充字节
</code></pre><ul>
<li>union 内存对齐策略</li>
</ul>
<pre><code>1.所有成员相对于基地址的偏移量都为0
2.空间要大到足够容纳最“宽”的成员，包括数组
3.结构体总大小为结构体所有成员大小的整数倍 
</code></pre><p><br></p>
<h2 id="java"><a href="#java" class="headerlink" title="java"></a>java</h2><h4 id="各基本类型占用字节数-1"><a href="#各基本类型占用字节数-1" class="headerlink" title="各基本类型占用字节数"></a>各基本类型占用字节数</h4><ul>
<li>byte 1  </li>
<li>boolean 1   </li>
<li>char 2                </li>
<li>short 2                 </li>
<li>int 4  </li>
<li>float 4                  </li>
<li>double 8  </li>
<li>long 8                                                </li>
</ul>
<h4 id="字符占用字节数"><a href="#字符占用字节数" class="headerlink" title="字符占用字节数"></a>字符占用字节数</h4><ul>
<li>iso8859-1，1，无法表示中文字符</li>
<li>GBK 编码，英文字符 1，汉字字符 2</li>
<li>UTF-8 编码，英文字符 1，汉字字符 3到4</li>
<li>UTF-16 编码，英文字符 2，汉字字符 3到4</li>
<li>UTF-32 编码，4</li>
</ul>
<h4 id="枚举的实现原理，占用内存"><a href="#枚举的实现原理，占用内存" class="headerlink" title="枚举的实现原理，占用内存"></a>枚举的实现原理，占用内存</h4><p><strong>详见<a href="https://blog.csdn.net/caomiao2006/article/details/51586047" target="_blank" rel="external">这里</a></strong></p>
<ul>
<li>枚举在经过编译器编译过后，变成了一个抽象类，继承自java.lang.Enum</li>
</ul>
<ul>
<li>枚举中定义的每个枚举常量，变为引用类型为该抽象类的公共静态常量(public static final)，名称不变，实际类型为该抽象类的内部类，有多少个枚举就有多少个内部类，同时还生成了一个静态字段$VALUES(保存所有枚举常量对象的数组)，生成的代码中在静态初始化块中为这些引用赋值</li>
</ul>
<ul>
<li>生成的方法则包括两个静态方法，values(返回clone的$VALUES数组)，valueOf(调用Enum.valueOf)，以及一个构造方法，构造方法参数为枚举类中的参数以及Enum中用到的name和ordinal，ordinal是一个顺序号，根据定义的顺序分别赋予一个整形值</li>
</ul>
<ul>
<li>Enum类的实现中定义的name和ordinal属性都是final的，大部分方法也都是final的，特别是clone、readObject、writeObject这三个方法，保证了枚举类型的不可变性，不能通过克隆，不能通过序列化和反序列化来复制枚举，保证一个枚举常量是单例的</li>
</ul>
<ul>
<li>枚举类占用的内存就是所有生成的内部类及其对象占用的运行时内存，它相对于使用@XXdef定义的常量，开销还是相当大的</li>
</ul>
<h4 id="静态内部类和非静态内部类的区别"><a href="#静态内部类和非静态内部类的区别" class="headerlink" title="静态内部类和非静态内部类的区别"></a>静态内部类和非静态内部类的区别</h4><ul>
<li>静态内部类可以有静态字段，而非静态内部类则不能有静态字段</li>
</ul>
<ul>
<li>静态内部类的成员方法可以访问外部类的静态字段，不可访问外部类的非静态字段</li>
</ul>
<ul>
<li>非静态内部类的成员法可以访问外部类的静态字段和非静态字段</li>
</ul>
<ul>
<li>生成一个静态内部类不需要外部类成员</li>
</ul>
<ul>
<li>编译器会默认为非静态内部类添加了一个指向外部类对象的final引用，名为this，在构造器添加外部类类型的参数，在常量池中添加该外部类的信息</li>
</ul>
<h4 id="局部内部类和匿名内部类的区别"><a href="#局部内部类和匿名内部类的区别" class="headerlink" title="局部内部类和匿名内部类的区别"></a>局部内部类和匿名内部类的区别</h4><ul>
<li>没有太大区别，只是匿名类被编译器自动命名为 外部类名+$+序号 的形式，局部内部类本身就有名字</li>
</ul>
<ul>
<li>对于这些内部类使用到的局部变量，如果这个变量的值在编译期间可以确定，则编译器默认会在匿名内部类（局部内部类）的常量池中添加一个内容相等的字面量或直接将相应的字节码嵌入到执行字节码中；如果局部变量的值无法在编译期间确定，则通过构造器传参的方式来对拷贝进行初始化赋值。不管怎样都是拷贝，局部变量需要定义为final</li>
</ul>
<h4 id="自动装箱"><a href="#自动装箱" class="headerlink" title="自动装箱"></a>自动装箱</h4><p><strong>详见<a href="https://www.cnblogs.com/wang-yaz/p/8516151.html" target="_blank" rel="external">这里</a></strong></p>
<ul>
<li>装箱就是自动将基本数据类型转换为包装器类型；拆箱就是自动将包装器类型转换为基本数据类型，这些是编译器为我们做的，本质就是在编译成class文件时自动调用包装类的valueOf()方法和XXValue()方法，如intValue</li>
</ul>
<ul>
<li>有的面试官可能喜欢问一些吊轨问题，对于整型的自动装箱需要特别注意，整型的包装类（Integer、Short、Byte、Character、Long）的valueOf方法的实现了缓存机制（1.8中为XXXCache的静态内部类，如IntegerCache），在静态初始化块中创建了绝对值在128以内的所有包装对象，需要时直接获取，对于大于该范围的数值，则每次都创建一个新对象。对于浮点类型，则没有使用缓存，所有情况下都创建新对象。另外XXXValue()方法的实现是很简单的，直接返回包装对象维护的value域</li>
</ul>
<h4 id="hashcode实现原理"><a href="#hashcode实现原理" class="headerlink" title="hashcode实现原理"></a>hashcode实现原理</h4><ul>
<li>equals() 的作用是 用来判断两个对象是否相等</li>
</ul>
<p><br></p>
<h2 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h2><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><h4 id="Activity生命周期"><a href="#Activity生命周期" class="headerlink" title="Activity生命周期"></a>Activity生命周期</h4><ul>
<li>onCreate()表示Activity正在创建，常做初始化工作，如初始化界面资源、初始化数据，setContentView，findViewById通常在onCreate中被调用</li>
</ul>
<ul>
<li>onStart()表示Activity正在启动，这时Activity可见但不在前台，无法和用户交互</li>
</ul>
<ul>
<li>onResume()表示Activity获得焦点，此时Activity在前台可以交互，重新回到前台时也会调用onResume方法。可以在onResume方法中初始化一些资源，开启动画，或者打开独占设备（比如相机）</li>
</ul>
<ul>
<li>onPause()表示Activity正在停止，可做数据存储、执行停止动画等比较耗CPU的事物</li>
</ul>
<ul>
<li>onStop()表示activity即将停止，可做稍微重量级回收工作，如取消网络连接、注销广播接收器等，在内存不足而导致系统自动回收进程情况下，onStop() 可能不会被执行</li>
</ul>
<ul>
<li>onDestroy()表示Activity即将销毁，常做回收工作、资源释放</li>
</ul>
<ul>
<li>onRestart() 表示Activity重新启动，当Activity由不可见到可见时会调用</li>
</ul>
<h4 id="启动Activity调用的生命周期方法"><a href="#启动Activity调用的生命周期方法" class="headerlink" title="启动Activity调用的生命周期方法"></a>启动Activity调用的生命周期方法</h4><ul>
<li>Activity A启动Activity B：Activity A的onPause，Activity B的onCreate，onStart，onResume，Activity A的onStop，如果Activity B是完全透明的，则最后不会调用Activity A的onStop，如果是Dialog主题的Activity，同完全透明的情况</li>
</ul>
<h4 id="onSavedInstanceState和onRestoreInstanceState"><a href="#onSavedInstanceState和onRestoreInstanceState" class="headerlink" title="onSavedInstanceState和onRestoreInstanceState"></a>onSavedInstanceState和onRestoreInstanceState</h4><ul>
<li>当应用遇到意外情况（内存不足，用户直接按home键）由系统直接销毁一个Activity时，onSaveInstanceState()就会调用，onSaveInstanceState()会在onPause()或onStop()之前执行，默认情况下默认会自动保存Activity中的某些状态，比如activity中各种UI的状态，因此在activity被“系统”销毁和重建的时候，这些Ui的状态会默认保存，但是前提条件是Ui控件必须制定id,如果没有指定id的话，UI的状态是无法保存的，也可以使用该方法来保存一些界面状态</li>
</ul>
<ul>
<li>onSaveInstanceState()只有在activity销毁重建的时候onRestoreInstanceState()才会调用，所以和onSaveInstanceState不一定成对出现，onRestoreInstanceState()会在onStart()和onResume()之间执行</li>
</ul>
<h4 id="Fragment生命周期"><a href="#Fragment生命周期" class="headerlink" title="Fragment生命周期"></a>Fragment生命周期</h4><ul>
<li>onAttach()->onCreate()-> onCreateView()->onActivityCreated()->onStart()->onResume()->onPause()->onStop()->onDestroyView()->onDestroy()->onDetach()</li>
</ul>
<ul>
<li>onAttach()：当Fragment与Activity发生关联时，该方法被调用</li>
</ul>
<ul>
<li>onCreateView()：当Fragment创建视图时调用</li>
</ul>
<ul>
<li>onActivityCreated()：执行该方法时，与Fragment绑定的Activity的onCreate方法已经执行完成并返回，在该方法内可以进行与Activity交互的UI操作</li>
</ul>
<ul>
<li>onDestroyView，销毁与Fragment有关的视图，但未与Activity解除绑定，依然可以通过onCreateView方法重新创建视图</li>
</ul>
<ul>
<li>onDetach()：当Fragment和Activity解除关联时调用</li>
</ul>
<h4 id="Service生命周期"><a href="#Service生命周期" class="headerlink" title="Service生命周期"></a>Service生命周期</h4><ul>
<li>onCreate（）：服务第一次被创建时调用</li>
</ul>
<ul>
<li>onStartComand（）：服务启动时调用</li>
</ul>
<ul>
<li>onBind（）：服务被绑定时调用</li>
</ul>
<ul>
<li>onUnBind（）：服务被解绑时调用</li>
</ul>
<ul>
<li>onDestroy（）：服务停止时调用</li>
</ul>
<h4 id="service的两种启动方式"><a href="#service的两种启动方式" class="headerlink" title="service的两种启动方式"></a>service的两种启动方式</h4><ul>
<li>startService()方法可以启动一个Service，并回调服务中的onStartCommand()。如果服务还没创建，那么回调onCreate()->onStartCommand()。服务会一直保持运行状态，直到stopService()或stopSelf()方法被调用，并回调onDestroy()。无论调用多少次startService()方法，只需调用一次stopService()或stopSelf()方法</li>
</ul>
<ul>
<li>bindService()可以绑定一个Service，并回调onBind()方法。如果该服务还没创建，回调的顺序是onCreate()->onBind()。调用方可以获取到onBind()方法里返回的IBinder实例，实现和服务进行通信。服务会一直保持运行状态，直到所有客户端都调用了unbindService()方法，或则所有客户端都已经被销毁，服务才会调用onUnBind()->onDestroy()</li>
</ul>
<ul>
<li>混合使用两种方式时onDestroy需要在unbindService和stopService都被调用后才会执行onDestroy</li>
</ul>
<h4 id="常见的系统service"><a href="#常见的系统service" class="headerlink" title="常见的系统service"></a>常见的系统service</h4><p><strong><a href="https://www.cnblogs.com/PengLee/p/4092712.html" target="_blank" rel="external">详见</a></strong></p>
<ul>
<li>ConnectivityManager，网络管理服务</li>
</ul>
<ul>
<li>AudioManager，音频管理服务</li>
</ul>
<ul>
<li>AlarmManager，全局定时器</li>
</ul>
<ul>
<li>NotificationManager，通知服务</li>
</ul>
<ul>
<li>SensorManager，传感服务</li>
</ul>
<h4 id="启动其他应用的Activity"><a href="#启动其他应用的Activity" class="headerlink" title="启动其他应用的Activity"></a>启动其他应用的Activity</h4><ul>
<li>显示启动，确的指定被启动的对象的组件信息，包括包名和类名</li>
</ul>
<ul>
<li>隐式启动，Intent 能够匹配目标组件的 IntentFilter 中所设置的过滤信息，需要同时匹配 action，category，data</li>
</ul>
<ul>
<li>隐式方式启动一个Activity的时候，可以判断看有没有Activity能够匹配Intent，PackageManager 或者 Intent 的 resolveActivity() 方法，以及PackageManager 的 queryIntentActivities() 方法</li>
</ul>
<h4 id="避免配置改变时Activity重建"><a href="#避免配置改变时Activity重建" class="headerlink" title="避免配置改变时Activity重建"></a>避免配置改变时Activity重建</h4><ul>
<li>manifest中设置configChanges=”orientation|keyboardHidden|screenSize”</li>
</ul>
<h4 id="四种启动模式"><a href="#四种启动模式" class="headerlink" title="四种启动模式"></a>四种启动模式</h4><ul>
<li>standard：每次启动一个Activity就会创建一个新的实例，大部分情况下，都应该使用这种模式</li>
</ul>
<ul>
<li>singleTop：如果在任务的栈顶正好存在该Activity的实例，就重用该实例，否则就会创建新的实例并放入栈顶，当它不需要创建新的Activity对象时，它会调用onNewIntent()方法</li>
</ul>
<ul>
<li>singleTask：如果要激活的Activity在任务栈中存在该实例，则不需要创建，只需要把此Activity放入栈顶，并把该Activity以上的Activity实例都pop(弹出销毁)；这个模式可以用来退出整个应用</li>
</ul>
<ul>
<li>singleInstance：会启动一个新的任务栈来管理Activity实例，并且该实力在整个系统中只有一个。无论从哪个任务栈中启动该Activity，都会是该Activity所在的任务栈转移到前台，从而使Activity显示。主要作用是为了在不同程序中共享一个Activity实例</li>
</ul>
<h3 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h3><h4 id="Handler原理，Message如何存储在MessageQueen"><a href="#Handler原理，Message如何存储在MessageQueen" class="headerlink" title="Handler原理，Message如何存储在MessageQueen"></a>Handler原理，Message如何存储在MessageQueen</h4><p><strong><a href="https://tocreate.app/2019/01/21/AOSHandler/" target="_blank" rel="external">详见</a></strong></p>
<ul>
<li>Handler用于发送和处理消息(Message)和Runnable对象，使用Handler机制的线程都有一个消息队列(MessageQueue)，当Handler被创建时，它会通过ThreadLocal与当前线程的Looper绑定，Looper是真正执行消息循环的对象，负责维护一个MessageQueue且基于该MessageQueue 发送/取出处理 Message 和 Runnable给handler消费，MessageQueen的实现是一个链表，节点为Message对象</li>
</ul>
<h4 id="loop怎么做到不影响app"><a href="#loop怎么做到不影响app" class="headerlink" title="loop怎么做到不影响app"></a>loop怎么做到不影响app</h4><ul>
<li>loop方法会不停调用next方法，这个方法的作用不是单纯的把消息从队列头里拿出来，整体效果应该是，待到第一个可处理的消息的处理时机返回这个消息，也就是说该方法会导致阻塞，使线程休眠，next简单来说两个效果，一个是查找第一个可处理的消息，另一个是阻塞到这个消息的处理时机</li>
</ul>
<ul>
<li>next实现上是使用名为nativePollOnce的native方法，这个方法有两个参数，一个是MessageQueue的指针，一个是阻塞的时间，阻塞时间为-1时只能由外界唤醒。Looper调用next方法如果能得到消息就用SystemClock.uptimeMillis()计算需要阻塞多久，如果拿不到那就设为-1, 等enqueueMessage方法把新消息入队列时判断如果需要唤醒就调用nativeWake唤醒它</li>
</ul>
<ul>
<li>可以的话使劲吹到这里。消息阻塞的实现是 Linux pipe/epoll，Linux的io接口，是为处理大批量句柄而作了改进的poll，公认为Linux2.6下性能最好的多路I/O就绪通知方法。<a href="https://blog.csdn.net/libaineu2004/article/details/70197825" target="_blank" rel="external">详见</a></li>
</ul>
<h4 id="子线程实现Handler"><a href="#子线程实现Handler" class="headerlink" title="子线程实现Handler"></a>子线程实现Handler</h4><ul>
<li><p>Looper.prepare，new handler，Looper.loop</p>
</li>
<li><p>实现时注意避免内存泄漏</p>
</li>
</ul>
<h4 id="handler内存泄漏原因和解决"><a href="#handler内存泄漏原因和解决" class="headerlink" title="handler内存泄漏原因和解决"></a>handler内存泄漏原因和解决</h4><ul>
<li>内部类或匿名内部类的方式创建Handler时，Handler对象会隐式地持有一个外部类对象的引用，在耗时任务时由于通过handler来处理回调，常常直接或间接导致Activity不能回收</li>
</ul>
<ul>
<li>解决方法</li>
</ul>
<pre><code>将Handler声明为静态内部类
Handler中添加对外部Activity的弱引用
</code></pre><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><h4 id="Android系统的进程优先级"><a href="#Android系统的进程优先级" class="headerlink" title="Android系统的进程优先级"></a>Android系统的进程优先级</h4><ul>
<li>前台进程 ：处于前台正在与用户进行交互的Activity，或者在前台绑定的Service</li>
</ul>
<ul>
<li>可见进程 ：可见但不可交互的Activity</li>
</ul>
<ul>
<li>服务进程 ：包含非前台service</li>
</ul>
<ul>
<li>后台进程 ：只包含不可见Activity</li>
</ul>
<ul>
<li>空进程 ：用于缓存，可被随时收回</li>
</ul>
<h4 id="进程的回收策略"><a href="#进程的回收策略" class="headerlink" title="进程的回收策略"></a>进程的回收策略</h4><ul>
<li>Low memory killer机制：系统定时进行检查，通过基于OOM_ADJ的比较复杂的评分机制，对进程进行打分，然后将分数高的进程杀死并释放内存</li>
</ul>
<h4 id="进程保活策略"><a href="#进程保活策略" class="headerlink" title="进程保活策略"></a>进程保活策略</h4><p><strong><a href="https://tocreate.app/2019/02/20/AOSProcessPrio/" target="_blank" rel="external">详见</a></strong></p>
<ul>
<li>1.前台service 2.双进程 3.一像素 4.jobService 6.WakeLock 7.开机广播 8.账号同步 9.native 10.其他(persistent, STATR_STICK，意义不大)</li>
</ul>
<h4 id="ANR原理-及-解决手段"><a href="#ANR原理-及-解决手段" class="headerlink" title="ANR原理 及 解决手段"></a>ANR原理 及 解决手段</h4><ul>
<li>Application Not Responding，也就是应用程序无响应，包含以下四种</li>
</ul>
<pre><code>InputDispatching Timeout：5秒内无法响应屏幕触摸事件或键盘输入事件

BroadcastQueue Timeout ：在执行前台广播（BroadcastReceiver）的onReceive()函数时10秒没有处理完成，后台为60秒

Service Timeout ：前台服务20秒内，后台服务在200秒内没有执行完毕

ContentProvider Timeout ：ContentProvider的publish在10s内没进行完
</code></pre><ul>
<li>常见的直接原因有一下几种，</li>
</ul>
<pre><code>I/O阻塞
网络阻塞；
onReceiver执行时间超过10s;
多线程死锁
</code></pre><ul>
<li>ANR原理：android中使用handler机制进行事件的调度，这种情况下如果一个线程阻塞了，因为无法对自己进监控，那么这个线程本身无能为力，所以需要另一个线程进行监控，ActivityThread所在的线程（主线程）的监控线程就是AMS线程，AMS在调用组件的回调方法时如果需要计时会使用sendMessageAtTime来发送一个延迟消息，ActivityThread在执行完方法时，会反过来让AMS取消这个消息，如果在规定时间内这个消息没有取消那么就可以判断是ANR了，详见<a href="https://www.jianshu.com/p/388166988cef" target="_blank" rel="external">这里</a></li>
</ul>
<ul>
<li>WatchDog原理：这个机制本身和ANR无直接关联，但是可以拓展来讲。由于ActivityThread的监控线程本身是AMS线程，那么为了保证ANR机制，同样也要保证AMS线程不发生死锁，AMS线程的监控线程就是同在SystemServer中的WatchDog线程，这个WatchDog类直接继承自Thread类，它使用HandlerChecker来判断Handler绑定的线程是否死锁，这里的handler不一定是AMS的，SystemServer中很多线程被它监控，HandlerChecker调用MessageQueue的isPolling时返回true，则说明MessageQueue正在工作，没有死锁，如果返回false则说明正在处理消息，这个时候HandlerChecker就设置一个标记，投递一个用来取消标记的Runnable，在这个Runnable在取消标记前会使用synchronized关键字尝试获取AMS的锁，如果30秒后检测到这个标记没能清除，则会输出log，超时60秒则会重启，<a href="https://www.jianshu.com/p/5c18c4e8c826" target="_blank" rel="external">详见</a></li>
</ul>
<ul>
<li>分析定位：</li>
</ul>
<pre><code>1.直接使用log，ActivityManager作为tag来过滤
2.使用/data/anr/traces.txt文件
3.使用Android Profiler的Record功能查看方法耗时
</code></pre><h4 id="混淆的功能"><a href="#混淆的功能" class="headerlink" title="混淆的功能"></a>混淆的功能</h4><ul>
<li><p>压缩，检查并移除代码中无用的类</p>
</li>
<li><p>优化，对字节码的优化，提高效率</p>
</li>
<li><p>混淆，混淆定义的名称，避免反编译</p>
</li>
<li><p>预检测，在java平台对处理后的代码再次进行检测</p>
</li>
</ul>
<h4 id="为什么使用代码混淆"><a href="#为什么使用代码混淆" class="headerlink" title="为什么使用代码混淆"></a>为什么使用代码混淆</h4><ul>
<li>java的源代码会被编译成字节码文件，存储在.class文件中，由于跨平台的需要，java的字节码中包含了很多源代码信息，诸如变量名、方法名等等。并且通过这些名称来访问变量和方法，这些变量很多是无意义的，但是又很容易反编译成java源代码，为了防止这种现象，我们就需要通过proguard来对java的字节码进行混淆</li>
</ul>
<h3 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h3><h4 id="DP-DPI-PX"><a href="#DP-DPI-PX" class="headerlink" title="DP DPI PX"></a>DP DPI PX</h4><ul>
<li>dpi，dots per inch, 每英寸包含像素个数，可以通过mContext.getResources().getDisplayMetrics()获得，dpi根据范围可以归类为下面几种</li>
</ul>
<pre><code> 0 dpi \~ 120dpi ldpi
120dpi \~ 160dpi mdpi
160dpi \~ 240dpi hdpi
240dpi \~ 320dpi xhdpi
320dpi \~ 480dpi xxhdpi
480dpi \~ 640dpi xxxhdpi
</code></pre><ul>
<li>dp，dip，设备独立像素，根据不同的dpi范围，每个单位对应不同的像素个数，大小跟像素是无关的，就是说dp能够让同一数值在不同的分辨率展示出大致相同的尺寸大小，也就是看起来差不多一样大</li>
</ul>
<pre><code>ldpi   1dp=0.75px 
mdpi   1dp=1.0px 
hdpi   1dp=1.5px 
xhdpi  1dp=2.0px 
xxhdpi 1dp=3px 
</code></pre><ul>
<li>资源id来去引用图片时，Android会使用一些规则来去帮我们匹配最适合的图片。比如我的手机屏幕密度为xxhdpi，那么就在drawable-xxhdpi中寻找，如果最佳文件夹下没有这张图时，会优先去更高密度的文件夹寻找，如果所有更高密度的都没有就在drawable-nodpi文件夹找这张图，如果还没有，那么就依次去更低密度的文件夹下面找</li>
</ul>
<ul>
<li>当系统被迫在更高或更低的dpi文件夹中寻找图片时，会相应缩小或放大图片，以适应本机的屏幕，这样一般会使显示效果更好，如果资源放错文件夹可能会导致图片模糊</li>
</ul>
<h4 id="bitmap-和-drawable-的区别"><a href="#bitmap-和-drawable-的区别" class="headerlink" title="bitmap 和 drawable 的区别"></a>bitmap 和 drawable 的区别</h4><pre><code>* A Drawable is a general abstraction for &quot;something that can be drawn.&quot;  Most
* often you will deal with Drawable as the type of resource retrieved for
* drawing things to the screen; the Drawable class provides a generic API for
* dealing with an underlying visual resource that may take a variety of forms.
* Unlike a {@link android.view.View}, a Drawable does not have any facility to
* receive events or otherwise interact with the user.

...

Though usually not visible to the application, Drawables may take a variety of forms:
1. Bitmap: the simplest Drawable, a PNG or JPEG image.
2. Nine Patch: an extension to the PNG format allows it to specify information about how to stretch it and place things inside of it.
3. Shape: contains simple drawing commands instead of a raw bitmap, allowing it to resize better in some cases.
4. Layers: a compound drawable, which draws multiple underlying drawables on top of each other.
5. States: a compound drawable that selects one of a set of drawables based on its state.
6. Levels: a compound drawable that selects one of a set of drawables based on its level.
7. Scale : a compound drawable with a single child drawable, whose overall size is modified based on the current level.
</code></pre><ul>
<li>Drawable是一个抽象的可绘制类，它用来表示可以画在canvas上的东西，主要提供了一个可绘制的区域bound属性以及一个draw方法，不同的派生类通过重载draw函数的实现而产生不同的绘制结果。view在绘制drawable时就是调用drawable的draw方法，而drawable又各自调用canvas的draw方法，bitmap用于在view上显示时同样需要封装为drawable，setImageBitmap其实就是将bitmap封装为bitmapDrawable的过程，常用的drawable见<a href="https://www.jianshu.com/p/578125001dc2" target="_blank" rel="external">这里</a></li>
</ul>
<pre><code>ColorDrawable
BitmapDrawable
NinePatchDrawable
ScaleDrawable
RotateDrawable
GradientDrawable
TransitionDrawable
AnimationDrawable
InsetDrawable
ClipDrawable
LayerDrawable
LevelListDrawable
StateListDrawable
</code></pre><p><br></p>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h4 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h4><ul>
<li>单位：进程是资源分配的基本单位，线程是处理机调度的基本单位</li>
</ul>
<ul>
<li>内存：进程有独立的内存空间，线程则共享进程中的资源，使用相同的地址空间，因此CPU创建和切换一个线程的花费远比进程要小很多</li>
</ul>
<ul>
<li>通信：进程下的线程共享内存空间，线程间通信基本不需要什么特别的机制，而进程之间的通信需要IPC</li>
</ul>
<ul>
<li>同步：进程和线程都存在同步问题，只不过进程主要处理资源的同步</li>
</ul>
<ul>
<li>Linux上进程和线程的联系：Linux的线程属于一种特殊的轻量进程，linux中使用一对一模型的LWP。linux上的pthread的实现在glibc中，在2.4以前使用的是的linuxThreads，在2.4以后使用的是redhat实现的NPTL，不管是哪一种，都是直接使用进程实现线程，使用的是同样的系统调用(clone，最终调用fork)和结构体(task_struct)，只不过同一进程下创建的线程公用进程的内存空间（准确的说只是部分，用户栈和内核栈不同），内核只看得见进程，一个进程就对应了一个线程，从这个角度来说，linux的线程就是内核线程，之所以成为轻量进程是因为他对于普通的进程来说权重较轻。使用这种手段的原因是实现者认为linux的进程以及很轻量了，不用在去实现一套更加轻量的东西(线程)</li>
</ul>
<h4 id="死锁是什么，怎么产生，如何避免"><a href="#死锁是什么，怎么产生，如何避免" class="headerlink" title="死锁是什么，怎么产生，如何避免"></a>死锁是什么，怎么产生，如何避免</h4><ul>
<li><p>定义：A.S Tanenbaum的定义为：如果一个进程集合中的每一个进程都在等待只能由本集合中的其他进程才能引发的事件，那么该进程的死锁的。</p>
</li>
<li><p>产生条件：</p>
</li>
</ul>
<pre><code>1.互斥：资源被一个进程占用时，其他进程不能使用
2.请求和保持：资源请求者在请求其他资源时可以继续占用原有资源
3.不可抢占：资源请求者不能强制从占有者中夺取资源，只能等待其主动释放
4.环路等待：系统中必然有一条或两条以上的进程组成等待关系的环路
</code></pre><ul>
<li>产生原因：（1）竞争系统资源 （2）进程的推进顺序不当。在java的情况中可能是一个线程持有锁L1并且申请获得锁L2，另一个线程T2持有锁L2并且申请获得锁L1，不过实际情况会更复杂，往往涉及多个线程、及相应的同步块</li>
</ul>
<ul>
<li>避免死锁，从操作系统的角度：</li>
</ul>
<pre><code>资源有序分配法：给每种资源编号，进程获取资源时需按编号递增获取递减释放

银行家算法
</code></pre><ul>
<li>从java的角度：可以通过jstack拿到该应用程序死锁的线程转储文件来分析，在Android中可以使用trace.txt文件</li>
</ul>
<p><br></p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="设计模式六大原则"><a href="#设计模式六大原则" class="headerlink" title="设计模式六大原则"></a>设计模式六大原则</h3><ul>
<li>单一职责原则: 一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因</li>
</ul>
<ul>
<li>开闭原则:一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展</li>
</ul>
<ul>
<li>里氏替换原则:所有引用基类（父类）的地方必须能透明地使用其子类的对象</li>
</ul>
<ul>
<li>依赖倒置原则:抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。</li>
</ul>
<ul>
<li>接口隔离原则:使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口</li>
</ul>
<ul>
<li>迪米特法则:一个软件实体应当尽可能少地与其他实体发生相互作用</li>
</ul>
<h3 id="常见设计模式"><a href="#常见设计模式" class="headerlink" title="常见设计模式"></a>常见设计模式</h3><ul>
<li>都在<a href="https://tocreate.app/2019/02/04/JavaDesignPattern/" target="_blank" rel="external">这</a>了</li>
</ul>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h4 id="acid"><a href="#acid" class="headerlink" title="acid"></a>acid</h4><ul>
<li>原子性：整个事务中的所有操作，要么全部完成，要么全部不完成，发生错误，会回滚（Rollback）</li>
</ul>
<ul>
<li>一致性：事务必须始终保持系统处于一致的状态，不管在任何给定的时间并发事务有多少，表现为串行</li>
</ul>
<ul>
<li>持久性：该事务完成后对数据库的更改持久保存在数据库之中并不会被无理由回滚</li>
</ul>
<ul>
<li>隔离性：确保每一事务在系统中认为只有该事务在使用系统</li>
</ul>
<h4 id="对SQLite数据库中进行大量的数据插入"><a href="#对SQLite数据库中进行大量的数据插入" class="headerlink" title="对SQLite数据库中进行大量的数据插入"></a>对SQLite数据库中进行大量的数据插入</h4><ul>
<li>事务+SQLiteStatement</li>
</ul>
<ul>
<li>Sqlite中事务基于rollback journal文件，借助这个临时文件来完成原子操作和回滚功能，exec()方法中，其实隐式开启了事务了，相当于一条sql语句的事务，打开和关闭一次事务，大大的增加IO了，因此批操作务必提前开启事务</li>
</ul>
<ul>
<li>sql语句需要编译成SQLiteStatement才可以执行，对于相同的sql语句s可以使用sqLiteDatabase.compileStatement(insertSQL)复用编译结果</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="常见数据结构时间复杂度"><a href="#常见数据结构时间复杂度" class="headerlink" title="常见数据结构时间复杂度"></a>常见数据结构时间复杂度</h3><ul>
<li><a href="https://blog.csdn.net/chao2016/article/details/82425317" target="_blank" rel="external">详见</a></li>
</ul>
<p><br><br><strong>本篇未完</strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[设计模式汇总]]></title>
      <url>/2019/01/04/JavaDesignPattern/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><strong>只是简单描述一下，方便回忆，本文中的各种设计模式将会尽量把相似的排列在一起</strong></p>
<p><br></p>
<h3 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1 单例模式"></a>1 单例模式</h3><ul>
<li>特点：某个类只能有一个实例，提供给外界一定访问权限，大体上可以分为懒汉式和饿汉式</li>
</ul>
<ul>
<li>场景： 需要避免可复用的对象重复创建</li>
</ul>
<p><br></p>
<h4 id="双重锁"><a href="#双重锁" class="headerlink" title="双重锁"></a>双重锁</h4><ul>
<li>双重锁，double check，volatile是为了避免重排序(见并发一章)，因为分配内存，调用构造函数，将对象指向该内存，可能因为重排序导致第三步先与第二部执行使其他线程看到不完整的对象，从而抛出异常，synchronized因为有可能初始化未完毕多个线程都观察到对象引用为空</li>
</ul>
<pre><code>public class Single {

    private static volatile Single INSTANCE;

    public static Single getInstance(){
        if(INSTANCE == null){
            synchronized (Single.class){
                if (INSTANCE == null){
                    INSTANCE = new Single();
                }
            }
        }
        return INSTANCE;
    }
}
</code></pre><p><br></p>
<h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><ul>
<li>饿汉式，基于classloader机制，在需要单例的类被访问时初始化</li>
</ul>
<pre><code>public class Single {

    private static volatile Single INSTANCE = new Single();

    public static Single getInstance(){
        return INSTANCE;
    }
}

public class Single {

    private static volatile Single INSTANCE;

    static{
        INSTANCE = new Single();
    }

    public static Single getInstance(){
        return INSTANCE;
    }
}
</code></pre><p><br></p>
<h4 id="静态内部类式"><a href="#静态内部类式" class="headerlink" title="静态内部类式"></a>静态内部类式</h4><ul>
<li>静态内部类模式，同样基于classloader机制，但是在Holder被访问时才会初始化</li>
</ul>
<pre><code>public class Single {

    private static class Holder{
        private static Single INSTANCE = new Single();
    }

    public Single getInstance(){
        return Holder.INSTANCE;
    }

    private Single(){
        if(Holder.INSTANCE != null){
            throw new IllegalStateException();
        }
    }
}
</code></pre><p><br></p>
<h4 id="枚举式"><a href="#枚举式" class="headerlink" title="枚举式"></a>枚举式</h4><ul>
<li>枚举，对非延迟加载来说是最好的模式，可以避免多线程同步问题，以及防止反序列化重新创建新的对象</li>
</ul>
<pre><code>public enum Single {
    instance;
}
</code></pre><p><br></p>
<h3 id="2-工厂模式"><a href="#2-工厂模式" class="headerlink" title="2 工厂模式"></a>2 工厂模式</h3><p><br></p>
<h4 id="简单工厂式"><a href="#简单工厂式" class="headerlink" title="简单工厂式"></a>简单工厂式</h4><ul>
<li>建立一个工厂类，一个产品接口，在工厂类的静态方法中对产品实现类进行实例创建</li>
</ul>
<ul>
<li>在工厂类的方法中处理创建对象的细节，创建的产品如需改变，只需修改工厂类</li>
</ul>
<ul>
<li>需要修改工厂类的方法。在运行期改变创建行为上存在一定局限性</li>
</ul>
<p><br></p>
<h4 id="工厂方法式"><a href="#工厂方法式" class="headerlink" title="工厂方法式"></a>工厂方法式</h4><ul>
<li>建立一个工厂接口，一个产品接口，每一个工厂实现类对应一个产品实现类，由工厂实现类决定要如何实例化产品实现类</li>
</ul>
<ul>
<li>消费者和产品实现类隔离</li>
</ul>
<p><br></p>
<h4 id="抽象工厂式"><a href="#抽象工厂式" class="headerlink" title="抽象工厂式"></a>抽象工厂式</h4><ul>
<li>一般来说在工厂模式的基础上，有多个产品接口就属于抽象工厂模式，这个时候工厂的接口通常设计为可以创建多个产品，每个工厂实现类代表一个产品族，不同产品族使用的产品实现类可以不同</li>
</ul>
<ul>
<li>场景中需要有多个产品族时，添加新的产品族或产品实现类会很简单</li>
</ul>
<ul>
<li>添加新类型的产品(产品接口)时，需要修改工厂接口以及其所有实现类</li>
</ul>
<p><br></p>
<h3 id="3-建造者模式"><a href="#3-建造者模式" class="headerlink" title="3 建造者模式"></a>3 建造者模式</h3><ul>
<li>包括产品类Product和建造者类Builder，建造者类用于设置和组装产品类实例的各个模块，业务复杂的情况下还可能需要专门的导演类Director来指定各个模块的顺序，或者为Product和Builder抽取接口</li>
</ul>
<ul>
<li>场景：实例的相关的方法需要一定的调用顺序来使用，多个部件都可以装配到一个对象中，产品类非常复杂，都可以使用这种模式</li>
</ul>
<p><br></p>
<h3 id="4-原型模式"><a href="#4-原型模式" class="headerlink" title="4 原型模式"></a>4 原型模式</h3><ul>
<li>通过拷贝原型创建新的对象，而不是使用构造方法，原型模式实际上就是实现Cloneable接口，重写clone()方法</li>
</ul>
<pre><code>... implements Cloneable {

...
   public Object clone() {
      Object clone = null;
      try {
         clone = super.clone();
      } catch (CloneNotSupportedException e) {
         e.printStackTrace();
      }
      return clone;
   }
}
</code></pre><ul>
<li>优点：高效，不需要使用构造方法</li>
</ul>
<ul>
<li>场景：对象初始化流程较长，反复创建相同对象，相关方法有访问权限限制</li>
</ul>
<p><br></p>
<h3 id="5-享元模式"><a href="#5-享元模式" class="headerlink" title="5 享元模式"></a>5 享元模式</h3><ul>
<li>建立享元对象接口，享元实现对象，享元工厂，所谓的享元对象即是可以共享的对象，概念上包含内部状态和外部状态，外部状态在创建时传入并且不可改变，外部状态在调用方法时传入。使用享元工厂来维护享元池缓存享元对象，以此减少对象的创建</li>
</ul>
<pre><code>public class FlyweightFactory {
    private Map&lt;Character,Flyweight&gt; sharedObject = new HashMap&lt;Character,Flyweight&gt;();

    public Flyweight factory(Character state){
        //先从缓存中查找对象
        Flyweight fly = sharedObject.get(state);
        if(fly == null){
            //如果对象不存在则创建一个新的Flyweight对象
            fly = new ConcreteFlyweight(state);
            //把这个新的Flyweight对象添加到缓存中
            sharedObject.put(state, fly);
        }
        return fly;
    }
}
</code></pre><ul>
<li>场景：系统有大量相同或者相似的对象，对象的大部分状态都可以从外部传入，缺点需要维护一个存储享元对象的享元池，例子有，String常量池，数据库连接池等</li>
</ul>
<p><br></p>
<h3 id="6-组合模式"><a href="#6-组合模式" class="headerlink" title="6 组合模式"></a>6 组合模式</h3><ul>
<li>将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</li>
</ul>
<ul>
<li>Component（抽象构件），为叶子构件和容器构件对象声明接口，定义了访问及管理它的子构件的方法</li>
</ul>
<ul>
<li>Leaf（叶子构件），它在组合结构中表示叶子节点对象，叶子节点没有子节点</li>
</ul>
<ul>
<li>Composite（容器构件）：它在组合结构中表示容器节点对象，容器节点包含子节点，其子节点可以是叶子节点，也可以是容器节点，它提供一个集合用于存储子节点，实现了在抽象构件中定义的行为，包括那些访问及管理子构件的方法，在其业务方法中可以递归调用其子节点的业务方法</li>
</ul>
<ul>
<li>场景：维护和展示部分-整体关系的场景，如树形菜单、文件和文件夹管理。树形结构。</li>
</ul>
<p><br></p>
<h3 id="7-适配器模式"><a href="#7-适配器模式" class="headerlink" title="7 适配器模式"></a>7 适配器模式</h3><ul>
<li><p>需要使用一个已有或新建立的类，但这个类又不符合系统的接口，适配器继承或依赖已有的对象，实现想要的目标接口</p>
</li>
<li><p>缺点：1、过多地使用适配器，会让系统非常零乱，不易整体进行把握 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类</p>
</li>
</ul>
<p><br></p>
<h3 id="8-模板方法模式"><a href="#8-模板方法模式" class="headerlink" title="8 模板方法模式"></a>8 模板方法模式</h3><ul>
<li>实现算法框架的过程中，将一些步骤延迟到子类中。包括基本方法，由子类实现的抽象方法，模板方法，调用抽象方法和实现部分算法的具体方法，为了防止恶意的操作，一般模板方法都加上final关键字，不允许被覆写</li>
</ul>
<ul>
<li>优点：使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤</li>
</ul>
<ul>
<li>场景：多个子类有公有的方法，并且逻辑基本相同时</li>
</ul>
<p><br></p>
<h3 id="9-策略模式"><a href="#9-策略模式" class="headerlink" title="9 策略模式"></a>9 策略模式</h3><ul>
<li>定义一组算法，将每个算法都封装起来，为对象，Context封装角色，屏蔽高层模块对策略、算法的直接访问，Strategy抽象策略角色，ConcreteStrategy具体策略角色，实现抽象策略中的操作，该类含有具体的算法</li>
</ul>
<ul>
<li>场景: 多个类只有在算法或行为上稍有不同的场景， 算法需要自由切换的场景，需要屏蔽算法规则的场景</li>
</ul>
<p><br></p>
<h3 id="10-桥接模式"><a href="#10-桥接模式" class="headerlink" title="10 桥接模式"></a>10 桥接模式</h3><ul>
<li>把抽象(Abstraction)与行为实现(Implementation)分离开来，从而可以保持各部分的独立性以及应对他们的功能扩展</li>
</ul>
<ul>
<li>Abstraction，抽象化角色，定义出该角色的行为，保存一个对实现化角色的引用，因此该角色一般是抽象类</li>
</ul>
<ul>
<li>Implementor，实现化角色，它是接口或者抽象类，定义角色必需的行为和属性。</li>
</ul>
<ul>
<li>RefinedAbstraction，修正抽象化角色，通过继承持有实现化角色对抽象化角色进行修正。</li>
</ul>
<ul>
<li>ConcreteImplementor，具体实现化角色，它实现接口或抽象类定义的方法和属性。</li>
</ul>
<ul>
<li>桥接模式和策略模式的主要区别是，桥接模式中的abstraction和策略模式中的context不同，abstraction一般为抽象类，只负责持有实现着，并且定义基本的方法，因为桥接模式关注的是抽象和实现两方的可变性。策略模式中的strategy类一般都是无状态的，因为它只用来实现一个算法过程，而桥接模式中的Implementor就没有这种特性。</li>
</ul>
<p><br></p>
<h3 id="11-过滤器模式"><a href="#11-过滤器模式" class="headerlink" title="11 过滤器模式"></a>11 过滤器模式</h3><ul>
<li>过滤器模式（Filter Pattern）或标准模式（Criteria Pattern）是一种设计模式，这种模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来</li>
</ul>
<p><br></p>
<h3 id="12-包装模式"><a href="#12-包装模式" class="headerlink" title="12 包装模式"></a>12 包装模式</h3><ul>
<li>这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。</li>
</ul>
<ul>
<li>Component为统一接口，也是装饰类和被装饰类的基本类型</li>
</ul>
<ul>
<li>ConcreteComponent为具体实现类，也是被装饰类，是个具有一些功能的完整的类</li>
</ul>
<ul>
<li>Decorator是装饰类，实现了Component接口的同时还在内部维护了一个ConcreteComponent的实例，通常采用默认实现</li>
</ul>
<ul>
<li>ConcreteDecorator是具体的装饰产品类，每一种装饰产品都具有特定的装饰效果</li>
</ul>
<p><br></p>
<h3 id="13-代理模式"><a href="#13-代理模式" class="headerlink" title="13 代理模式"></a>13 代理模式</h3><ul>
<li>静态代理和包装模式的实现是一致的 </li>
</ul>
<ul>
<li>Subject为统一接口，也是代理类和被代理类的基本类型。RealSubject为具体实现类，也是被装饰类。Proxy是代理类，实现了Subject接口的同时还在内部维护了一个RealSubject的实例，控制外界对被RealSubject的访问，普通代理的情况下RealSubject是客户端传入的，强制代理的情况下，客户端只能创造代理对象，RealSubject由Proxy自行创建，RealSubject对外界不可知</li>
</ul>
<ul>
<li>动态代理的关键步骤如下，其中Proxy是反射包提供的api，newProxyInstance用于动态创建一个代理类和代理类的实例，ProxyHandler为InvocationHandler的实例，需要自己实现，其invoke方法中可以获取方法对了真实method和参数args，代理对象中的方法都会交由该方法来处理，需要在这里面通过反射调用真实方法</li>
</ul>
<pre><code>RealSubject real = new RealSubject();
Subject proxySubject = (Subject) Proxy.newProxyInstance(
        Subject.class.getClassLoader()
        , new Class[]{Subject.class}
        , new ProxyHandler(real));
proxySubject.doSomething();
</code></pre><ul>
<li>jdk生成的代理对象类型为jdkproxy.$Proxy0(数字由先后决定)并实现了subject接口，父类为java.lang.reflect.Proxy，$Proxy0持有InvocationHandler对象，InvocationHandler对象持有realsubject对象，$Proxy0会在静态初始化域中通过反射获取到Method对象，在自动生成的方法直接调用invocationHandler对象的invoke方法，invoke则是实现了代理的业务逻辑，调用了realsubject相应的方法。JDK Proxy会把hashCode()、equals()、toString()这三个非接口方法转发给InvocationHandler，其余的Object方法则不会转发</li>
</ul>
<pre><code>// JDK代理类具体实现
public final class $Proxy0 extends Proxy implements Subject
{
  private static Method m1;
  private static Method m2;
  private static Method m3;
  private static Method m0;
  ...
    try
    {
      m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, new Class[] { Class.forName(&quot;java.lang.Object&quot;) });
      ...
    }
  ...
  public $Proxy0(InvocationHandler invocationhandler)
  {
    super(invocationhandler);
  }
  ...
  @Override
  public final String doXX(String str){
    ...
    return super.h.invoke(this, m3, new Object[] {str});
  }
  ...
}
</code></pre><ul>
<li>另外一种实现动态代理的方式为CGLIB，CGLIB通过基于ASM的字节码生成库来生成代理类，它使用的是继承的方式，即代理类为被代理类的子类，对象的所有非final方法都会被交给MethodInterceptor（类似InvocationHandler）来处理，通过子类的invokeSuper方法可以调用被代理类即父类的方法。对于从Object中继承的方法，CGLIB代理也会进行代理，如hashCode()、equals()、toString()等，但是getClass()、wait()等方法不会，因为它是final方法，CGLIB无法代理</li>
</ul>
<p><br></p>
<h3 id="14-外观模式"><a href="#14-外观模式" class="headerlink" title="14 外观模式"></a>14 外观模式</h3><ul>
<li>外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口</li>
</ul>
<ul>
<li>Facade，它熟悉子系统的功能。内部根据客户角色的需求预定了几种功能的组合，实现了子系统的功能。它对客户角色和Facade时未知的。它内部可以有系统内的相互交互，也可以由供外界调用的接口</li>
</ul>
<p><br></p>
<h3 id="15-责任链模式"><a href="#15-责任链模式" class="headerlink" title="15 责任链模式"></a>15 责任链模式</h3><ul>
<li>使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止</li>
</ul>
<ul>
<li>一般有两种实现方式，一种是直接将handler对象放到一个容器当中，由专门的类去管理责任链，另一个是将handler作为责任链的节点，设置setNext方法设置下一个节点，handlerMessage方法处理请求</li>
</ul>
<ul>
<li>场景：有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定</li>
</ul>
<p><br></p>
<h3 id="16-命令模式"><a href="#16-命令模式" class="headerlink" title="16 命令模式"></a>16 命令模式</h3><ul>
<li>请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令</li>
</ul>
<ul>
<li><p>Receive 接收者角色，Command 命令角色，Invoker 调用者角色</p>
</li>
<li><p>场景：本身不是一种很特殊或专门的设计模式，认为是命令的地方就可以采用命令模式</p>
</li>
</ul>
<p><br></p>
<h3 id="17-解释器模式"><a href="#17-解释器模式" class="headerlink" title="17 解释器模式"></a>17 解释器模式</h3><ul>
<li><p>给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子</p>
</li>
<li><p>AbstractExpression，抽象解释器。TerminalExpression，终结符表达式，实现与文法中的元素相关联的解释操作，通常一个解释器模式中只有一个终结符表达式，但有多个实例，对应不同的终结符</p>
</li>
<li><p>NonterminalExpression，非终结符表达式，文法中的每条规则对应于一个非终结表达式，非终结符表达式根据逻辑的复杂程度而增加，原则上每个文法规则都对应一个非终结符表达式</p>
</li>
<li><p>Context，环境角色</p>
</li>
<li><p>场景：重复发生的问题可以使用解释器模式，一个简单语法需要解释的场景</p>
</li>
</ul>
<ul>
<li>缺点：尽量不要在重要的模块中使用解释器模式，否则维护会是一个很大的问题，在项目中可以使用shell、JRuby、Groovy等脚本语言来代替解释器模式，弥补Java编译型语言的不足</li>
</ul>
<p><br></p>
<h3 id="18-迭代器模式"><a href="#18-迭代器模式" class="headerlink" title="18 迭代器模式"></a>18 迭代器模式</h3><ul>
<li>它提供一种方法访问一个容器对象中各个元素，而又不需暴露该对象的内部细节</li>
</ul>
<ul>
<li>Iterator抽象迭代器，负责定义访问和遍历元素的接口，有固定的3个方法：first()获得第一个元素，next()访问下一个元素，hasNext()是否已经访问到底部</li>
</ul>
<ul>
<li>ConcreteIterator具体迭代器，具体迭代器角色要实现迭代器接口，完成容器元素的遍历。</li>
</ul>
<ul>
<li>Aggregate抽象容器，容器角色负责提供创建具体迭代器角色的接口，必然提供一个类似createIterator()这样的方法，在Java中一般是iterator()方法</li>
</ul>
<ul>
<li>ConcreteAggregate具体容器，具体容器实现容器接口定义的方法，创建出容纳迭代器的对象</li>
</ul>
<ul>
<li>场景：访问一个聚合对象的内容而无须暴露它的内部表示。需要为聚合对象提供多种遍历方式。为遍历不同的聚合结构提供一个统一的接口</li>
</ul>
<p><br></p>
<h3 id="19-中介者模式"><a href="#19-中介者模式" class="headerlink" title="19.中介者模式"></a>19.中介者模式</h3><ul>
<li>用一个中介对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使其耦合松散，而且可以独立地改变它们之间的交互</li>
</ul>
<ul>
<li>Mediator 抽象中介者角色，抽象中介者角色定义统一的接口，用于各同事角色之间的通信</li>
</ul>
<ul>
<li>Concrete Mediator 具体中介者角色，具体中介者角色通过协调各同事角色实现协作行为，因此它必须依赖于各个同事角色</li>
</ul>
<ul>
<li>Colleague 同事角色，每一个同事角色都知道中介者角色，而且与其他的同事角色通信的时候，一定要通过中介者角色协作。同事类的行为分为两种：一种是同事本身的行为，比如改变对象本身的状态，处理自己的行为等，这种行为叫做自发行为（Self-Method），与其他的同事类或中介者没有任何的依赖；第二种是必须依赖中介者才能完成的行为，叫做依赖方法（Dep-Method）</li>
</ul>
<ul>
<li>和外观模式的区别：</li>
</ul>
<pre><code>外观模式的子系统如果脱离外观模式还是可以运行的，子系统是不知道外观类的存在的
中介者模式增加了业务逻辑，同事类不能脱离中介者而独自存在，每个同事类都知道中介者

外观模式的协议是单向的，即外观模式向子系统提出请求，但反过来则不行
中介者模式，是进行多个对象之间的协作，通信是多向的

中介者隔离了各个子系统
外观模式只隔离了子系统群和客户端
在业务复杂时外观模式仍有可能出现子系统互相调用的情况
</code></pre><p><br></p>
<h3 id="20-备忘录模式"><a href="#20-备忘录模式" class="headerlink" title="20.备忘录模式"></a>20.备忘录模式</h3><ul>
<li>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态</li>
</ul>
<ul>
<li>Originator，发起人角色，记录当前时刻的内部状态，负责定义哪些属于备份范围的状态，负责创建和恢复备忘录数据</li>
</ul>
<ul>
<li><p>Memento，备忘录角色（简单的javabean），负责存储和提供发起人对象的内部状态</p>
</li>
<li><p>Caretaker备忘录管理员角色（简单的javabean），对备忘录进行管理、保存和提供备忘录</p>
</li>
</ul>
<p><br></p>
<h3 id="21-观察者模式"><a href="#21-观察者模式" class="headerlink" title="21.观察者模式"></a>21.观察者模式</h3><ul>
<li>定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新</li>
</ul>
<ul>
<li>Subject被观察者，定义被观察者必须实现的职责，它必须能够动态地增加、取消观察者。它一般是抽象类或者是实现类，仅仅完成作为被观察者必须实现的职责：管理观察者并通知观察者</li>
</ul>
<ul>
<li>Observer观察者，观察者接收到消息后，即进行update（更新方法）操作，对接收到的信息进行处理</li>
</ul>
<ul>
<li>ConcreteSubject具体的被观察者，定义被观察者自己的业务逻辑，同时定义对哪些事件进行通知</li>
</ul>
<ul>
<li>ConcreteObserver具体的观察者，每个观察在接收到消息后的处理反应是不同，各个观察者有自己的处理逻辑</li>
</ul>
<p><br></p>
<h3 id="22-状态模式"><a href="#22-状态模式" class="headerlink" title="22.状态模式"></a>22.状态模式</h3><p>* </p>
<p><br><br><strong>本篇未完</strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入操作系统 12 - 引导内核]]></title>
      <url>/2019/01/03/OSBiosBootLoader/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><a href="https://tocreate.app/2019/03/02/OperatingSystem/" target="_blank" rel="external">本文为深入操作系统系列的一部分</a></p>
<p><a href="https://tocreate.app/2018/12/10/OSsynchro/" target="_blank" rel="external">可能需要阅读前文</a></p>
<p><strong>看Android系统启动流程的时候又遇到了bootloader相关的内容，想起来之前研究过grub，虽然在qemu上成功引导了一个内核程序，不过毕竟不是自己写BootLoader，对整个启动流程不是很了解，这里做一下总结</strong></p>
<p><strong>参考</strong><br><strong><a href="https://www.ibm.com/developerworks/cn/linux/l-bios.html" target="_blank" rel="external">用于 Linux 的开放 BIOS</a></strong><br><strong><a href="https://wiki.osdev.org/BIOS" target="_blank" rel="external">BIOS</a></strong></p>
<p><br></p>
<h3 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS ?"></a>BIOS ?</h3><ul>
<li><p>bios，bootloader, 两个很容易把人搞糊涂的东西，主要是使用的环境相关</p>
</li>
<li><p>bios一般固化在pc机的主板的rom芯片上和BootLoader共同引导内核</p>
</li>
<li><p>而在嵌入式系统上则是将BootLoader放在 rom 或 flash。bootloader一般会被映射到一个固定的地址开始执行，BIOS就不存在了，靠BootLoader独立完成</p>
</li>
</ul>
<p><br></p>
<h3 id="pc-机的启动流程"><a href="#pc-机的启动流程" class="headerlink" title="pc 机的启动流程"></a>pc 机的启动流程</h3><p><strong>以x86为例，虽然是一个比较典型的例子，但实际上并不是所有pc机都会采用这样的流程，有些机器上就没有bios，这种机器的启动流程贴近于嵌入式机器的启动流程</strong></p>
<p><br></p>
<h4 id="BIOS-内存分布"><a href="#BIOS-内存分布" class="headerlink" title="BIOS 内存分布"></a>BIOS 内存分布</h4><ul>
<li>计算机开机后的第一件事是读取ROM芯片中的bios，上电后cpu的IP指针指向BIOS内存区，开始执行BIOS程序，这个流程是自动的，之前我们说过早期cpu实模式下最多只能寻址1m内存，虽然往后寻址能力大了很多，但是为了向前兼容，bios的内存分布是在这1m（0x00000-0xFFFFF）内定好了的</li>
</ul>
<ul>
<li>0x00000-0x9FFFF: 基本内存（640KB）</li>
</ul>
<pre><code>0x00000 \~ 0x003FF: 中断向量表（1024B）
0x00400 \~ 0x004FF: bios数据区（256B）
0x00500 \~ 0x07BFF: 自由内存区
0x07C00 \~ 0x07DFF: 引导程序加载区（512B）
0x07E00 \~ 0x9FFFF: 自由内存区
</code></pre><ul>
<li>0xA0000-0xBFFFF: 显存（128KB）</li>
</ul>
<pre><code>0xA0000 \~ 0xAFFFF: EGA/VGA/XGA/XVGA图形视频缓冲区（64KB）
0xB0000 \~ 0xB7FFF: Mono text video buffer（32KB）
</code></pre><ul>
<li>0xC0000-0xFFFFF: bios自己使用（256KB）</li>
</ul>
<pre><code>0xC0000 \~ 0xC7FFFF: 显卡bios使用（32KB）
0xC8000 \~ 0xCBFFFF: ide控制器bios使用（16KB）
0xCC000 \~ 0xEFFFFF: 
0xF0000 \~ 0xFFFFFF: 系统bios使用（64KB）
</code></pre><p><br></p>
<h4 id="BIOS-主要工作"><a href="#BIOS-主要工作" class="headerlink" title="BIOS 主要工作"></a>BIOS 主要工作</h4><p><br></p>
<h5 id="加电测试"><a href="#加电测试" class="headerlink" title="加电测试"></a>加电测试</h5><ul>
<li>检查计算机硬件是否良好，确定可用内存，确定时钟速度等。如果测试成功，机器的喇叭就会响一声。该过程称为加电测试（power-on self test）或 POST。自检中如发现有错误，按两种情况处理：对于严重故障（致命性故障）则停机，此时各种初始化操作还没完成，不能给出任何提示或信号；对于非严重故障则给出提示或声音报警信号，等待用户处理</li>
</ul>
<p><br></p>
<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><ul>
<li>内存初始化：BIOS 要负责对内存进行初始化。并非所有的操作系统都需要对内存进行初始化，早期的 DOS 系统通常需要进行这种操作，今天大部分 BIOS 为兼容性的目的也进行初始化。这个过程可能需要很长时间，很多现代系统允许彻底或部分将其禁用。BIOS 还会试图确定系统中有多少内存可用，还可能包括对处理器缓存的初始化和启用，配置双 CPU，构建有关处理器的信息表，构建连接到系统中的 PCI 设备，甚至运行这些设备提供的引导 ROM，这可以加载其他驱动程序</li>
</ul>
<ul>
<li>硬件初始化：某些操作系统的硬件驱动程序需要在启动时就已经加载上来，为这些驱动程序提供的标准接口是由 BIOS 来处理的，BIOS 需要对设备进行探测、识别，还可能要进行初始化</li>
</ul>
<pre><code>对于 Linux、BSD 或 Windows 来说，操作系统有自己的驱动程序。
操作系统可以丢弃连接到系统上的 PCI 设备列表，并开始加载这些设备。BIOS 所做的工作大部分会被忽略掉，操作系统一旦加载 SCSI 驱动程序之后，就会自行扫描 SCSI 总线。
BIOS 并没有做什么其他工作，仅仅是提供信息而已，并且它所提供的很多信息也都不会被使用
</code></pre><ul>
<li>硬件中断处理；开机时BIOS会告诉CPU各硬件设备的中断号，当用户发出使用某个设备的指令后，CPU就根据中断号使用相对应的硬件完成工作，再根据中断号跳回原来的工作</li>
</ul>
<ul>
<li>程序服务处理；通过特定的数据端口发出命令，传送或者接受各种外部设备的数据，实现软件程序对硬件的直接操作，这些服务通常被叫做bios函数（BIOS functions），这些服务给BootLoader提供很多便利，在实模式（BootLoader一般就运行在实模式，除了最终阶段）下可以直接使用软中断进行调用，一般调用的方法是设定AH寄存器的值，然后使用INT指令，合并后可以cpu可以找到具体的中断，如下表是其中一部分，需要的参数则放在其他寄存器当中，注意在保护模式下这些服务一般不能使用，否则会导致异常或无用的结果，如果一定需要使用，可以考虑虚拟8086模式或则暂时切会实模式，但这不是什么好办法</li>
</ul>
<pre><code>INT 0x10, AH = 1 -- set up the cursor
INT 0x10, AH = 3 -- cursor position
INT 0x10, AH = 0xE -- display char
INT 0x10, AH = 0xF -- get video page and mode
INT 0x10, AH = 0x11 -- set 8x8 font
INT 0x10, AH = 0x12 -- detect EGA/VGA
INT 0x10, AH = 0x13 -- display string
INT 0x10, AH = 0x1200 -- Alternate print screen
INT 0x10, AH = 0x1201 -- turn off cursor emulation
INT 0x10, AX = 0x4F00 -- video memory size
INT 0x10, AX = 0x4F01 -- VESA get mode information call
INT 0x10, AX = 0x4F02 -- select VESA video modes
INT 0x10, AX = 0x4F0A -- VESA 2.0 protected mode interface
</code></pre><ul>
<li>加载引导程序：功能是引导内核，此时会在硬盘引导扇区(Boot Sector)读取引导记录，然后把计算机的控制权转交给BootLoader，BIOS的这部分任务就完成了。也就是说BIOS本身不能引导OS内核</li>
</ul>
<pre><code>BIOS加载磁盘第一扇区代码到07c00h
第一扇区代码加载第一阶段的bootloader到090100h
第二阶段的bootloader加载kernel到08000h，并切换到保护模式
执行08000h的代码（进入内核）
</code></pre><p><br></p>
<h4 id="主引导扇区"><a href="#主引导扇区" class="headerlink" title="主引导扇区"></a>主引导扇区</h4><ul>
<li>引导扇区(Boot Sector) 通常指设备的第一个扇区，为硬盘的0柱面、0磁头、1扇区，占用512个字节</li>
</ul>
<ul>
<li>MBR不属于任何一个操作系统，不随操作系统的不同而不同，即使不同，MBR也不会夹带操作系统的性质，具有公共引导的特性。但还是有办法改写，如LINUX的LILO</li>
</ul>
<ul>
<li>主引导记录MBR，446字节，主分区表DPT，64字节，引导区标记Boot Record ID，2字节(0x55AA)</li>
</ul>
<p><img src="http://wx3.sinaimg.cn/mw690/007vHOvngy1fyx6993gq3j30bo0e1my0.jpg" alt=""></p>
<p><br></p>
<h4 id="阶段化的-BootLoader"><a href="#阶段化的-BootLoader" class="headerlink" title="阶段化的 BootLoader"></a>阶段化的 BootLoader</h4><p><strong> x86的BootLoader最大只能使用512字节，因此可能需要使用一些技巧来打破这个限制，一般来说BootLoader都遵循下列设计准则</strong></p>
<ul>
<li>Single Stage Bootloader，只有一阶段的BootLoader，被BIOS整个加载上来，在有限的空间内做完所有事情，只使用446字节，这通常不太容易</li>
</ul>
<ul>
<li>Two-Stage Bootloader，两阶段的BootLoader，第一阶段由bios加载，并且足够小，用来引导第二阶段，第二阶段可以使用需要的全部空间，即使不是x86专用的BootLoader通常也采取阶段式的设计模式，大多数是两阶段，也有三阶段的</li>
</ul>
<ul>
<li>Mixed Bootloader，混合的BootLoader，实际上是将Bootloader拆分，只有一个BootLoader，但前512字节可以加载剩余的部分</li>
</ul>
<p><br></p>
<h4 id="Bootloader的主要工作"><a href="#Bootloader的主要工作" class="headerlink" title="Bootloader的主要工作"></a>Bootloader的主要工作</h4><p><strong>大部分内容不仅限于存在bios的pc机上，嵌入式机器也适用</strong></p>
<ul>
<li>将内核载入内存，从“哪里”载入内核的“什么”呢，一般来说常用的BootLoader会提供足够的配置，因为每个操作系统需要载入的文件都不一样，pc上最常用的如GRUB的配置可以看<a href="https://blog.csdn.net/mmoooodd/article/details/53690870" target="_blank" rel="external">这里</a>，而实际载入的方法用到的就是我们之前提到的bios function，具体来说是INT 13</li>
</ul>
<pre><code>INT 0x13, AH = 0 -- reset floppy/hard disk
INT 0x13, AH = 2 -- read floppy/hard disk in CHS mode
INT 0x13, AH = 3 -- write floppy/hard disk in CHS mode
INT 0x13, AH = 0x15 -- detect second disk
INT 0x13, AH = 0x41 -- test existence of INT 13 extensions
INT 0x13, AH = 0x42 -- read hard disk in LBA mode
INT 0x13, AH = 0x43 -- write hard disk in LBA mode
</code></pre><ul>
<li>为内核提供足够的信息，最重要的是寻址空间，如从哪里开始是物理内存</li>
</ul>
<ul>
<li>将环境切换到内核需要的状态，如保护模式（打开A20总线，加载gdt，设置cr0，这个在前几篇已经讲过了），通常来说BootLoader会保持关中断的状态（内核设置完中断向量表之后自行开启）</li>
</ul>
<ul>
<li>将控制权转交给内核，执行某个固定地址的代码，如x86的08000h</li>
</ul>
<p><br></p>
<h3 id="linux嵌入系统的启动流程"><a href="#linux嵌入系统的启动流程" class="headerlink" title="linux嵌入系统的启动流程"></a>linux嵌入系统的启动流程</h3><p><strong>嵌入式系统中不需要bios，因为BootLoader把bios的工作也做了</strong></p>
<p><br></p>
<h4 id="uboot"><a href="#uboot" class="headerlink" title="uboot"></a>uboot</h4><p><strong>uboot是嵌入式linux最常用的BootLoader，也是Android系统使用的BootLoader，uboot采用常见的Two-Stage设计</strong></p>
<p><strong>以下内容来自<a href="https://blog.csdn.net/kai_zone/article/details/80443820" target="_blank" rel="external">这里</a></strong></p>
<p><br></p>
<h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><ul>
<li>CPU上电后，会从某个地址开始执行，具体取决于架构，如MIPS为0xBFC00000，ARM为0x00000000，嵌入式开发板中，需要把存储器件的ROM或Flash等映射到这个地址，Bootloader就存放在这个地址的开始处，一上电就开始执行</li>
</ul>
<ul>
<li>Stage1使用汇编编写，主要工作如下</li>
</ul>
<pre><code>（1）定义入口
（2）设置异常向量（Exception Vector）。 
（3）设置CPU的速度、时钟频率及终端控制寄存器。 
（4）初始化内存控制器。 
（5）将ROM中的程序复制到RAM中。 
（6）关中断，关看门狗
（7）初始化堆栈，清bss段，为第二阶段准备。
（8）转到RAM中执行，该工作可使用指令ldr pc来完成。
</code></pre><ul>
<li>stage2使用c语言编写，主要工作如下</li>
</ul>
<pre><code>（1）调用一系列的初始化函数。 
（2）初始化存储设备
（3）初始化简单硬件如串口，lcd等 
（4）初始化相关网络设备，填写IP、MAC地址等。 
（5）进去命令循环（即整个boot的工作循环），接受用户从串口输入的命令，然后进行相应的工作
</code></pre><p><img src="http://wx1.sinaimg.cn/mw690/007vHOvngy1fyx7nb9ki0j30hh0dedh2.jpg" alt=""></p>
<p><br><br><strong>本篇完</strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入Java并发 1 基础]]></title>
      <url>/2019/01/02/ConcurBase/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><strong>网站的基本功能算是写完了，不过写着写着就不自觉给自己加需求了，大概还得摸一段时间</strong></p>
<p><br></p>
<h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><ul>
<li>实际上jvm和java语言规范中并没有去定义线程状态（至少se 8里面是没有），我们讨论的线程状态一般就是两种 Thread.sate 里面的5个线程状态和jstack里面的线程状态，至于有的人说什么5种状态，那是拿操作系统上进程的状态生搬硬套在java线程上，没什么意义</li>
</ul>
<ul>
<li>用 Thead.getState 可以获取线程的状态，在用户层线程的状态定义在 Thread.State 枚举当中：</li>
</ul>
<pre><code>new：创建后未启动

Runnable：包括运行running和就绪ready，区别在于是否被调度

Waiting：无限期等待，需要被其他进程显式唤醒
Object.wait(),Thread.jon()，LockSupport.park()会导致这种

Timed Waiting：有限期等待，一段时间后被系统自动唤醒
Thread.sleep，Object.wait(timeOut)，Thread.join(millis)，LockSupport.parkNanos()，LockSupport.parkUntil()会导致这种

Blocked: 由于阻塞io或获取锁导致的阻塞

Terminated：终止，结束执行
</code></pre><ul>
<li><p>jstack的 dump文件中线程可能出现下面几个状态，具体可以看这篇<a href="https://jameswxx.iteye.com/blog/1041173" target="_blank" rel="external">文章</a></p>
<p>  Runnable<br>  Wait on condition：线程等待某个条件的发生，比如等待资源或者被唤醒时间<br>  Waiting on monitor entry和Object.wait()：线程在等待进入一个临界区</p>
</li>
</ul>
<p><img src="http://wx3.sinaimg.cn/mw690/007vHOvngy1fy35vigta5j30xt0u0jzf.jpg" alt=""></p>
<pre><code>/**
    * A thread state.  A thread can be in one of the following states:
    * &lt;ul&gt;
    * &lt;li&gt;{@link #NEW}&lt;br&gt;
    *     A thread that has not yet started is in this state.
    *     &lt;/li&gt;
    * &lt;li&gt;{@link #RUNNABLE}&lt;br&gt;
    *     A thread executing in the Java virtual machine is in this state.
    *     &lt;/li&gt;
    * &lt;li&gt;{@link #BLOCKED}&lt;br&gt;
    *     A thread that is blocked waiting for a monitor lock
    *     is in this state.
    *     &lt;/li&gt;
    * &lt;li&gt;{@link #WAITING}&lt;br&gt;
    *     A thread that is waiting indefinitely for another thread to
    *     perform a particular action is in this state.
    *     &lt;/li&gt;
    * &lt;li&gt;{@link #TIMED_WAITING}&lt;br&gt;
    *     A thread that is waiting for another thread to perform an action
    *     for up to a specified waiting time is in this state.
    *     &lt;/li&gt;
    * &lt;li&gt;{@link #TERMINATED}&lt;br&gt;
    *     A thread that has exited is in this state.
    *     &lt;/li&gt;
    * &lt;/ul&gt;
    *
    * &lt;p&gt;
    * A thread can be in only one state at a given point in time.
    * These states are virtual machine states which do not reflect
    * any operating system thread states.
    *
    * @since   1.5
    * @see #getState
    */
   public enum State {
       /**
        * Thread state for a thread which has not yet started.
        */
       NEW,

       /**
        * Thread state for a runnable thread.  A thread in the runnable
        * state is executing in the Java virtual machine but it may
        * be waiting for other resources from the operating system
        * such as processor.
        */
       RUNNABLE,

       /**
        * Thread state for a thread blocked waiting for a monitor lock.
        * A thread in the blocked state is waiting for a monitor lock
        * to enter a synchronized block/method or
        * reenter a synchronized block/method after calling
        * {@link Object#wait() Object.wait}.
        */
       BLOCKED,

       /**
        * Thread state for a waiting thread.
        * A thread is in the waiting state due to calling one of the
        * following methods:
        * &lt;ul&gt;
        *   &lt;li&gt;{@link Object#wait() Object.wait} with no timeout&lt;/li&gt;
        *   &lt;li&gt;{@link #join() Thread.join} with no timeout&lt;/li&gt;
        *   &lt;li&gt;{@link LockSupport#park() LockSupport.park}&lt;/li&gt;
        * &lt;/ul&gt;
        *
        * &lt;p&gt;A thread in the waiting state is waiting for another thread to
        * perform a particular action.
        *
        * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;
        * on an object is waiting for another thread to call
        * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on
        * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;
        * is waiting for a specified thread to terminate.
        */
       WAITING,

       /**
        * Thread state for a waiting thread with a specified waiting time.
        * A thread is in the timed waiting state due to calling one of
        * the following methods with a specified positive waiting time:
        * &lt;ul&gt;
        *   &lt;li&gt;{@link #sleep Thread.sleep}&lt;/li&gt;
        *   &lt;li&gt;{@link Object#wait(long) Object.wait} with timeout&lt;/li&gt;
        *   &lt;li&gt;{@link #join(long) Thread.join} with timeout&lt;/li&gt;
        *   &lt;li&gt;{@link LockSupport#parkNanos LockSupport.parkNanos}&lt;/li&gt;
        *   &lt;li&gt;{@link LockSupport#parkUntil LockSupport.parkUntil}&lt;/li&gt;
        * &lt;/ul&gt;
        */
       TIMED_WAITING,

       /**
        * Thread state for a terminated thread.
        * The thread has completed execution.
        */
       TERMINATED;
   }
</code></pre><ul>
<li>再深入的话，我们也可以参考 hotspot 中的线程状态</li>
</ul>
<pre><code># in http://hg.openjdk.java.net/jdk7u/jdk7u/hotspot/file/2cd3690f644c/src/share/vm/utilities/globalDefinitions.hpp#l749
enum JavaThreadState {
  \_thread\_uninitialized     =  0, // should never happen (missing initialization)
  \_thread\_new               =  2, // just starting up, i.e., in process of being initialized
  \_thread\_new\_trans         =  3, // corresponding transition state (not used, included for completness)
  \_thread\_in\_native         =  4, // running in native code
  \_thread\_in\_native\_trans   =  5, // corresponding transition state
  \_thread\_in\_vm             =  6, // running in VM
  \_thread\_in\_vm\_trans       =  7, // corresponding transition state
  \_thread\_in\_Java           =  8, // running in Java or in stub code
  \_thread\_in\_Java\_trans     =  9, // corresponding transition state (not used, included for completness)
  \_thread\_blocked           = 10, // blocked in vm
  \_thread\_blocked\_trans     = 11, // corresponding transition state
  \_thread\_max\_state         = 12  // maximum thread state+1 - used for statistics allocation
};
</code></pre><ul>
<li>简化一下，从 hotspot的角度看，线程主要有下面四个状态，其他还有一些处于这些状态间的转换转态则不是很重要</li>
</ul>
<pre><code>\_thread\_new：线程正在初始化
\_thread\_in\_Java：线程正在执行Java代码
\_thread\_in\_vm：线程正在虚拟机内部执行
\_thread\_blocked：由于某些原因（正在获取锁，等待条件被满足，休眠，执行阻塞的I/O操作等等）线程被阻塞了
</code></pre><p><br></p>
<h3 id="线程映射"><a href="#线程映射" class="headerlink" title="线程映射"></a>线程映射</h3><p><br></p>
<h4 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h4><ul>
<li>在考古时代，jdk 1.2 之前的线程都基于绿色线程，1.2 开始开始则是使用本地线程</li>
</ul>
<ul>
<li>绿色线程就是完全在用户空间实现的线程系统，程序里面的线程不会真正映射到操作系统的线程，而是由语言运行平台自身来调度，这种线程相对容易实现平台一致性</li>
</ul>
<ul>
<li>本地线程即 native thread，使用操作系统原生的线程，这种线程的特性基于操作系统本身，但平台差异一般来说对用户是透明的，对这些线程的支持，可以是多处理器，也可以是单处理器的时间片机制，或者多处理器的时间片机制，虽然通常来说会对应到posix thread，但posix并没有太严格和详细规定的语义，有些系统的posix thread也不一定就符合posix thread标准，jvm负责处理这些平台不一致性</li>
</ul>
<p><br></p>
<h4 id="hotspot"><a href="#hotspot" class="headerlink" title="hotspot"></a>hotspot</h4><ul>
<li>java.lang.Thread 实例表示一个Java层的线程</li>
</ul>
<ul>
<li>虚拟机内部则用JavaThread表示一个java.lang.Thread实例。它包含了一些附加信息来追踪线程的状态。JavaThread持有一个与之相关联的java.lang.Thread对象（oop表示）的引用，java.lang.Thread对象也保存了对应的JavaThread（原生int类型表示）的引用。JavaThread同时也持有了相关联的OSThread实例的引用。</li>
</ul>
<ul>
<li>OSThread实例表示了一个操作系统线程，它包含了一些操作系统级别的附加信息，用于追踪线程状态。OSThread还包含了一个平台相关的”handle”用来找出真正的操作系统线程</li>
</ul>
<pre><code>|                  |              |           |
|      java        |     vm       |     os    |
|                  |              |           |
 java.lang.Thread \&lt;-\&gt; JavaThread -\&gt;  OSThread
</code></pre><ul>
<li>在linux当中 Thread.start 方法最终会执行 os::create_thread 函数，在这个函数当中会调用 pthread_create，pthread 在深入操作系统系列中已经提及了，要么是早期的 LinuxThread，要么是 redhat 的 NTPL，重点是 pthread 在 linux 当中是1：1的线程模型，直接使用与当前进程共享内存空间的进程（注意是进程）也就是轻量级进程LWP实现</li>
</ul>
<pre><code>pthread\_t tid;
    int ret = pthread_create(&amp;tid, &amp;attr, (void* (*)(void*)) java_start, thread);
</code></pre><p><br></p>
<h4 id="本地线程导致的平台相关性"><a href="#本地线程导致的平台相关性" class="headerlink" title="本地线程导致的平台相关性"></a>本地线程导致的平台相关性</h4><ul>
<li>java 中为线程设置了10个优先级，实际操作系统就不一定了，在 windows上是 7 个，linux上的进程优先级则较为复杂，要么是 -20到19的nice值，要么是0到99的实时优先级，另外有些操作系统会动态改变优先级，因此java线程中的优先级在不同系统甚至同一系统上表现都可能不一致</li>
</ul>
<ul>
<li>同样的，不同系统的调度机制不一致直接导致在同硬件配备的不同系统并发性能也可能相差很大</li>
</ul>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入JVM系列 8 - HotSpot Runtime Overview]]></title>
      <url>/2019/01/02/JVMHotspotRuntime/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><a href="https://tocreate.app/2018/09/05/jvm/" target="_blank" rel="external">本文为深入JVM系列的一部分</a></p>
<p><strong>记录一些<a href="http://openjdk.java.net/groups/hotspot/docs/RuntimeOverview.html" target="_blank" rel="external">HotSpot Runtime Overview</a>中的要点</strong></p>
<p><br></p>
<h3 id="命令行参数处理"><a href="#命令行参数处理" class="headerlink" title="命令行参数处理"></a>命令行参数处理</h3><p><br></p>
<h4 id="命令行选项"><a href="#命令行选项" class="headerlink" title="命令行选项"></a>命令行选项</h4><ul>
<li>命令行选项和环境变量可以影响到HotSpot虚拟机的性能。其中有些选项直接由启动器处理（例如-server和-client），有些则是启动器先加工后交给虚拟机处理，但大部分选项还是由启动器直接交给虚拟机处理</li>
</ul>
<ul>
<li>命令行选项分为3种</li>
</ul>
<pre><code>标准选项:
所有的JVM实现都要支持标准选项，
即使不同的版本也要稳定支持（不管选项是否被弃用)

非标准选项:
以-X开头的是非标准选项（并不能保证所有的JVM实现都支持该选项）
非标准选项在后续的Java SDK版本有可能在你不知情的情况下就被修改

开发者选项:
以-XX开头的是开发者选项，这些选项通常需要特定的系统环境支持，
并且可能需要访问系统配置参数的权限,一般用户并不推荐使用
开发者选项也可能在你不知情的情况下被修改
</code></pre><p><br></p>
<h4 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h4><ul>
<li>命令行参数可以设置虚拟机内部变量，这些变量都有默认值</li>
</ul>
<ul>
<li>对于布尔类型的变量，命令行标记出现与否就可以控制该变量的值。对于-XX选项控制的布尔变量，在变量名前面加上+或者-分别可以设置该变量的值为true或者false</li>
</ul>
<ul>
<li>对于那些需要额外参数的变量，有许多不同的方式进行参数传递。有些标记可以直接将参数放在标记名后面, 有些则需要用:或者=将标记名与参数隔开。很不幸，使用哪种传递方式要看具体是哪个标记。开发者标记（-XX标记）只有三种格式：-XX:+OptionName，-XX:-OptionName，和-XX:OptionName=。</li>
</ul>
<ul>
<li>大部分用整数来表示大小的选项都可以使用k，m或者g作后缀来表示多少K，多少M或者多少G。通常是用在控制内存大小的参数上。</li>
</ul>
<p><br></p>
<h3 id="虚拟机生命周期"><a href="#虚拟机生命周期" class="headerlink" title="虚拟机生命周期"></a>虚拟机生命周期</h3><p><br></p>
<h4 id="启动器"><a href="#启动器" class="headerlink" title="启动器"></a>启动器</h4><ul>
<li>在JavaSE中有几个HotSpot虚拟机的启动器，通常使用的是，Unix平台上的java命令，Windows平台上的java和javaw命令，不要和javaws混淆起来，javaws是一个基于网络的启动器</li>
</ul>
<p><br></p>
<h4 id="虚拟机的启动操作"><a href="#虚拟机的启动操作" class="headerlink" title="虚拟机的启动操作"></a>虚拟机的启动操作</h4><ul>
<li>解析命令行选项，一些选项由启动器自己处理，如-client和-server，它们被用来选择具体要加载的虚拟机库，其他的选项则包装在JavaVMInitArgs再传给虚拟机处理。</li>
</ul>
<ul>
<li><p>如果没有在命令行显示指定堆的大小和编译器类型（client或者server）则需要计算一下</p>
</li>
<li><p>设置环境变量，例如LD_LIBRARY_PATH和CLASSPATH。</p>
</li>
<li><p>如果命令行没有指定Main-Class则从JAR包的manifest读取。</p>
</li>
<li><p>启动一个新线程并调用JNI_CreateJavaVM来创建虚拟机。注意：如果在原来的线程创建虚拟机将会大大降低定制虚拟机的能力，例如在Windows平台上栈的大小会受限制。</p>
</li>
<li><p>一旦虚拟机被创建并初始化，Main-Class就会被加载，并且启动器也能拿到Main-Class的main方法了。</p>
</li>
<li><p>通过CallStaticVoidMethod调用main方法。</p>
</li>
</ul>
<ul>
<li>执行完main方法后需要检查下是否有产生阻塞的异常，如果有则清除掉，并返回退出状态。通过调用ExceptionOccurred来进行清除，方法返回值为0表示成功，其他都表示失败。</li>
</ul>
<ul>
<li>通过调用DetachCurrentThread来detach main线程DetachCurrentThread方法会减小线程计数，可以确保main线程不会再在虚拟机中执行操作并且没有活动的Java栈帧。之后就可以安全地调用DestroyJavaVM了</li>
</ul>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 混淆 总结]]></title>
      <url>/2019/01/02/ProGuard/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><br></p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li>简单来说混淆就是移除无用代码，进行简短的重命名，并做一些优化。由shrink、optimize、obfuscate和preveirfy四个步骤组成，每个步骤都是可选的</li>
</ul>
<ul>
<li>压缩(Shrink)：检测并移除代码中无用的类、字段、方法和特性（Attribute）</li>
</ul>
<ul>
<li>优化(Optimize)：对字节码进行优化，提高运行效率</li>
</ul>
<ul>
<li>混淆(Obfuscate)：使用a，b，c，d这样简短而无意义的名称对类，字段和方法进行重命名</li>
</ul>
<ul>
<li>预检(Preveirfy)：对处理后的代码进行预检，确保加载的class文件是可执行的</li>
</ul>
<p><br></p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ul>
<li>ProGuard使用Entry Point来寻找需要混淆和丢弃的代码，它本身是在ProGuard过程中不会被处理的类或方法</li>
</ul>
<ul>
<li>在压缩的步骤中，ProGuard从EntryPoint开始递归遍历，对于没有被使用的类和成员，将在压缩阶段丢弃</li>
</ul>
<ul>
<li>在优化的步骤中，ProGuard将部分非EntryPoint的类和方法会被设置为private、static或final，不使用的参数会被移除</li>
</ul>
<ul>
<li>在混淆的步骤中，ProGuard对非EntryPoint的类和方法进行重命名</li>
</ul>
<p><br></p>
<h3 id="禁止混淆"><a href="#禁止混淆" class="headerlink" title="禁止混淆"></a>禁止混淆</h3><ul>
<li>反射用到的类</li>
</ul>
<ul>
<li>在AndroidManifest中配置的类，比如四大组件</li>
</ul>
<ul>
<li>WebView中JavaScript调用的方法</li>
</ul>
<ul>
<li>Layout文件引用到的自定义View</li>
</ul>
<ul>
<li>一些引入的第三方库</li>
</ul>
<p><br></p>
<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><ul>
<li>在gradle的buildTypes闭包中添加如下代码</li>
</ul>
<pre><code>android {
    ...
    buildTypes {
        release {
            minifyEnabled true
            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;
        }
    }
}
</code></pre><p><br></p>
<h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p><strong>详见<a href="https://blog.csdn.net/lihenair/article/details/78591443" target="_blank" rel="external">这里</a></strong></p>
<ul>
<li>-keep，不压缩，不混淆</li>
</ul>
<ul>
<li>-keepattributes {name}，保护给定的属性不被混淆</li>
</ul>
<pre><code>-keepattributes *Annotation*
</code></pre><ul>
<li>dontwarn {name}，不要警告指定库中找不到的引用。混淆在默认检查每个库的引用是否正确，有些第三方库里面会有用不到的类，有些没有正确引用，所以需要对第三方库取消警告 否则会报错</li>
</ul>
<ul>
<li>keepnames，压缩类及成员，但不混淆，未使用的代码将被移除</li>
</ul>
<ul>
<li>keepclassmembers，保护类的成员不被压缩和混淆，如果类未被使用，则删除类。如果类被使用，保留并重命名该类。类里的成员维持不变，仍然是之前的名字</li>
</ul>
<ul>
<li>keepclassmembernames，移除未使用的类，剩下的类被重命名，类中未使用的成员将被移除，剩余的成员保留原来的名称</li>
</ul>
<ul>
<li>keepclasseswithmembers，与keep作用一致。区别是它只适用于拥有类规范中所有成员的类</li>
</ul>
<ul>
<li>keepclasseswithmembernames，与keepnames一致。区别是它只适用于拥有类规范中所有成员的类</li>
</ul>
<ul>
<li>@Keep注解，保持使用keep注解的元素</li>
</ul>
<pre><code># 手动启用support keep注解
# http://tools.android.com/tech-docs/support-annotations
-dontskipnonpubliclibraryclassmembers
-printconfiguration
-keep,allowobfuscation @interface android.support.annotation.Keep

-keep @android.support.annotation.Keep class \*
-keepclassmembers class \* {
    @android.support.annotation.Keep *;
}
</code></pre><p><br></p>
<h3 id="资源混淆"><a href="#资源混淆" class="headerlink" title="资源混淆"></a>资源混淆</h3><p><br></p>
<h4 id="资源加载原理"><a href="#资源加载原理" class="headerlink" title="资源加载原理"></a>资源加载原理</h4><ul>
<li>AAPT（Android Asset Packaging Tool），位于SDK的tools/目录下，可以通过它查看查看、创建、更新压缩文件(如 .zip文件，.jar文件, .apk文件), 也可以把资源编译为二进制文件，并生成resources.arsc，在打包过程中会使用AAPT对APK中用到的资源进行打包，主要流程如下</li>
</ul>
<pre><code>把assets和res/raw目录下的所有资源进行打包
（根据不同文件后缀选择压缩或不压缩）
而res/目录下的其他资源进行编译或者其他处理后才进行打包
（根据不同文件后缀后缀进行不同处理，例如.xml会编译成二进制文件，.png文件会进行优化）

对assets之外的所有资源赋予一个ID常量，生成资源索引表resources.arsc

编译AndroidManifest.xml成二进制的XML文件

生成结果保存在一个\*.ap\_文件，并把各个资源ID常量定义在一个R.java中
</code></pre><ul>
<li>Android资源管理框架实际是由AssetManager和Resources两个类来实现的，AssetManager类根据文件名来查找资源，Resources类根据ID来查找资源，Resources查找到对应文件名之后会交给AssetManager处理</li>
</ul>
<p><br></p>
<h4 id="AndResGuard"><a href="#AndResGuard" class="headerlink" title="AndResGuard"></a>AndResGuard</h4><p><strong>来自<a href="https://www.jianshu.com/p/fe988af9c663" target="_blank" rel="external">这篇</a></strong></p>
<ul>
<li>AndResGuard通过修改resources.arsc文件，从而可以混淆安卓的资源文件路径，andresGuard在原生的buildApk步骤之后，使用产生的apk作为输入文件，对其进行混淆压缩，产出一个新的apk</li>
</ul>
<ul>
<li>默认andResGuard会混淆所有资源文件，而白名单使用正则表达式指定了不被混淆的资源文件，配置参考如下</li>
</ul>
<pre><code>apply plugin: &apos;AndResGuard&apos;
buildscript {
    repositories {
        jcenter()
    }

    dependencies {
        classpath &apos;com.android.tools.build:gradle:2.2.3&apos;
        classpath &apos;com.tencent.mm:AndResGuard-gradle-plugin:1.1.16&apos;
    }
}

andResGuard {
    // mappingFile = file(&quot;./resource_mapping.txt&quot;)
    mappingFile = null
    use7zip = true
    useSign = true
    // it will keep the origin path of your resources when it&apos;s true
    keepRoot = false
    whiteList = [
            // your icon
            &quot;R.drawable.icon&quot;,
            // for fabric
            &quot;R.string.com.crashlytics.*&quot;,
            // for umeng update
            &quot;R.string.umeng*&quot;,
            &quot;R.string.UM*&quot;,
            &quot;R.string.tb_*&quot;,
            &quot;R.string.rc_*&quot;,
            &quot;R.layout.umeng*&quot;,
            &quot;R.layout.tb_*&quot;,
            &quot;R.layout.rc_*&quot;,
            &quot;R.drawable.umeng*&quot;,
            &quot;R.drawable.tb_*&quot;,
            &quot;R.drawable.rc_*&quot;,
            &quot;R.drawable.u1*&quot;,
            &quot;R.drawable.u2*&quot;,
            &quot;R.anim.umeng*&quot;,
            &quot;R.color.umeng*&quot;,
            &quot;R.color.tb_*&quot;,
            &quot;R.color.rc_*&quot;,
            &quot;R.style.*UM*&quot;,
            &quot;R.style.umeng*&quot;,
            &quot;R.style.rc_*&quot;,
            &quot;R.id.umeng*&quot;,
            &quot;R.id.rc_*&quot;,
            // umeng share for sina
            &quot;R.drawable.sina*&quot;,
            // for google-services.json
            &quot;R.string.google_app_id&quot;,
            &quot;R.string.gcm_defaultSenderId&quot;,
            &quot;R.string.default_web_client_id&quot;,
            &quot;R.string.ga_trackingId&quot;,
            &quot;R.string.firebase_database_url&quot;,
            &quot;R.string.google_api_key&quot;,
            &quot;R.string.google_crash_reporting_api_key&quot;,
            &quot;R.dimen.rc_*&quot;
    ]
    compressFilePattern = [
            &quot;*.png&quot;,
            &quot;*.jpg&quot;,
            &quot;*.jpeg&quot;,
            &quot;*.gif&quot;,
            &quot;resources.arsc&quot;
    ]
    sevenzip {
        artifact = &apos;com.tencent.mm:SevenZip:1.1.16&apos;
    }
}
</code></pre><p><br><br><strong>本篇完</strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入操作系统 11 - 存储管理]]></title>
      <url>/2018/12/15/page/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><a href="https://tocreate.app/2018/11/08/OperatingSystem/" target="_blank" rel="external">本文为深入操作系统系列的一部分</a></p>
<p><a href="https://tocreate.app/2018/12/10/OSsynchro/" target="_blank" rel="external">可能需要阅读前文</a></p>
<p><strong>这部分与前几篇的分段相关，老实说现在我也说不准哪里相关，毕竟内容太多了，卒</strong></p>
<p><strong> 过段时间就告别 hexo 了，最近在用 ssm 和 vue 自己写这个站点，前后端分离，没什么意外的话月末之前挂到自己的vps上面，估计会有很多bug就是了</strong></p>
<p><br></p>
<h3 id="存储层次结构"><a href="#存储层次结构" class="headerlink" title="存储层次结构"></a>存储层次结构</h3><p><strong>对程序员来说，理想的存储器应该无限大无限快而且具有永久性，但这样的存储介质并不存在（实际上软件规模的增长速度和存储介质性能的增长速度几乎差不多），现代操作系统的解决方案是使用多层结构的存储系统</strong></p>
<ul>
<li>存储层次一般为四层</li>
</ul>
<pre><code>一: cpu内部的寄存器
二: cache
三: 主存
四: 磁盘
</code></pre><ul>
<li>操作系统当中负责管理这个层次结构的程序叫做存储管理器（memory manager 或 memory management，简称 mm，这个简称实际上是很多内核不约而同的文件命名），它的主要任务包括</li>
</ul>
<pre><code>记录存储器使用情况
分配和回收进程空间
内存不够时进行交换
</code></pre><ul>
<li>多数操作系统的内存管理器都在内核当中，如 linux 内核代码的 mm 目录，minix 3 则很特殊地放在内核之外</li>
</ul>
<p><br></p>
<h3 id="分段的历史遗留问题"><a href="#分段的历史遗留问题" class="headerlink" title="分段的历史遗留问题"></a>分段的历史遗留问题</h3><ul>
<li>之前我们构造gdt的时候建立过分段机制，代码如下，null 段是 intel 定死的，不用去管它，关键是我们这里建立了代码段和数据段，基址为0，最大范围都为0xfffff，这意味着每个段都为4g大小（通常情况下32位系统本身也就只支持4g虚拟地址，2^32-1）</li>
</ul>
<pre><code>gdt:
SEG\_NULLASM                                     # null seg
SEG\_ASM(STA\_X|STA\_R, 0x0, 0xffffffff)           # code seg for bootloader and kernel
SEG\_ASM(STA\_W, 0x0, 0xffffffff)                 # data seg for bootloader and kernel
</code></pre><ul>
<li>引入分段，又只分一个段，这种做法看似毫无意义多此一举，为什么要这么做呢，因为分页机制出来以后分段确实没什么太大意义，而且非常鸡肋，在 x86-64 当中分页是不支持分段（寄存器变直接就是64位，完全依赖分页机制），即使是32位体系结构，也并不都支持分段，因此大多数操作系统更倾向于只使用分页</li>
</ul>
<pre><code>Segmentation is considered obsolete memory protection technique in protected mode by both CPU manufacturers and most of programmers. 
It is no longer supported in long mode. The information here is required to get protected mode working;
also 64 bit GDT is needed to enter long mode and segments are still used to jump from long mode to compatibility mode and the other way around. 
If you want to be serious about OS development, we strongly recommend using flat memory model and paging as memory management technique.
</code></pre><ul>
<li>由于历史原因 x86 保护模式的分段机制无法关闭，因为不管怎样都需要gdt，不能只使用分页，那么最常见的做法就是使用 flat memory model，也就是只用一个段，基址为 0，大小为4g，剩下的交由分页机制去完成，典型的例子，windows，linux 都是这种，下面就是linux的gdt</li>
</ul>
<p><img src="http://wx3.sinaimg.cn/mw690/987832a0gy1fysbs6hr02j20xm06z75r.jpg" alt=""></p>
<p><br></p>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入操作系统 10 - Linux内核同步]]></title>
      <url>/2018/12/10/OSsynchro/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><a href="https://tocreate.app/2019/03/02/OperatingSystem/" target="_blank" rel="external">本文为深入操作系统系列的一部分</a></p>
<p><a href="https://tocreate.app/2018/12/02/OSProcess/" target="_blank" rel="external">可能需要阅读前文</a></p>
<p><strong>前面中断和进程线程还没总结完，主要是看得烦了，过两天再说</strong></p>
<p><strong>注意不要将这一部分涉及的同步与互斥和java中的同步与互斥混淆</strong></p>
<p><br></p>
<h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><p><br></p>
<h4 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h4><ul>
<li>linux为所有的体系结构提供了两组原子操作的接口，分别针对整数进行操作和针对单独的位进行操作</li>
</ul>
<ul>
<li>大多数体系结构会支持原子操作的简单算数指令，有些体系结构确实缺少简单的原子操作指令，但也为单步执行提供了锁内存总线的指令，确保其他改变内存的操作不可能同时发生，如arm的<a href="https://blog.csdn.net/u013686019/article/details/78235624" target="_blank" rel="external">ldrex和strex指令</a>，intel著名的<a href="https://blog.csdn.net/infinite_sh/article/details/44236803" target="_blank" rel="external">lock前缀</a></li>
</ul>
<p><br></p>
<h4 id="atomic-t"><a href="#atomic-t" class="headerlink" title="atomic_t"></a>atomic_t</h4><ul>
<li>linux/types.h 下定义了 atomic_t 类型，本质上就是个int，使用结构体是为了使这种原操作必须使用特殊的类型，防止编译器进行访问优化，和屏蔽体系结构的差异</li>
</ul>
<pre><code>typedef struct{
        volatile int counter
}atomic64\_t
</code></pre><ul>
<li>这个类型所提供的原子操作都在 asm/atomic.h 下（关于这个，偶然发现了一篇很暴力的<a href="https://blog.csdn.net/kocmoc5/article/details/68945068" target="_blank" rel="external">文章</a>，写得挺有意思的）</li>
</ul>
<pre><code># define ATOMIC\_INIT(i)  { (i) }

# define atomic\_read(v)  ((v)-\&gt;counter)

# define atomic\_set(v, i) (((v)-\&gt;counter) = (i))

static inline void atomic\_inc(atomic\_t \*v)
{
    atomic_add_return(1, v);
}

static inline void atomic\_dec(atomic\_t \*v)
{
    atomic_sub_return(1, v);
}

# define atomic\_dec\_return(v)        atomic\_sub\_return(1, (v))

# define atomic\_inc\_return(v)        atomic\_add\_return(1, (v))

# define atomic\_sub\_and\_test(i, v)   (atomic\_sub\_return((i), (v)) == 0)

# define atomic\_dec\_and\_test(v)      (atomic\_sub\_return(1, (v)) == 0)

# define atomic\_inc\_and\_test(v)      (atomic\_add\_return(1, (v)) == 0)
</code></pre><ul>
<li>原子操作的核心一般都是内联汇编(注意是inline asm，即在c中嵌入汇编语句，不要和普通inline混淆)完成（不过大部分体系结构中读取字节本身就是原子的，这个时候就是个简单的宏）,如atomic_add的实现,这里使用到LOCK宏，对于本身就是原子操作的情况这个宏是空的，对于非原子操作lock前缀会导致锁总线或执行内存一致协议来保证原子性</li>
</ul>
<pre><code>static __inline__ void atomic\_add(int i, volatile atomic\_t \*v)
 {
         __asm__ __volatile__(
                 LOCK &quot;addl %1,%0&quot;
                 :&quot;=m&quot; (__atomic_fool_gcc(v))
                 :&quot;ir&quot; (i), &quot;m&quot; (__atomic_fool_gcc(v)));
 }
</code></pre><p><br></p>
<h4 id="atomic64-t"><a href="#atomic64-t" class="headerlink" title="atomic64_t"></a>atomic64_t</h4><ul>
<li>所有64位体系结构都提供，atomic_t的64位版本，本质是long，提供的操作基本一致，只是32位体系结构一般不支持这种类型的原子操作</li>
</ul>
<pre><code>typedef struct{
        volatile long counter
}atomic64\_t
</code></pre><p><br></p>
<h4 id="set-bit"><a href="#set-bit" class="headerlink" title="set_bit"></a>set_bit</h4><ul>
<li>与atomic不同，set_bit及其类似的原子操作可以是普通的内存地址，只需要传递一个指针和要修改的位的位号即可，set操作将其置1，clear操作将其置0，test操作在除了置位以外还会返回当前值，一般的用法为 if(test_bit(..)){ }</li>
</ul>
<pre><code>void set\_bit(int nr,void \*addr)
void clear\_bit(int nr,void \*addr)
void change\_bit(int nr,void \*addr)
int test\_and\_set\_bit(int nr,void \*addr)
int test\_and\_clear\_bit(int nr,void \*addr)
int test\_and\_change\_bit(int nr,void \*addr)
int test\_bit(int nr, volatile void \*addr)
</code></pre><p><br></p>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><ul>
<li>只是对简单的数据结构或者位进行原子操作无法总是满足需求，我们有时需要使临界区中的整段代码都具有原子性，这个时候就需要用到锁</li>
</ul>
<ul>
<li>自旋锁是最常见的锁，它只能被一个线程持有，未被持有的自旋锁可以直接获取，被持有的自旋锁获取需要进行循环-旋转-等待到被释放时才能再次获取，自旋是这种锁最大的特性，这是一种轻量级的锁，适合在短期内使用，另一种实现方式是睡眠（信号量使用的就是这种），睡眠会同时带来上下文切换</li>
</ul>
<ul>
<li>自旋锁定义在 asm/spinlock.h 中，使用形式如下，自旋锁可以分两种，一种是内核态的自旋锁，也就是下面这个，本文中的自旋锁指都是这种，在内核当中使用，另一种是用户态的自旋锁，如 pthread 中的自旋锁，</li>
</ul>
<pre><code>DEFINE\_SPINLOCK(MR\_LOCK);
spin\_lock(&amp;mr\_lock);
/\* 临界区 \*/
spin\_unlock(&amp;mr\_lock);
</code></pre><p><br></p>
<h4 id="单核处理器自旋锁"><a href="#单核处理器自旋锁" class="headerlink" title="单核处理器自旋锁"></a>单核处理器自旋锁</h4><ul>
<li>在单核的情况下如果系统不支持抢占，那么自旋锁就什么都不做，毕竟确实无事要做，编译时自旋锁甚至会被完全剔除出内核</li>
</ul>
<ul>
<li>如果系统支持抢占，那么加锁只是关闭了内核启用抢占的开关，这个时候不允许调度，也就可以独占资源了</li>
</ul>
<ul>
<li>总结一下就是，单核自旋锁不自旋</li>
</ul>
<p><br></p>
<h4 id="多核处理器自旋锁"><a href="#多核处理器自旋锁" class="headerlink" title="多核处理器自旋锁"></a>多核处理器自旋锁</h4><ul>
<li>进程在获取其他处理器上的进程占有的锁时同样会自旋，如果所有处理器都需要一个处理器上进程锁时，那么就等于只有一个进程和处理器在执行</li>
</ul>
<ul>
<li>x86上自旋的实现是用lock前缀对一个数进行自减（即原子操作），然后判断结果是否等于0，如果等于0则取锁成功，否则从自减开始重试，而释放锁则只是将这个数设为1</li>
</ul>
<p><br></p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p><strong>linux中的自旋锁有几个特性需要注意</strong></p>
<ul>
<li>不可递归，自旋锁是不可重入锁，在自旋当中是没有可能再次获得锁的，因为这个时候根本释放不了锁</li>
</ul>
<ul>
<li>在中断处理程序中需要锁时一般使用自旋锁（因为不能睡眠所以不能使用信号量），在内核代码中，获取中断处理程序使用的锁时，一定要先关中断，否则内核中的进程获取了锁后如果产生了中断，那么中断处理程序获取同一个锁时就会由于自旋而无法结束，这时进程也得不到执行自然无法释放锁，这就是双重请求死锁，关中断只需要关当前处理器的中断，其他处理器的中断不会导致死锁，内核提供简洁的自锁锁接口，关闭和启用中断</li>
</ul>
<pre><code>DEFINE\_SPINLOCK(mr\_lock)
unsigned long flag
spin\_lock\_irqsave(&amp;mr\_lock,flag)
/\*
临界区
\*/
spin\_unlock\_irqrestore
</code></pre><p><br></p>
<h4 id="读-写-自旋锁"><a href="#读-写-自旋锁" class="headerlink" title="读-写 自旋锁"></a>读-写 自旋锁</h4><ul>
<li>由于只要没有写操作，多少个并发读都是安全的，因此锁也可以分成两个用途，一个或多个读任务可以并发地持有读者锁，用于写的锁最多只能被一个写任务持有，而且不能有并发的读操作，写操作需要等待所有读锁释放，读写锁的用法和自旋锁类似</li>
</ul>
<pre><code>DEFINE\_RWLOCK(mr\_rwlock);
read\_lock(&amp;mr\_lock);
/\* 临界区（只读）\*/
read\_unlock(&amp;mr\_rwlock);
...
write\_lock(&amp;mr\_lock);
/\* 临界区（读写）\*/
write\_unlock(&amp;mr\_rwlock);
</code></pre><ul>
<li>读锁不能被升级为写锁，因为写锁会不断自旋等待读锁释放，下面的代码会造成死锁</li>
</ul>
<pre><code>read\_lock(&amp;mr\_rwlock);
write\_lock(&amp;mr\_rwlock);
</code></pre><p><br></p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><ul>
<li>信号量是一种睡眠锁，在任务试图获取不可占用的信号量时，信号量会将其推进一个等待队列，然后让其睡眠，当信号量可用时任务才会被唤醒</li>
</ul>
<ul>
<li>使用信号量有几点需要注意：信号量适用于锁会被长时间持有的状况。信号量只能在进程上下文中使用，因为在中断上下文中是不能执行调度的。信号量不能在持有自旋锁时使用，因为持有自旋锁本质上是禁止抢占（见上文）</li>
</ul>
<p><br></p>
<h4 id="二值-amp-记数"><a href="#二值-amp-记数" class="headerlink" title="二值 &amp; 记数"></a>二值 &amp; 记数</h4><ul>
<li>信号量允许任意数量的锁持有者，通常情况下设置的数量为1，这个时候称为二值信号量（要么被持有，要么空闲），或者成为互斥信号量，当数量大于1时允许多个线程同时访问临界区，这个时候成为计数信号量</li>
</ul>
<ul>
<li>迪杰斯特拉在提出信号量的时候将信号量支持的两个操作叫做P() V()，在真实的操作系统上一般叫做 down() up()，down() 对信号量减1来获取一个信号量，如果结果是-1，则任务会被放进队列，up()对信号量加1来释放信号量，队列中的任务会被唤醒时会同时获取信号量</li>
</ul>
<ul>
<li>在内核中使用 down_interruptible() 比 down() 更加普遍，如果信号量不可用，进程将睡眠，如果接受到信号它会被唤醒，而不是直接忽略信号</li>
</ul>
<pre><code>static DECLARE\_MUTEX(MR\_SEM);

if(down\_interruptible(&amp;mr\_sem))
/*信号被接受但，还未获取到信号量*/
}
/*临界区*/
up(&amp;mr\_sem);
</code></pre><p><br></p>
<h4 id="读-写-信号量"><a href="#读-写-信号量" class="headerlink" title="读-写 信号量"></a>读-写 信号量</h4><ul>
<li>读 - 写信号量都是互斥信号量，引用计数都为1，但它只对写者互斥，所有读写锁都不会被信号打断，因此它只有一个down操作，其他特性与普通信号量一致，用法则和读写自旋锁类似</li>
</ul>
<pre><code>static DECLEAR\_RWSEM(mr\_rwsem);

down\_read(&amp;mr\_rwsem);
/*临界区 读*/
up\_read(&amp;mr\_rwsem);

down\_write(&amp;mr\_rwsem);
/*临界区 写*/
up\_write(&amp;mr\_rwsem);
</code></pre><p><br></p>
<h3 id="互斥体"><a href="#互斥体" class="headerlink" title="互斥体"></a>互斥体</h3><ul>
<li>互斥体(mutex)本质上是任何可以睡眠的强制互斥锁，比如计数为1的信号量，但是由于以前linux上没有直接对应的实现，所以需要时也就只能用计数为1的信号量，直到后来引入了一个比信号量更加简单的专门实现，直接就叫做 mutex</li>
</ul>
<pre><code>mutex\_init(&amp;mutex);
mutex\_lock(&amp;mutex);
/*临界区*/
mutex\_unlock(&amp;mutex);
</code></pre><ul>
<li>使用mutex需要注意：mutex计数是1。上锁者必须负责解锁。解锁必须在同一上下文。不允许递归。持有锁时进程不能退出。不能在中断或下半部中使用。不可被拷贝，重复或手动初始化。</li>
</ul>
<p><br></p>
<h3 id="大内核锁"><a href="#大内核锁" class="headerlink" title="大内核锁"></a>大内核锁</h3><p><strong>这名字真心牛逼</strong></p>
<ul>
<li>大内核锁(BLK)是内核为了向smp(见进程一文)过渡而引入的锁，2.0开始支持smp，但2.2以前不管是多少核的cpu，内核一个时刻只能运行一个任务，BLK就是这种机制的“暴力”实现，BLK本质上是一个全局唯一的锁，有用自旋锁时间的时期，也有用信号量实现的时期，任何处理器进入内核态时就获取该锁，而其他处理器就只能等待，现在内核已经能够很好地支持smp了，BLK也被弃用</li>
</ul>
<ul>
<li>BLK的主要特性：持有时可以睡眠，调度时锁会自动的释放和获取，但锁被释放时临界区的资源得不到保障。可递归，BKL支持多次请求，不会产生死锁。只能用在进程上下文中，和信号量一样不允许用在中断上下文中。新用户禁止使用BLK，因为毫无必要</li>
</ul>
<pre><code>lock\_kernel();
/*临界区*/
unlock\_kernel();
</code></pre><p><br></p>
<h3 id="顺序锁"><a href="#顺序锁" class="headerlink" title="顺序锁"></a>顺序锁</h3><ul>
<li>顺序锁(seq)是一种写者优先的读写锁，普通的读写锁中写者需要等待所有读者，但顺序锁中只要没有其他的写者，写者总能成功获取锁，而读者则要反复的进行失败-重试，直到整个临界区的操作过程没有被写者打断，才算成功</li>
</ul>
<pre><code>seqlock\_t mr\_seq\_lock = DEFINE\_SEQLOCK(mr\_seq\_lock);
write\_sequnlock(&amp;mr\_seq\_lock);
/\* 写者操作 \*/
write\_sequnlock(&amp;mr\_seq\_lock);

unsigned long seq;
do{
        seq = resd_seqbegin(&amp;mr_seq_lock);
        /* 读者操作 */
}while(read\_seqretry(&amp;mr\_seq\_lock));
</code></pre><ul>
<li>seq锁一般用在读者数量明显大于写者的情况下</li>
</ul>
<p><br><br><strong>本篇完</strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入操作系统 9 - 进程与线程]]></title>
      <url>/2018/12/02/OSProcess/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><a href="https://tocreate.app/2019/03/02/OperatingSystem/" target="_blank" rel="external">本文为深入操作系统系列的一部分</a></p>
<p><a href="https://tocreate.app/2018/12/02/OSSysCall/" target="_blank" rel="external">可能需要阅读前文</a></p>
<p><strong>这篇无图字多，看起来会有点恐怖</strong></p>
<p><br></p>
<h3 id="程序流类型"><a href="#程序流类型" class="headerlink" title="程序流类型"></a>程序流类型</h3><p><strong>在os的发展历程当中与调度相关的概念有任务，作业，进程，线程，这些模型可能全部或部分存在于某一个实际的操作系统上，并且往往相互交叉</strong></p>
<ul>
<li>任务是最抽象的，指由软件完成的一个活动，它显然是一个依赖于语境才能推测其含义的概念，本质上可以是作业，进程，或线程，如在linux中，它只是进程的别名，而在uC/OS-II中，它是线程</li>
</ul>
<ul>
<li>作业，早期使用作业这个概念的时候，进程的概念还没有出现，作业往往被用在批处理操作系统当中，当时程序以作业的形式脱机输入到磁带（或别的什么低效存储介质），操作系统做的只是将作业调入内存一个一个地执行，从这个角度来说，如今实时操作系统的时代已经不存在作业这个概念了，不过在linux中，作业这个词被用来形容由一个或多个命令组成的整体,类似于脚本，<a href="https://www.cnblogs.com/echobfy/p/3851497.html" target="_blank" rel="external">详见</a></li>
</ul>
<ul>
<li>进程，最早叫顺序进程，是多道程序设计中发展出来的概念，进程是运行中的程序与相关资源的统称，在概念上拥有自己的虚拟cpu，是正在执行代码的实时结果，再具体地说，进程不但包含代码段，全局变量的数据段，还包含打开的文件句柄，挂起的信号，内核内部数据，处理器状态（程序计数器、寄存器的当前值），一个或多个具有内存映射的内存地址空间，一个或多个线程等等，现代内核的调度单位一般是线程，对于那些直接使用进程来实现线程的操作系统，如linux，调度单位也可以说是进程</li>
</ul>
<ul>
<li>线程是在进程中活动的对象，是进程的一个执行流，也是内核的调度对象，每个线程都拥有一个独立的程序计数器，进程栈，和一组进程寄存器，线程的出现是为了更加高效地利用多处理器的性能和简化异步事件的处理</li>
</ul>
<p><br></p>
<h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><p><strong>一般只讨论进程和线程的区别，现代程序员不关心作业</strong></p>
<ul>
<li>进程是资源分配的基本单位，线程是处理机调度的基本单位</li>
</ul>
<ul>
<li>进程有独立的内存空间，线程则共享进程中的资源，使用相同的地址空间，因此CPU创建和切换一个线程的花费远比进程要小很多</li>
</ul>
<ul>
<li>进程下的线程共享内存空间，线程间通信基本不需要什么特别的机制，而进程之间的通信需要IPC</li>
</ul>
<ul>
<li>进程和线程都存在同步问题，只不过进程主要处理资源的同步</li>
</ul>
<p><br></p>
<h3 id="内核线程-amp-用户线程-amp-轻量进程"><a href="#内核线程-amp-用户线程-amp-轻量进程" class="headerlink" title="内核线程 &amp; 用户线程 &amp; 轻量进程"></a>内核线程 &amp; 用户线程 &amp; 轻量进程</h3><p><strong>网络上很多关于linux线程的文章在这部分都有错误，这里更正一下</strong></p>
<ul>
<li>通常的进程，无论是系统进程还是用户进程，进程的创建、撤消，I/O 操作，都是利用系统调用而进入内核，再由内核中的相应处理程序予以完成的，进程的切换同样是在内核的支持下实现的</li>
</ul>
<ul>
<li>内核线程：准确的说是内核支持线程，同样是在内核支持下运行的，即无论是用户进程中的线程，还是系统进程中的线程，创建、撤消和切换等也是依靠内核，在内核空间实现。在内核空间还为每一个内核支持线程设置一个线程控制块，内核根据该控制块而感知某线程的存在，并加以控制</li>
</ul>
<ul>
<li>用户线程：准确的说是用户级线程，与内核无关的，仅存在于用户空间中，创建、撤消、同步、通信等功能，都无须利用系统调用。切换的规则简单，切换速度快。线程的任务控制块都是设置在用户空间，所执行的操作也无须内核帮助，因而内核完全不知道用户级线程的存在</li>
</ul>
<ul>
<li>轻量进程：轻量进程（LWP）是一种特殊的用户线程，每一个进程可拥有多个 LWP，每个 LWP 都有自己的数据结构(如 TCB)，其中包括线程标识符、优先级、状态，另外还有栈和局部存储区等，它们也可以共享进程所拥有的资源，一个用户级线程运行时，只要将它连接到一个 LWP 上，此时它便具有了内核支持线程的所有属性，用户级线程数量可能很大，为了节省系统开销，可把 LWP 做成一个缓冲池。用户进程中任一用户线程可以连接到池中任一个 LWP，连接根据用户线程和内核线程的映射数量关系可以有三种不同的实现模型:一对一、多对一和多对多</li>
</ul>
<ul>
<li>那么Linux的线程属于哪一种呢？答案是它是一种特殊的轻量进程，linux中使用一对一模型的LWP，linux上的pthread的实现在glibc中，在2.4以前使用的是的linuxThreads，在2.4以后使用的是NPTL，不管是哪一种，都是直接使用进程实现线程，使用的是同样的系统调用(clone，最终调用fork)和结构体(task_struct)，只不过同一进程下创建的线程公用进程的内存空间（准确的说只是部分，用户栈和内核栈不同），内核只看得见进程，一个进程就对应了一个线程，从这个角度来说，linux的线程就是内核线程，之所以成为轻量进程是因为他对于普通的进程来说权重较轻。使用这种手段的原因是实现者认为linux的进程以及很轻量了，不用在去实现一个更加轻量的东西(线程)</li>
</ul>
<p><br></p>
<h3 id="LinuxThread-amp-NPTL"><a href="#LinuxThread-amp-NPTL" class="headerlink" title="LinuxThread &amp; NPTL"></a>LinuxThread &amp; NPTL</h3><p><strong>linux上线程的两种实现，简单对比一下差异</strong></p>
<ul>
<li>PID，LinuxThreads拥有独立的PID，这是不符合posix标准的。NPTL则在原来的进程管理结构新增了一个TGIP的字段，当一个线程的TGID等于PID时，这个线程就是线程组长，其PID也就是这个线程组的进程号，线程组内所有线程的TGID字段都指向线程组长的PID，由于使用getpid返回的都是TGID字段，所以线程返回的就是相同的PID字段，而不是线程各自的PID</li>
</ul>
<ul>
<li>创建，同样是使用clone()系统调用，不过新的clone()调用的flag参数新增了一个标志位CLONE_THREAD，表示创建一个线程，内核内部初始管理结构时把TGID指向调用者的PID</li>
</ul>
<ul>
<li>同步，NPTL提供的线程同步互斥机制都建立在futex上，快速用户空间系统锁。因为进程内的所有线程都使用了相同的内存空间，所以这个锁可以保存在用户空间。这样对这个锁的操作不需要每次都切换到内核态</li>
</ul>
<ul>
<li>信号，LinuxThreads在进程调度、信号处理、IO等方面享有与普通进程一样的能力，NPTL中同一个进程内的线程都属于该进程，所以信号处理跟POSIX标准完全统一</li>
</ul>
<ul>
<li>管理，LinuxThreads中专门为每一个进程构造了一个管理线程，负责处理线程相关的管理工作。当进程第一次调用pthread_create()创建一个线程的时候就会创建并启动管理线程,由管理线程再来创建用户请求的线程，如果管理线程被杀死将会造成僵尸线程，同时管理线程在高并发环境下本身也是一个开销，NTPL中线程创建与结束的管理都由内核负责，不存在管理线程</li>
</ul>
<p><br></p>
<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><ul>
<li><a href="https://en.wikipedia.org/wiki/Nice_(Unix)" target="_blank" rel="external">nice</a> 是unix和类unix中标准化的概念，一个进程的nice值可以通过同名的nice函数设置它，范围是 -20到19，越低的nice值有越高的优先级，但不同的系统在nice值的使用上并不一致，os x中nice代表分配给进程的时间片的绝对值，在linux中则代表时间片的比例</li>
</ul>
<ul>
<li>linux采用两种不同的优先级，一种是上面的nice，一种是实时优先级，范围从 0 到 99，这个值越高则优先级越高。由于任何实时进程优先级都高于普通进程，因此这两种优先级可以互不相交地工作</li>
</ul>
<p><br></p>
<h3 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h3><ul>
<li>为了实现进程模型，操作系统维持一张表格（数组，队列 ..），即进程表，每个进程占用一个表项（称为进程控制块，即pcb），pcb内部通常包含它的程序计数器，栈指针，内存分配状况，打开文件状况，统计和调度信息，定时器和其他信息，以及进程由运行态到就绪切换时所必须保存的其他信息，进程随后能够被再次启动，就像从未被中断过一样</li>
</ul>
<ul>
<li>pcb通常可以根据模块进行分类，设计良好的内核中个模块负责维护它们各自所需要的那些域</li>
</ul>
<ul>
<li>minix当中部分域如下</li>
</ul>
<p><img src="http://wx2.sinaimg.cn/mw690/007vHOvngy1fz89sgfp7sj30uy0l6ahc.jpg" alt=""></p>
<ul>
<li>linu的进程控制块（进程描述符）如下</li>
</ul>
<pre><code>调度数据成员 
(1) volatile long states; 
(2) unsigned long flags; 
(3) long priority; 
(4) unsigned long rt\_priority; 
(5) long counter; 
(6) unsigned long policy;
信号处理 
(1) unsigned long signal; 
(2) unsigned long blocked; 
(3) struct signal\_struct \*sig;
进程队列指针 
(1) struct task\_struct *next\_task，*prev\_task; 
(2) struct task\_struct *next\_run，*prev\_run; 
(3) struct task\_struct *p\_opptr，*p\_pptr;和struct task\_struct *p\_cptr，*p\_ysptr，\*p\_osptr;

进程标识 
(1) unsigned short uid，gid; 
(2) int groups[NGROUPS]; 
(3) unsigned short euid，egid; 
(4) unsigned short fsuid，fsgid; 
(5) unsigned short suid，sgid; 
(6) int pid，pgrp，session; 
(7) int leader;

时间数据成员 
(1) unsigned long timeout; 
(2) unsigned long it\_real\_value，it\_real\_iner; 
(3) struct timer\_list real\_timer; 
(4) unsigned long it\_virt\_value，it\_virt\_incr; 
(5) unsigned long it\_prof\_value，it\_prof\_incr; 
(6) long utime，stime，cutime，cstime，start\_time;

信号量数据成员 
(1) struct sem\_undo \*semundo; 
(2) struct sem\_queue \*semsleeping;

进程上下文环境 
(1) struct desc\_struct \*ldt; 
(2) struct thread\_struct tss; 
(3) unsigned long saved\_kernel\_stack; 
(4) unsigned long kernel\_stack\_page;

文件系统数据成员 
(1) struct fs\_struct \*fs; 
(2) struct files\_struct \*files; 
(3) int link\_count;

内存数据成员 
(1) struct mm\_struct \*mm;

页面管理 
(1) int swappable:1; 
(2) unsigned long swap\_address; 
(3) unsigned long min\_flt，maj\_flt; 
(4) unsigned long nswap; 
(5) unsigned long cmin\_flt，cmaj\_flt，cnswap; 
(6) unsigned long old\_maj\_flt，dec\_flt; 
(7) unsigned long swap\_cnt;

支持对称多处理器方式(SMP)时的数据成员 
(1) int processor; 
(2) int last\_processor; 
(3) int lock\_depth;

其它数据成员 
(1) unsigned short used\_math; 
(2) char comm[16]; 
(3) struct rlimit rlim[RLIM\_NLIMITS]; 
(4) int errno; 
(5) long debugreg[8]; 
(6) struct exec\_domain \*exec\_domain; 
(7) unsigned long personality; 
(8) struct linux\_binfmt \*binfmt; 
(9) int exit\_code，exit\_signal; 
(10) int dumpable:1; 
(11) int did\_exec:1; 
(12) int tty\_old\_pgrp; 
(13) struct tty\_struct \*tty; 
(14) struct wait\_queue \*wait\_chldexit;

进程队列的全局变量 
(1) current; 
(2) struct task\_struct init\_task; 
(3) struct task\_struct \*task[NR\_TASKS]; 
(4) unsigned long volatile jiffies; 
(5) int need\_resched; 
(6) unsigned long intr\_count;
</code></pre><p><br></p>
<h3 id="创建和运行"><a href="#创建和运行" class="headerlink" title="创建和运行"></a>创建和运行</h3><p><br></p>
<h3 id="第一个进程"><a href="#第一个进程" class="headerlink" title="第一个进程"></a>第一个进程</h3><p><br></p>
<h4 id="linux-与-init"><a href="#linux-与-init" class="headerlink" title="linux 与 init"></a>linux 与 init</h4><p><br></p>
<h4 id="xv6-与-userinit"><a href="#xv6-与-userinit" class="headerlink" title="xv6 与 userinit"></a>xv6 与 userinit</h4><p><br></p>
<h4 id="Android-zygote-与-初始化"><a href="#Android-zygote-与-初始化" class="headerlink" title="Android zygote 与 初始化"></a>Android zygote 与 初始化</h4><ul>
<li>写在另一系列，<a href="https://tocreate.app/2019/01/10/AOSInit/" target="_blank" rel="external">详见</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入操作系统 目录]]></title>
      <url>/2018/12/02/OperatingSystem/</url>
      <content type="html"><![CDATA[<p><strong> 程序员的三大浪漫，编译原理，图形学，操作系统 </strong></p>
<a id="more"></a>
<p><strong>本系列主要内容来自以下书籍和操作系统相关的网络博客文章</strong></p>
<p><strong>  OSDev社区</strong><br><strong>《计算机操作系统（第四版）》</strong><br><strong>《操作系统设计与实现（第三版）》</strong><br><strong>《Linux内核设计与实现（第三版）》</strong><br><strong>《OrangeS一个操作系统的实现》</strong><br><strong><a href="https://th0ar.gitbooks.io/xv6-chinese/content/content/cover.html" target="_blank" rel="external">《xv6 一个简单，类 Unix 的教学操作系统》</a></strong></p>
<p><strong>另外，建议学习操作系统之前先系统地学习计算机组成原理，否则 io，中断等硬件相关的内容将会比较难以理解。推荐《计算机组成与设计：软件/硬件接口》</strong></p>
<p><br></p>
<h2 id="基础环境"><a href="#基础环境" class="headerlink" title="基础环境"></a>基础环境</h2><p><strong>包括了 xv6 ,linux 内核，minix, android 系统的源码获取和部分基础环境的搭建，篇幅较长，跳转到专门的文章，下同</strong></p>
<p><a href="https://tocreate.app/2018/09/21/OSEnv/" target="_blank" rel="external">详见</a></p>
<p><br></p>
<h2 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h2><p><strong>编译一个 GCC Cross-Compiler</strong></p>
<p><a href="https://tocreate.app/2018/09/22/OSCrossGcc/" target="_blank" rel="external">详见</a></p>
<p><br></p>
<h2 id="引导"><a href="#引导" class="headerlink" title="引导"></a>引导</h2><p><strong>制作并引导一个简单镜像</strong></p>
<p><a href="https://tocreate.app/2018/10/15/OSBootstrap/" target="_blank" rel="external">详见</a></p>
<p><strong>讲解BIOS和BootLoader</strong></p>
<p><a href="https://tocreate.app/2019/01/03/OSBiosBootLoader/" target="_blank" rel="external">详见</a></p>
<p><br></p>
<h2 id="系统库函数"><a href="#系统库函数" class="headerlink" title="系统库函数"></a>系统库函数</h2><p><strong>搭建最基本的开发环境</strong></p>
<p><a href="https://tocreate.app/2018/10/15/OSBaseLib/" target="_blank" rel="external">详见</a></p>
<p><br></p>
<h2 id="分段-amp-保护模式"><a href="#分段-amp-保护模式" class="headerlink" title="分段 &amp; 保护模式"></a>分段 &amp; 保护模式</h2><p><strong>简单介绍分段机制与 GDT</strong></p>
<p><a href="https://tocreate.app/2018/10/31/OSGdt/" target="_blank" rel="external">详见</a></p>
<p><strong>创建GDT，进入保护模式</strong></p>
<p><a href="https://tocreate.app/2018/11/08/OSGdtCreate/" target="_blank" rel="external">详见</a></p>
<p><br></p>
<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p><strong>x86的中断机制及linux的中断处理</strong></p>
<p><a href="https://tocreate.app/2018/11/29/OSInterrupts/" target="_blank" rel="external">详见</a></p>
<p><br></p>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p><strong>系统调用</strong></p>
<p><a href="https://tocreate.app/2018/12/02/OSSysCall/" target="_blank" rel="external">详见</a></p>
<p><br></p>
<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p><strong>进程管理</strong></p>
<p><a href="https://tocreate.app/2018/12/02/OSProcess/" target="_blank" rel="external">详见</a></p>
<p><br></p>
<h2 id="内核同步"><a href="#内核同步" class="headerlink" title="内核同步"></a>内核同步</h2><p><strong>主要为Linux下的同步与互斥</strong></p>
<p><a href="https://tocreate.app/2018/12/10/OSsynchro/" target="_blank" rel="external">详见</a></p>
<p><br></p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p><strong>分页</strong><br><a href="https://tocreate.app/2018/12/15/page/" target="_blank" rel="external">详见</a></p>
<p><br><br><br></p>
<p><strong>待续</strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入操作系统 8 - 系统调用]]></title>
      <url>/2018/12/02/OSSysCall/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><a href="https://tocreate.app/2019/03/02/OperatingSystem/" target="_blank" rel="external">本文为深入操作系统系列的一部分</a></p>
<p><a href="https://tocreate.app/2018/11/29/OSInterrupts/" target="_blank" rel="external">可能需要阅读前文</a></p>
<p><strong>个人觉得系统调用大部分的内容已经被中断的知识覆盖了，剩下的东西都是编程细节，所以不做深入</strong></p>
<p><br></p>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p><br></p>
<h4 id="产生"><a href="#产生" class="headerlink" title="产生"></a>产生</h4><ul>
<li>系统调用设计目的为：用户进程和内核之间的一个中间层，为用户提供抽象接口；保证系统的稳定安全，进行访问裁决</li>
</ul>
<ul>
<li>在绝大多数操作系统当中，系统调用都直接(如 linux)或间接（如 minix）通过软中断（或者说陷入来实现）实现，需要中断的原因是”用户空间的程序无法直接执行内核代码，不能直接调用内核空间中的函数，因为内核驻留在受保护的地址空间上。如果进程可以直接在内核的地址空间上读写的话，系统的安全性和稳定性将不存在”，至于中断相关的内容可以阅读上文</li>
</ul>
<ul>
<li>系统调用倾向于简洁，似乎提供的函数越少越好，提供50+个系统调用的minix被认为比提供300+个系统调用的linux简洁，对于那些有一千多个系统调用的系统来说，linux其实已经算十分优秀了</li>
</ul>
<p><br></p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p><br></p>
<h5 id="minix"><a href="#minix" class="headerlink" title="minix"></a>minix</h5><ul>
<li>minix的系统调用使用的软中断指令为 int 33，但这个中断号在 minix 是给 ipc（进程间通信）使用的，本质上来说 minix 的系统调用就是 ipc 的一种实际用途，只是将需要执行的任务以消息的形式发往指定的进程，因此在内核中其实只存在用于进程通信的系统调用，微内核非常喜欢这种能复用就复用的设计</li>
</ul>
<pre><code> /\* Now check if the call is known and try to perform the request. The only
   * system calls that exist in MINIX are sending and receiving messages.
   *   - SENDREC: combines SEND and RECEIVE in a single system call
   *   - SEND:    sender blocks until its message has been delivered
   *   - RECEIVE: receiver blocks until an acceptable message has arrived
   *   - NOTIFY:  asynchronous call; deliver notification or mark pending
   *   - SENDA:   list of asynchronous send requests
   \*/
  switch(call\_nr) {
    case SENDREC:
    case SEND:          
    case RECEIVE:           
    case NOTIFY:
    case SENDNB:
//...
</code></pre><ul>
<li>minix 上系统调用的实现，见<a href="https://www.cnblogs.com/Ricezhang/articles/MINIX.html" target="_blank" rel="external">文章</a></li>
</ul>
<ul>
<li>在minix上添加系统调用，见<a href="http://zealscott.com/posts/65090/" target="_blank" rel="external">文章</a></li>
</ul>
<p><br></p>
<h5 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h5><p><img src="http://wx3.sinaimg.cn/mw690/987832a0gy1fxtnj3u7pfj20dz078jtw.jpg" alt=""></p>
<ul>
<li><a href="http://www.cnblogs.com/yangyuliufeng/p/9214400.html" target="_blank" rel="external">图源</a></li>
</ul>
<ul>
<li>linux 的系统调用则复杂一点调用使用的软中断指令为 int 80h，unistd_32.h 中定义了 300 多个系统调用</li>
</ul>
<pre><code>//linux-2.6/arch/sh/include/uapi/asm/unistd\_32.h
//...
# define \_\_NR\_userfaultfd    377
# define \_\_NR\_membarrier     378
# define \_\_NR\_mlock2     379
# define \_\_NR\_copy\_file\_range    380
# define \_\_NR\_preadv2        381
# define \_\_NR\_pwritev2       382

# define NR\_syscalls 383
</code></pre><ul>
<li>这些系统调用号需要添加的一个系统调用表当中</li>
</ul>
<pre><code># linux-2.6/arch/alpha/kernel/systbls.S
.data
    .align 3
    .globl sys_call_table
sys\_call\_table:
    .quad alpha_ni_syscall          /* 0 */
    .quad sys_exit
    .quad alpha_fork
    .quad sys_read
    .quad sys_write
    .quad alpha_ni_syscall          /* 5 */
# ...
</code></pre><ul>
<li>中断处理程序会根据系统调用号在系统调用表中查找系统调用函数，然后执行</li>
</ul>
<ul>
<li>linux 上系统调用的实现，见<a href="https://www.cnblogs.com/sky-heaven/p/6985616.html" target="_blank" rel="external">文章</a></li>
</ul>
<p><br></p>
<h3 id="posix-amp-ANSI-C"><a href="#posix-amp-ANSI-C" class="headerlink" title="posix &amp; ANSI C"></a>posix &amp; ANSI C</h3><ul>
<li>posix 是由 IEEE 定制的系统调用标准，旨在提高可移植性，并没有规定需要使用什么语言实现，只是大多数操作系统倾向用c语言实现，但往往不会完全根据规范去定义函数接口，因为部分系统调用完全可以合并实现，对参数可能也有自己的考量，有些垃圾操作系统则宁愿去实现一套似是而非的posix接口，比如windows</li>
</ul>
<ul>
<li>ANSI C 和 posix 同时制定，ANSI C 支持了一部分 posix 的函数，但没有完全支持，可以认为 posix 是 ANSI C 的一个超集，没有特殊的理由，程序员应该使用 ANSI C 定义的函数，ANSI C 才是具有可移植性的</li>
</ul>
<ul>
<li>ANSI C 头文件</li>
</ul>
<pre><code>\&lt;assert.h\&gt;      Contains the assert macro, used to assist with detecting logical errors and other types of bug in debugging versions of a program.
\&lt;complex.h\&gt; C99 A set of functions for manipulating complex numbers.
\&lt;ctype.h\&gt;       Defines set of functions used to classify characters by their types or to convert between upper and lower case in a way that is independent of the used character set (typically ASCII or one of its extensions, although implementations utilizing EBCDIC are also known).
\&lt;errno.h\&gt;       For testing error codes reported by library functions.
\&lt;fenv.h\&gt;    C99 Defines a set of functions for controlling floating-point environment.
\&lt;float.h\&gt;       Defines macro constants specifying the implementation-specific properties of the floating-point library.
\&lt;inttypes.h\&gt;    C99 Defines exact width integer types.
\&lt;iso646.h\&gt;  NA1 Defines several macros that implement alternative ways to express several standard tokens. For programming in ISO 646 variant character sets.
\&lt;limits.h\&gt;      Defines macro constants specifying the implementation-specific properties of the integer types.
\&lt;locale.h\&gt;      Defines localization functions.
\&lt;math.h\&gt;        Defines common mathematical functions.
\&lt;setjmp.h\&gt;      Declares the macros setjmp and longjmp, which are used for non-local exits.
\&lt;signal.h\&gt;      Defines signal handling functions.
\&lt;stdalign.h\&gt;    C11 For querying and specifying the alignment of objects.
\&lt;stdarg.h\&gt;      For accessing a varying number of arguments passed to functions.
\&lt;stdatomic.h\&gt;   C11 For atomic operations on data shared between threads.
\&lt;stdbool.h\&gt; C99 Defines a boolean data type.
\&lt;stddef.h\&gt;      Defines several useful types and macros.
\&lt;stdint.h\&gt;  C99 Defines exact width integer types.
\&lt;stdio.h\&gt;       Defines core input and output functions
\&lt;stdlib.h\&gt;      Defines numeric conversion functions, pseudo-random numbers generation functions, memory allocation, process control functions
\&lt;stdnoreturn.h\&gt; C11 For specifying non-returning functions.
\&lt;string.h\&gt;      Defines string handling functions.
\&lt;tgmath.h\&gt;  C99 Defines type-generic mathematical functions.
\&lt;threads.h\&gt; C11 Defines functions for managing multiple Threads as well as mutexes and condition variables.
\&lt;time.h\&gt;        Defines date and time handling functions
\&lt;uchar.h\&gt;   C11 Types and functions for manipulating Unicode characters.
\&lt;wchar.h\&gt;   NA1 Defines wide string handling functions.
\&lt;wctype.h\&gt;  NA1 Defines set of functions used to classify wide characters by their types or to convert between upper and lower case
</code></pre><ul>
<li>posix 头文件（不包括ANSI C部分）</li>
</ul>
<pre><code>\&lt;aio.h\&gt; Asynchronous input and output   Issue 5
\&lt;arpa/inet.h\&gt;   Functions for manipulating numeric IP addresses (part of Berkeley sockets)  Issue 6
\&lt;assert.h\&gt;  Verify assumptions   ??
\&lt;complex.h\&gt; Complex Arithmetic, see C mathematical functions     ??
\&lt;cpio.h\&gt;    Magic numbers for the cpio archive format   Issue 3
\&lt;dirent.h\&gt;  Allows the opening and listing of directories   Issue 2
\&lt;dlfcn.h\&gt;   Dynamic linking Issue 5
\&lt;errno.h\&gt;   Retrieving Error Number  ??
\&lt;fcntl.h\&gt;   File opening, locking and other operations  Issue 1
\&lt;fenv.h\&gt;    Floating-Point Environment (FPE), see C mathematical functions   ??
\&lt;float.h\&gt;   Floating-point types, see C data types   ??
\&lt;fmtmsg.h\&gt;  Message display structures  Issue 4
\&lt;fnmatch.h\&gt; Filename matching   Issue 4
\&lt;ftw.h\&gt; File tree traversal Issue 1
\&lt;glob.h\&gt;    Pathname &quot;globbing&quot; (pattern-matching)  Issue 4
\&lt;grp.h\&gt; User group information and control  Issue 1
\&lt;iconv.h\&gt;   Codeset conversion facility Issue 4
\&lt;inttypes.h\&gt;    Fixed sized integer types, see C data types  ??
\&lt;iso646.h\&gt;  Alternative spellings, see C alternative tokens  ??
\&lt;langinfo.h\&gt;    Language information constants – builds on C localization functions Issue 2
\&lt;libgen.h\&gt;  Pathname manipulation   Issue 4
\&lt;limits.h\&gt;  Implementation-defined constants, see C data types   ??
\&lt;locale.h\&gt;  Category macros, see C localization functions    ??
\&lt;math.h\&gt;    Mathematical declarations, see C mathematical functions  ??
\&lt;monetary.h\&gt;    String formatting of monetary units Issue 4
\&lt;mqueue.h\&gt;  Message queue   Issue 5
\&lt;ndbm.h\&gt;    NDBM database operations    Issue 4
\&lt;net/if.h\&gt;  Listing of local network interfaces Issue 6
\&lt;netdb.h\&gt;   Translating protocol and host names into numeric addresses (part of Berkeley sockets)   Issue 6
\&lt;netinet/in.h\&gt;  Defines Internet protocol and address family (part of Berkeley sockets) Issue 6
\&lt;netinet/tcp.h\&gt; Additional TCP control options (part of Berkeley sockets)   Issue 6
\&lt;nl\_types.h\&gt;    Localization message catalog functions  Issue 2
\&lt;poll.h\&gt;    Asynchronous file descriptor multiplexing   Issue 4
\&lt;pthread.h\&gt; Defines an API for creating and manipulating POSIX threads  Issue 5
\&lt;pwd.h\&gt; passwd (user information) access and control    Issue 1
\&lt;regex.h\&gt;   Regular expression matching Issue 4
\&lt;sched.h\&gt;   Execution scheduling    Issue 5
\&lt;search.h\&gt;  Search tables   Issue 1
\&lt;semaphore.h\&gt;   POSIX semaphores    Issue 5
\&lt;setjmp.h\&gt;  Stack environment declarations   ??
\&lt;signal.h\&gt;  Signals, see C signal handling   ??
\&lt;spawn.h\&gt;   Process spawning    Issue 6
\&lt;stdarg.h\&gt;  Handle Variable Argument List    ??
\&lt;stdbool.h\&gt; Boolean type and values, see C data types    ??
\&lt;stddef.h\&gt;  Standard type definitions, see C data types  ??
\&lt;stdint.h\&gt;  Integer types, see C data types  ??
\&lt;stdio.h\&gt;   Standard buffered input/output, see C file input/output  ??
\&lt;stdlib.h\&gt;  Standard library definitions, see C standard library     ??
\&lt;string.h\&gt;  Several String Operations, see C string handling     ??
\&lt;strings.h\&gt; Case-insensitive string comparisons Issue 4
\&lt;stropts.h\&gt; Stream manipulation, including ioctl    Issue 4
\&lt;sys/ipc.h\&gt; Inter-process communication (IPC)   Issue 2
\&lt;sys/mman.h\&gt;    Memory management, including POSIX shared memory and memory mapped files    Issue 4
\&lt;sys/msg.h\&gt; POSIX message queues    Issue 2
\&lt;sys/resource.h\&gt;    Resource usage, priorities, and limiting    Issue 4
\&lt;sys/select.h\&gt;  Synchronous I/O multiplexing    Issue 6
\&lt;sys/sem.h\&gt; XSI (SysV style) semaphores Issue 2
\&lt;sys/shm.h\&gt; XSI (SysV style) shared memory  Issue 2
\&lt;sys/socket.h\&gt;  Main Berkley sockets header Issue 6
\&lt;sys/stat.h\&gt;    File information (stat et al.)  Issue 1
\&lt;sys/statvfs.h\&gt; File System information Issue 4
\&lt;sys/time.h\&gt;    Time and date functions and structures  Issue 4
\&lt;sys/times.h\&gt;   File access and modification times  Issue 1
\&lt;sys/types.h\&gt;   Various data types used elsewhere   Issue 1
\&lt;sys/uio.h\&gt; Vectored I/O operations Issue 4
\&lt;sys/un.h\&gt;  Unix domain sockets Issue 6
\&lt;sys/utsname.h\&gt; Operating system information, including uname   Issue 1
\&lt;sys/wait.h\&gt;    Status of terminated child processes (see wait) Issue 3
\&lt;syslog.h\&gt;  System error logging    Issue 4
\&lt;tar.h\&gt; Magic numbers for the tar archive format    Issue 3
\&lt;termios.h\&gt; Allows terminal I/O interfaces  Issue 3
\&lt;tgmath.h\&gt;  Type-Generic Macros, see C mathematical functions    ??
\&lt;time.h\&gt;    Type-Generic Macros, see C date and time functions   ??
\&lt;trace.h\&gt;   Tracing of runtime behavior (DEPRECATED)    Issue 6
\&lt;ulimit.h\&gt;  Resource limiting (DEPRECATED in favor of \&lt;sys/resource.h\&gt;) Issue 1
\&lt;unistd.h\&gt;  Various essential POSIX functions and constants Issue 1
\&lt;utime.h\&gt;   inode access and modification times Issue 3
\&lt;utmpx.h\&gt;   User accounting database functions  Issue 4
\&lt;wchar.h\&gt;   Wide-Character Handling, see C string handling   ??
\&lt;wctype.h\&gt;  Wide-Character Classification and Mapping Utilities, see C character classification  ??
\&lt;wordexp.h\&gt; Word-expansion like the shell would perform
</code></pre><p><strong>本篇完</strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入JVM系列 7 - 类的加载]]></title>
      <url>/2018/11/29/JVMLoadLink/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><a href="https://tocreate.app/2018/09/05/jvm/" target="_blank" rel="external">本文为深入JVM系列的一部分</a></p>
<p><a href="https://tocreate.app/2018/11/29/JVMClassStatic/" target="_blank" rel="external">可能需要阅读前文</a></p>
<p><strong>之前解析Class文件的内容没怎么用心看（虽然都是些零碎的定义就是了），这次顺便补充一下</strong></p>
<p><br></p>
<h3 id="类的状态"><a href="#类的状态" class="headerlink" title="类的状态"></a>类的状态</h3><p><br></p>
<h4 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h4><ul>
<li>加载</li>
</ul>
<ul>
<li>链接（验证，准备，解析）</li>
</ul>
<ul>
<li>初始化</li>
</ul>
<ul>
<li>使用</li>
</ul>
<ul>
<li>卸载</li>
</ul>
<ul>
<li>这些生命周期不是完全分离的，如验证往往就和加载交叉进行</li>
</ul>
<p><br></p>
<h4 id="hotspot-类内部状态"><a href="#hotspot-类内部状态" class="headerlink" title="hotspot 类内部状态"></a>hotspot 类内部状态</h4><ul>
<li>未解析</li>
</ul>
<ul>
<li>已分配</li>
</ul>
<ul>
<li>已加载</li>
</ul>
<ul>
<li>已链接</li>
</ul>
<ul>
<li>初始化中</li>
</ul>
<ul>
<li>完成初始化</li>
</ul>
<ul>
<li>初始化出错</li>
</ul>
<p><br></p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p><br></p>
<h4 id="加载-1"><a href="#加载-1" class="headerlink" title="加载"></a>加载</h4><ul>
<li>加载过程通过类的全限定名来获取类的二进制流字节流，将字节流的静态存储结构转换为方法区的运行时数据结构</li>
</ul>
<ul>
<li>非数组类由类加载器加载，数组类由虚拟机直接创建，在内存中生成一个java.lang.class对象作为类数据的访问入口，java规范没有规定该对象存于何处，对于 hotspot，早期存在永久代，7及以后存在堆中</li>
</ul>
<p><br></p>
<h4 id="ClassFileParser"><a href="#ClassFileParser" class="headerlink" title="ClassFileParser"></a>ClassFileParser</h4><ul>
<li>在hotspot中加载过程由Classloader，ClassFileStream，ClassFileParser共同完成，这里的Classloader就是BootStrap ClassLoader的主要实现，主要逻辑在ClassLoader::load_classfile函数中，Classloader的主要职责是根据符号引用来构造ClassFileStream并将其传递给ClassFileParser去处理</li>
</ul>
<pre><code>// Load individual .class file
static instanceKlassHandle load_classfile(Symbol* h_name, TRAPS);
</code></pre><ul>
<li>本质上ClassFileStream只是个bytes数组，Classloader根据路径获取class文件并读取成ClassFileStream</li>
</ul>
<pre><code>ClassFileStream* ClassPathDirEntry::open_stream(const char* name, TRAPS) {
  // construct full path name
  char path[JVM_MAXPATHLEN];
  if (jio_snprintf(path, sizeof(path), &quot;%s%s%s&quot;, _dir, os::file_separator(), name) == -1) {
    return NULL;
  }
</code></pre><ul>
<li>ClassFileParser的ClassFileStream 的处理过程主要在parseClassFile函数当中，在读取数据的同时进行校验，最终创建klass对象和java mirror对象，下面只列出大致流程，校验的代码略去</li>
</ul>
<ul>
<li>校验魔数即CAFEBABE</li>
</ul>
<pre><code>// Version numbers
 u2 minor_version = cfs-&gt;get_u2_fast();
 u2 major_version = cfs-&gt;get_u2_fast();

 // Check version numbers - we check this even with verifier off
 if (!is_supported_version(major_version, minor_version)) 
</code></pre><ul>
<li>校验版本号</li>
</ul>
<pre><code>_major_version = major_version;
 _minor_version = minor_version;
</code></pre><ul>
<li>设置 accessflag</li>
</ul>
<pre><code>AccessFlags access_flags;
 jint flags = cfs-&gt;get_u2_fast() &amp; JVM_RECOGNIZED_CLASS_MODIFIERS;

 if ((flags &amp; JVM_ACC_INTERFACE) &amp;&amp; _major_version &lt; JAVA_6_VERSION) {
   // Set abstract bit for old class files for backward compatibility
   flags |= JVM_ACC_ABSTRACT;
 }

 verify_legal_class_modifiers(flags, CHECK_(nullHandle));
 access_flags.set_flags(flags);
</code></pre><ul>
<li>读取该类及其父类索引和句柄</li>
</ul>
<pre><code>instanceKlassHandle super_klass;
 u2 this_class_index = cfs-&gt;get_u2_fast();
 check_property(
   valid_cp_range(this_class_index, cp_size) &amp;&amp;
     cp-&gt;tag_at(this_class_index).is_unresolved_klass(),
   &quot;Invalid this class index %u in constant pool in class file %s&quot;,
   this_class_index, CHECK_(nullHandle));

 Symbol*  class_name  = cp-&gt;unresolved_klass_at(this_class_index);
 assert(class_name != NULL, &quot;class_name can&apos;t be null&quot;);
</code></pre><ul>
<li>读取接口包括本类的接口和父类传递的接口</li>
</ul>
<pre><code>local_interfaces = parse_interfaces(cp, itfs_len, class_loader, protection_domain, _class_name, CHECK_(nullHandle));
</code></pre><ul>
<li>读取字段，会计算域的大小，偏移和按分配策略进行分配</li>
</ul>
<pre><code>typeArrayHandle fields = parse_fields(class_name, cp, access_flags.is_interface(), &amp;fac, &amp;fields_annotations,
                                      &amp;java_fields_count,
                                      CHECK_(nullHandle));
</code></pre><ul>
<li>读取方法</li>
</ul>
<pre><code>// These need to be oop pointers because they are allocated lazily
// inside parse_methods inside a nested HandleMark
objArrayOop methods_annotations_oop = NULL;
objArrayOop methods_parameter_annotations_oop = NULL;
objArrayOop methods_default_annotations_oop = NULL;
objArrayHandle methods = parse_methods(class_loader, cp,
                                       access_flags.is_interface(),
                                       &amp;promoted_flags,
                                       &amp;has_final_method,
                                       &amp;methods_annotations_oop,
                                       &amp;methods_parameter_annotations_oop,
                                       &amp;methods_default_annotations_oop,
                                       CHECK_(nullHandle));
</code></pre><ul>
<li>根据上面的信息创建klass对象，这样类元信息就存放到方法区了</li>
</ul>
<pre><code>// We can now create the basic klassOop for this klass
klassOop ik = oopFactory::new_instanceKlass(name, vtable_size, itable_size,
                                            static_field_size,
                                            total_oop_map_count,
                                            access_flags,
                                            rt, host_klass,
                                            CHECK_(nullHandle));
instanceKlassHandle this_klass (THREAD, ik);
</code></pre><ul>
<li>最后创建 java mirror</li>
</ul>
<pre><code>// Allocate mirror and initialize static fields
java_lang_Class::create_mirror(this_klass, class_loader, CHECK_(nullHandle));
</code></pre><p><br></p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><br></p>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><ul>
<li>由于规范中没有限制class文件需要如何产生，因此jvm需验证以避免有害的字节流，不符合规范的class文件在验证阶段将抛出 java.lang.VerifyError</li>
</ul>
<ul>
<li>验证过程主要包括，文件格式验证（在加载时进行），类的元数据信息验证，字节码的语义验证，符号引用合法性验证</li>
</ul>
<p><br></p>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><ul>
<li>准备主要指为静态变量分配内存并设置其初始值，一般来说分配在堆中（hotspot最终分配在堆中，详见上一篇），初始值一般则为零值，而不是在声明时定义的值（如static int i = 123），除非字段属性表中存在 ConstantValue 属性（如 final 常量），则会将其初始化为 ConstantValue 定义的值</li>
</ul>
<p><br></p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><ul>
<li>解析主要指将符号引用转换为直接引用</li>
</ul>
<ul>
<li>class 文件使用符号引用进行逻辑上的链接，以字符串形式存在，在class文件中的常量池存放这些符号引用，加载完后class文件的常量池会在jvm内部创建为运行时内存中的常量池，即运行时常量池。符号引用需要被转换为直接引用才可以定位内存实体，这个过程则为解析</li>
</ul>
<p><br></p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul>
<li>初始化值得是执行类或接口的初始化方法，触发初始化的情形如下</li>
</ul>
<pre><code>jvm遇到需要引用类和接口的指令时：new getstatic putstatic invokestatic
初次调用 java.lang.invoke.MethodHandle 实例时，返回结果为 REF_getstatic REF_putStatic或REF_invokeStatic的方法句柄
调用类库中的反射方法时，如class类或java.lang.reflect包
初始化类的子类时
类被设计用作jvm启动的启动类
</code></pre><p><strong>未完待续</strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入操作系统 7 - 中断]]></title>
      <url>/2018/11/29/OSInterrupts/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><a href="https://tocreate.app/2019/03/02/OperatingSystem/" target="_blank" rel="external">本文为深入操作系统系列的一部分</a></p>
<p><a href="https://tocreate.app/2018/11/08/OSGdtCreate/" target="_blank" rel="external">可能需要阅读前文</a></p>
<p><strong>前面制作镜像，库函数，gdt，保护模式都有可执行的代码，中断这部分就没有了，没时间，如果你的操作系统想要支持中断，核心部分在idt，为了实现idt，首先需要gdt，可以看一下前几篇文章</strong></p>
<p><strong>题外话，android系统源码的也差不多开始看了，预计jvm系列完了以后，包括dalvik和art一起看，之前就有找过android虚拟机方面国内像样的书和文章几乎没有，有空找一下有没有好的英文资料，没有就随缘学学了</strong></p>
<p><strong>中断的相关的分类概念基本上是一团乱麻（软中断，硬中断，内中断，外中断，异常，陷入 ..），不同的cpu架构对中断有不同的定义，而不同的操作系统对中断指令的使用和中断处理程序又有不同的实现，个人认为最好的学习方法是，不去划分边界，我只关注x86中断的定义和指令，及linux在基于其上的实现</strong></p>
<p><br></p>
<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p><br></p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul>
<li>所谓中断往往指代的是外中断，即中断源在cpu外部的中断</li>
</ul>
<ul>
<li>外中断是为了让处理器避免使用轮询这种低效的方法与外设协同工作而产生的新机制</li>
</ul>
<ul>
<li>外中断本质上是一种电信号，由设备产生，送入与cpu直接相连的中断控制器，cpu接受到中断控制器传来的信号（携带中断号）后会暂停当前的工作去处理中断，并通知操作系统</li>
</ul>
<ul>
<li>接受到中断之后，处理器会根据中断号在中断向量表(ivt,在intel的保护模式下idt就是它的替代物)上查找需要跳转的中断处理程序</li>
</ul>
<p><br></p>
<h3 id="x86"><a href="#x86" class="headerlink" title="x86"></a>x86</h3><p><strong>x86的中断机制实际上分为外部中断(intr，mni)和异常(INT n，INTO，故障，陷阱，终止)两种</strong></p>
<p><br></p>
<h4 id="中断向量"><a href="#中断向量" class="headerlink" title="中断向量"></a>中断向量</h4><ul>
<li>x86 支持 256 个中断源，每个中断源用唯一的中断向量进行标识（0到255），这里的中断指的是所有的中断类型，包括内中断和外中断</li>
</ul>
<ul>
<li>0-31号中断向量被intel公司保留用来处理异常事件（也就是异常和非屏蔽中断），不能另作它用。对这 0-31，操作系统只需提供异常的处理程序，当产生一个异常时，处理机就会自动把控制转移到相应的处理程序的入口，运行相应的处理程序，不过实际上2.6版本的 Linux只提供了0-17号中断向量的处理程序</li>
</ul>
<ul>
<li>其余的中断向量一般用在外部硬件的中断源上，即后面的INTR中断</li>
</ul>
<p><img src="https://wx1.sinaimg.cn/mw1024/987832a0gy1fxrk04r1btj20k30dzwgy.jpg" alt="intel定义的中断号"></p>
<ul>
<li><a href="https://www.cnblogs.com/wahaha02/p/6341095.html" target="_blank" rel="external">图源</a></li>
</ul>
<p><br></p>
<h4 id="外中断"><a href="#外中断" class="headerlink" title="外中断"></a>外中断</h4><p><br></p>
<h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><ul>
<li>外中断在x86上等同于硬件中断，是产生于cpu外部的中断何谓外部和硬件？ x86 cpu只为外部设备提供两个引脚，分别是 nmi 和 intr，硬件设备的中断信号最终通过这两个引脚进入 cpu，因此对cpu来说外部中断都是异步的</li>
</ul>
<p><img src="https://wx1.sinaimg.cn/mw690/987832a0gy1fxrkbo2hcej20rv0au40e.jpg" alt=""></p>
<ul>
<li><a href="https://blog.csdn.net/jia_guoqiang/article/details/52982496" target="_blank" rel="external">图源</a></li>
</ul>
<p><br></p>
<h5 id="INTR中断"><a href="#INTR中断" class="headerlink" title="INTR中断"></a>INTR中断</h5><ul>
<li>INTR引脚用于产生可屏蔽中断，可屏蔽是指INTR中断可以通过指令屏蔽中断，屏蔽后 cpu 不会响应中断请求</li>
</ul>
<ul>
<li>INTR引脚直接与中断控制器（如PIC或APIC）相连，设备可以通过中断控制器提供的irq引脚（irq lines，中断线）发送中断信号，这是硬件开发者常用请求方式，我们平时说的中断往往指的都是这种中断（当然是在 x86 环境下）</li>
</ul>
<ul>
<li>屏蔽中断的方法由两种：设置cpu的标志寄存器中的IF中断屏蔽位，设置中断控制器的中断屏蔽位（如8259A的IMR寄存器的Di位）</li>
</ul>
<p><br></p>
<h5 id="NMI中断"><a href="#NMI中断" class="headerlink" title="NMI中断"></a>NMI中断</h5><ul>
<li>NMI引脚于产生不可屏蔽中断(Non-maskable        interrupts，不过这种中断也可以不通过该针脚而由cpu内部产生)，它通常被用于关键性硬件发生的错误，如电源掉电和物理存储器奇偶校验错，风扇故障，温度传感器故障等</li>
</ul>
<ul>
<li>NMI中断不与中断控制器相连，一般的设备也用不到NMI中断</li>
</ul>
<p><br></p>
<h5 id="中断控制器"><a href="#中断控制器" class="headerlink" title="中断控制器"></a>中断控制器</h5><ul>
<li>中断控制器就是与INTR引脚直接相连的这部分，前面提到 x86 支持 256 个中断源，而中断控制器是可编程的硬件设备用于集中处理中断信号，并对设备提供中断线来接受 256 个中断源中指定的连续部分，中断控制器系统主要分为 PIC和APIC(IOAPIC LAPIC)两种</li>
</ul>
<ul>
<li>PIC（已过时）, 一般由两片 8259A 芯片级联组成，提供15个中断线（最多级连9个，提供64个中断线），8259A芯片上都有一个8位的中断屏蔽寄存器，每一位对应一条中断线。在对应为上置1则可屏蔽此条中断线, 8259A的优先级分为固定优先级和自动循环优先级，固定优先级为IR0到IR7由高到低，自动循环优先级指刚处理的中断线优先级最低，接下来依次提高</li>
</ul>
<ul>
<li>APIC，PIC是使用在单cpu上的中断控制器，为了中断传递给多个 CPU，产生了APIC，APIC系统包含 LAPIC 和 IOAPIC。LAPIC集成在每个cpu内部，有自己的一系列寄存器、一个内部时钟、一个本地定时设备和两条 IRQ 线（LINT0 和 LINT1），IOAPIC一般位于南桥，像 PIC 一样连接各个设备，提供有 24 个中断线。APIC的优先级体现在LAPIC内部，但IOAPIC不设优先级，每条中断线平等对待</li>
</ul>
<p><br></p>
<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><ul>
<li>异常可以分类为故障(Fault)、陷阱(Trap)和中止(Abort)，异常产生的原因包括非法操作码，地址越界，算术溢出，虚存系统的缺页，陷入指令等等</li>
</ul>
<ul>
<li>故障（fault）是由错误条件引起的，保存的EIP指向触发异常的那条指令，处理程序把故障排除后，执行IRET返回到引起故障的程序继续执行时，引起故障的指令可重新得到执行，如果不能处理，则转换为终止</li>
</ul>
<ul>
<li>陷入（trap）是有意识安排的，保存的EIP指向触发异常的那条指令的下一条指令，指令不会重新执行</li>
</ul>
<ul>
<li>终止（Abort）是由严重错误引起的，通常只有强制结束造成Abort的程序</li>
</ul>
<ul>
<li>软中断也是异常的一种（准确地说属于陷入），也叫可编程异常，是由指令引起的中断，x86可以引起中断的指令有 int n（软件中断）int 3（断点）Into（检查溢出）bound（检查数组越界），arm上也有swi这样的软中断指令，int 80h 指令的使用是linux系统在调用在x86的唯一实现，它使系统从用户态进入内核态（另一种意义上的陷入），另外，intel将32到255的中断定义为INTR中断或 int n指令引起的中断，但没有再具体细分</li>
</ul>
<ul>
<li>注意linux应用中中断处理程序的一种实现方式也叫软件中断（另一种方式叫tasklet），它只是linux提供给开发者的接口，属于上层的业务，碰巧起了这个名字，不过也不能说完全错误</li>
</ul>
<ul>
<li>一般来说异常的优先级是最高的，可以粗略地定义为 异常>nmi中断>intr中断</li>
</ul>
<pre><code>调试故障    
其它故障    
陷阱指令INT n和INTO    
调试陷阱    
NMI中断 
INTR中断  
</code></pre><p><br></p>
<h4 id="ivt-amp-idt"><a href="#ivt-amp-idt" class="headerlink" title="ivt &amp; idt"></a>ivt &amp; idt</h4><ul>
<li>实模式下中断处理程序入口为的数据结构ivt（中断向量表），保护模式下中断处理程序入口的数据结构为idt（中断描述符表）</li>
</ul>
<ul>
<li>ivt：CPU 加电以后会访问0xFFFFFFF0处的第一条地址，最终会访问到ROM，此时ROM将BIOS装入系统，BIOS的初始化过程中IVT也会被初始化，当和前面系列提到的一样，这些初始化过程能做的十分有限，BIOS只是将IVT的入口地址设置为 0（此处与arm一致，这个非常特殊的地址导致了很多旧的设计上中断号和中断向量直接等同），大小则为0x00000到0x003ff（1KB，共 256 个中断），而这个表中的中断处理程序地址全都指向一条iret指令，也就是说IVT是空的，操作系统可以选择使用lidt指令设置基址，简单使用 mov 填充ivt表</li>
</ul>
<p><br></p>
<h3 id="中断应用"><a href="#中断应用" class="headerlink" title="中断应用"></a>中断应用</h3><p><br></p>
<h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><ul>
<li>操作系统往往使用软中断来实现系统调用，详见下一篇<a href="https://tocreate.app/2018/12/02/OSSysCall/" target="_blank" rel="external">文章</a></li>
</ul>
<p><br></p>
<h4 id="进程中断"><a href="#进程中断" class="headerlink" title="进程中断"></a>进程中断</h4><ul>
<li>这部分内容涉及进程以及定时器，关于进程中断的部分内容详见下下篇<a href="https://tocreate.app/2018/12/02/OSProcess/" target="_blank" rel="external">文章</a>，关于定时器的内容以后再补充</li>
</ul>
<p><br></p>
<h3 id="中断处理过程"><a href="#中断处理过程" class="headerlink" title="中断处理过程"></a>中断处理过程</h3><p><br></p>
<h3 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h3><p><br></p>
<h4 id="中断请求"><a href="#中断请求" class="headerlink" title="中断请求"></a>中断请求</h4><p><br></p>
<h4 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h4><p><br></p>
<h5 id="前半部"><a href="#前半部" class="headerlink" title="前半部"></a>前半部</h5><p><br></p>
<h5 id="后半部"><a href="#后半部" class="headerlink" title="后半部"></a>后半部</h5>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入JVM系列 6 - Class对象与静态变量的存储]]></title>
      <url>/2018/11/29/JVMClassStatic/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><a href="https://tocreate.app/2018/09/05/jvm/" target="_blank" rel="external">本文为深入JVM系列的一部分</a></p>
<p><a href="https://tocreate.app/2018/11/26/JVMObjectMemo/" target="_blank" rel="external">可能需要阅读前文</a></p>
<p><strong>这部分太长了，和上篇拆开来</strong></p>
<p><br></p>
<h3 id="反射-amp-mirror"><a href="#反射-amp-mirror" class="headerlink" title="反射 &amp; mirror"></a>反射 &amp; mirror</h3><ul>
<li>R大在这篇<a href="http://rednaxelafx.iteye.com/blog/730461" target="_blank" rel="external">文章</a>和这篇<a href="http://rednaxelafx.iteye.com/blog/1847971" target="_blank" rel="external">文章</a>里提到了mirror,原话差不多是这样,HotSpot并不把instanceKlass暴露给Java，而会另外创建对应的java.lang.Class对象，将instanceKlass包装了一层来暴露给Java层使用，并将后者称为前者的镜像，InstanceKlass和java_mirror互相持有，obj.getClass()，在HotSpot VM里实际上经过了两层间接引用才能找到最终的Class对象，反射最终调用的jni方法也会通过as_klass函数将java_mirror转换为instanceKlass</li>
</ul>
<pre><code>obj-\&gt;\_klass-\&gt;\_java\_mirror  
</code></pre><ul>
<li>关于 mirror ，我现在也只了解了一些表面的东西，这篇<a href="chrome-extension://oemmndcbldboiebfnladdacbdfmadadm/http://bracha.org/mirrors.pdf" target="_blank" rel="external">论文</a>专门描述了这种设计，不过看得我云里雾里的</li>
</ul>
<ul>
<li>传统的反射实现中，class的实现横跨了基本层面和元数据层面，但使用镜像模式设计的class，每次从基本层面访问元数据层面都是一次反射调用，很清楚地隔离了边界，可以屏蔽一些实现细节（运行期从本地或远程获取元数据，甚至使用多种不同的实现来获取元数据，诸如此类的特性），其他还有一些涉及可移植性的优点实在是没搞明白</li>
</ul>
<p><img src="http://wx4.sinaimg.cn/mw690/987832a0gy1fxo6ctblqvj21980bkwgi.jpg" alt=""></p>
<p><br></p>
<h3 id="java-mirror"><a href="#java-mirror" class="headerlink" title="java mirror"></a>java mirror</h3><p><br></p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul>
<li>java mirror 是class的实现，这个指的是java mirror java.lang.Class 在 native 层的对等实体，再准确的说，java mirror的类型是 instanceMirrorKlass，它是 Klass 类的属性，自然也被子类继承</li>
</ul>
<pre><code>// An instanceMirrorKlass is a specialized instanceKlass for
// java.lang.Class instances.  These instances are special because
// they contain the static fields of the class in addition to the
// normal fields of Class.  This means they are variable sized
// instances and need special logic for computing their size and for
// iteration of their oops.

class instanceMirrorKlass: public instanceKlass {

//...

}

class Klass : public Klass\_vtbl {

//...

// java/lang/Class instance mirroring this class
  oop       \_java\_mirror;
}
</code></pre><ul>
<li>instanceMirrorKlass很容易和hotspot中的java_lang_Class类搞混,实际上后者只提供了一些java层的java.lang.Class类的访问接口，在设置或查询信息时用到</li>
</ul>
<pre><code>// Interface to java.lang.Class objects

class java\_lang\_Class : AllStatic {
</code></pre><p><br></p>
<h4 id="对应"><a href="#对应" class="headerlink" title="对应"></a>对应</h4><ul>
<li>当然这里指定的是hotspot中的实现，从java语言层面上来说是否使用mirror都是底层技术细节，不是规范里的内容，只是class类的一种实现而已，现在我们来验证一下java mirror是怎么对应到class类的</li>
</ul>
<ul>
<li>既然是反射相关，那么当然从反射入手，关于反射我这里强推一篇<a href="https://www.jianshu.com/p/b6cb4c694951" target="_blank" rel="external">文章</a>，以反射为例将 klass opp 模型讲得很具体了(物理)，这里我就直接切入到后面了，我们平时调用的 getDeclaredMethod 会调用到 Reflection::new_method 函数,它会创建一个java.lang.reflect.Method对象</li>
</ul>
<pre><code>// Create a java.lang.reflect.Method object based on a method
 static oop new\_method(methodHandle method, bool intern\_name, bool for\_constant\_pool\_access, TRAPS);
</code></pre><ul>
<li>而在创建的过程中会调用 set_parameter_types 函数返回设置parameterTypes属性，它则调用get_parameter_types获取objArrayHandle对象，如果参数声明是类，那么它内部包含了java mirror</li>
</ul>
<pre><code>objArrayHandle Reflection::get\_parameter\_types(methodHandle method, int parameter\_count, oop\* return\_type, TRAPS) {
//...
 while (!ss.at\_return\_type()) {
    oop mirror = get_mirror_from_signature(method, &amp;ss, CHECK_(objArrayHandle()));
    mirrors-&gt;obj_at_put(index++, mirror);
    ss.next();
  }
//...
}

oop get\_mirror\_from\_signature(methodHandle method, SignatureStream\* ss, TRAPS) {
//...

    case T_OBJECT:
    case T_ARRAY:
//..
      klassOop k = SystemDictionary::resolve_or_fail(
                                       name,
                                       Handle(THREAD, loader),
                                       Handle(THREAD, protection_domain),
                                       true, CHECK_NULL);

      return k-&gt;java_mirror();
  };
</code></pre><ul>
<li>至于Method对象的创建就是上文说过的内容，略过，我们回到java层，在Method中的parameterType正是Class类型，returnType同理，也是靠get_mirror_from_signature，不过上文的代码省略掉了</li>
</ul>
<pre><code>public final class Method extends Executable {
    private Class&lt;?&gt;            clazz;
    private int                 slot;
    // This is guaranteed to be interned by the VM in the 1.4
    // reflection implementation
    private String              name;
    private Class&lt;?&gt;            returnType;
    private Class&lt;?&gt;[]          parameterTypes;
    private Class&lt;?&gt;[]          exceptionTypes;
    private int                 modifiers;
</code></pre><p><br></p>
<h3 id="静态字段的内存分配"><a href="#静态字段的内存分配" class="headerlink" title="静态字段的内存分配"></a>静态字段的内存分配</h3><p><br></p>
<h4 id="jdk-6"><a href="#jdk-6" class="headerlink" title="jdk 6"></a>jdk 6</h4><ul>
<li>hotspot 6 当中的 klass 不管是普通的 instanceklass 还是其子类 instanceMirrorklass(java mirror，java.lang.class)、instanceRefKlass(softRefenrence,weakRefenrence..) 都存放在 PermGen(对应概念上的方法区)中, 而静态变量存放在instanceklass的末尾</li>
</ul>
<pre><code>//src/share/vm/oops/klass.cpp 
klassOop Klass::base\_create\_klass\_oop(KlassHandle&amp; klass, int size,
                                      const Klass_vtbl&amp; vtbl, TRAPS) {
  size = align\_object\_size(size);
// allocate and initialize vtable
// 在PermGen中分配
  Klass\*   kl = (Klass\*) vtbl.allocate\_permanent(klass, size, CHECK\_NULL);
  klassOop k  = kl-\&gt;as\_klassOop();
</code></pre><ul>
<li>jdk 6 中 instanceKlass 内存布局如下，末尾为 static 变量</li>
</ul>
<pre><code>//  instanceKlass layout:
//    [header                     ] klassOop
//    [klass pointer              ] klassOop
//    [C++ vtbl pointer           ] Klass
//    [subtype cache              ] Klass
//    [instance size              ] Klass
//    [java mirror                ] Klass
//    [super                      ] Klass
//    [access\_flags               ] Klass
//    [name                       ] Klass
//    [first subklass             ] Klass
//    [next sibling               ] Klass
//    [array klasses              ]
//    [methods                    ]
//    [local interfaces           ]
//    [transitive interfaces      ]
//    [number of implementors     ]
//    [implementors               ] klassOop[2][7]
//    [fields                     ]
//    [constants                  ]
//    [class loader               ]
//    [protection domain          ]
//    [signers                    ]
//    [source file name           ]
//    [inner classes              ]
//    [static field size          ]
//    [nonstatic field size       ]
//    [static oop fields size     ]
//    [nonstatic oop maps size    ]
//    [has finalize method        ]
//    [deoptimization mark bit    ]
//    [initialization state       ]
//    [initializing thread        ]
//    [Java vtable length         ]
//    [oop map cache (stack maps) ]
//    [EMBEDDED Java vtable             ] size in words = vtable\_len
//    [EMBEDDED static oop fields       ] size in words = static\_oop\_fields\_size
//    [         static non-oop fields   ] size in words = static\_field\_size - static\_oop\_fields\_size
//    [EMBEDDED nonstatic oop-map blocks] size in words = nonstatic\_oop\_map\_size
</code></pre><p><br></p>
<h4 id="jdk-7"><a href="#jdk-7" class="headerlink" title="jdk 7"></a>jdk 7</h4><ul>
<li>hotspot 7 中 java_mirror 的实例在堆中创建，静态变量存放在 java_mirror 当中，初始化静态变量时，核心都是调用xxx field_put函数，将变量存放在指定偏移量处</li>
</ul>
<ul>
<li>静态变量迁移到 java_mirror当中的原因是为了移除永久区做准备，具体可以看 oracle 的 <a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=7017732" target="_blank" rel="external">issue</a></li>
</ul>
<pre><code>//初始化静态变量
//src/share/vm/classfile/javaClasses.cpp
static void initialize\_static\_field(fieldDescriptor\* fd, TRAPS) {
  Handle mirror (THREAD, fd-\&gt;field\_holder()-\&gt;java\_mirror());
//...
    switch (t) {
      case T_BYTE:
        mirror()-&gt;byte_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
              break;
      case T_BOOLEAN:
        mirror()-&gt;bool_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
              break;
      case T_CHAR:
        mirror()-&gt;char_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
              break;
      case T_SHORT:
        mirror()-&gt;short_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
              break;
      case T_INT:
        mirror()-&gt;int_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
        break;
      case T_FLOAT:
        mirror()-&gt;float_field_put(fd-&gt;offset(), fd-&gt;float_initial_value());
        break;
      case T_DOUBLE:
        mirror()-&gt;double_field_put(fd-&gt;offset(), fd-&gt;double_initial_value());
        break;
      case T_LONG:
        mirror()-&gt;long_field_put(fd-&gt;offset(), fd-&gt;long_initial_value());
        break;
      case T_OBJECT:
        {
          oop string = fd-&gt;string_initial_value(CHECK);
          mirror()-&gt;obj_field_put(fd-&gt;offset(), string);
        }
        break;
      default:
    }
  }
}
</code></pre><ul>
<li>instanceMirrorKlass 的创建如下，JavaObjectsInPerm 写死是 false，common_mem_allocate_init 上一篇分析过了，在堆中分配内存</li>
</ul>
<pre><code>//创建java\_mirror，调用过程由上到下
/java\_lang\_Class::create\_mirror
//instanceMirrorKlass::allocate\_instance
//CollectedHeap::Class\_obj\_allocate

oop CollectedHeap::Class\_obj\_allocate(KlassHandle klass, int size, KlassHandle real\_klass, TRAPS) {
  HeapWord\* obj;
//默认为false
  if (JavaObjectsInPerm) {
    obj = common_permanent_mem_allocate_init(size, CHECK_NULL);
  } else {
    assert(ScavengeRootsInCode &gt; 0, &quot;must be&quot;);
    obj = common_mem_allocate_init(real_klass, size, CHECK_NULL);
  }
</code></pre><p><br></p>
<h4 id="Jdk-8"><a href="#Jdk-8" class="headerlink" title="Jdk 8"></a>Jdk 8</h4><ul>
<li>hotspot 8 移除了 PermGen，而使用 MetaSpace(元空间，不受堆管理器管理)，但是 java_mirror 并不受影响，依然放在堆当中</li>
</ul>
<ul>
<li>静态变量大体上保留 7 中的做法，还在java_mirror当中，只是java_mirror的创建不再判断JavaObjectsInPerm了，直接调用common_mem_allocate_init，而klass则放在元空间当中，这里不再赘述</li>
</ul>
<p><strong>本篇完</strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入JVM系列 5 - 对象内存布局与分配]]></title>
      <url>/2018/11/26/JVMObjectMemo/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><a href="https://tocreate.app/2018/09/05/jvm/" target="_blank" rel="external">本文为深入JVM系列的一部分</a></p>
<p><a href="https://tocreate.app/2018/10/19/JVMClassFile/" target="_blank" rel="external">可能需要阅读前文</a></p>
<p><strong>最近备考一些垃圾课没怎么复习，现在考完3科，正式开始复习了</strong></p>
<p><br></p>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p><strong>hotSpot中对象可以分为对象头，实例数据和对齐填充三部分</strong></p>
<p><br></p>
<h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><ul>
<li>对象头在上一篇写过了，它分为mark word 和 元数据指针（klassInstance指针），不再复述</li>
</ul>
<pre><code>//in hotspot/src/share/vm/oops/oop.hpp
class oopDesc {
  friend class VMStructs;
 private:
  volatile markOop  _mark;
  union _metadata {
    wideKlassOop    _klass;
    narrowOop       _compressed_klass;
  } _metadata;
</code></pre><p><br></p>
<h4 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h4><ul>
<li>实例数据包括通过继承或自身定义得到的所有字段(成员变量)，不包括类变量（静态变量）</li>
</ul>
<ul>
<li>字段的存储顺序受定义顺序和虚拟机策略共同影响，默认规则如下</li>
</ul>
<pre><code>顺序为 longs/doubles，ints，shorts/chars，bytes/booleans，OOPS
父类定义的变量可能出现在子类之前
子类较窄的变量可能插入到父类变量的空隙之中
</code></pre><p><br></p>
<h4 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h4><ul>
<li>对象大小必须是8字节的整数倍</li>
</ul>
<p><br></p>
<h3 id="对象的创建流程"><a href="#对象的创建流程" class="headerlink" title="对象的创建流程"></a>对象的创建流程</h3><ul>
<li>new 关键字的实现为InterpreterRuntime::_new，主要分为三部</li>
</ul>
<ul>
<li>解析类获得instanceKlass，它是java类在jvm的对等实体，如果已被解析过则直接返回查找到的instanceKlass，否则加载类，生成对应的instanceKlass对象并更新符号引用</li>
</ul>
<ul>
<li>初始化instanceKlass，这个过程需要加锁并且会初始化父类和接口，初始化时就会完成成员布局的初始化也就是实现上文提到的几个规则（具体可以阅读<a href="https://blog.csdn.net/sky1young/article/details/27063821" target="_blank" rel="external">这篇文章</a>）</li>
</ul>
<ul>
<li>创建对象，检查是否设置Finalizer函数，获取对象所需空间的大小，调用CollectedHeap的obj_allocate()创建一个instanceOop(堆上对象实例)，并根据情况注册Finalizer函数</li>
</ul>
<pre><code>IRT_ENTRY(void, InterpreterRuntime::_new(JavaThread* thread, constantPoolOopDesc* pool, int index))

//解析
  klassOop k_oop = pool-&gt;klass_at(index, CHECK);
  instanceKlassHandle klass (THREAD, k_oop);

//检查是否为抽象类
  klass-&gt;check_valid_for_instantiation(true, CHECK);

//初始化klass
  klass-&gt;initialize(CHECK);

  oop obj = klass-&gt;allocate_instance(CHECK);
  thread-&gt;set_vm_result(obj);
IRT_END

instanceOop instanceKlass::allocate_instance(TRAPS) {
  assert(!oop_is_instanceMirror(), &quot;wrong allocation path&quot;);
  bool has_finalizer_flag = has_finalizer(); // Query before possible GC
  int size = size_helper();  // Query before forming handle.

  KlassHandle h_k(THREAD, as_klassOop());

  instanceOop i;
//创建对象
  i = (instanceOop)CollectedHeap::obj_allocate(h_k, size, CHECK_NULL);
  if (has_finalizer_flag &amp;&amp; !RegisterFinalizersAtInit) {
    i = register_finalizer(i, CHECK_NULL);
  }
  return i;
}
</code></pre><p><br></p>
<h3 id="对象内存空间分配"><a href="#对象内存空间分配" class="headerlink" title="对象内存空间分配"></a>对象内存空间分配</h3><p><br></p>
<h4 id="tlab分配"><a href="#tlab分配" class="headerlink" title="tlab分配"></a>tlab分配</h4><ul>
<li>hotspot 1.6 引入了 tlab（ThreadLocalAllocBuffer）</li>
</ul>
<ul>
<li>tlab 是从 eden 区划分出来的内存空间，是提供给线程的专用的内存分配区域，tlab 与 线程有一对一的关系，每个线程使用自己的tlab 分配对象空间，避免同步的消耗</li>
</ul>
<ul>
<li>tlab 默认开启，可以使用 XX:+UseTLAB 参数进行设置，如果开启了tlab，vm 就会尝试在 tlab 上创建对象，tlab上创建失败才在 eden 的普通区域中创建对象</li>
</ul>
<pre><code>//下面这个函数会被上文中的 CollectedHeap::obj\_allocate 函数调用
//in hotspot/src/share/vm/gc_interface/collectedHeap.inline.hpp
//in common_mem_allocate_noinit()

 if (UseTLAB) {
    result = allocate_from_tlab(klass, THREAD, size);
    if (result != NULL) {
      assert(!HAS_PENDING_EXCEPTION,
             &quot;Unexpected exception, will result in uninitialized storage&quot;);
      return result;
    }
  }
  bool gc_overhead_limit_was_exceeded = false;
  result = Universe::heap()-&gt;mem_allocate(size,
                                          &amp;gc_overhead_limit_was_exceeded);
</code></pre><ul>
<li>tlab 只涉及对象的分配，整个eden区上的对象依然允许多个线程访问的，tlab本质上只是指向eden某区域的三个指针，start，top 和 end，使用指针碰撞规则进行管理，即 top + new_obj_size >= end时重新分配内存，根据新开辟的裸空间重新设置指针</li>
</ul>
<pre><code> HeapWord* _start;                               //起始地址
  HeapWord* _top;                                //当前地址
  HeapWord* _pf_top;                             // allocation prefetch watermark
  HeapWord* _end;                                //结束地址
  size_t    _desired_size;                       //tlab大小
  size_t    _refill_waste_limit;                 //最大浪费空间
//如果某次请求时空间不足分配，如果剩余空间如果大于改值
//则不会重新申请tlab，而是使用慢分配
</code></pre><ul>
<li>当 tlab 重新分配时原有已使用的空间只是归还给了 CollectedHeap管理，而未使用的空间则会被设置为一个 filler object 而浪费掉</li>
</ul>
<pre><code>filler object对堆管理器来说是一个假对象，这样做是为了让堆可以线性扫描，即将堆作为一个个连续的对象，只要通过对象头记录的对象大小就可以访问下一个对象
如果没有filler object，则由于未使用的部分不是对象，堆管理器为了实现线性访问需要额外记录这些空洞，但这样做的缺点是filler object本质上无谓地占用了堆内存，这些空间只能等待gc回收
</code></pre><p><br></p>
<h4 id="慢速分配"><a href="#慢速分配" class="headerlink" title="慢速分配"></a>慢速分配</h4><ul>
<li>有的人称其为堆分配，实际上tlab也在堆上，称之为慢速分配更加合适，毕竟相对的tlab只在申请时才加锁，算是快了。从哪里开始算慢速分配这点也需要说下，有人觉得 InterpreterRuntime::_new，就是慢速分配，还有人觉得只要用cas无锁分配也算快速分配。上文提到 InterpreterRuntime::_new 也会先尝试在tlab上分配，然后尝试cas无锁分配，这就很矛盾，所以个人认为上文的 common_mem_allocate_noinit 用来划分最合适，要么调用 allocate_from_tlab，要么调用 mem_allocate(由堆实现)，前者代表快速分配后者代表慢速分配，当然并不是所有情况都会走这个函数，只是将tlab称为快速分配，其余的都划分为慢速分配会更加清晰，mem_allocate 核心在于 GenCollectorPolicy::mem_allocate_work，主要流程如下</li>
</ul>
<ul>
<li>创建对象会开启循环重试，要么分配成功要么分配失败抛出异常</li>
</ul>
<pre><code>for (int try_count = 1, gclocker_stalled_count = 0; /* return or throw */; try_count += 1) {
</code></pre><ul>
<li>第一次分配使用 cas，对象优先在eden区分配，但大对象略过这一步，直接在老年代分配</li>
</ul>
<pre><code>// First allocation attempt is lock-free.
Generation *gen0 = gch-&gt;get_gen(0);
assert(gen0-&gt;supports_inline_contig_alloc(),
  &quot;Otherwise, must do alloc within heap lock&quot;);
if (gen0-&gt;should_allocate(size, is_tlab)) {
  result = gen0-&gt;par_allocate(size, is_tlab);
  if (result != NULL) {
    assert(gch-&gt;is_in_reserved(result), &quot;result not in heap&quot;);
    return result;
  }
}
</code></pre><ul>
<li>如果无锁分配失败，则在新生代或老年代使用堆的互斥锁进行加锁分配，其中只有大对象才会在老年代分配</li>
</ul>
<pre><code>unsigned int gc_count_before;  // read inside the Heap_lock locked region
{
  MutexLocker ml(Heap_lock);
  if (PrintGC &amp;&amp; Verbose) {
    gclog_or_tty-&gt;print_cr(&quot;TwoGenerationCollectorPolicy::mem_allocate_work:&quot;
                  &quot; attempting locked slow path allocation&quot;);
  }
  // Note that only large objects get a shot at being
  // allocated in later generations.
  bool first_only = ! should_try_older_generation_allocation(size);

  result = gch-&gt;attempt_allocation(size, is_tlab, first_only);
  if (result != NULL) {
    assert(gch-&gt;is_in_reserved(result), &quot;result not in heap&quot;);
    return result;
  }
</code></pre><ul>
<li>分配失败,如果这个时候 gc 已经被其他线程触发，但仍未执行，那么尝试扩展堆空间并再次尝试</li>
</ul>
<pre><code>if (GC_locker::is_active_and_needs_gc()) {
   if (is_tlab) {
     return NULL;  // Caller will retry allocating individual object
   }
   if (!gch-&gt;is_maximal_no_gc()) {
     // Try and expand heap to satisfy request
     result = expand_heap_and_allocate(size, is_tlab);
     // result could be null if we are out of space
     if (result != NULL) {
       return result;
     }
   }
</code></pre><ul>
<li>如果没有空间可以扩展，那么只能gc了，这个时候释放堆的互斥锁，让被触发的gc可以执行</li>
</ul>
<pre><code>JavaThread* jthr = JavaThread::current();
        if (!jthr-&gt;in_critical()) {
          MutexUnlocker mul(Heap_lock);
          // Wait for JNI critical section to be exited
          GC_locker::stall_until_clear();
          continue;
        }
</code></pre><ul>
<li>在没有gc被触发的情况下，则主动触发一次gc，这之后会做一些记录操作信息之类的零碎工作，然后循坏重头开始</li>
</ul>
<pre><code>VM_GenCollectForAllocation op(size,
                              is_tlab,
                              gc_count_before);
VMThread::execute(&amp;op);
if (op.prologue_succeeded()) {
  result = op.result();
  if (op.gc_locked()) {
     assert(result == NULL, &quot;must be NULL if gc_locked() is true&quot;);
     continue;  // retry and/or stall as necessary
  }
</code></pre><ul>
<li>注意 hotSpot 中gc分为minor gc和full gc两种，前者回收新生代，后者回收所有分代，这个时候对象可能会按 eden->survivor->老年代的顺序晋升，是否晋升到老年代由对象经历的minor gc次数和大小决定</li>
</ul>
<p><strong>本篇完</strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring Boot 部署]]></title>
      <url>/2018/11/17/SpringDeploy/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><strong>应用开发仔还是要懂点后台的，至少做demo的时候可以给自己写点接口，自己动手，丰衣足食</strong></p>
<ul>
<li>以前学过一点点php，go，最近看了一下node.js，对比下来觉得，就这点需求来说，spring对于Android程序员而言入门成本才是最低的</li>
</ul>
<ul>
<li>特别是Retrofit，Dagger，MVVM用得多的人，姑且不论内部实现，至少模型和api设计上都是些眼熟的东西，可能AOP对某些人算例外，不过大多数有经验的人应该还是听过AspectJ的</li>
</ul>
<p><br></p>
<h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><ul>
<li>在 pom.xml 下面配置信息 artifactId和version会拼接成包的名称，packaging是打包的形式，war或jar，这里我使用jar</li>
</ul>
<pre><code>&lt;artifactId&gt;demo&lt;/artifactId&gt;
&lt;version&gt;1&lt;/version&gt;
&lt;packaging&gt;jar&lt;/packaging&gt;
</code></pre><ul>
<li>在 idea 的 Maven 插件下面找到 package，双击，在 target 目录下可以找到 jar 包，测试运行一下</li>
</ul>
<pre><code>java -jar xxx.jar
</code></pre><p><br></p>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><ul>
<li>我的云服务器用的是vultr的vps，环境是 ubuntu 18.04，首先把 jar 包丢上去</li>
</ul>
<pre><code>sudo scp xxx.jar xxx@xxx.xxx.xxx.xxx:/home
</code></pre><ul>
<li>下载 open-jdk，默认是最新的 release，目前是 java 11</li>
</ul>
<pre><code>sudo apt install default-jdk
</code></pre><ul>
<li>登录云服务器后运行, 这里直接使用 java -jar 是不行的，因为连接断开之后终端就关闭了，使用nohup永久执行，&amp; 表示后台执行，然后就可以用ip或域名访问了</li>
</ul>
<pre><code>nohup java -jar spb-1.jar &amp;
</code></pre><ul>
<li>有个问题是由于之前开了 nginx，导致 404，nginx 配置没怎么了解过，我就直接把他关掉了,之后有时间再研究</li>
</ul>
<pre><code>nginx -s stop
</code></pre><p><br><br><strong>完</strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[计算机网络  2 - IP 和 IPv4]]></title>
      <url>/2018/11/10/NetIPv4/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><br></p>
<h3 id="传统分类"><a href="#传统分类" class="headerlink" title="传统分类"></a>传统分类</h3><p><br></p>
<h4 id="网络号划分"><a href="#网络号划分" class="headerlink" title="网络号划分"></a>网络号划分</h4><table>
<thead>
<tr>
<th>类别</th>
<th>网络号</th>
<th>主机</th>
<th>百分比</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>0开头，共8位</td>
<td>24位</td>
<td>1/2</td>
</tr>
<tr>
<td>B</td>
<td>10开头，共16位</td>
<td>16位</td>
<td>1/4</td>
</tr>
<tr>
<td>C</td>
<td>110开头，共24位</td>
<td>8位</td>
<td>1/8</td>
</tr>
<tr>
<td>D</td>
<td>1110开头，共32位，组播地址</td>
<td>-</td>
<td>1/16</td>
</tr>
<tr>
<td>E</td>
<td>1111开头，共32位，保留</td>
<td>-</td>
<td>1/16</td>
</tr>
</tbody>
</table>
<ul>
<li>传统ip分类，A B 类浪费太多地址，C 类不能提供足够地址，这种分类方式已经过时，基本已无实际意义，它被 CIDR 取代</li>
</ul>
<p><br></p>
<h4 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h4><ul>
<li>站点由 isp 分配网络号之后，可以进行子网划分</li>
</ul>
<ul>
<li>在32位ip地址中。网络号后面的位可以再划分为子网号和主机号</li>
</ul>
<pre><code>       固定位数     自由分配
ip地址 = 网络号 +（子网号+主机号）
</code></pre><ul>
<li>只有划分子网的网络中的主机和路由器知道子网结构，internet 的其他部分不受影响</li>
</ul>
<p><br></p>
<h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><ul>
<li>由连续的1和连续的0组成,常见的表示方法有三种</li>
</ul>
<pre><code>点分十进制：255.255.255.192  
前缀长度：/27  
二进制：11111111 11111111 11111111 11100000
</code></pre><ul>
<li>子网掩码有路由器和注解使用，以确定一个ip地址的网络/子网部分的结束和主机部分的开始，方法是和IP地址进行按位与，结果是ip地址所属子网号</li>
</ul>
<pre><code>地址：10000000 00100000 00000001 00001110  -\&gt; 128.32.1.14
掩码：11111111 11111111 11111111 00000000  -\&gt; 255.255.255.0
结果：10000000 00100000 00000001 00000000  -\&gt; 128.32.1.0
</code></pre><p><br></p>
<h4 id="可变长子网掩码-VLSM"><a href="#可变长子网掩码-VLSM" class="headerlink" title="可变长子网掩码 VLSM"></a>可变长子网掩码 VLSM</h4><ul>
<li>VLAM 支持每个站点的不同部分使用不同长度的子网掩码，这样每个子网可以支持不同数量的主机</li>
</ul>
<ul>
<li>主机和路由器的每个接口都必须用 IP 地址和子网掩码来描述</li>
</ul>
<ul>
<li>基于动态路由协议（如 OSPF, IS-IS, RIPv2 ）,流量可以在同一站点的主机之间正确流动</li>
</ul>
<p><br></p>
<h4 id="广播地址"><a href="#广播地址" class="headerlink" title="广播地址"></a>广播地址</h4><ul>
<li>子网中主机部分全为1的ip地址，编程上可以子网中的ip地址与按位取反后的掩码进行按位或的方法获取</li>
</ul>
<pre><code>地址：10000000 00100000 00000001 00001110  -\&gt; 128.32.1.14
掩码：00000000 00000000 00000000 11111111 -\&gt; 255.255.255.0
结果：10000000 00100000 00000001 11111111  -\&gt; 128.32.1.255
</code></pre><ul>
<li>理论上，这种地址可以通过internet路由到目标子网，再作为一组广播数据报发给子网中的所有主机，这种数据报叫定向广播</li>
</ul>
<pre><code>路由器现在默认禁止转发定向广播，甚至完全省略支持能力
</code></pre><ul>
<li>255.255.255.255 被保留为本地网络广播，它不会被路由器转发，注意 IPv6 中不存在任何广播地址</li>
</ul>
<pre><code>主机默认支持本地网络广播，并且不需要路由器支持
</code></pre><p><br></p>
<h3 id="CIDR-amp-聚合"><a href="#CIDR-amp-聚合" class="headerlink" title="CIDR &amp; 聚合"></a>CIDR &amp; 聚合</h3><p><br></p>
<h4 id="前缀"><a href="#前缀" class="headerlink" title="前缀"></a>前缀</h4><ul>
<li>CIDR 使用类似子网掩码的 CIDR 掩码，它不局限于一个站点，对整个 Internet 可见</li>
</ul>
<ul>
<li>路由器必须可以处理网络号和掩码，网络号和子网掩码合称网络前缀，表示如下，括号为固定的数值，用来涵盖可能的地址范围</li>
</ul>
<pre><code>128.0.0.0/1 (1)0000000 00000000 00000000 00000000
128.0.0.0/24 (10000000 00000000 00000000) 00000000
198.128.128.192/27 (10000000 00000000 0000000 0000)0000
</code></pre><p><br></p>
<h4 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h4><ul>
<li>CIDR 前缀实现了可定义的网络号长度，但是没有解决路由表中表项过多的问题</li>
</ul>
<ul>
<li>路由聚合将多个IP前缀合并到更短的前缀中去，过程如下</li>
</ul>
<pre><code>长前缀表项：
172.18.129.0/24
172.18.130.0/24
172.18.132.0/24
172.18.133.0/24

二进制:
129 -\&gt; 10000001
130 -\&gt; 10000010
132 -\&gt; 10000100
133 -\&gt; 10000101

划归相同位:
172.18.128.0/21
</code></pre><p><br></p>
<h4 id="组播"><a href="#组播" class="headerlink" title="组播"></a>组播</h4><p><strong>这里只讨论IPv4的组播形式</strong></p>
<ul>
<li>组播表示一组计算机接口而不是单个</li>
</ul>
<ul>
<li>不同于广播，主机可以选择加入或离开一个组，不再特定组内的主机不会接收改组的数据报</li>
</ul>
<ul>
<li>D类地址空间被分配为组播地址，之后又被继续细分</li>
</ul>
<table>
<thead>
<tr>
<th>范围</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>224.0.0.0 - 224.0.0.255</td>
<td>本地网络控制，不转发</td>
</tr>
<tr>
<td>224.0.1.0 - 224.0.1.255</td>
<td>互联网络控制，转发</td>
</tr>
<tr>
<td>224.0.2.0 - 224.0.255.255</td>
<td>Ad hoc 块 1</td>
</tr>
<tr>
<td>224.1.0.0 - 224.1.255.255</td>
<td>保留</td>
</tr>
<tr>
<td>224.2.0.0 - 224.2.255.255</td>
<td>SDP/SAP</td>
</tr>
<tr>
<td>224.3.0.0 - 224.4.255.255</td>
<td>Ad hoc 块 2</td>
</tr>
<tr>
<td>224.5.0.0 - 224.255.255.255</td>
<td>保留</td>
</tr>
<tr>
<td>225.0.0.0 - 231.255.255.255</td>
<td>保留</td>
</tr>
<tr>
<td>232.0.0.0 - 232.255.255.255</td>
<td>保留</td>
</tr>
<tr>
<td>233.0.0.0 - 233.255.255.255</td>
<td>源特定组播（SSM）</td>
</tr>
<tr>
<td>233.0.0.0 - 233.251.255.255</td>
<td>GLOP</td>
</tr>
<tr>
<td>233.252.0.0 - 233.255.255.255</td>
<td>Ad hoc 块3(233.252.0.0/24)</td>
</tr>
<tr>
<td>234.0.0.0 - 234.255.255.255</td>
<td>基于单播前缀的IPv4 组播地址保留</td>
</tr>
<tr>
<td>235.0.0.0 - 238.255.255.255</td>
<td>基于单播前缀的IPv4 组播地址保留</td>
</tr>
<tr>
<td>239.0.0.0 - 239.255.255.255</td>
<td>管理范围</td>
</tr>
</tbody>
</table>
<p><br><br><strong>本篇完</strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[计算机网络系列 8 - HTTP]]></title>
      <url>/2018/11/10/NetHttp/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><br></p>
<h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><p><br></p>
<h4 id="URI，URL-UR"><a href="#URI，URL-UR" class="headerlink" title="URI，URL  UR"></a>URI，URL  UR</h4><ul>
<li>URI是一种更通用的资源标识符，URI主要包括URL和URN。URL通过描述资源的位置来标识资源。而URN通过名字来识别资源，与位置无关</li>
</ul>
<p><br></p>
<h4 id="URL语法"><a href="#URL语法" class="headerlink" title="URL语法"></a>URL语法</h4><ul>
<li>资源可以通过不同的方案进行访问，因此URL的语法会随着方案的不同而不同，大多数URL方案的语法都建立在由9个组件构成的通用格式上，注意几乎没有哪个URL包含了所有的组件，这些组件当中最重要的是方案scheme、主机host、路径path</li>
</ul>
<pre><code>&lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;\\\\\\#&lt;frag&gt;
</code></pre><ul>
<li>通用组件如下</li>
</ul>
<table>
<thead>
<tr>
<th>组件</th>
<th style="text-align:center">描述</th>
<th style="text-align:right">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>方案</td>
<td style="text-align:center">访问服务器以获取资源时要使用哪种协议</td>
<td style="text-align:right">无</td>
</tr>
<tr>
<td>用户</td>
<td style="text-align:center">某些方案访问资源时需要的用户名</td>
<td style="text-align:right">匿名</td>
</tr>
<tr>
<td>密码</td>
<td style="text-align:center">用户名后面可能包含的密码，中间由冒号分割</td>
<td style="text-align:right">E-mail地址</td>
</tr>
<tr>
<td>主机</td>
<td style="text-align:center">资源宿主服务器的主机名或点分IP地址</td>
<td style="text-align:right">无</td>
</tr>
<tr>
<td>端口</td>
<td style="text-align:center">资源宿主服务器正在监听的端口号。很多方案都有默认端口号（http的默认端口号为80）</td>
<td style="text-align:right">每个方案特有</td>
</tr>
<tr>
<td>路径</td>
<td style="text-align:center">服务器上资源的本地名，有一个斜杠（/）将其与前面的URL组件分隔开。路径组件的语法是与服务器和方案有关的，URL路径可以分成若干段，每段都可以有其特有的组件</td>
<td style="text-align:right">无</td>
</tr>
<tr>
<td>参数</td>
<td style="text-align:center">某些方案侯勇这个组件来指定输入参数，参数为名值对。URL中可以包含多个参数字段，它们互相之间以及与路径之间的其余部分之间用分号（;）分隔</td>
<td style="text-align:right">无</td>
</tr>
<tr>
<td>查询</td>
<td style="text-align:center">某些方案会用这个组件传递参数以激活应用程序（数据库，公告板，搜索引擎等）。查询组件的内容没用通用哪个格式，用问号（?）将其与URL的其余部分分隔开来</td>
<td style="text-align:right">无</td>
</tr>
<tr>
<td>片段</td>
<td style="text-align:center">一小片或者一部分资源的名字，引用对象时，不会将frag字段穿给服务器，这个字段是在客户端内部使用的，因此服务器会请求整个资源</td>
<td style="text-align:right">无</td>
</tr>
</tbody>
</table>
<p><br></p>
<h4 id="URL字符"><a href="#URL字符" class="headerlink" title="URL字符"></a>URL字符</h4><ul>
<li>URL只能使用一些相对较小的，通用的，安全字母表中的文字，因为安全传输意味着URL的传输不能丢失信息，有些协议，的协议会剥去一些特定的字符，比如传输电子邮件，设计者还希望URL可供人阅读，因此不可见字符不能在URL中使用</li>
</ul>
<ul>
<li>有时URL确实需要包含通用的安全字母表之外的二进制数据或字符。因此需要将不安全的字符转义为安全字符，这种转义方法包含一个百分号（%）和后面两个表示ASCII码的十六进制</li>
</ul>
<p><br></p>
<h4 id="字符限制"><a href="#字符限制" class="headerlink" title="字符限制"></a>字符限制</h4><ul>
<li>在URL中有几个字符被保留起来，有着特殊的含义。有些字符不在定义的US-ASCII可打印字符中，有些字符会与某些因特网网关和协议产生混淆，因此不赞成使用</li>
</ul>
<ul>
<li>客户端在向其他应用程序发送任意URL之前，最好把所有不安全或者受限的字符进行转换，常见的保留及受限的字符如下</li>
</ul>
<table>
<thead>
<tr>
<th>字符</th>
<th>保留/受限</th>
</tr>
</thead>
<tbody>
<tr>
<td>%</td>
<td>保留为编码字符的转移标志</td>
</tr>
<tr>
<td>/</td>
<td>保留作为路径组件中分隔路径段的定界符</td>
</tr>
<tr>
<td>.</td>
<td>保留在路径组件中使用</td>
</tr>
<tr>
<td>..</td>
<td>保留在路径组件中使用</td>
</tr>
<tr>
<td>#</td>
<td>保留作为分段定界符使用</td>
</tr>
<tr>
<td>?</td>
<td>保留作为查询字符串定界符使用</td>
</tr>
<tr>
<td>;</td>
<td>保留作为参数定界符使用</td>
</tr>
<tr>
<td>:</td>
<td>保留作为方案，用户/口令，以及主机/端口组件的定界符使用</td>
</tr>
<tr>
<td>$,+</td>
<td>保留</td>
</tr>
<tr>
<td>@ &amp; =</td>
<td>在某些方案的上下文中有特殊意义，保留</td>
</tr>
<tr>
<td>{}  ^ [ ] ’</td>
<td>由于各种传输Agent代理，比如网关的不安全处理，使用受限</td>
</tr>
<tr>
<td>\&lt;> “</td>
<td>不安全，这些字符在URL范围之外通常是有意义的，比如在文档中对URL自身进行定界，所以应该对其进行编码</td>
</tr>
<tr>
<td>0x00-0x1f，0x7f</td>
<td>受限，这些十六进制范围内的字符都在US-ASCII字符集的不可打印区间内</td>
</tr>
<tr>
<td>>0x7F</td>
<td>受限，十六进制值在此范围内的字符都不在US-ASCII字符集的7比特范围内</td>
</tr>
</tbody>
</table>
<p><br></p>
<h4 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h4><ul>
<li>常见方案如下</li>
</ul>
<table>
<thead>
<tr>
<th>方案</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>http</td>
<td>超文本传输协议，除了没有用户名和密码之外，与通用的URL格式相符，如果省略了端口，就默认为80，基本格式 <a href="http://host:port/path?query#frag" target="_blank" rel="external">http://host:port/path?query#frag</a></td>
</tr>
<tr>
<td>https</td>
<td>方案https与http是一对，唯一区别在于方案https使用了网景的SSL，SSL为HTTP连接提供了端到端的加密机制，其语法与HTTP的语法相同，默认端口为443</td>
</tr>
<tr>
<td>mailto</td>
<td>Mailto URL指向的是E-Mail地址，由于E-mail的行为与其他方案都有所不同（它并不指向任何可以直接访问的对象），所以mailto URL的格式与标准URL的格式也有所不同，基本格式 mailto:addr-spec 如 mailto:joe@joes-hardware.com</td>
</tr>
<tr>
<td>ftp</td>
<td>文件传输URL可以用来从FTP服务器上下载或者向其上载文件，并获取FTP服务器上的目录结构内容的列表，基本格式 ftp:user:passwird@host:port/path;params</td>
</tr>
<tr>
<td>file</td>
<td>表示一台指定的主机上可以直接访问的文件，如果省略了主机名就默认为正在使用URL的本地主机，基本格式 file:host/path</td>
</tr>
<tr>
<td>telnet</td>
<td>用于访问交互式业务，它表示的不是对象自身，而是可通过telnet协议访问的交互式应用程序</td>
</tr>
</tbody>
</table>
<p><br></p>
<h3 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h3><p><br></p>
<h4 id="报文组成"><a href="#报文组成" class="headerlink" title="报文组成"></a>报文组成</h4><ul>
<li>http报文由三部分组成，起始行startline，首部header，主体body(可选)，报文可以分为两种，请求报文request和响应报文response，结构上只在起始行有区别</li>
</ul>
<pre><code>请求报文格式
&lt;method&gt;&lt;request-url&gt;&lt;version&gt;
&lt;headers&gt;
&lt;entity-body&gt;

响应报文格式:
&lt;version&gt;&lt;status&gt;&lt;reason-phrase&gt;
&lt;headers&gt;
&lt;entity-body&gt;
</code></pre><ul>
<li>起始行startline：请求行，请求报文的起始行，包含方法，请求url。响应行，响应报文的起始行，包含http版本，状态码，原因短语</li>
</ul>
<ul>
<li>方法method：客户端希望服务器对资源执行的动作，为单独动词，比如 GET，POST，DELETE，见下文</li>
</ul>
<ul>
<li>请求URL：见上文</li>
</ul>
<ul>
<li>版本version：http版本，格式如 http/\<major\>.\<min\>，主次版本号都是整数，版本号用于互相了解对方的能力和报文格式</min\></major\></li>
</ul>
<ul>
<li>状态码status-code: 用于描述请求过程中发生的状况，其中第一位用于描述类别，如成功，出错等</li>
</ul>
<ul>
<li>原因短语reason-phrase：状态码的可读版本，只对人类有意义</li>
</ul>
<ul>
<li>首部header: 可以有零个或多个首部，由名：值组成，首部是由一个crlf结束的</li>
</ul>
<ul>
<li>主体body：包含由任意数据组成的数据块，并不是所有报文都有这个结构</li>
</ul>
<p><br></p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul>
<li>方法用来告知服务器要做什么，http规范中定义了一组常用的请求方法如下，其中只有post和put规定了需要包含一定的主体，并不是所有的服务器都实现了这些方法，服务器也可以扩展实现自己的请求方法，这些方法称为扩展方法</li>
</ul>
<pre><code>GET: 从服务器获取一份文稿
HEAD：从服务器获取文档的首部
POST：向服务器发送需要处理的数据
PUT：请求将主体部分存储在服务器上
TRACE：对可能经过代理服务器传送到服务器上的报文进行追踪
OPTIONS：决定可以在服务器上执行哪些方法
DELETE：从服务器上删除一份文档
</code></pre><p><br></p>
<h4 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h4><ul>
<li>状态码用来告诉客户端发送了什么事，状态码会跟随可读的原因短语，一般来说为3位数，分类如下</li>
</ul>
<pre><code>100-199 信息提示
200-299 成功
300-399 重定向
400-499 客户端错误
500-599 服务器错误
</code></pre><ul>
<li>常见的状态码及其对应的原因短语如下</li>
</ul>
<pre><code>200 OK                        客户端请求成功
400 Bad Request               客户端请求有语法错误，不能被服务器所理解
401 Unauthorized              请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 
403 Forbidden                 服务器收到请求，但是拒绝提供服务
404 Not Found                 请求资源不存在，eg：输入了错误的URL
500 Internal Server Error     服务器发生不可预期的错误
503 Server Unavailable        服务器当前不能处理客户端的请求，一段时间后可能恢复正常
</code></pre><p><br></p>
<h4 id="首部"><a href="#首部" class="headerlink" title="首部"></a>首部</h4><ul>
<li>首部用于添加附加信息，一般只是一些名值对列表，首部可以分为以下几类</li>
</ul>
<pre><code>通用首部：出现在两类报文中
请求首部
响应首部
实体首部：描述主体的长度和内容，或资源自身
扩展首部：规范中没有定义的新首部
</code></pre><ul>
<li>常见请求首部</li>
</ul>
<pre><code>Host: 标名请求主机器名，可为IP也可为域名，http1.1后强制使用
用此请求信息，可在服务端做WEB虚拟机，实现一机多WEB服务

Content-Length:响应体的数据字节大小

Accept-Encoding:可接受的文本压缩算法，如： gzip, deflate

Accept-Language:支持语言，客户端浏览器的设置，如：zh-cn,zh;q=0.8,en-us;q=0.5,en;q=0.3
User- Agent:浏览器信息，如：Mozilla/5.0 (Macintosh; Intel Mac OS X 10.7; rv:12.0) Gecko/20100101 Firefox/12.0

Cookie:服务器或客户端在上次设置的COOKIE，包括作用域名，过期时间，键与值
大部分WEB服务器都会在第一次访问时在响应头上加Set-Cookie，
指某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据（通常经过加密）如：BAIDUID=49415814CDBBB4CE65EC50EE4BB65E9A:FG=1; expires=Wed, 07-Nov-42 07:03:34 GMT; path=/; domain=.baidu.com

Referer:从一个连接打开一个新页面，新页面的请求一般会加此信息，标名是从哪里跳过来的
有的页面的打开历史链就可被挖掘出来，有利于分析用户行为与CPS分成

Content-Type:响应的数据类型：text/html;charset=gbk
</code></pre><ul>
<li>常见响应首部</li>
</ul>
<pre><code>Content-Type：响应的数据类型：text/html;charset=gbk

Content-Length：响应的数据体大小

Content-Encoding：如果为文本、HTML信息，则使用的编码方式

Date：当前服务器日期

Server：服务器名

Set- Cookie：第一次访问或服务设置COOKIE时，响应头里会有此信息，
如BAIDUID=49415814CDBBB4CE65EC50EE4BB65E9A:FG=1; expires=Wed, 07-Nov-42 07:03:34 GMT; path=/; domain=.baidu.com
</code></pre><ul>
<li>Cache-Control , Expires分别为控制缓存的响应头和请求头，如果都出现在响应头里，按Cache-Controler计算，Cache-Controler有如下取值，Expires在Http1.1以上版本与Max-Age一样，用来控制缓存的失效日期</li>
</ul>
<pre><code>Public:当前系统任何登录的用户都可使用
Private:当前系统登录的此用户进行缓存
no-cache:不做缓存
max-age:缓存指定秒数，如Cache-control: max-age=5
表示当访问此网页后的5秒内再次访问不会去服务器
</code></pre><p><br></p>
<h3 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h3><p><br></p>
<h4 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h4><ul>
<li>web客户端经常会打开同一个站点的连接，这种现象称为连接本地性，因此http允许事务结束之后tcp连接依然保持在打开状态，以便为未来的http请求重用现在的连接，直到其中一端决定将其关闭为止，这样可以避开tcp的慢启动，保持打开状态的连接称为持久连接，持久连接有两种类型 1.0的keep-alive和1.1的persistent，非持久连接会在一个事务结束后被关闭</li>
</ul>
<ul>
<li>实现keep-alive连接的客户端可以通过包含Connection:keep-alive首部请求将一条连接保持在打开状态，如果服务器愿意这么做，就在响应中包含相同的首部，否则客户端就将连接关闭，本质上keep-alive只是一种请求，连接两端可以在任意时刻关闭的keep-alive连接，并限制keep-alive连接处理事务的数量，可以使用keep-alive首部中用逗号分隔的选项来调节其行为，如下</li>
</ul>
<pre><code>timeout：表示服务器希望将连接保持在活跃状态的时间，并不是一个承诺值

max：表示服务器还希望为多少个事务保持连接的活跃状态，并不是一个承诺值

其他：支持任意未经处理的属性，用于测试调试
</code></pre><ul>
<li>keep-alive具有如下限制</li>
</ul>
<pre><code>不是默认使用，客户端必须发生Connection：keep-alive首部来激活
如果没有响应返回这个首部，激活将失败

实体部分必须有正确的content-length，否则无法检测一条报文的结束和另一报文的开始

代理和网关必须执行Connection首部的规则，即删除connection首部
</code></pre><ul>
<li>实现persistent的客户端默认情况下是激活持久连接的，在事务处理结束之后要关闭连接，必须使用Connection:close首部，否则连接一直打开</li>
</ul>
<ul>
<li>persistent也有限制如下</li>
</ul>
<pre><code>content-length必须正确，或者使用分块传输编码方式

每个持久连接都只适用于一跳传输，也就是代理必须分别管理两端的持久连接

不管Connection取什么值，两端都可以在任意时刻关闭连接，虽然这样做并不好
</code></pre><p><br></p>
<h4 id="管道化连接"><a href="#管道化连接" class="headerlink" title="管道化连接"></a>管道化连接</h4><ul>
<li>1.1在持久连接的基础上可以使用请求管道，在响应到达之前将更多的请求放入队列，当第一条请求通过网络流向另一端的服务器时，下一条请求也可以发送，而不是等待响应</li>
</ul>
<ul>
<li>管道化连接具有如下限制</li>
</ul>
<pre><code>如果http客户端无法确认连接是持久的，就不能使用管道

http客户端必须做好连接被关闭的准备，发送所有未完成的管道化请求

http客户端不可以用管道发送有副作用的请求，比如post，因为出错时管道化会阻碍客户端了解错误的是哪些请求
</code></pre><p><br><br><strong>本篇完</strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[计算机网络系列 7 - TCP]]></title>
      <url>/2018/11/09/NetTcp/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><br></p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>TCP提供一种面向连接的、可靠的字节流服务，包含如下组成要输</strong></p>
<ul>
<li>字节流服务，指数据在应用层看来是没有消息边界的，发送端可以多次写入不同大小的数据，接受方也可以多次读入不同大小的数据，读写次数及读写量不需要一致。tcp不会解读字节流里的内容，但它需要把字节流打散为ip可以携带的分组(也就是我们说的包)，每个分组对应一个序列号，该序列号是数据在整个字节流的偏移量</li>
</ul>
<ul>
<li>校验和，tcp包含一个强制校验和来检测比特差错，与udp一样使用端到端的伪首部和函数来计算，被检出差错的包会被丢弃，不发生确认</li>
</ul>
<ul>
<li>确认(ack) ，tcp会发送一个确认来表示收到了正确的数据，一般而言这个确认不是接受到报文段就立即发送的，因为tcp使用的ack字段是累加的，它代表共接收到多少字节，这样的设计可以减少发送报文的时间，并且使一个ack丢失时，后续的ack可以用来确认前面的报文段</li>
</ul>
<ul>
<li>超时重传，tcp为每个滑动窗口设置一个重传计时器，在ack到达时更新，如果有一个确认没有被按时收到，那么报文段就会被重传</li>
</ul>
<ul>
<li>全双工，数据可以向两个方向流动，两个方向相互独立，因此tcp需要为每个方向的数据都建立序列号。一个方向的报文段也用来承载相反方向数据的ack，同样是为了减少发送报文的时间</li>
</ul>
<p><br></p>
<h3 id="报文结构"><a href="#报文结构" class="headerlink" title="报文结构"></a>报文结构</h3><p><img src="http://wx3.sinaimg.cn/mw690/007vHOvngy1fzkf0tfh8yj30r60f674s.jpg" alt=""></p>
<ul>
<li>端口号，作用与udp一致，tcp使四元组来对应一个socket</li>
</ul>
<ul>
<li>序列号，标识了报文段中第一个字节在流中的偏移量，为32位无符号数，到达2^32-1后循环为0</li>
</ul>
<ul>
<li>确认号，确认号实际上是期待接收的下一个序号，在ACK字段启用时才有效，通常在初始和结束以外的报文段中都有效，</li>
</ul>
<ul>
<li>头部号，TCP头部通常是20字节长，带选项的话则可达60字节，因此头部长度是可变的</li>
</ul>
<ul>
<li>窗口大小，用于tcp流量控制，这个窗口大小是字节数，窗口由ACK号指定的字节开始</li>
</ul>
<ul>
<li>ACK，确认（确认号字段有效，建立连接后一般都启用），ACK不消耗序列号，不支持重传</li>
</ul>
<ul>
<li>SYN，用于初始化一个连接的同步序号，建立一个新连接时，客户机向服务器发送的第一个报文段的SYN位字段被启用，序列号字段则为一个随机的初始序列号(ISN，随机是一种安全措施)，随后该方向的所有序列号的确然号都建立在这个ISN上面。SYN，FIN，以及应用字节都会消耗一个序列号(即数据的第一个字节序列号为ISN+1)，这意味着它们都支持重传</li>
</ul>
<ul>
<li>CWR，拥塞窗口减（发送方降低发送速率）</li>
</ul>
<ul>
<li>ECE，ECN回显（发送方接受到了一个更早的拥塞通告）</li>
</ul>
<ul>
<li>URG，紧急（紧急指针字段有效，很少用）</li>
</ul>
<ul>
<li>PSH，推送（接收方尽快给应用程序传送这个数据，没有被可靠的实现或使用）</li>
</ul>
<ul>
<li>RST，重置连接（连接取消，回到listen，经常是因为错误）</li>
</ul>
<ul>
<li>FIN，发送方已经结束向对方发送数据</li>
</ul>
<ul>
<li>校验和，校验和覆盖了tcp头部和数据以及首部中的一些字段，是强制的，由发送方计算，接收方验证，使用的算法和ip，udp，icmp相同</li>
</ul>
<ul>
<li>紧急指针，在URG字段启用时才有效，它是一个偏移量，加载序列号字段上面标识紧急数据的最后一个字节，作用是告诉接收方尽快接受这些数据</li>
</ul>
<ul>
<li>选项字段，最常见的是最大段大小(MSS)，一般在每个端点发送的第一个报文段上指定，表示希望收到的报文段的最大值</li>
</ul>
<ul>
<li>数据部分，数据部分本身也是可选的，连接建立，终止，确认时都有可能发送不带任何数据吧报文段</li>
</ul>
<p><br></p>
<h3 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h3><p><strong>从这里开始才是tcp机制的重点</strong></p>
<ul>
<li>一个tcp连接的标识由一个四元组构成，包括两个ip地址和两个端口号，每个连接对应一对端点(或套接字)，当四元组完全重复时，端系统将禁止建立链接并返回一个错误</li>
</ul>
<ul>
<li>一个tcp连接分为3个阶段：启动、传输、退出</li>
</ul>
<p><img src="http://wx2.sinaimg.cn/mw690/007vHOvngy1fztan4y7ucj30fs0i5jsk.jpg" alt=""></p>
<p><br></p>
<h4 id="连接打开"><a href="#连接打开" class="headerlink" title="连接打开"></a>连接打开</h4><ul>
<li>建立连接需要完成以下步骤，一共包括三个报文段，因此也称为三次握手，这里将连接的主动建立方称为客户端，被动建立方称为服务器，这种方式属于常见的情况，还有一种服务器和客户端同时建立连接的情况</li>
</ul>
<ol>
<li>客户端发送syn报文段，该报文段syn位置位，包含需要连接的端口号，seq数值为初始序列号isn，</li>
<li>服务器发送syn + ack报文段，该报文段syn位和ack位置位，ack数值为isn + 1 ，seq数值为另一isn，因此syn报文段如果丢失，客户端也可以知道需要重传，该报文段表示服务器收到了请求</li>
<li>客户端发送ack报文段，该报文段 ack 位置位，ack数值和seq数值为 各自方向上的isn +1，该报文段表示客户端收到了服务器的回应</li>
</ol>
<p><br></p>
<h4 id="序列号"><a href="#序列号" class="headerlink" title="序列号"></a>序列号</h4><ul>
<li>序列号用于解决报文接受顺序混乱的问题，在发送syn报文之前，都双方需要确定一个初始序列号</li>
</ul>
<ul>
<li><p>初始序列号需要设计得难以预测，因为当攻击者使用伪装成用户，使用用户的ip时，如果可以推测出初始序列号，那么即使攻击者实际上收不到syn+ack报文段，也可以通过初始序列号发送正确的ack报文建立连接，并且发送数据</p>
</li>
<li><p>一般初始序列号的随机机制建立在时钟之上，Linux上为对每个连接为时钟设置由散列函数得出的偏移量</p>
</li>
</ul>
<p><br></p>
<h4 id="连接关闭"><a href="#连接关闭" class="headerlink" title="连接关闭"></a>连接关闭</h4><ul>
<li>关闭连接需要完成以下步骤，一共包括四个报文段，因此也称为四次挥手，通常来说关闭连接的发起方也是客户端，不过web服务器在作出相应之后也可能发起一个关闭操作</li>
</ul>
<ol>
<li>主动关闭方发送fin + ack报文段，ack数值和seq数值取决于前面数据传输的情况，这里假设分别为L和K</li>
<li>被动关闭方发送ack报文段，ack数值为K+1，seq数值为L，表示已经接受到了关闭请求</li>
<li>被动关闭方发送fin + ack报文段，ack数值为L，seq数值为K+1，表示被动方也决定关闭相反方向的连接</li>
<li>主动关闭方发送ACK报文段，ack数值为L+1，seq数值为K，同样表示收到了对方的关闭请求，注意上述的两个fin报文段，如果没有收到响应的ack报文段，则就会重新传输</li>
</ol>
<p><br></p>
<h4 id="连接半关闭"><a href="#连接半关闭" class="headerlink" title="连接半关闭"></a>连接半关闭</h4><ul>
<li>值得注意的是上述的两个fin报文段，代表各自方向的关闭请求，如果没有收到响应的ack报文段，则就会重新发送fin报文段，但并不是两个传输方向都必须发送关闭请求，可以选择仅仅关闭传输的其中一个方向，这种状况被称为半关闭，对于关闭哪个方向，协议上也不做限制</li>
</ul>
<pre><code>int shutdown(int sockfd,int how);

SHUT\_RD（0）：关闭sockfd上的读功能，此选项将不允许sockfd进行读操作。不允许接受

SHUT\_WR（1）：关闭sockfd的写功能，此选项将不允许sockfd进行写操作。不允许发送

SHUT\_RDWR（2）：关闭sockfd的读写功能。不允许发送和接受(和 close() 一样)

int close(int fd);

关闭读写，它将防止套接字上更多的数据的读写
任何在另一端读写套接字的企图都将返回错误
</code></pre><ul>
<li>socket中半关闭的api对应的是shutdown(fd,1), 在操作系统的支持下shutdown本质上接受两个连接上的控制，普通关闭的方式为close(fd)，它的效果和 shutdown(fd,2) 一样，连接半关闭需要两个报文段，两个方向上的半关闭就相当于普通的关闭，只是在它们之间仍允许一个方向发送数据，注意某个方向的连接半关闭时，依然会发送ack报文段进行确认，只是该报文段不再携带数据</li>
</ul>
<ol>
<li>主动关闭方发送fin + ack报文段，ack数值和seq数值取决于前面数据传输的情况，这里假设分别为L和K</li>
<li>被动关闭方发送ack报文段，ack数值为K+1，seq数值为L，表示已经接受到了关闭请求</li>
<li>被动关闭放仍可以发送数据报文段，但主动关闭方只能发送ack报文段</li>
</ol>
<p><img src="http://wx1.sinaimg.cn/mw690/007vHOvngy1fztav6f70hj30fs0fkmxw.jpg" alt=""></p>
<p><br></p>
<h4 id="同时打开与关闭"><a href="#同时打开与关闭" class="headerlink" title="同时打开与关闭"></a>同时打开与关闭</h4><ul>
<li>这种情况下双方必须都知道对方用于通信的ip和端口号，同时打开与关闭都需要四个报文段，并且报文段的发送接受一般是交叉进行的</li>
</ul>
<ul>
<li>同时关闭连接和正常关闭连接基本没有区别，但同时开启连接时双方都需要发送一个syn和一个syn+ack报文段，用于发送请求和确认请求</li>
</ul>
<p><br></p>
<h4 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h4><ul>
<li>tcp的11个状态转换情况如下，这11个状态名称来自*nix和win上面的nestat命令的输出名称，下面只讲解一些比较重要的点</li>
</ul>
<p><img src="http://wx1.sinaimg.cn/mw690/987832a0gy1g00itnztknj20oi0jm0vi.jpg" alt=""></p>
<ul>
<li>SYN_RCVD返回LISTEN状态只有在SYN_RCVD是在LISTEN状态转换来的才是正确的，它的作用是让SYN_RCVD状态中的客户端接受到重置报文后返回LISTEN状态等待另一个连接请求</li>
</ul>
<ul>
<li>TIME_WAIT状态，也称为2MSL状态，首先调用close()发起主动关闭的一方，在发送最后一个ack之后会进入time_wait的状态，保持2MSL时间(最大段生存期)之后才会正式关闭连接，需要TIME_WAIT的原因有两个，一个是为实现连接的可靠释放，因为最后一个ack可能丢失，这时被动关闭方会超时重发fin报文段同时使这个ack能重新发送，第二个原因是使旧的数据包在网络因过期而消失，这时为了避免之后使用相同四元组时建立的新连接接受到上一次连接的旧数据。在高并发的业务场景下可能会出现产生了大量TIME_WAIT的socket的问题，服务器可以使用SO_REUSEADDR来重用TIME_WAIT状态下的端口，或者更加合理的设置2MSL时间</li>
</ul>
<ul>
<li>CLOSE_WAIT状态，当被动关闭方接受到FIN报文段时，在端系统未调用close之前都处于这种情况，正常情况下一般是还有数据没发送完，或者还没到关闭的时机，非正常情况则是程序员遗漏了close操作(多进程需要特别注意close，因为不同与shutdown，close受socket引用计数的影响)，这时往往会导致大量处于该状态的socket，最好是排查程序，另外还可以设置超时</li>
</ul>
<ul>
<li>FIN_WAIT2状态，当主动关闭方发送完FIN报文段后，如果接受到的不是fin+ack，而是ack报文段时会进入该状态，因为还需要一个fin报文段才可以关闭连接，正常情况是在使用半关闭通信，KeepAlive ，或者发送方还没有发送完数据，非正常情况下则是客户端设计不合理，也可以使用超时来解决，这个超时不是协议规定的，但大部分系统都有实现，<a href="https://www.2cto.com/shouce/ApacheManual/misc/fin_wait_2.html" target="_blank" rel="external">详见</a></li>
</ul>
<ul>
<li>RST报文段，tcp首部的rst位置位时即为重置报文段(socket上为SO_LINGER字段)，一般来说都是连接不正确导致的，比如对没有被监听的端口发送了连接请求，一般是客户端设错了本地端口，upd的情况是会导致一个不可达的icmp报文段，tcp则是使用rst报文段来完成相同的工作。RST可以用来强制释放一个连接，因为fin报文段需要在排队数据都发送完后才会被发送，但rst则会抛弃所有排队数据，fin被称为有序释放，rst被称为终止释放，终止释放有时被用于通信一端以外断开导致的半连接状态，当该段重启并再次连接时需要用RST回应旧连接的报文段，表示它对这些数据一无所知。rst对部分处在time_wait状态的接受端也适用，这时候将产生一个时间等待错误TWA，直接关闭连接，有些端系统在time_wait时不对RST做出任何反应</li>
</ul>
<p><br></p>
<h3 id="TCP选项"><a href="#TCP选项" class="headerlink" title="TCP选项"></a>TCP选项</h3><ul>
<li>tcp选项是由IANA维护的，每一个选项的头一个字节为种类，部分类型的选项长度是固定的，另外则是可变的，常见的tcp选项如下</li>
</ul>
<ol>
<li>最大段大小MSS，允许对方发送的最大报文段，只记录数据字段，不包括tcp与ip头部，建立连接时每一方都需要使用该选项来说明允许的大小，否则默认为536字节，因为任何主机都只是需要能处理576字节(需要去掉最小头部)</li>
<li>选择确认SACK，由于窗口滑动机制容易产生空洞，于是使用选择确认机制来通知发送方已接收到的数据块序列范围(SACK块)，SACK选项可以携带多个SACK块</li>
<li>窗口放大WSCALE，用来将tcp窗口大小从16位扩展到32位</li>
<li>时间戳TSPOT，用来发送2个4字节的时间戳，接收方可以利用这些时间戳计算往返时间，计算往返时间主要用于设置超时重传时间</li>
<li>用户超时UTO，用来指明发送者在确认对方收到数据之前愿意等待ACK确认的时间</li>
</ol>
<p><br></p>
<h3 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h3><ul>
<li>tcp采用基于计时器的重传策略，每次重传使用二进制指数退避，即等待重传的时间为上一次间隔的一倍，我们把一个间隔称为RTO，RTO需要通过RTT来确定，tcp还使用两个阈值来决定是否继续重传同一个报文段，R1为重传次数，至少为3次，R2为所用时间，至少为100秒</li>
</ul>
<ul>
<li>RTT：RTO不能大于RTT，避免数据报还未到达就重发，RTT的确定需要采集RTT样本，通常可以使用发送报文段和收到确认报文的时间间隔，并采用一定的算法得出比较合理的统计数值，这里不深入研究。每一个连接的rtt都独立估算，并且重传时钟会会对任何占用序列号的在传数据计时</li>
</ul>
<ul>
<li>计时：一旦得到了估计的RTT，就可以设置RTO了，在记录报文段的序列号之后，tcp为报文段设置一个定时器，当收到该报文的ack，则将这个定时器取消，每一个新的数据报都需要一个新的计时器</li>
</ul>
<ul>
<li>超时：若在一个RTO之内没有收到ack，那么就触发超时重传，超时重传还会导致tcp降低发送速率，一种方法是基于拥塞控制减小发送窗口的大小，另一种方法是增大RTO，即二进制指数退避</li>
</ul>
<p><br></p>
<h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h3><ul>
<li>接收方当收到失序的分组时，即收到序列号大于期待值的分组时，会发送冗余ack，当发送端接受到一定数量(dupthresh一般为3)的冗余ack就会引发快速重传，冗余ack通常也包括sack选项，用于表示有多少个空缺，导致失序分组的原因一般有两个，分组丢失或延迟到达，因为不能确定是哪一种情况，所以才需要设置dupthresh。快速重传也会触发拥塞控制机制</li>
</ul>
<p><br></p>
<h3 id="窗口管理"><a href="#窗口管理" class="headerlink" title="窗口管理"></a>窗口管理</h3><p><br></p>
<h4 id="nagle算法"><a href="#nagle算法" class="headerlink" title="nagle算法"></a>nagle算法</h4><ul>
<li>nagle算法是指任意时刻，最多只能有一个未被确认的小段，也就是小于MSS而且还没有收到ack的数据块，尽量搜集普通的小数据包合并成大的数据包，对于大于mss，或含有fin，或设置了TCP_NODELAY，或超时，或当前没有未确认小段时，数据包都是直接发送的</li>
</ul>
<pre><code>（1）如果包长度达到MSS，则允许发送；
（2）如果该包含有FIN，则允许发送；
（3）设置了TCP\_NODELAY选项，则允许发送；
（4）未设置TCP\_CORK选项时，若所有发出去的小数据包（包长度小于MSS）均被确认，则允许发送；
（5）上述条件都未满足，但发生了超时（一般为200ms），则立即发送。
</code></pre><ul>
<li>TCP_NODELAY本质是禁用nagle算法，TCP_CORK则是使用比nagle更加强制性的算法，它没有一个未被确认的小段的限制，会尽量的将数据包合并为一个MSS</li>
</ul>
<p><br></p>
<h4 id="延迟确认"><a href="#延迟确认" class="headerlink" title="延迟确认"></a>延迟确认</h4><ul>
<li>tcp一般不对每个数据包都返回ack，而是将ack和需要传输的数据结合发送，以减少数据包的数量</li>
</ul>
<ul>
<li>延迟确认在大数据包传输中大量使用，但在小数据包传输中和nagle等算法配合可能不太令人满意，因为服务端在等待客户端的延迟ack时可能由于nagle而不能发送更多数据包</li>
</ul>
<p><br></p>
<h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><ul>
<li>每个tcp都是双向连接，连接的收发数据是通过一组窗口结构维护的，每个连接的两端都都维护一个发送窗口和一个接受窗口，窗口以字节为管理单位，提供窗口的大小是由接受端的ack中的窗口大小字段控制的</li>
</ul>
<ul>
<li>提供窗口结构如下，窗口边界不能左移，因为ack号有累积性不能返回，当ack增大时窗口大小不变时为右滑，窗口也有可能减小，当大小为零时，称为零窗口</li>
</ul>
<p><img src="http://wx1.sinaimg.cn/mw690/987832a0gy1g01pdy84wyj20hn0bbt93.jpg" alt=""></p>
<ul>
<li>接受窗口结构如下，该窗口内的字节没有区分，只要序列号不再窗口范围当中，报文段都会被抛弃，使用sack选项时窗口范围内的任何序列号都可以接受确认，若不使用sack，则只有左边界的序列号可以接受确认，左边界的序列号被确认时会导致窗口右滑</li>
</ul>
<p><img src="http://wx2.sinaimg.cn/mw690/987832a0gy1g01q1n2ynvj20hn0aujrm.jpg" alt=""></p>
<ul>
<li>比较特殊的情况是零窗口，它可以有效阻止发送端继续发送数据，当接收端可以接受数据时需要发送一个窗口更新ack报文段，它通常不包含任何数据。为了避免该报文段丢失，发送端会使用一个持续计时器来间歇性的发送窗口探测报文段查询接收端，它包含一个字节的数据，因此避免丢失</li>
</ul>
<p><br></p>
<h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><ul>
<li>并没有一种精确的方法可以知晓中间路由器的状况，tcp最常用的拥塞检测方法基于丢包，其他方法包括时延测量和显示拥塞通知，当检测当拥塞，tcp需要有效减缓tcp的发送</li>
</ul>
<ul>
<li>tcp使用拥塞窗口cwnd来反应网络传输能力，它和接受端通知窗口awnd共同决定发送端窗口大小，不能大于两者中的较小值，由于cwnd不可能精确得到，因此一般使用慢启动来确定</li>
</ul>
<ul>
<li>慢启动：慢启动一般在连接建立或检测到超时重传时使用，发送端长时间空闲时也可能使用，慢启动用于在启用拥塞避免之前逐步获取cwnd值，以及帮助tcp建立ack时钟。慢启动的初始值一般为1个SMSS(发送方最大段大小)，每接受到新序列号的ack，会以min(接收方新接受的数据量,SMSS)来增加cwnd值，当cwnd增加时，可发送数据包数量也会增加，因此初始值为1时，正常情况下cwnd会以1 2 4 8 .. 增长，因此理想状态下cwnd会以指数增长</li>
</ul>
<ul>
<li>拥塞避免：为了避免慢启动中cwnd高速增长，tcp需要使用一种更加缓和的增长算法，它就是拥塞避免，公式如下，假设cwnd分k个包发送，数据接受完cwnd则增长了大约一个SMSS</li>
</ul>
<pre><code>cwnd=cwnd+SMSS\*SMSS/cwnd 
cwnd=cwnd+(1/k)\*SMSS
</code></pre><ul>
<li>ssthresh：慢启动什么时候进入拥塞避免由慢启动阈值ssthresh确定，当cwnd值大于ssthresh时使用拥塞避免机制，ssthresh不是固定的，它会记录上次最好的窗口估计值，一般是从拥塞避免来的，当发送超时重传时，会导致ssthresh降低为大约cwnd值的一半，cwnd重新设置为1，重新进入慢启动过程，发生快速重传时则会把ssthresh设置为cwnd的一半，把cwnd再设置为ssthresh的值，重新进入拥塞避免阶段</li>
</ul>
<ul>
<li>快速恢复：快速恢复建立在前面快速重传的情况下，TCP最后进入的不是拥塞避免阶段，而是快速恢复阶段，快速重传和快速恢复算法一般同时使用，但后者更加详细，也多一些步骤，快速恢复基于数据包守恒原则，只有当老数据包离开了网络后，才能向网络中发送一个新数据包，如果发送方收到一个重复的ack，那么就表明有一个数据包离开了网络</li>
</ul>
<pre><code>1.当收到3个重复ACK时，把ssthresh设置为cwnd的一半，把cwnd设置为ssthresh的值加3，然后重传丢失的报文段
加3的原因是因为收到3个重复的ACK，表明有3个“老”的数据包离开了网络。 

2.再收到重复的ACK时，拥塞窗口增加1。

3.当收到新的数据包的ACK时，把cwnd设置为第一步中的ssthresh的值。
原因是因为该不重复的好的ack表示失序问题已经解决
该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态
</code></pre><p><br><br><strong>本篇完</strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[计算机网络系列 6 - 运输层 & UDP]]></title>
      <url>/2018/11/09/NetUdp/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><br></p>
<h3 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h3><p><br></p>
<h4 id="运输层服务"><a href="#运输层服务" class="headerlink" title="运输层服务"></a>运输层服务</h4><ul>
<li>传输层提供两种协议，tcp和udp，udp提供不可靠无连接的服务，tcp提供可靠面向连接的服务（其实还有一个stcp，不过不在本文讨论范围）</li>
</ul>
<ul>
<li>提供程到进程之间的逻辑通信，运输层在端系统而不是在路由器上实现，由于ip为不可靠服务（不确保交付和顺序），将ip扩展为两个端系统进程之间的这种交付服务称为多路复用与多路分解</li>
</ul>
<ul>
<li>简单来说，运输层提供最低限度的服务包括，进程间的数据交付，差错检查，这两种也是udp提供的全部服务，而tcp还提供可靠数据传输（正确，有序）和拥塞控制</li>
</ul>
<p><br></p>
<h4 id="多路分解复用-amp-端口号"><a href="#多路分解复用-amp-端口号" class="headerlink" title="多路分解复用 &amp; 端口号"></a>多路分解复用 &amp; 端口号</h4><ul>
<li>运输层的数据实际上并不是直接交付给进程的，而是交付给对应的套接字，根据报文段中的首部信息将其定向到目标套接字就是多路分解</li>
</ul>
<ul>
<li>相对的，为数据加上这些首部信息，然后投递到网络层就称为多路复用</li>
</ul>
<ul>
<li>需要的字段包括源端口号，目的端口号和其他一些字段，端口号为两个字节，0到1023为受限端口号，1024到49151为注册端口号，49152到65535为动态端口或者私人端口，受限端口和注册端口可以在IANA的这个<a href="https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml" target="_blank" rel="external">网站</a>查看，redhat旧版的<a href="http://cert.sjtu.edu.cn/doc/linux/ch-ports.html" target="_blank" rel="external">安全手册</a>也有提供常见的端口号，看一下下面这些就够了</li>
</ul>
<pre><code>HTTP协议代理服务器常用端口号：80/8080/3128/8081/9098

SOCKS代理协议服务器常用端口号：1080

FTP（文件传输）协议代理服务器常用端口号：20（控制端口）/tcp、21（数据传输端口）/tcp

Telnet（远程登录）协议代理服务器常用端口号：23/tcp

DNS（域名解析服务）默认端口号：53/udp

HTTP服务器，默认端口号：80/tcp

POP3 （邮局协议版本3）使用的端口号：110/tcp

HTTPS（securely transferring web pages）服务器，默认端口号：443/tcp

TFTP（Trivial File Transfer Protocol），默认端口号：69/udp

SSH（安全登录）、SCP（文件传输）、端口号重定向，默认的端口号：22/tcp

SMTP （Simple Mail Transfer Protocol），默认端口号：25/tcp

POP3 Post Office Protocol（E-mail），默认端口号：110/tcp

Webshpere应用程序默认端口号：9080

webshpere管理工具，默认端口号：9090

JBOSS，默认端口号：8080

TOMCAT，默认端口号：8080

WIN2003远程登录，默认端口号：3389

Symantec AV/Filter for MSE,默认端口号：8081

MSN Messenger的文件传输功能所使用的端口号：1863/tcp

Oracle 数据库默认的端口号：1521/tcp

ORACLE EMCTL，默认的端口号为1158

Oracle XDB（XML 数据库），默认的端口号为8080

Oracle XDB FTP服务，默认的端口号为2100

MS SQL SERVER数据库server，默认的端口号为1433/tcp

MS SQL SERVER数据库monitor，默认的端口号为1434/tcp

Microsoft RDP 微软远程桌面使用的端口号：1863/tcp

Symantec pcAnywhere 远程控制数据传输时使用的端口号：5631/tcp

Symantec pcAnywhere 主控端扫描被控端时使用的端口号：5632/udp

MS SQL Server使用的端口号：5000/tcp
</code></pre><p><br></p>
<h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p><br></p>
<h5 id="定向"><a href="#定向" class="headerlink" title="定向"></a>定向</h5><ul>
<li>自顶向下上面说udp用两元组来确定一个socket，tcp用四元组来确定一个socket，报文段指定的元组的元素相同就会通过相同的套接字定向到相同的目的进程</li>
</ul>
<ul>
<li>这个说法有点绕，而且不是很恰当，因为本质上不管多少元组，最多都只能定位到socket，操作系统保证同时建立(accept，Socket)创建socket时不会产生重复的socket，进程持有socket的描述符socketfd，因此可以监听到这些报文段，由于fd是共享资源，假如一个进程创建socket后fork了一个或多个子进程，那么哪个进程能拿到报文段取决于谁先读取数据，并且多个进程都可以往同一socket写数据，当然这种情况不常见，因为通常只有tcp链接中的监听socketfd(由Socket函数产生)才设计成在各个进程间共享，而它指向的socket是不用来传输数据的，只不过这种问题确实有可能发生，而且不只是读写，我们还要关注关闭socket的情况，socketfd是具有引用计数的，一个进程调用close只会让引用计数减一，只有减到0才会进行关闭，而调用shutdown则会不管计数直接关闭，因此不当使用close可能会引发大量的close_wait的socket导致端系统崩溃的问题</li>
</ul>
<p><br></p>
<h5 id="五元组"><a href="#五元组" class="headerlink" title="五元组"></a>五元组</h5><ul>
<li>在计算机网络中，五元组可以唯一确定一个会话，一个会话只会对应一对socket(源，目的)，五元组具体指的是下面这五个</li>
</ul>
<pre><code>src\_ip, 源ip
src\_port，源端口
dest\_ip，目的ip
dest\_port，目的端口
protocol\_type，协议类型
</code></pre><ul>
<li>知道这个有什么用呢，有的，我们可以推导一个会话能否成立，比如说，不同的协议能否运行在相同的端口呢，答案是可以的，<a href="https://www.jianshu.com/p/df9e55e94f95" target="_blank" rel="external">详见</a>，其他元组也是这样，都是很普通的情况了</li>
</ul>
<ul>
<li>在进一步知道协议的情况下，比如tcp和udp，我们通常就使用四元组了，因为上面的 protocol_type 是已知的了（SOCK_STREAM，或者SOCK_DGRAM）</li>
</ul>
<p><br></p>
<h5 id="二元组-amp-四元组"><a href="#二元组-amp-四元组" class="headerlink" title="二元组 &amp; 四元组"></a>二元组 &amp; 四元组</h5><p><strong>这一节的图片来自《unix网络编程》</strong></p>
<ul>
<li>细心的人会发现不管TCP还是UDP的首部一般都只有五元组中的源端口和目的端口，实际上程序接受一个UPD或TCP消息时，IP首部和udp，tcp首部都已经被剥掉，但五元组就是由这些首部共同构成的，不管什么时候都可以通过操作系统的接口获取(如果确实有)，<a href="https://blog.csdn.net/iicup/article/details/41041215?utm_source=blogxgwz3" target="_blank" rel="external">例子</a></li>
</ul>
<ul>
<li>那么为什么说TCP的套接字是四元组而UDP套接字却是二元组呢，这里讲的其实是套接字的定向，先看TCP的情况，由于TCP是面向连接的传输服务，而一个连接自然就包含了一个四元组，因此建立一个链接就需要创建一个socket，也就是accept函数每次返回的是一个新的socket的描述符，需要四元组才能定向到这个socket</li>
</ul>
<p><br><br><img src="http://wx3.sinaimg.cn/mw690/007vHOvngy1fzi7px6exej30u00vzgs7.jpg" alt=""></p>
<ul>
<li>再看UDP的情况，UDP是无连接的，更关键的是它是不可靠的，源ip和源端口无关紧要(同时udp协议中源端口号是可选的，可设置为0)，因此UDP的socket是可以复用的，也就是说目的ip和端口一致的报文段全都发往一个socket就行了，这个时候我们同样可以同过recvfrom获取到源地址</li>
</ul>
<p><br><br><img src="http://wx1.sinaimg.cn/mw690/007vHOvngy1fzi7qar0kuj30z00rsdwn.jpg" alt=""></p>
<ul>
<li>最后看端口复用的情况，端口复用概念只存在于TCP的情况(毕竟udp一直都是复用的)，我们知道通常Socket里一个端口一个程序只能bind一次，多次bind一个端口，就叫做端口复用，我们可以使用setsockopt来设置端口复用，但端口复用本身是有限制的，它只是通知内核，如果端口被占用且TCP状态位于 TIME_WAIT ，就重用端口，否则将bind时将一直返回Error，这是由于socket本身只含有四元组，如果有同一时刻同一协议绑定相同端口，那么请求到来时就无法匹配到唯一的socket，这也导致了端口复用的应用上有一定难度，具体可以看，<a href="https://www.cnblogs.com/kex1n/p/7437290.html" target="_blank" rel="external">这里</a></li>
</ul>
<pre><code>setsockopt(sockfd, SOL\_SOCKET, SO\_REUSEADDR, (const voidvoid \*)&amp;opt, sizeof(opt));
</code></pre><p><br></p>
<h3 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h3><p><br></p>
<h4 id="适用领域"><a href="#适用领域" class="headerlink" title="适用领域"></a>适用领域</h4><ul>
<li>udp不提供向tcp那么完善的服务，但这也是udp的优点，它更加灵活低耗，应用采用udp的原因可能如下</li>
</ul>
<pre><code>可以更精细地控制什么时候发送数据，避免tcp中的拥塞控制和确认机制导致不必要的延迟和重传，保证实时应用的最小发送速率

无需建立连接，不会引入建立连接的时延

端系统开销小，无连接也就不需要维护连接状态，如缓存，拥塞控制参数，确认号等

分组首部开销小，udp首部只有8字节的开销，tcp则为20字节
</code></pre><ul>
<li>使用udp的例子如下，有一个误区是实时流媒体都用udp，比如什么直播用的都是udp，或者由于web基于http所以视频播放都是基于tcp，实际上流视频不可能是那么简单的事情，硬要说的话，目前主流的web直播使用的是http-flv(基于http，自热也就基于tcp)，或则是http-flv + rtmp(同样基于tcp)，并且向http-flv靠拢是趋势，移动端上也是rtmp比较多，详细可以看<a href="https://www.zhihu.com/question/24034147" target="_blank" rel="external">这里</a>，或<a href="https://blog.csdn.net/xiaojun111111/article/details/79805344" target="_blank" rel="external">这里</a></li>
</ul>
<pre><code>NFS(网络文件系统协议)
SNMP(简单网络管理协议)
RIP(路由选择协议)
DNS(域名解析协议，通常使用udp)
</code></pre><p><br></p>
<h4 id="报文结构"><a href="#报文结构" class="headerlink" title="报文结构"></a>报文结构</h4><p><img src="http://wx3.sinaimg.cn/mw690/007vHOvngy1fziwdregvoj30cm09xjri.jpg" alt=""></p>
<ul>
<li>端口号是协议间独立的，因为ip协议中的协议字段或ipv6中的下一个首部字段可以用于协议间的隔离，源端口号是可选的，如果发送方不提供端口号，那么设置为0</li>
</ul>
<ul>
<li>长度是总长度，包括头部和数据部分，同时这个字段也是冗余的，因为通过ip和ipv6的数据报都可以简单计算出这个长度</li>
</ul>
<ul>
<li>校验和是端到端的，是包含了ip头部中的源ip和目的ip的udp伪头部计算得来的</li>
</ul>
<p><br></p>
<h4 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h4><p><br></p>
<h5 id="校验出错"><a href="#校验出错" class="headerlink" title="校验出错"></a>校验出错</h5><ul>
<li>先说一下校验出错时会发生什么，当一个数据报被检验出错时，端系统只是将其直接抛弃，这里就涉及到分片的问题，由长度字段可以算出udp的mtu在64k左右，但ethernet的mtu为1500，那么假如udp数据报的长度超过1500，就会导致分片，这个某个数据报发生任何差错都会无法重组，端系统会丢弃所有的分片，所以一般来说状态不好的端系统应该将数据长度限制在1464(去掉头部)以内</li>
</ul>
<ul>
<li>ipv4的情况下校验和是可选的，ipv6则是强制的，但由于校验和计算是规定默认启用的，所以我们通常认为udp的差错控制是受保证的，如果校验和为0则认为不启用校验，如果计算出来的校验和正好为0，为避免歧义，将设置为全1(0xFFFF)_ </li>
</ul>
<p><br></p>
<h5 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h5><ul>
<li>udp的校验和并不是使用原本的数据报直接计算得出的，而是需要加上伪首部，这是因为udp要实现端到端的差错检测，而udp首部本身只有端口信息，伪首部本身不会被发送，只是计算时才使用，另外伪首部中包含有长度字段，这在udp中是冗余的，只是tcp中需要这个字段</li>
</ul>
<ul>
<li>ipv4首部结构如下</li>
</ul>
<p><img src="http://wx1.sinaimg.cn/mw690/007vHOvngy1fzizqombk8j30h10foq38.jpg" alt=""></p>
<ul>
<li>ipv6伪首部结构如下</li>
</ul>
<p><img src="http://wx4.sinaimg.cn/mw690/007vHOvngy1fzj0c5h9uij30h6094wek.jpg" alt=""></p>
<ul>
<li>计算方法是</li>
</ul>
<pre><code>1 将校验和字段置0
2 将每个16位的按位相加，如第17、18位出现的进位，将其值与第1，2位相加
3 再将所得的结果取反码，最后得到的结果即为UDP校验和
</code></pre><p><br><br><strong>本篇完</strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入操作系统 6 - 构建 GDT & 进入保护模式]]></title>
      <url>/2018/11/08/OSGdtCreate/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><a href="https://tocreate.app/2019/03/02/OperatingSystem/" target="_blank" rel="external">本文为深入操作系统系列的一部分</a></p>
<p><a href="https://tocreate.app/2018/10/31/OSGdt/" target="_blank" rel="external">可能需要阅读前文</a></p>
<p><strong>本文中的所有代码可以在 <a href="https://github.com/AlbertHumbert/Chaos" target="_blank" rel="external">https://github.com/AlbertHumbert/Chaos</a> 获取</strong><br><strong>对应 commit版本为 7faf1e9cbd8026f57cc207100b481708c2b74d65</strong></p>
<p><strong>本文源码使用是 GAS 汇编，涉及较多intel cpu的特性</strong></p>
<p><strong>题外话，最近比较忙没时间死磕了，下一部分本应该是分页，不过还是先回到概念和linux源码方面的内容，这几天主要还是复习计网</strong></p>
<p><br></p>
<h3 id="实模式与保护模式的区别"><a href="#实模式与保护模式的区别" class="headerlink" title="实模式与保护模式的区别"></a>实模式与保护模式的区别</h3><ul>
<li>启动: intel cpu 加电后自动进入实模式，保护模式需要设置特定的寄存器（CR0）</li>
</ul>
<ul>
<li>程序: 实模式只能运行 16 位代码，保护模式可以运行 32 位代码</li>
</ul>
<ul>
<li>寻址能力: 实模式，80286 最高为 1mb，保护模式，允许使用 4g 内存</li>
</ul>
<ul>
<li>寻址模式：实模式，20位基地址（16位左移4位），16位偏移，保护模式，选择符16位，32位段内偏移</li>
</ul>
<ul>
<li>其他：实模式无内存保护</li>
</ul>
<p><br></p>
<h3 id="GRUB"><a href="#GRUB" class="headerlink" title="GRUB"></a>GRUB</h3><p><strong>如果人生苦短，不妨试一下 GRUB </strong></p>
<ul>
<li><p>GRUB 为内核做了充足的工作，使用 GRUB 的内核已经进入了 32 位保护模式</p>
</li>
<li><p>由于进入保护模式就意味着必须有一个 GDT 所以 GRUB 已经为我们载入了一个 GDT，但它并没有什么用处，我们还是需要自己设置 GDT</p>
</li>
<li><p>虽然使用了 GRUB 但是为了学习之用本文的源码还是去做了诸如打开 A20 总线，设置 cr0 寄存器等工作</p>
</li>
</ul>
<p><br></p>
<h3 id="进入保护模式"><a href="#进入保护模式" class="headerlink" title="进入保护模式"></a>进入保护模式</h3><p><strong>本文的主要代码参考自 xv6，ucore 和 oranges （ucore 来自 jos，jos 来自 xv6，它们之间相同的代码非常多）</strong></p>
<p><br></p>
<h5 id="构建描述符"><a href="#构建描述符" class="headerlink" title="构建描述符"></a>构建描述符</h5><ul>
<li>进入保护模式的前提是必须要有一个 gdt（不然保护模式的寻址模式怎么发挥作用呢），下面这些宏简化了描述符的定义操作，描述符的结构之前的文章已经讲过了</li>
</ul>
<pre><code>/\* Application segment type bits \*/
# define STA\_X       0x8     // Executable segment
# define STA\_E       0x4     // Expand down (non-executable segments)
# define STA\_C       0x4     // Conforming code segment (executable only)
# define STA\_W       0x2     // Writeable (non-executable segments)
# define STA\_R       0x2     // Readable (executable segments)
# define STA\_A       0x1     // Accessed

# define SEG\_ASM(type,base,lim)                              \\
.word (((lim) \&gt;\&gt; 12) &amp; 0xffff), ((base) &amp; 0xffff);          \\
.byte (((base) \&gt;\&gt; 16) &amp; 0xff), (0x90 | (type)),             \\
(0xC0 | (((lim) \&gt;\&gt; 28) &amp; 0xf)), (((base) \&gt;\&gt; 24) &amp; 0xff)

/\* Normal segment \*/
# define SEG\_NULLASM                                         \\
.word 0, 0;                                                 \\
.byte 0, 0, 0, 0
</code></pre><ul>
<li>根据 intel 的规范，第一个描述符必须是  Null Segment ，也就是全 0 ，没有为什么，接下来是代码段和数据段，代码段是可读可执行的, 数据段是可写的</li>
</ul>
<pre><code># Bootstrap GDT
.p2align 2                                          # force 4 byte alignment
gdt:
SEG\_NULLASM                                     # null seg
SEG\_ASM(STA\_X|STA\_R, 0x0, 0xffffffff)           # code seg for bootloader and kernel
SEG\_ASM(STA\_W, 0x0, 0xffffffff)                 # data seg for bootloader and kernel
</code></pre><ul>
<li>接下来是构造 GDTR （回顾上文），它由 gdt 大小和基地址构成 </li>
</ul>
<pre><code>gdtdesc:
.word 0x17                                      # sizeof(gdt) - 1
.long gdt                                       # address gdt
</code></pre><p><br></p>
<h4 id="关中断"><a href="#关中断" class="headerlink" title="关中断"></a>关中断</h4><ul>
<li>现在我们不能被任何事情打扰，使用 cli 指令关中断，注意这里的 .code16，这是告诉编译器代码以16形式编译，因为我们还处于实模式因此需要告知编译器</li>
</ul>
<pre><code>.code16
.section .text
.globl \_start
.type \_start, @function
.code16
\_start:

cli                                             # Disable interrupts
</code></pre><p><br></p>
<h4 id="清理寄存器"><a href="#清理寄存器" class="headerlink" title="清理寄存器"></a>清理寄存器</h4><pre><code># Set up the important data segment registers (DS, ES, SS).
xorw %ax, %ax                                   # Segment number zero
movw %ax, %ds                                   # -&gt; Data Segment
movw %ax, %es                                   # -&gt; Extra Segment
movw %ax, %ss                                   # -&gt; Stack Segment
</code></pre><p><br></p>
<h4 id="打开-A20-总线"><a href="#打开-A20-总线" class="headerlink" title="打开 A20 总线"></a>打开 A20 总线</h4><ul>
<li>这里主要涉及一个兼容性的问题，我们前面提到 8086 使用 左移4位+16位偏移来寻址，实际上这样的算出来的最大地址是略大于1m的，有兴趣的话可以自己去算一下，那么现在问题就和原来的反过来了，地址表示能力大于了寻址能力（20位地址线）</li>
</ul>
<ul>
<li>为了解决这个问题，当访问的地址超过1m时，intel设计使 cpu 不产生越界异常，而是进行回滚（wrap around，重0开始算，即取模）</li>
</ul>
<ul>
<li>进入下一个时代，80286 已经可以拥有了 24 条总线了，当访问的地址超过 1m 时，又该怎么办呢，intel决定兼容 8086，intel 设计了一个门结构来决定 A20总线（第21条总线）是否启用回滚功能</li>
</ul>
<ul>
<li>我们提到过保护模式是 80286 的产物，因此 A20 总线应该总是开启，由于 intel 选择使用 8042 键盘控制器来实现前面提到特殊的门结构，而此时键盘缓冲仍被占用，因此我们写入数据之前还要进行等待然后再写入数据</li>
</ul>
<pre><code># Enable A20:
# For backwards compatibility with the earliest PCs, physical
# address line 20 is tied low, so that addresses higher than
# 1MB wrap around to zero by default. This code undoes this.
seta20.1:
inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).
testb $0x2, %al
jnz seta20.1

movb $0xd1, %al                                 # 0xd1 -\&gt; port 0x64
outb %al, $0x64                                 # 0xd1 means: write data to 8042&apos;s P2 port

seta20.2:
inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).
testb $0x2, %al
jnz seta20.2


movb $0xdf, %al                                 # 0xdf -\&gt; port 0x60
outb %al, $0x60                                 # 0xdf = 11011111, means set P2&apos;s A20 bit(the 1 bit) to 1
</code></pre><p><br></p>
<h4 id="lgdt-amp-设置-cr0-寄存器"><a href="#lgdt-amp-设置-cr0-寄存器" class="headerlink" title="lgdt &amp; 设置 cr0 寄存器"></a>lgdt &amp; 设置 cr0 寄存器</h4><ul>
<li>lgdt 指令专门用来设置 gdtr</li>
</ul>
<ul>
<li>cr0 主要用于存储两个标志位，保护模式和分页，理论上来讲，设置了这个位 cpu 就进入了保护模式，但是知道新值载入到段寄存器 CS，地址转换的过程都不会发生变化</li>
</ul>
<pre><code># Switch from real to protected mode, using a bootstrap GDT
# and segment translation that makes virtual addresses
# identical to physical addresses, so that the
# effective memory map does not change during the switch.
lgdt gdtdesc
movl %cr0, %eax
orl $CR0\_PE\_ON, %eax
movl %eax, %cr0
</code></pre><p><br></p>
<h4 id="切换-32-位模式"><a href="#切换-32-位模式" class="headerlink" title="切换 32 位模式"></a>切换 32 位模式</h4><ul>
<li>下面第一行的远跳转指令中 PROT_MODE_CSEG 为 0000 0000 0000 1000 即是GDT中的第1个段，即代码段，intel 不允许直接修改 cs 寄存器所以这里使用跳转指令，protcseg 偏移量</li>
</ul>
<ul>
<li>.code32 的作用和前面提到 .code16 对应，现在打开了 cr0 的保护模式标志，cpu 就按保护模式的方式寻址，那么这里就应该告诉编译器切换到 32 位模式 protcseg 即为段内偏移</li>
</ul>
<pre><code># Jump to next instruction, but in 32-bit code segment.
# Switches processor into 32-bit mode.
ljmp $PROT\_MODE\_CSEG, $protcseg
.code32                                        # Assemble for 32-bit mode
protcseg:
# Set up the protected-mode data segment registers
movw $PROT\_MODE\_DSEG, %ax                       # Our data segment selector
movw %ax, %ds                                   # -\&gt; DS: Data Segment
movw %ax, %es                                   # -\&gt; ES: Extra Segment
movw %ax, %fs                                   # -\&gt; FS
movw %ax, %gs                                   # -\&gt; GS
movw %ax, %ss                                   # -\&gt; SS: Stack Segment

# Set up the stack pointer and call into C. The stack region is from 0--start(0x7c00)
movl $0x0, %ebp
movl $\_start, %esp

call kernel\_main
spin:
jmp spin
# If bootmain returns (it shouldn&apos;t), loop.
</code></pre><p><strong>本文完</strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[计算机网络系列 5 - 防火墙 & NAT]]></title>
      <url>/2018/11/08/NetGateWayNAT/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><br></p>
<h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><ul>
<li>早期因特网发展时很少有人关心安全问题，如今要确保所有端系统中的问题都被修复已经非常困难，因此确保端系统免受攻击的焦点转为利用防火墙来过滤部分流量以限制流量流向端系统</li>
</ul>
<ul>
<li>防火墙分为两类，包过滤防火墙和代理防火墙</li>
</ul>
<p><br></p>
<h3 id="包过滤防火墙"><a href="#包过滤防火墙" class="headerlink" title="包过滤防火墙"></a>包过滤防火墙</h3><ul>
<li>包过滤防火墙是一种路由器，能够过滤（丢弃）一些数据包，通常检查的范围如下，有些防火墙是无状态的，只是单独处理每一个包，有状态的防火墙可以关联已经到来或即将到来的数据报来推断流或数据报的信息，并且能够处理ip分片</li>
</ul>
<pre><code>源地址
目的地址
目的设备的端口号(请求类型)
该数据包所属的协议(TCP、UDP等等)
数据包的传输方向，向外传到因特网或向内传给局域网
数据库中既定数据包的署名
</code></pre><ul>
<li>通常包过滤防火墙的配置如下，其中DMZ称为非军事区，DMZ子网和内网均能访问外网，外网和内网均能访问DMZ子网，但DMZ子网和外网都不能访问内网，这样在隔离内外网的情况下，内网依然可以利用DMZ提供一些对外服务，包过滤防火墙通过访问控制表ACL实现这些要求</li>
</ul>
<pre><code>| DMZ | -----------|       |
                   | 包过滤 |---------| 外网 |
                   | 防火墙 |
| 内网 |  --------- |       |
</code></pre><p><br></p>
<h3 id="代理防火墙"><a href="#代理防火墙" class="headerlink" title="代理防火墙"></a>代理防火墙</h3><ul>
<li>代理防火墙通常不是真正的路由器，没有ip转发的功能，而是运行应用层网关的主机，它在应用层中继两个连接的特点类型的流量，因此客户端通常只需要一定配置来连接防火墙，而不是实际连接到运行防火墙的物理终端</li>
</ul>
<ul>
<li>常见的代理防火墙如：http代理防火墙(也叫web代理)用来提供web缓存，进行过滤过滤，或防止被过滤(如隧道代理)。SOCKS代理，可以用于web及以外的功能，如udp传输，ipv6寻址等</li>
</ul>
<pre><code>                     | 代理   |
| 客户端 |----------- | 防火墙 |---------| 外网 |
                     |       |
</code></pre><p><br></p>
<h3 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h3><ul>
<li>NAT本质是一种允许在互联网的不同地方重复使用相同ip地址集的机制(设置了NAT之后网络可以被分为公网和私网两部分)，用于解决ip地址资源枯竭和问题和提高路由可扩展性，由于NAT本质是临时方案，因此这两个问题最终是被ipv6和cidr解决的(见前几篇)。NAT具有一些缺点，因为互联网上的设备无法直接访问私有地址的主机，连接双向的数据报都需要通过相同的NAT，NAT和互联网协议的基本宗旨相违背，它需要跟踪多个状态，因此操作会贯穿多个协议层，NAT面对的最重要的问题是分片的ip数据报中可能没有端口号，这导致NAT一般不能正确处理分片的情况，另一个问题是两个NAT系统中的内部主机如何通讯的问题，可以通过NAT穿越来解决。NAT的使用目前依然非常广泛，基本上被所有家用低端路由器支持</li>
</ul>
<ul>
<li>NAT的工作原理就是重写通过路由器的数据报的识别信息，包括两个方向的ip地址和端口号，传出的数据报的源ip地址会变为NAT路由器面向Internet的网络接口地址而不是原始主机的接口地址，从互联网上的主机来看，数据报来自于具有全局路由ip的NAT路由器，而不是NAT内部的私有地址主机，大多数NAT路由器还同时执行转换和包过滤，包过滤的标准取决于NAT的动态状态</li>
</ul>
<ul>
<li>传统的NAT包括：基本NAT和NAPT。基本NAT只执行IP地址的重写，本质上就是将私有地址改写为公共地址，该公共地址一般来自ips提供的地址池或公有地址访问，地址范围必须大于或等于希望同时访问Internet的主机数量，这种类型的NAT较少使用。NATP则使用传输层标识符（tcp和udp端口号，icmp查询标识符）来确定一个特点的数据包到底和NAT内部的哪台私有主机关联，这使得大量的内部主机可以同时访问互联网，但需要的公有地址往往只需一个，因此为了避免冲突有时需要重写端口号，我们说的NAT通常包含传统的NAT和NAPT</li>
</ul>
<ul>
<li>地址池：原则上NAT内部可以使用任何ip地址，只是如果在私有范围内使用公共地址，可能导致公共范围的共用地址无法访问，因此一般使用10.0.0.0/8,172.16.0.0/12,192.168.0.0/16，NAT实现了一定的安全策略，几乎允许所有传出及其返回的流量通过，但几乎阻断所有传入的连接请求，这样可以抑制ip地址的“探测”攻击，对外隐藏内部的地址数量和配置</li>
</ul>
<p><br></p>
<h3 id="NAT-amp-TCP-amp-UDP"><a href="#NAT-amp-TCP-amp-UDP" class="headerlink" title="NAT &amp; TCP &amp; UDP"></a>NAT &amp; TCP &amp; UDP</h3><ul>
<li>tcp相关的内容在后面几篇，当NAT收到一个向外的syn报文段时，会将源ip地址修改为NAT路由器的外部接口的ip地址，并创建一个会话状态来记录连接，该状态至少包含一个端口号和一个源IP地址，这样NAT可以通过端口号来映射ip地址，在数据包出入NAT路由器时修改这些ip地址</li>
</ul>
<ul>
<li>会话状态会在如下几个情况下被删除，双方交换fin报文段(正常关闭)，状态会在流量很少或收到rst报文段(非正常关闭)，NAT还会在传出一个syn报文段使设置连接计时器，如果ack未按时到达，状态会被删除，若ack按时到达则开启一个超长的会话计时器，当超时时会向内部节点发送探测报文，如果收到探测报文的ack就重置计时器，表示连接还处于激活状态，如果ack超时则删除会话状态</li>
</ul>
<ul>
<li>NAT在处理udp时需要处理的问题和tcp大多数是一样的，但udp缺少连接建立和清除的过程，没有syn fin等标志位，因此NAT使用一个映射计时器来清除NAT的状态</li>
</ul>
<p><br></p>
<h3 id="NAT穿越"><a href="#NAT穿越" class="headerlink" title="NAT穿越"></a>NAT穿越</h3><ul>
<li>NAT穿越一般是指使用一个服务器作为多个NAT系统的中继来实现客户端之间的通信，因为NAT不允许为建立连接的外部请求，因此任一方都无法直接向对方建立请求，利用服务器建立连接的过程称为打洞，大致流程为两个客户端通过向外连接来访问服务器，这样就建立了两个NAT映射，服务器可以在客户端之间交换它们的外部寻址信息，一旦知道这个信息，客户端就可以进行直接连接</li>
</ul>
<ul>
<li>具体的打洞流程如UNSAF和STUN之后如果有时间会进行补充</li>
</ul>
<p><br><br><strong>本篇完</strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[计算机网络系列 4 - 数据链路层]]></title>
      <url>/2018/11/07/NetEthernet/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><br></p>
<h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h3><p><br></p>
<h4 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h4><ul>
<li><p>以太网(Ethernet)指的是由Xerox公司创建的局域网规范，IEEE 将其稍微修改定义了 802.3 标准，我们现在指以太网帧大多数是指 802.3 帧</p>
</li>
<li><p>早期以太网包含一个或多个站，多个站共享电缆段，使用 CSMA/CD 解决冲突</p>
</li>
<li><p>目前基于竞争的以太网不再流行，每个站用一条专用线路连接到交换机端口，不再需要 CSMA/CD 协议</p>
</li>
</ul>
<p><br></p>
<h4 id="以太网帧结构"><a href="#以太网帧结构" class="headerlink" title="以太网帧结构"></a>以太网帧结构</h4><table>
<thead>
<tr>
<th>长度</th>
<th>字段</th>
<th>目的</th>
</tr>
</thead>
<tbody>
<tr>
<td>7</td>
<td>前导码</td>
<td>同步</td>
</tr>
<tr>
<td>1</td>
<td>帧开始符 SFD</td>
<td>恢复时钟并表示下1字节为MAC字段</td>
</tr>
<tr>
<td>6</td>
<td>目的 MAC</td>
<td>指明帧的接受者</td>
</tr>
<tr>
<td>6</td>
<td>源 MAC</td>
<td>指明帧的发送者</td>
</tr>
<tr>
<td>2</td>
<td>长度 Length</td>
<td>帧的数据字段的长度或类型</td>
</tr>
<tr>
<td>2</td>
<td>类型 Type</td>
<td>帧中数据的协议长度或类型</td>
</tr>
<tr>
<td>46-1500</td>
<td>数据和填充 Data and Pad</td>
<td>高层的数据，通常为3层协议数据单元。对于TCP/IP是IP数据包</td>
</tr>
<tr>
<td>4</td>
<td>校验序列 FCS</td>
<td>CRC 校验</td>
</tr>
</tbody>
</table>
<p><br></p>
<h4 id="帧大小"><a href="#帧大小" class="headerlink" title="帧大小"></a>帧大小</h4><ul>
<li>最小帧 64 字节，有效载荷最小为 48 字节，保证 CSMA/CD 能探测冲突</li>
</ul>
<ul>
<li>最大帧 1518 字节,避免错误重发时的损耗</li>
</ul>
<ul>
<li>非标准扩展中的以太网巨型帧大小可以远远超于 1518 字节</li>
</ul>
<p><br></p>
<h4 id="VLAN-及-QoS"><a href="#VLAN-及-QoS" class="headerlink" title="VLAN 及 QoS"></a>VLAN 及 QoS</h4><p><strong>避免组播和广播流量盲目消耗带宽，可以使用 VLAN 进行流量分隔</strong></p>
<ul>
<li>VLAN 划分方法有四种，基于端口，基于mac地址，基于路由，基于策略</li>
</ul>
<ul>
<li>不同 VLAN 的主机连接同一交换机时，交换机保证流量不互相泄漏</li>
</ul>
<ul>
<li>不同 VLAN 的主机跨越多个交换机时，交换机负责用 VLAN 标记和确定帧的归属</li>
</ul>
<ul>
<li>以太网帧中的QoS字段用 3 有效位定义了 8 个优先级，但优先级的实现并没有定义</li>
</ul>
<p><br></p>
<h4 id="VLAN-特点"><a href="#VLAN-特点" class="headerlink" title="VLAN 特点"></a>VLAN 特点</h4><ul>
<li>分段，一个VLAN就是一个网段，也是一个广播域打破传统 交换机只有一个广播域的限制</li>
</ul>
<ul>
<li>管理灵活，修改VLAN设置可以减少设置路由信息和ip配置</li>
</ul>
<ul>
<li>安全性，隔离网段之间的用户访问，控制广播域的大小位置</li>
</ul>
<p><br></p>
<h4 id="VLAN-划分方法"><a href="#VLAN-划分方法" class="headerlink" title="VLAN 划分方法"></a>VLAN 划分方法</h4><p><br></p>
<h5 id="基于端口的VLAN"><a href="#基于端口的VLAN" class="headerlink" title="基于端口的VLAN"></a>基于端口的VLAN</h5><ul>
<li>多交换机端口定义VLAN，多个交换机中多个端口分别标记VLAN，支持多个交换机</li>
</ul>
<ul>
<li>单交换价端口定义VLAN，单个交换机中不同端口分别标记VLAN，只支持一个交换机</li>
</ul>
<ul>
<li>优点，简单有效</li>
</ul>
<ul>
<li>缺点，用户从一个端口移动到另一个端口时必须重新配置</li>
</ul>
<p><br></p>
<h5 id="基于MAC地址的VLAN"><a href="#基于MAC地址的VLAN" class="headerlink" title="基于MAC地址的VLAN"></a>基于MAC地址的VLAN</h5><ul>
<li>原理，使用终端系统的mac地址定义VLAN</li>
</ul>
<ul>
<li>优点，允许工作站移动到网络的其他物理网段，而保持原来的VLAN成员资格</li>
</ul>
<ul>
<li>缺点，随着网络规模的增大，管理难度也增大</li>
</ul>
<p><br></p>
<h5 id="基于路由的VLAN"><a href="#基于路由的VLAN" class="headerlink" title="基于路由的VLAN"></a>基于路由的VLAN</h5><ul>
<li>原理，路由协议工作在7层协议的第3层-网络层，比如基于IP和IPX的路由协议，这类设备包括路由器和路由交换机。该方式允许一个VLAN跨越多个交换机，或一个端口位于多个VLAN中。在按IP划分的VLAN中，很容易实现路由，即将交换功能和路由功能融合在VLAN交换机</li>
</ul>
<ul>
<li>优点，这种方式既达到了作为VLAN控制广播风暴的最基本目的，又不需要外接路由器</li>
</ul>
<ul>
<li>缺点，对VLAN成员之间的通信速度不是很理想</li>
</ul>
<p><br></p>
<h5 id="基于策略的VLAN"><a href="#基于策略的VLAN" class="headerlink" title="基于策略的VLAN"></a>基于策略的VLAN</h5><ul>
<li>原理，同时使用三种进行融合划分</li>
</ul>
<ul>
<li>优点，控制广播风暴、增强网络的安全性、增强网络管理</li>
</ul>
<p><br></p>
<h4 id="链路聚合"><a href="#链路聚合" class="headerlink" title="链路聚合"></a>链路聚合</h4><p><strong>对于拥有多个网络接口的系统，链路聚合使多个接口被视为一个</strong></p>
<ul>
<li><p>多个链路聚合可以提供更高的带宽，成本比高速的接口更便宜</p>
</li>
<li><p>LACP协议用于避免手工配置链路聚合的建立工作，LACP 协议使用特定的 802 帧</p>
</li>
</ul>
<p><br></p>
<h3 id="网桥-交换机"><a href="#网桥-交换机" class="headerlink" title="网桥/交换机"></a>网桥/交换机</h3><p><strong>网桥或交换机用于连接多个物理的链路层网络，交换机本质上是高性能的网桥</strong></p>
<p><br></p>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ul>
<li><p>交换机互联形成扩展的局域网，其中包括交换机在内的每个节点都有自己的 mac 地址</p>
</li>
<li><p>交换机通过“学习”建立端口列表（过滤数据库），即将帧的源地址和对应的端口添加到表中</p>
</li>
<li><p>每学习一个地址后，网桥启动一个计时器（通常为5分钟），在有效期内没有再次看见该地址，就将其删除</p>
</li>
<li><p>每次接收到目的地不是自己的帧时，交换机为所有的端口发送帧的备份</p>
</li>
</ul>
<p><br></p>
<h4 id="使用-pc-作为交换机"><a href="#使用-pc-作为交换机" class="headerlink" title="使用 pc 作为交换机"></a>使用 pc 作为交换机</h4><ul>
<li>多数操作系统支持网络接口之间的网桥功能，这意味着有多个接口的计算机可以用作网桥</li>
</ul>
<ul>
<li>在 Linux 上安装 bridge-utils，可以使用如下命令将 pc 作为网桥</li>
</ul>
<pre><code>brctl addbr br0 # 创建网桥
brctl addif br0 eth0 # 为网桥增加接口 eth0
brctl addif br0 eth1 # 为网桥增加接口 eth1
ifconfig eth0 up # 启动 eth0
ifconfig eth1 up  # 启动 eth1
ifconfig br0 up  # 启动 br0
</code></pre><p><br></p>
<h4 id="生成树协议"><a href="#生成树协议" class="headerlink" title="生成树协议"></a>生成树协议</h4><p><strong>网桥与其他网桥共同运行时可能存在级联关系导致帧循环</strong></p>
<p><br></p>
<h5 id="STP"><a href="#STP" class="headerlink" title="STP"></a>STP</h5><ul>
<li>STP (生成树) 协议使用分布式的算法在多个网桥之间建立成本最低的生成树，在新的标准中已经被 RSTP (快速生成树) 协议替代</li>
</ul>
<ul>
<li>STP 实现原理是：在每个网桥禁用一些端口，以及根据链路速度计算到根网桥的最小成本</li>
</ul>
<p><br></p>
<h5 id="BPDU"><a href="#BPDU" class="headerlink" title="BPDU"></a>BPDU</h5><ul>
<li>BPDU(网桥协议数据单元) 是 STP用来形成和维护生成树的帧</li>
</ul>
<ul>
<li>网桥端口有 5 种状态</li>
</ul>
<pre><code>阻塞：不学习，不转发数据，接受 BPDU
侦听：不学习，不转发数据，收发 BPDU
学习：学习，不转发数据，收发 BPDU
转发：学习，转发数据，收发 BPDU
禁用：不学习，不转发数据，不收发 BPDU
</code></pre><ul>
<li>状态转换过程，注意所有初始化外的状态都可以转为禁用</li>
</ul>
<pre><code>初始化
 |
 |\&lt;--------------------------------------------|
 V    最大时间 20s             转发延迟 15s     |
阻塞 ---------------\&gt; 监听 ------------------\&gt; 学习
 A                                              |
 |                                              |  转发延迟 15s
 |      拓扑改变                 拓扑改变          |  
 |\&lt;------------------ 转发 \&lt;---------------------|
                   --&gt;禁用
</code></pre><ul>
<li>端口有四种常见角色</li>
</ul>
<pre><code>根端口：指向根的线段的终点的端口
指定端口：用于转发状态并与根相连的线段中路径成本最小的端口
备用端口: 比指定端口成本高的端口
备份端口：连接到同一线段作为同一网桥指定端口使用的端口
</code></pre><ul>
<li>BPDU 帧结构</li>
</ul>
<p><br></p>
<h5 id="建立生成树"><a href="#建立生成树" class="headerlink" title="建立生成树"></a>建立生成树</h5><p><strong>未完待续</strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Dart 语言 入门]]></title>
      <url>/2018/11/03/LangDart/</url>
      <content type="html"><![CDATA[<p>-</p>
<p>无聊的时候，学点 Dart</p>
<a id="more"></a>
<p><strong>如果想更全面地了解 dart2 的特性，可以查看官方<a href="https://api.dartlang.org/stable/2.0.0/index.html" target="_blank" rel="external">文档</a></strong><br><strong>本文大部分是以前从官网摘要然后翻译来的，目前dart中文网已有翻译，建议去那里阅读</strong></p>
<p><br></p>
<h3 id="基本样例"><a href="#基本样例" class="headerlink" title="基本样例"></a>基本样例</h3><p><strong>可以在<a href="https://dartpad.cn/" target="_blank" rel="external">这里</a>运行代码（无需翻墙）</strong></p>
<pre><code>// 函数定义
printInteger(int aNumber) {
  print(&apos;The number is $aNumber.&apos;); // Print to console.
}

// 应用从这里开始执行
main() {
  var number = 42; // Declare and initialize a variable.
  printInteger(number); // Call a function.
}
</code></pre><p><br></p>
<h3 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h3><ul>
<li>注释</li>
</ul>
<pre><code>// This is a comment.
</code></pre><ul>
<li>一切变量皆对象，一切对象皆 Object</li>
</ul>
<ul>
<li>dart 是强类型语言，但 dart 支持类型推断（使用 var），也支持声明非限定的类型（使用 dynamic）</li>
</ul>
<ul>
<li>dart 支持泛型</li>
</ul>
<pre><code>List&lt;int&gt; ，List&lt;dynamic&gt;（List中的对象可以是任何类型）
</code></pre><ul>
<li>dart 支持顶级函数（如 main），类（静态）函数，实例函数，闭包（函数内定义的函数）</li>
</ul>
<ul>
<li>dart 支持静态变量和实例变量（属性）</li>
</ul>
<ul>
<li>dart 没有  public, protected, private 字段，但可以使用下滑线开始的名称使其只能在库中使用</li>
</ul>
<ul>
<li>dart 包含表达式和语句，表达式可以作为值</li>
</ul>
<ul>
<li>dart tools 可以报告两种问题，warnings 和 errors. 编译时 error 直接导致代码无法运行，运行时 error 则将抛出异常</li>
</ul>
<p><br></p>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>abstract</td>
<td>dynamic</td>
<td>implements</td>
<td>show</td>
</tr>
<tr>
<td>as</td>
<td>else</td>
<td>import</td>
<td>static</td>
</tr>
<tr>
<td>assert</td>
<td>enum</td>
<td>in</td>
<td>super</td>
</tr>
<tr>
<td>async</td>
<td>export</td>
<td>interface</td>
<td>switch</td>
</tr>
<tr>
<td>await</td>
<td>external</td>
<td>is</td>
<td>sync</td>
</tr>
<tr>
<td>break</td>
<td>extends</td>
<td>library</td>
<td>this</td>
</tr>
<tr>
<td>case</td>
<td>factory</td>
<td>mixin</td>
<td>throw</td>
</tr>
<tr>
<td>catch</td>
<td>false</td>
<td>new</td>
<td>true</td>
</tr>
<tr>
<td>class</td>
<td>final</td>
<td>null</td>
<td>try</td>
</tr>
<tr>
<td>const</td>
<td>finally</td>
<td>on</td>
<td>typedef</td>
</tr>
<tr>
<td>continue</td>
<td>for</td>
<td>operator</td>
<td>var</td>
</tr>
<tr>
<td>covariant</td>
<td>Function</td>
<td>part</td>
<td>void</td>
</tr>
<tr>
<td>default</td>
<td>get</td>
<td>rethrow</td>
<td>while</td>
</tr>
<tr>
<td>deferred</td>
<td>hide</td>
<td>return</td>
<td>with</td>
</tr>
<tr>
<td>do</td>
<td>if</td>
<td>set</td>
<td>yield</td>
</tr>
</tbody>
</table>
<p><br></p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p><br></p>
<h4 id="var"><a href="#var" class="headerlink" title="var"></a>var</h4><pre><code>var name = &apos;Bob&apos;;
</code></pre><ul>
<li>name 的类型被推断为 String</li>
</ul>
<pre><code>String name = &apos;Bob&apos;;
</code></pre><ul>
<li>也可指定类型，如果变量不需要类型限定可以使用 object 或 dynamic 类型</li>
</ul>
<p><br></p>
<h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><ul>
<li>一切变量的默认值都是 null，int double…也是如此，毕竟一切皆变量</li>
</ul>
<pre><code>int lineCount;
assert(lineCount == null);
//assert 在正式版本中会被忽略，在开发版本中根据条件判断是否抛出异常
</code></pre><p><br></p>
<h4 id="Final-和-const"><a href="#Final-和-const" class="headerlink" title="Final 和 const"></a>Final 和 const</h4><ul>
<li>final 和 const 引用只能赋值一次</li>
</ul>
<pre><code>final name = &apos;Bob&apos;; // Without a type annotation
final String nickname = &apos;Bobby&apos;;
const nickname2 = &quot;...&quot;;
</code></pre><ul>
<li>final 和 const 的其中一个区别是，const可以用于定义编译时变量，这意味着它的值会在编译时被展开，算是一种优化，而final会被延迟到第一次使用前才赋值</li>
</ul>
<pre><code>const bar = 1000000; // Unit of pressure (dynes/cm2)
const double atm = 1.01325 \* bar; // Standard atmosphere
</code></pre><ul>
<li>另一个区别是，const 可以用于限定常量值，它修饰的容器是只读的常量容器</li>
</ul>
<pre><code>const baz = []; //baz是常量
var foo = const []; //foo的值都是常量，即右边这个数组只能放常量
baz = [42]; //改变 baz，报错
var test = const[1,2,intVar];//如果 intVar 是 const 正确，否则报错
test[1]() = 2//错误，test不能修改
</code></pre><p><br></p>
<h3 id="内建类型"><a href="#内建类型" class="headerlink" title="内建类型"></a>内建类型</h3><p><br></p>
<h4 id="七大类型"><a href="#七大类型" class="headerlink" title="七大类型"></a>七大类型</h4><ul>
<li>numbers</li>
<li>strings</li>
<li>booleans</li>
<li>lists </li>
<li>maps</li>
<li>runes </li>
</ul>
<p><br></p>
<h4 id="Numbers"><a href="#Numbers" class="headerlink" title="Numbers"></a>Numbers</h4><ul>
<li>int，长度小于 64 位 ，具体大小与平台相关，dart vm 上为 -263 到 263 - 1，如果编译为 js 则为 -253 到 253 - 1</li>
</ul>
<ul>
<li>double，64 位浮点型</li>
</ul>
<ul>
<li>numbers 与 String 互换</li>
</ul>
<pre><code>// String -\&gt; int
var one = int.parse(&apos;1&apos;);
assert(one == 1);
// String -\&gt; double
var onePointOne = double.parse(&apos;1.1&apos;);
assert(onePointOne == 1.1);
// int -\&gt; String
String oneAsString = 1.toString();
assert(oneAsString == &apos;1&apos;);
// double -\&gt; String
String piAsString = 3.14159.toStringAsFixed(2);
assert(piAsString == &apos;3.14&apos;);
</code></pre><p><br></p>
<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><ul>
<li>创建 String,使用 单引号 或 双引号</li>
</ul>
<pre><code>var s1 = &apos;Single quotes work well for string literals.&apos;;
var s2 = &quot;Double quotes work just as well.&quot;;
var s3 = &apos;It\&apos;s easy to escape the string delimiter.&apos;;
var s4 = &quot;It&apos;s even easier to use the other delimiter.&quot;;
</code></pre><ul>
<li>String 支持支持多行，不需要引号以外的其他符号，像多个字符串一样罗列即可</li>
</ul>
<pre><code>var s1 = &apos;String &apos;
     &apos;concatenation&apos;
     &quot; works even over line breaks.&quot;;
 assert(s1 ==
     &apos;String concatenation works even over &apos;
         &apos;line breaks.&apos;);
 var s2 = &apos;The + operator &apos; + &apos;works, as well.&apos;;
 assert(s2 == &apos;The + operator works, as well.&apos;);
</code></pre><ul>
<li>三引号实现换行，适用于长文本</li>
</ul>
<pre><code> var s1 = &apos;&apos;&apos;
You can create
multi-line strings like this one.
\&apos;&apos;&apos;;
  var s2 = &quot;&quot;&quot;This is also a
multi-line string.&quot;&quot;&quot;;
</code></pre><ul>
<li>嵌入表达式，使用 ${expression}，如果表达式是一个变量，可以去掉括号，该变量的toString函数会被用于转换字符串</li>
</ul>
<pre><code>var s = &apos;string interpolation&apos;;
 assert(&apos;Dart has $s, &apos;
     &apos;which is very handy.&apos; ==
     &apos;Dart has string interpolation, &apos;
     &apos;which is very handy.&apos;);
 assert(&apos;That deserves all caps. &apos;
     &apos;${s.toUpperCase()} is very handy!&apos; ==
     &apos;That deserves all caps. &apos;
     &apos;STRING INTERPOLATION is very handy!&apos;);
</code></pre><ul>
<li>创建 raw String, 使用 r’XXX’，raw String中的字符不会被特殊处理，下面的 \n 不会换行</li>
</ul>
<pre><code>var s = r&apos;In a raw string, not even \n gets special treatment.&apos;;
</code></pre><ul>
<li>由常量构成的字符串字面量才是编译时常量,否则不能使用 const 关键字</li>
</ul>
<pre><code>// These work in a const string.
  const aConstNum = 0;
  const aConstBool = true;
  const aConstString = &apos;a constant string&apos;;
// These do NOT work in a const string.
  var aNum = 0;
  var aBool = true;
  var aString = &apos;a string&apos;;
  const aConstList = [1, 2, 3];
  const validConstString = &apos;$aConstNum $aConstBool $aConstString&apos;;
  const invalidConstString = &apos;$aNum $aBool $aString $aConstList&apos;;
</code></pre><p><br></p>
<h4 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h4><ul>
<li>在 dart 中，数组就是 list，用法和 js 类似</li>
</ul>
<pre><code>var list = [1, 2, 3];
</code></pre><ul>
<li>list 从0计数</li>
</ul>
<pre><code>var list = [1, 2, 3];
assert(list.length == 3);
assert(list[1][4] == 2);
list[1][5] = 1;
assert(list[1][6] == 1);
</code></pre><ul>
<li>创建只读的运行时常量容器，使用 const关键字</li>
</ul>
<pre><code>var constantList = const [1, 2, 3];
// constantList[1][7] = 1; // 错误，constantList只读
</code></pre><p><br></p>
<h4 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h4><ul>
<li>map 是基于键值对的数据结构</li>
</ul>
<ul>
<li><p>使用花括号创建 map</p>
<p>  var gifts = {</p>
<pre><code>// Key:    Value
&apos;first&apos;: &apos;partridge&apos;,
&apos;second&apos;: &apos;turtledoves&apos;,
&apos;fifth&apos;: &apos;golden rings&apos;
</code></pre><p>  };<br>  var nobleGases = {</p>
<pre><code>2: &apos;helium&apos;,
10: &apos;neon&apos;,
18: &apos;argon&apos;,
</code></pre><p>  };</p>
</li>
</ul>
<ul>
<li>使用构造函数创建 map</li>
</ul>
<pre><code>var gifts = Map();
gifts[&apos;first&apos;] = &apos;partridge&apos;;
gifts[&apos;second&apos;] = &apos;turtledoves&apos;;
gifts[&apos;fifth&apos;] = &apos;golden rings&apos;;
var nobleGases = Map();
nobleGases[2][8] = &apos;helium&apos;;
nobleGases[10][9] = &apos;neon&apos;;
nobleGases[18] = &apos;argon&apos;;
</code></pre><ul>
<li>存入键值对，类似 js</li>
</ul>
<pre><code>var gifts = {&apos;first&apos;: &apos;partridge&apos;};
gifts[&apos;fourth&apos;] = &apos;calling birds&apos;; // Add a key-value pair
</code></pre><ul>
<li>如果键不存在，获取时返回null</li>
</ul>
<pre><code>var gifts = {&apos;first&apos;: &apos;partridge&apos;};
assert(gifts[&apos;fifth&apos;] == null);
</code></pre><ul>
<li>.length 返回 map 的大小</li>
</ul>
<pre><code>var gifts = {&apos;first&apos;: &apos;partridge&apos;};
gifts[&apos;fourth&apos;] = &apos;calling birds&apos;;
assert(gifts.length == 2);
</code></pre><ul>
<li>创建运行时常量的只读 map,使用 const</li>
</ul>
<pre><code>final constantMap = const {
  2: &apos;helium&apos;,
  10: &apos;neon&apos;,
  18: &apos;argon&apos;,
};
// constantMap[2][10] = &apos;Helium&apos;; // 错误，只读 
</code></pre><p><br></p>
<h4 id="Runes"><a href="#Runes" class="headerlink" title="Runes"></a>Runes</h4><ul>
<li><p>runes 用于表示 UTF-32 字符</p>
<p>   var clapping = ‘\u{1f44f}’;</p>
<pre><code>print(clapping);
print(clapping.codeUnits);
print(clapping.runes.toList());
Runes input = new Runes(
    &apos;\u2665  \u{1f605}  \u{1f60e}  \u{1f47b}  \u{1f596}  \u{1f44d}&apos;);
print(new String.fromCharCodes(input)); //web storm 的控制台中会输出 emoji
</code></pre></li>
</ul>
<p><br></p>
<h4 id="Symbols"><a href="#Symbols" class="headerlink" title="Symbols"></a>Symbols</h4><ul>
<li>symbol 代表一个操作符或描述符，用于 dart 反射机制</li>
</ul>
<ul>
<li>这个类型一般比较少用到，相关概念可以参考<a href="http://www.cndartlang.com/987.html" target="_blank" rel="external">这里</a></li>
</ul>
<p><br></p>
<h4 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h4><p><br></p>
<h5 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h5><ul>
<li>在 dart 中，函数也是对象</li>
</ul>
<pre><code>bool isNoble(int atomicNumber) {
  return \_nobleGases[atomicNumber] != null;
}
</code></pre><ul>
<li>参数可以省略类型</li>
</ul>
<pre><code>isNoble(atomicNumber) {
  return \_nobleGases[atomicNumber] != null;
}
</code></pre><ul>
<li>函数体只包含一个表达式时，可以使用 => 进行简化</li>
</ul>
<pre><code>bool isNoble(int atomicNumber) =\&gt; \_nobleGases[atomicNumber] != null;
</code></pre><ul>
<li>函数有两种参数类型，required(必填) 和 optional(可选)，不使用括号修饰的参数是 required 参数，调用时必填</li>
</ul>
<pre><code>void test(int a,int b){
}
</code></pre><ul>
<li>命名参数，使用花括号修饰的命名参数是可选参数，调用时需要指出参数名,不需要按定义的顺序，这种调用方法增加了代码可读性</li>
</ul>
<pre><code>main() {
  test(b: 1, a: 2);
}
void test({int a, int b}) {}
</code></pre><ul>
<li>位置参数，使用中括号修饰的位置参数是可选参数，调用时不需要指明参数名，参数按声明的位置传入</li>
</ul>
<pre><code>main() {
  test(1,2);
}
void test([int a,int b]){
}
</code></pre><ul>
<li>必填参数可以和可选参数可以混用，但是可选参数需要放在必填参数后面</li>
</ul>
<pre><code>main() {
  test(0,a: 1);
}
void test(int c,{int a} ) {
  print(a);
}
</code></pre><ul>
<li>可选参数可以设置默认值，注意并不是设置了默认值就可避免空指针异常，毕竟外部依然可以传入 null，list 和 map 参数也同样可以设置默认值</li>
</ul>
<pre><code>main() {
  test(0,a: 1);
  doStuff();
}
void test(int c,{int a, int b = 3} ) {
  print(b); //3
}
void doStuff(
    {List&lt;int&gt; list = const [1, 2, 3],
    Map&lt;String, String&gt; gifts = const {
      &apos;first&apos;: &apos;paper&apos;,
      &apos;second&apos;: &apos;cotton&apos;,
      &apos;third&apos;: &apos;leather&apos;
    }}) {
  print(&apos;list:  $list&apos;);
  print(&apos;gifts: $gifts&apos;);
}
</code></pre><p><br></p>
<h5 id="主函数-main"><a href="#主函数-main" class="headerlink" title="主函数 main"></a>主函数 main</h5><ul>
<li>每个应用必须包含一个 main 函数，main 函数是应用的入口</li>
</ul>
<ul>
<li>main 函数的参数可以为空，或者为 List\&lt;String</li>
</ul>
<p><br></p>
<h5 id="函数是第一类对象（一等公民）"><a href="#函数是第一类对象（一等公民）" class="headerlink" title="函数是第一类对象（一等公民）"></a>函数是第一类对象（一等公民）</h5><ul>
<li>函数可以作为对象传递</li>
</ul>
<pre><code>void main() { 
  list.forEach(printElement); //将函数 printElement 作为对象传递
}
void printElement(int element) {
  print(element);
}
var list = [1, 2, 3];
</code></pre><ul>
<li>函数可以作为对象声明</li>
</ul>
<pre><code>//声明一个匿名函数对象
 var loudify = (msg) =\&gt; &apos;!!! ${msg.toUpperCase()} !!!&apos;;
 //调用它
 assert(loudify(&apos;hello&apos;) == &apos;!!! HELLO !!!&apos;);
</code></pre><p><br></p>
<h5 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h5><ul>
<li>使用 （类型 参数）{} 的形式</li>
</ul>
<pre><code>void main() {
  var list =  [&quot;saf&quot;, &quot;asdf&quot;, &quot;asdf&quot;];
  list.forEach((item) {
    print(item);
  });
}
</code></pre><ul>
<li>如果函数只有一个参数，可以使用 => 进行简化</li>
</ul>
<pre><code>&apos;list.forEach(
    (item) =&gt; print(&apos;${list.indexOf(item)}: $item&apos;));
</code></pre><p><br></p>
<h4 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h4><ul>
<li>dart 是一门词法作用域语言，这意味着变量的作用域是在编译的词法分析阶段就用代码的布局决定了</li>
</ul>
<pre><code>bool topLevel = true;
void main() {
  var insideMain = true;
  void myFunction() {
    var insideFunction = true;

    void nestedFunction() {
      var insideNestedFunction = true;

      assert(topLevel);
      assert(insideMain);
      assert(insideFunction);
      assert(insideNestedFunction);
    }
  }
}
</code></pre><p><br></p>
<h4 id="词法闭包"><a href="#词法闭包" class="headerlink" title="词法闭包"></a>词法闭包</h4><ul>
<li>闭包指的是函数可以访问词法作用域中的所有变量，即使函数在其他作用域中使用</li>
</ul>
<pre><code>/// Returns a function that adds [addBy] to the
/// function&apos;s argument.
Function makeAdder(num addBy) {
  return (num i) =\&gt; addBy + i;
}
void main() {
  // Create a function that adds 2.
  var add2 = makeAdder(2);
  // Create a function that adds 4.
  var add4 = makeAdder(4);
  assert(add2(3) == 5);
  assert(add4(3) == 7);
}
</code></pre><p><br></p>
<h4 id="测试函数相等性"><a href="#测试函数相等性" class="headerlink" title="测试函数相等性"></a>测试函数相等性</h4><ul>
<li>使用 == 测试函数是否相等，相等的函数必须属于同一个对象而不只是类</li>
</ul>
<pre><code>void foo() {} // A top-level function
class A {
  static void bar() {} // A static method
  void baz() {} // An instance method
}
void main() {
  var x;
  // Comparing top-level functions.
  x = foo;
  assert(foo == x);
  // Comparing static methods.
  x = A.bar;
  assert(A.bar == x);
  // Comparing instance methods.
  var v = A(); // Instance #1 of A
  var w = A(); // Instance #2 of A
  var y = w;
  x = w.baz;
  // These closures refer to the same instance (#2),
  // so they&apos;re equal.
  assert(y.baz == x);
  // These closures refer to different instances,
  // so they&apos;re unequal.
  assert(v.baz != w.baz);
}
</code></pre><p><br></p>
<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><ul>
<li>一切函数皆有返回值，未指定返回值类型的函数返回null</li>
</ul>
<pre><code>foo() {}
main() {
  assert(foo() == null);
}
</code></pre><p><br></p>
<h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><ul>
<li>一下为 dart 中使用的操作符，许多操作符支持重载</li>
</ul>
<table>
<thead>
<tr>
<th>描述符</th>
<th>操作符</th>
</tr>
</thead>
<tbody>
<tr>
<td>unary postfix</td>
<td>expr++    expr–    ()    <a href=""></a>    .    ?.</td>
</tr>
<tr>
<td>unary prefix</td>
<td>-expr    !expr    expr    ++expr    –expr</td>
</tr>
<tr>
<td>multiplicative</td>
<td>*    /    %  /</td>
</tr>
<tr>
<td>additive</td>
<td>+    -</td>
</tr>
<tr>
<td>shift</td>
<td>\&lt;\&lt;    >></td>
</tr>
<tr>
<td>bitwise AND</td>
<td>&amp;</td>
</tr>
<tr>
<td>bitwise XOR</td>
<td>^</td>
</tr>
<tr>
<td>bitwise OR</td>
<td>\u007c</td>
</tr>
<tr>
<td>relational and type test</td>
<td>>=    >    \&lt;=    \&lt;    as    is    is!</td>
</tr>
<tr>
<td>equality</td>
<td>==    !=</td>
</tr>
<tr>
<td>logical AND</td>
<td>&amp;&amp;</td>
</tr>
<tr>
<td>logical OR</td>
<td>\u007c</td>
</tr>
<tr>
<td>if null</td>
<td>??</td>
</tr>
<tr>
<td>conditional</td>
<td>expr1 ? expr2 : expr3</td>
</tr>
<tr>
<td>cascade</td>
<td>..</td>
</tr>
<tr>
<td>assignment</td>
<td>=    *=    /=    /=    %=    +=    -=    \&lt;\&lt;=    >>=   &amp;=    ^=    \u007c=    ??=</td>
</tr>
</tbody>
</table>
<p><br></p>
<h4 id="算数操作符"><a href="#算数操作符" class="headerlink" title="算数操作符"></a>算数操作符</h4><ul>
<li><p>+，加</p>
</li>
<li><p>-，减</p>
</li>
<li><p>-(表达式)，取负</p>
</li>
<li><p>*，乘</p>
</li>
<li><p>/，除</p>
</li>
<li><p>~/，除，返回 integer</p>
</li>
<li><p>%，取余</p>
</li>
</ul>
<p><br></p>
<h4 id="相等，关系操作符"><a href="#相等，关系操作符" class="headerlink" title="相等，关系操作符"></a>相等，关系操作符</h4><ul>
<li><p>==，相等</p>
</li>
<li><p>!=，不等</p>
</li>
<li><p>>，大于</p>
</li>
<li><p>\&lt;，小于</p>
</li>
<li><p>>=，大于等于</p>
</li>
<li><p>\&lt;=，小于等于</p>
</li>
<li><p>测试两个对象值是否相等，使用 == 操作符，如果想要测试两个引用是否相等使用 identical()函数</p>
</li>
</ul>
<ul>
<li>x == y ，如果 x，y 都为 null，返回 true，如果只有一个为 null，返回 false，其他情况下将调用 x.==()，函数，这即是说 == 操作符本身就是函数，另外，你也可以重载 ==</li>
</ul>
<pre><code>assert(2 == 2);
assert(2 != 3);
assert(3 \&gt; 2);
assert(2 \&lt; 3);
assert(3 \&gt;= 3);
assert(2 \&lt;= 3);
</code></pre><p><br></p>
<h4 id="类型测试操作符"><a href="#类型测试操作符" class="headerlink" title="类型测试操作符"></a>类型测试操作符</h4><ul>
<li><p>as，类型转换</p>
</li>
<li><p>is，如果对象属于后面的类型，返回 true</p>
</li>
<li><p>is!, 如果对象属于后面的类型，返回 false</p>
</li>
</ul>
<ul>
<li>调用 is 为真后对象会自动被转换类型</li>
</ul>
<pre><code>if (emp is Person) {
  // Type check
  emp.firstName = &apos;Bob&apos;;
}
</code></pre><ul>
<li>使用 as 可以简化上面的操作</li>
</ul>
<p><br></p>
<h4 id="赋值操作符"><a href="#赋值操作符" class="headerlink" title="赋值操作符"></a>赋值操作符</h4><ul>
<li>使用 = 赋值，使用 ??= 避免赋空值(为null时不赋值)</li>
</ul>
<pre><code>// Assign value to a
a = value;
// Assign value to b if b is null; otherwise, b stays the same
b ??= value;
</code></pre><ul>
<li>类似自增自减，大部分操作都支持简化</li>
</ul>
<pre><code>=   –=    /=  %=  \&gt;\&gt;= ^=
+=  \*=  \~/= \&lt;\&lt;= &amp;=  |=
</code></pre><p><br></p>
<h4 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h4><ul>
<li>三目表达式</li>
</ul>
<pre><code>var visibility = isPublic ? &apos;public&apos; : &apos;private&apos;;
</code></pre><ul>
<li>避免赋空值,使用 expr1 ?? expr2</li>
</ul>
<pre><code>String playerName(String name) =\&gt; name ?? &apos;Guest&apos;;
</code></pre><p><br></p>
<h4 id="串行记号"><a href="#串行记号" class="headerlink" title="串行记号"></a>串行记号</h4><ul>
<li>dart在语言层面上支持链式调用，使用串行记号可以链式地调用函数和访问变量</li>
</ul>
<pre><code>querySelector(&apos;#confirm&apos;) // 获取对象
  ..text = &apos;Confirm&apos; // 使用成员变量
  ..classes.add(&apos;important&apos;)
  ..onClick.listen((e) =\&gt; window.alert(&apos;Confirmed!&apos;));

//上面的代码与下面的代码等价
var button = querySelector(&apos;#confirm&apos;);
button.text = &apos;Confirm&apos;;
button.classes.add(&apos;important&apos;);
button.onClick.listen((e) =\&gt; window.alert(&apos;Confirmed!&apos;));
</code></pre><ul>
<li>链式支持嵌套</li>
</ul>
<pre><code>final addressBook = (AddressBookBuilder()
      ..name = &apos;jenny&apos;
      ..email = &apos;jenny@example.com&apos;
      ..phone = (PhoneNumberBuilder()
            ..number = &apos;415-555-0100&apos;
            ..label = &apos;home&apos;)
          .build())
    .build();
</code></pre><ul>
<li>注意链式的开始必须是一个对象</li>
</ul>
<pre><code>var sb = StringBuffer();
sb.write(&apos;foo&apos;)
  ..write(&apos;bar&apos;); // write返回值为void，没有write方法
</code></pre><p><br></p>
<h4 id="其他操作符"><a href="#其他操作符" class="headerlink" title="其他操作符"></a>其他操作符</h4><ul>
<li><p>对象访问，使用点 .</p>
</li>
<li><p>对象条件访问，使用 .? 可以预防 nullpointerEx</p>
</li>
</ul>
<pre><code>p?.y = 4; //如果p为null，语句不执行
</code></pre><p><br></p>
<h3 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h3><ul>
<li>dart 支持 java 中的 if else 和 for，while do while 操作</li>
</ul>
<ul>
<li>对于遍历，如果对象是 Iterable，可以直接调用 forEach 方法</li>
</ul>
<pre><code>candidates.forEach((candidate) =\&gt; candidate.interview());
</code></pre><ul>
<li>类似 List 和 Set 的 Iterable 也支持 for in</li>
</ul>
<pre><code>var collection = [0, 1, 2];
for (var x in collection) {
  print(x); // 0 1 2
}
</code></pre><p><br></p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p><br></p>
<h4 id="Throw"><a href="#Throw" class="headerlink" title="Throw"></a>Throw</h4><ul>
<li>dart 提供 Exception 和 Error 两种类型及许多它们的子类，也允许自定义异常，并且 dart 运行抛出任何类型的对象</li>
</ul>
<ul>
<li>使用 throw 抛出异常</li>
</ul>
<pre><code>throw FormatException(&apos;Expected at least 1 section&apos;);
</code></pre><ul>
<li>一般来说 throw 后面使用 Exception，Error 或它们的子类，但 dart 除了不能抛出 null 以外，没有其他限制(然而throw null同样也是个异常)</li>
</ul>
<pre><code>throw &apos;Out of llamas!&apos;;
</code></pre><ul>
<li>可以使用 => 简化</li>
</ul>
<pre><code>void distanceTo(Point other) =\&gt; throw UnimplementedError();
</code></pre><p><br></p>
<h4 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h4><ul>
<li>使用 on 和 catch 捕获异常，只执行最匹配的类型对应的代码块，使用 catch (e)可以捕获任何东西</li>
</ul>
<pre><code>try {
  breedMoreLlamas();
} on OutOfLlamasException {
  // A specific exception
  buyMoreLlamas();
} on Exception catch (e) {
  // Anything else that is an exception
  print(&apos;Unknown exception: $e&apos;);
} catch (e) {
  // No specified type, handles all
  print(&apos;Something really unknown: $e&apos;);
}
</code></pre><ul>
<li>catch 可以有两个参数，第一个是捕获的异常，第二个是堆栈信息</li>
</ul>
<pre><code>catch (e, s) {
  print(&apos;Exception details:\n $e&apos;);
  print(&apos;Stack trace:\n $s&apos;);
}
</code></pre><ul>
<li>重新抛出异常使用关键字 rethrow</li>
</ul>
<pre><code>void misbehave() {
  try {
    dynamic foo = true;
    print(foo++); // Runtime error
  } catch (e) {
    print(&apos;misbehave() partially handled ${e.runtimeType}.&apos;);
    rethrow; // Allow callers to see the exception.
  }
}
</code></pre><p><br></p>
<h4 id="Finally"><a href="#Finally" class="headerlink" title="Finally"></a>Finally</h4><ul>
<li>finally 的用法和语义和 java 相同</li>
</ul>
<pre><code>try {
  breedMoreLlamas();
} finally {
  // Always clean up, even if an exception is thrown.
  cleanLlamaStalls();
}
</code></pre><p><br></p>
<h3 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h3><p><br></p>
<h4 id="使用成员变量"><a href="#使用成员变量" class="headerlink" title="使用成员变量"></a>使用成员变量</h4><ul>
<li>使用点，访问成员变量</li>
</ul>
<pre><code>p.y = 3;
</code></pre><ul>
<li>使用?.，访问成员变量，防止空指针异常,相当于 if(x.y!=null){ x.y .. }</li>
</ul>
<pre><code>// If p is non-null, set its y value to 4.
p?.y = 4;
</code></pre><p><br></p>
<h4 id="使用构造函数"><a href="#使用构造函数" class="headerlink" title="使用构造函数"></a>使用构造函数</h4><ul>
<li>构造函数可以是 类名 或 类名.标识符</li>
</ul>
<pre><code>var p1 = Point(2, 2);
var p2 = Point.fromJson({&apos;x&apos;: 1, &apos;y&apos;: 2});
</code></pre><ul>
<li>Dart 2 以后 new 关键字可以省略，加上它不会带来任何区别</li>
</ul>
<pre><code>var p1 = new Point(2, 2);
var p2 = new Point.fromJson({&apos;x&apos;: 1, &apos;y&apos;: 2});
</code></pre><ul>
<li>有些类提供常量构造函数</li>
</ul>
<pre><code>var p1 = const Point(2, 2);
p1.x = 3;//报错
</code></pre><ul>
<li>使用相同的参数调用常量构造函数，返回同一个对象的引用, 如果使用普通构造函数，返回的引用将不同</li>
</ul>
<pre><code>var p1 = const Point(2, 2);
 var p2 = const Point(2, 2);
 assert(identical(p1, p2));

 var p1 =  Point(2, 2);
 var p2 = const Point(2, 2);
 assert(!identical(p1, p2));
</code></pre><ul>
<li>在常量上下文中，大部分 const 关键字都可以省略</li>
</ul>
<pre><code>// Lots of const keywords here.
const pointAndLine = const {
  &apos;point&apos;: const [const ImmutablePoint(0, 0)],
  &apos;line&apos;: const [const ImmutablePoint(1, 10), const ImmutablePoint(-2, 11)],
};

// Only one const, which establishes the constant context.
const pointAndLine = {
  &apos;point&apos;: [ImmutablePoint(0, 0)],
  &apos;line&apos;: [ImmutablePoint(1, 10), ImmutablePoint(-2, 11)],
};
</code></pre><p><br></p>
<h4 id="声明构造函数"><a href="#声明构造函数" class="headerlink" title="声明构造函数"></a>声明构造函数</h4><ul>
<li>最简单的声明方式，注意这里使用了 this 关键字，官方的编码规范建议如果 this 不是必要的 dart 则省略它们</li>
</ul>
<pre><code>Point(num x, num y) {
   this.x = x;
   this.y = y;
 }
</code></pre><ul>
<li>dart 提供了简化这种简单构造函数的语法糖</li>
</ul>
<pre><code>Point(this.x, this.y);
</code></pre><ul>
<li>如果不声明构造函数 dart 将生成默认无参构造函数，它会调用父类的无参构造函数</li>
</ul>
<ul>
<li>构造函数是不会被继承的</li>
</ul>
<ul>
<li>命名构造函数是另一种构造函数，能有提供一定的信息, 注意这种构造函数也是不参与继承的</li>
</ul>
<pre><code>// Named constructor
 Point.origin() {
   x = 0;
   y = 0;
 }
</code></pre><ul>
<li>使用 : 符号, 可以将一些代码写在函数体之前,如调用父类的构造函数等</li>
</ul>
<pre><code>Employee.fromJson(Map data) : super.fromJson(data)

Employee() : super.fromJson(getDefaultData());

var p1 = Point.fromJson(Map());

class Point {
  num x;
  num y;

  Point.fromJson(Map\&lt;String, num\&gt; json)
      : x = json[&apos;x&apos;],
        y = json[&apos;y&apos;],
        assert(x &gt; 0) {
    print(&apos;In Point.fromJson(): ($x, $y)&apos;);
  }
}
</code></pre><ul>
<li>重定向函数</li>
</ul>
<pre><code>Point.alongXAxis(num x) : this(x, 0);
</code></pre><ul>
<li>声明常量构造函数，参数需要为 final，定义函数时需要加上 const 关键字</li>
</ul>
<pre><code>final num x, y;

 const ImmutablePoint(this.x, this.y);
</code></pre><ul>
<li>使用 factory 关键字创建工厂构造函数，工厂构造函数通常用来实现缓存，它不能使用 this 关键字，它需要 return 来确定引用，调用工厂参数和调用其他参数没有区别</li>
</ul>
<pre><code>class Logger {
  final String name;
  bool mute = false;
  static final Map\&lt;String, Logger\&gt; \_cache = \&lt;String, Logger\&gt;{};

  Logger.\_internal(this.name);

  factory Logger(String name) {
    if (_cache.containsKey(name)) {
      return _cache[name];
    } else {
      final logger = Logger._internal(name);
      _cache[name] = logger;
      return logger;
    }
  }
}
</code></pre><p><br></p>
<h4 id="获取对象类型"><a href="#获取对象类型" class="headerlink" title="获取对象类型"></a>获取对象类型</h4><ul>
<li>使用对象的 runtimeType 属性，可以在运行时获取类型</li>
</ul>
<pre><code>var p1 =  Point(2, 2);
  print(&apos;The type of a is ${p1.runtimeType}&apos;);
</code></pre><p><br></p>
<h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><ul>
<li>所有为赋值的成员变量都为 null</li>
</ul>
<pre><code>class Point {
  num x; // Declare instance variable x, initially null.
  num y; // Declare y, initially null.
  num z = 0; // Declare z, initially 0.
}
</code></pre><ul>
<li>所有成员变量自动生成 getter 函数，非 final 变量自动生成 getter 和 setter 函数</li>
</ul>
<p><br></p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul>
<li>dart 默认生成 getter setter 方法，使用 get 和 set 方法可以自定义 getter setter, 另外在抽象类中可以定义抽象的 getter setter</li>
</ul>
<pre><code>class Rectangle {
  num left, top, width, height;

  Rectangle(this.left, this.top, this.width, this.height);

  // Define two calculated properties: right and bottom.
  num get right =\&gt; left + width;

  num get bottom =\&gt; top + height;

  set bottom(num value) =\&gt; top = value - height;

  set right(num value) =\&gt; left = value - width;
      void getSize() {}
}

void main() {
  var rect = Rectangle(3, 4, 20, 15);
  assert(rect.left == 3);
  rect.right = 12;
  assert(rect.left == -8);
}
</code></pre><ul>
<li>抽象方法只能存在与抽象类当中</li>
</ul>
<pre><code>abstract class Doer {
  // Define instance variables and methods...

  void doSomething(); // Define an abstract method.
}
</code></pre><p><br></p>
<h4 id="extends-amp-implements"><a href="#extends-amp-implements" class="headerlink" title="extends &amp; implements"></a>extends &amp; implements</h4><ul>
<li>dart支持隐式接口，意味着你可以使用 implements 关键字实现任何类，不管它是否是抽象的，一个实现类不但要重写它通过 implements 关键字得到的所有方法，要需要重写所有属性，否则我们需要将其定义为抽象类</li>
</ul>
<pre><code>//抽象类
abstract class Square implements Rectangle {
}

//实现类
class Square implements Rectangle {
  @override
  num bottom;

  @override
  num height;

  @override
  num left;

  @override
  num right;

  @override
  num top;

  @override
  num width;

  @override
  void getSize() {
    //...
  }
}
</code></pre><ul>
<li>继承，使用 extends 关键字，并且可以通过 super 关键字访问父类，注意，在 dart 中，一个类允许直接实现多个接口，但只允许有一个直接父类</li>
</ul>
<pre><code>class Television {
  void turnOn() {
    _illuminateDisplay();
    _activateIrSensor();
  }
  // ···
}

class SmartTelevision extends Television {
  void turnOn() {
    super.turnOn();
    _bootNetworkInterface();
    _initializeMemory();
    _upgradeApps();
  }
  // ···
}
</code></pre><ul>
<li>有趣的是父类与接口之间允许存在直接或间接的关系</li>
</ul>
<pre><code>class BigSquare extends Rectangle implements Square{
  BigSquare(num left, num top, num width, num height) : super(left, top, width, height);
}

class BigSquare extends Square implements Rectangle{
}
</code></pre><ul>
<li>重写成员变量，子类允许重写成员变量，可以使用@override注解指明成员变量是重写的</li>
</ul>
<ul>
<li>重写操作符，以下操作符允许重写</li>
</ul>
<pre><code>\&lt;   +   |   []
&gt;   /   ^   []=
\&lt;=  \~/  &amp;   \~
&gt; =  \*   \&lt;\&lt;  ==
– %   \&gt;\&gt;
</code></pre><ul>
<li>重写操作符，使用 operator 关键字</li>
</ul>
<pre><code>class Vector {
  final int x, y;

  Vector(this.x, this.y);

  Vector operator +(Vector v) =\&gt; Vector(x + v.x, y + v.y);
  Vector operator -(Vector v) =\&gt; Vector(x - v.x, y - v.y);

  // Operator == and hashCode not shown. For details, see note below.
  // ···
}

void main() {
  final v = Vector(2, 3);
  final w = Vector(2, 2);

  assert(v + w == Vector(4, 5));
  assert(v - w == Vector(0, 1));
}
</code></pre><p><br></p>
<h4 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h4><ul>
<li>使用枚举类型</li>
</ul>
<pre><code>enum Color { red, green, blue }
</code></pre><ul>
<li>每个枚举含有一个 index 属性的 getter，返回它在定义中的位置</li>
</ul>
<pre><code>assert(Color.red.index == 0);
assert(Color.green.index == 1);
assert(Color.blue.index == 2);
</code></pre><ul>
<li>每个枚举类有一个 values 常量，返回所有枚举对象</li>
</ul>
<pre><code>List&lt;Color&gt; colors = Color.values;
assert(colors[2][13] == Color.blue);
</code></pre><p><br></p>
<h4 id="mixins"><a href="#mixins" class="headerlink" title="mixins"></a>mixins</h4><ul>
<li>mixins(混入)，为组合提供了语言上的支持，使用 with 关键字 来实现 mixins</li>
</ul>
<pre><code>class Musician extends Performer with Musical {
  // ···
}

class Maestro extends Person
    with Musical, Aggressive, Demented {
  Maestro(String maestroName) {
    name = maestroName;
    canConduct = true;
  }
}
</code></pre><ul>
<li>with 后面跟随的类必须是 object 类的直接子类，并且不能含有构造函数</li>
</ul>
<pre><code>abstract class Musical {
  bool canPlayPiano = false;
  bool canCompose = false;
  bool canConduct = false;

  void entertainMe() {
    if (canPlayPiano) {
      print(&apos;Playing piano&apos;);
    } else if (canConduct) {
      print(&apos;Waving hands&apos;);
    } else {
      print(&apos;Humming to self&apos;);
    }
  }
}
</code></pre><ul>
<li>目前来说 mixins 其实不怎么好用 ，不过谷歌正在对齐进行改进，有兴趣的可以看一下<a href="https://github.com/dart-lang/language/blob/master/accepted/2.1/super-mixins/feature-specification.md" target="_blank" rel="external">这里</a></li>
</ul>
<p><br></p>
<h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><ul>
<li>使用 static 声明类变量和方法，作用同 java</li>
</ul>
<pre><code>static const initialCapacity = 16;
static num distanceBetween(Point a, Point b){
}
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Nginx 静态文件服务器]]></title>
      <url>/2018/11/02/WebNginxImages/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><strong>以前放的图片全部挂了，国内找不到好的图床，想了下还是自己弄个服务器省心</strong></p>
<ul>
<li>nginx是一个代理服务器，可以拦截请求转发给不同的机器或者服务器程序（比如你在一台机上运行两个tomcat，用反向代理也可以实现隐藏80端口），主要用于实现负载均衡</li>
</ul>
<ul>
<li>nginx也是个普通的web服务器，只用它的静态资源服务也是可以的</li>
</ul>
<p><br></p>
<h3 id="安装-nginx"><a href="#安装-nginx" class="headerlink" title="安装 nginx"></a>安装 nginx</h3><ul>
<li>安装 ubuntu 18.04 上，使用</li>
</ul>
<pre><code>apt install nginx
</code></pre><ul>
<li>如果安装失败，很有可能是编译时出现了警告，nginx 用了 -Werror，所有警告当做错误处理，找到 Makefile 删掉这个参数重新 make，make install 即可</li>
</ul>
<ul>
<li>ubuntu上nginx默认放在 /etc/nginx </li>
</ul>
<p><br></p>
<h3 id="配置文件路径"><a href="#配置文件路径" class="headerlink" title="配置文件路径"></a>配置文件路径</h3><ul>
<li>将 /etc/nginx/nginx.conf 修改为</li>
</ul>
<pre><code>user root;
worker_processes  1;

error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;

#pid        logs/nginx.pid;


events {
    worker_connections  1024;
}


http {
    include       mime.types;

    #log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;
    #                  &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;
    #                  &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;

    #access_log  logs/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    #keepalive_timeout  0;
    keepalive_timeout  65;
    #gzip  on;

    server {
        listen       80;


        #charset koi8-r;

        #access_log  logs/host.access.log  main;

        location / {
            root  /home/images/;
            index  index.html index.htm;
         access_log /home/images.log;
        }

        #error_page  404              /404.html;

        # redirect server error pages to the static page /50x.html
        #
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }

        # proxy the PHP scripts to Apache listening on 127.0.0.1:80
        #
        #location ~ \.php$ {
        #    proxy_pass   http://127.0.0.1;
        #}

        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
      #
        #location ~ \.php$ {
        #    root           html;
        #    fastcgi_pass   127.0.0.1:9000;
        #    fastcgi_index  index.php;
        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
        #    include        fastcgi_params;
        #}

        # deny access to .htaccess files, if Apache&apos;s document root
        # concurs with nginx&apos;s one
        #
        #location ~ /\.ht {
        #    deny  all;
 }


    # another virtual host using mix of IP-, name-, and port-based configuration
    #
    #server {
    #    listen       8000;
    #    listen       somename:8080;
    #    server_name  somename  alias  another.alias;

    #    location / {
    #        root   html;
    #        index  index.html index.htm;
    #    }
    #}
#
    #server {
    #    listen       443 ssl;
    #    server_name  localhost;

    #    ssl_certificate      cert.pem;
    #    ssl_certificate_key  cert.key;

    #    ssl_session_cache    shared:SSL:1m;
    #    ssl_session_timeout  5m;

    #    ssl_ciphers  HIGH:!aNULL:!MD5;
    #    ssl_prefer_server_ciphers  on;

    #    location / {
    #        root   html;
    #        index  index.html index.htm;
    #    }
    #}
}
</code></pre><ul>
<li>注意一下第一行的 user 和下面的路径，这里我将文件放在 /home/images/（/root/home/images/）, url匹配规则为 /</li>
</ul>
<pre><code>location / {
     root  /home/images/;
     index  index.html index.htm;
     access_log /home/images.log;
 }
</code></pre><p><br></p>
<h3 id="启动-nginx"><a href="#启动-nginx" class="headerlink" title="启动 nginx"></a>启动 nginx</h3><ul>
<li>如果没有启动 nginx</li>
</ul>
<pre><code>nginx -c /etc/nginx/nginx.conf
</code></pre><ul>
<li>如果已经启动，检查一下配置是否正确</li>
</ul>
<pre><code>nginx -t
</code></pre><ul>
<li>重启</li>
</ul>
<pre><code>nginx -s reload
</code></pre><ul>
<li>使用scp将图片放在/home/images/，之后使用如下url即可获取到文件</li>
</ul>
<pre><code>http://[host]/1.png
</code></pre><p><br><br><strong>end</strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入操作系统 5 - 分段 & GDT]]></title>
      <url>/2018/10/31/OSGdt/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><a href="https://tocreate.app/2019/03/02/OperatingSystem/" target="_blank" rel="external">本文为深入操作系统系列的一部分</a></p>
<p><a href="https://tocreate.app/2018/10/15/OSBaseLib/" target="_blank" rel="external">可能需要阅读前文</a></p>
<p><strong>要了解 GDT 之前，我们需要知道非常非常非常多的预备知识，特备是对于高级语言用得多的程序员，这里我尽量用简洁的语言进行梳理</strong></p>
<p><br></p>
<h3 id="PC-？-CS-IP"><a href="#PC-？-CS-IP" class="headerlink" title="PC ？ CS:IP ?"></a>PC ？ CS:IP ?</h3><ul>
<li>在计算机组成系统中，或者说抽象概念中，程序计数器 PC 用于存储下一条指令</li>
</ul>
<ul>
<li>存在我们经常说的 PC 寄存器主要是由于早期的处理器当中，以及RISC 微处理器架构中确实存在一个 PC 寄存器，如 ARM 中 R15 寄存器</li>
</ul>
<ul>
<li>在 80x86 微处理器中则是通过两个寄存器 CS 和 IP 同时实现，CS 为段寄存器，IP 为指令寄存器，它们分别存储段地址和偏移地址，通过段地址和偏移地址即可获得需要的指令地址</li>
</ul>
<p><br></p>
<h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><ul>
<li><p>这里我们主要讨论实模式和保护模式</p>
</li>
<li><p>保护模式和实模式是 x86 体系中的概念，这两种模式的区别主要体现在内存寻址上</p>
</li>
</ul>
<pre><code>ARM 的寻址方式更像是实模式，更多的工作交由操作系统去实现
</code></pre><ul>
<li>所有x86处理器都在实模式下启动，所有现代操作系统都在保护模式下运行。</li>
</ul>
<pre><code>造成这种现象的原因是，早期 intel 的处理器是没有模式这一概念的
80286保护模式出现后所谓没有模式就成了实模式
为了兼容性或为了关闭了保护模式的处理器，CPU 都在实模式下启动
</code></pre><p><br></p>
<h3 id="实模式"><a href="#实模式" class="headerlink" title="实模式"></a>实模式</h3><p><br></p>
<h4 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h4><ul>
<li>8086 CPU 只有实模式，数据总线数量16位，地址总线20位，也就是说读取数据的能力为 64 kb，但寻址能力却为 1 mb</li>
</ul>
<ul>
<li>为了充分利用 20 位总线，8086 提出分段的概念，用段基地址+段内偏移地址表示物理地址，CS和IP都是16位，CS左移4位加上IP就构成20位地址</li>
</ul>
<pre><code>数据总线和地址总线的不对称，是出于性能的考量，16 位的寻址能力是远远不够的，至于 20 位 CPU ？显然不是什么好主意
</code></pre><p><br></p>
<h3 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h3><p><br></p>
<h4 id="寻址-1"><a href="#寻址-1" class="headerlink" title="寻址"></a>寻址</h4><ul>
<li>80286 及其后的 CPU 提供保护模式，允许访问 4GB 的内存地址</li>
</ul>
<pre><code>此时 80286 实际上已经有 24 根地址线，理论寻址能力为16MB
</code></pre><ul>
<li>保护模式不再直接使用段基地址，实际情况是 CS 寄存器中存储一个段选择符，在段描述符表中可以通过该选择符找到段描述符，而 IP 依然保存偏移量</li>
</ul>
<ul>
<li>在保护模式下，由于实现了内存区域的划分，CPU 可以提供访问权限等安全保障，这也就是保护模式的由来</li>
</ul>
<p><br></p>
<h4 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h4><ul>
<li>段描述符用于表示一个段的信息，它的长度为 8 字节，结构如下</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>位置(高32位)</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>Base(部分段基址)</td>
<td>31 - 24</td>
<td>组成段基址 31 - 24 位</td>
</tr>
<tr>
<td>G(颗粒度)</td>
<td>23</td>
<td>段限长的单位，0为b，1位kb</td>
</tr>
<tr>
<td>D/B</td>
<td>22</td>
<td>对于代码段，称为“D”位；栈段，此位称为“B”位</td>
</tr>
<tr>
<td>0</td>
<td>21</td>
<td>填充0</td>
</tr>
<tr>
<td>AVL</td>
<td>20</td>
<td>软件可以使用位，由操作系统来用，处理器不使用</td>
</tr>
<tr>
<td>Limit(部分段限长)</td>
<td>19 - 16</td>
<td>组成段限长 19 - 16 位</td>
</tr>
<tr>
<td>P (段存在)</td>
<td>15</td>
<td>标志段是否在内存中</td>
</tr>
<tr>
<td>DPL(特权级)</td>
<td>14-13</td>
<td>0（最高）到 3（最低），用于控制对段的访问</td>
</tr>
<tr>
<td>S(描述符类型)</td>
<td>12</td>
<td>0 为存储段（代码段或数据段），1 为系统描述符</td>
</tr>
<tr>
<td>TYPE(段类型)</td>
<td>11 - 8</td>
<td>依赖于S,对代码段、数据段或者系统描述符都不同</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>名称</th>
<th>位置(低32位)</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>Base(部分基地址)</td>
<td>7 - 0</td>
<td>组成段基址 23 - 16 位</td>
</tr>
<tr>
<td>Base(部分基地址)</td>
<td>31 - 16</td>
<td>组成段基址 0 - 15 位</td>
</tr>
<tr>
<td>Limit(部分段限长)</td>
<td>15 - 0</td>
<td>组成段限长 15 - 0 位</td>
</tr>
</tbody>
</table>
<ul>
<li>段基地址可以是0到4GB范围内的任意地址，是段的起始地址</li>
</ul>
<ul>
<li>段限长是段的最大长度，G用来指定其单位，TYPE 中的 E 指定其方向(向上扩展或向下扩展)</li>
</ul>
<p><br></p>
<h4 id="段选择符"><a href="#段选择符" class="headerlink" title="段选择符"></a>段选择符</h4><ul>
<li>实模式下的 6 个段寄存器在保护模式下叫做段选择器，存储的不是逻辑地址而是段选择符，结构如下</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>位置</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>index(描述符索引)</td>
<td>15 - 3</td>
<td>用于在描述符表中选择一个段描述符</td>
</tr>
<tr>
<td>TI(表指示器)</td>
<td>2</td>
<td>0 表示描述符在 GDT 中，1 表示描述符在 LDT 中</td>
</tr>
<tr>
<td>RPL(请求特权级)</td>
<td>1 - 0</td>
<td>用于控制访问权限</td>
</tr>
</tbody>
</table>
<p><br></p>
<h4 id="GDT-amp-LDT"><a href="#GDT-amp-LDT" class="headerlink" title="GDT &amp; LDT"></a>GDT &amp; LDT</h4><ul>
<li>GDT 为描述符表，可以认为段选择符就是该表的索引，通过段选择符确定GDT中的段描述符也就是确定了一个段</li>
</ul>
<ul>
<li>LDT 为局部描述符表，LDT是可选的，它LDT嵌套在GDT之中，相当于一个二级索引，LDT中局部的概念指的是一个任务占有一个LDT</li>
</ul>
<p><br></p>
<h4 id="GDTR-amp-LDTR"><a href="#GDTR-amp-LDTR" class="headerlink" title="GDTR &amp; LDTR"></a>GDTR &amp; LDTR</h4><ul>
<li>GDTR 为全局描述符寄存器，48位，高32位存放GDT基址，低16为存放GDT限长，用它来确定GDT的位置和大小</li>
</ul>
<ul>
<li>LDTR 为局部描述符寄存器，因为一个时刻只有一个任务在运行，因此 LDT 的寄存器也只需要有一个，这个寄存器存储当前 LDT 的位置，也就是GDT的段描述符</li>
</ul>
<p><strong>本篇主要记录保护模式实模式与 GDT 之间的关系，下篇我们尝试构建 GDT 从实模式进入保护模式</strong></p>
<p><br><br><strong>本篇完</strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[计算机网络  1 - 模型]]></title>
      <url>/2018/10/30/NetLayer/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><br></p>
<h3 id="分层模型"><a href="#分层模型" class="headerlink" title="分层模型"></a>分层模型</h3><p><br></p>
<h4 id="OSI-模型"><a href="#OSI-模型" class="headerlink" title="OSI 模型"></a>OSI 模型</h4><p><strong>由国际标准化组织 ISO 定义的开放系统互联标准 OSI 包含七层，OSI模型并未取得最终胜利，但一些思想和部分协议被 TCP/IP 吸收</strong></p>
<ul>
<li><p>应用层，由应用开发者实现，如 FTP，Skype</p>
</li>
<li><p>表示层，针对应用层的数据表示格式和转换规则的方法，如 EBCDIC 转 ASCII</p>
</li>
<li><p>会话层，由多个链接组成一个通信会话的方法，可能包括关闭链接，重启链接和检查点进度</p>
</li>
<li><p>传输层，运行在相同计算机系统的多个程序之间链接或关联的方法，如果其他地方没有实现，本层可以实现可靠投递，如 TCP，ISO TP4(等价于TCP)</p>
</li>
<li><p>网络层，指定经过潜在的不同类型链路层网络的多跳通信方法，对于分组网络，它描述了抽象的分组格式和标准的编址结构(如IP数据报)</p>
</li>
<li><p>链路层，指定经过单一链路的方法，包括多个系统共享同一介质时，“介质访问”控制协议。本层通常包括差错检测和链路层地址格式（如以太网，wifi）</p>
</li>
<li><p>物理层，指定连接器，数据率如何在某些介质上进行位编码。也包括底层的差错检测和纠正，频率分配</p>
</li>
</ul>
<p><br></p>
<h4 id="TCP-IP-模型"><a href="#TCP-IP-模型" class="headerlink" title="TCP/IP 模型"></a>TCP/IP 模型</h4><p><strong>TCP/IP 模型源于 ARPANET参考模型的分层</strong></p>
<ul>
<li>应用层，实际上是Internet兼容的任何应用，包括 http，dns，dhcp</li>
</ul>
<ul>
<li>传输层，端到端传输，包括差错和流量控制，如 TCP，UDP，SCTP，DCCP</li>
</ul>
<ul>
<li>网络层（辅助），协助完成网络层设置，管理和安全的非正式层，如 ICMP，IGMP，IPsec</li>
</ul>
<ul>
<li>网络层，定义抽象的数据报和提供路由，如 IP，IPv6</li>
</ul>
<ul>
<li>链路层（辅助），用于网络层到基于多接入链路层网络的链路层的地址映射的非正式的层</li>
</ul>
<p><br></p>
<h4 id="五层体系结构"><a href="#五层体系结构" class="headerlink" title="五层体系结构"></a>五层体系结构</h4><p><strong>五层协议只是OSI和TCP/IP的综合，实际应用还是TCP/IP的四层结构，高度抽象化后各层的作用如下</strong></p>
<ul>
<li>应用层，负责定义应用进程间通信和交互的规则，传输单位为报文</li>
</ul>
<ul>
<li>运输层，负责进程到进程之间的逻辑通信，其中，TCP提供面向链接，差错控制，流量控制，拥塞控制，UDP只提供无连接服务。传输单位为报文段（报文段和用户数据报）</li>
</ul>
<ul>
<li>网络层，负责主机到主机之间的通信服务，包括了IP协议和一些路由选择协议，定义了段系统和路由器应该处理ip协议中的各字段，传输单位为数据报</li>
</ul>
<ul>
<li>数据链路层，负责点到点之间的通信服务，提供封装成帧，透明传输，差错检测的相邻结点的数据链路传输，传输单位为帧</li>
</ul>
<ul>
<li>物理层，将帧中的数据以比特为单位从一个结点移动到下一个结点，并且进一步与链路的物理结构相关，如分别定义关于双绞线，光纤，同轴电缆的传输协议</li>
</ul>
<p><br></p>
<h3 id="应用模型"><a href="#应用模型" class="headerlink" title="应用模型"></a>应用模型</h3><ul>
<li>对等网模式，拓扑结构为总线型或星型，不一定需要专门的服务器和网络操作系统</li>
</ul>
<ul>
<li>文件服务器模式 ，早期局域网主流系统结构之一，将若干台计算机与一台或多台文件服务器通过通信线路和网络操作系统连接起来</li>
</ul>
<ul>
<li>客户机服务器模式</li>
</ul>
<ul>
<li>浏览器服务器模式</li>
</ul>
<p><br></p>
<h3 id="网络互连设备"><a href="#网络互连设备" class="headerlink" title="网络互连设备"></a>网络互连设备</h3><p><br></p>
<h4 id="中继器"><a href="#中继器" class="headerlink" title="中继器"></a>中继器</h4><p><strong> 工作在物理层，主要作用是信号的再生放大 </strong></p>
<ul>
<li><p>过滤电磁干扰和射频干扰引起的信号干扰或噪声</p>
</li>
<li><p>放大和修整进入的信号，使重新传输更精确</p>
</li>
<li><p>对信号重定时</p>
</li>
<li><p>在所有网段上复制信号</p>
</li>
</ul>
<p><br></p>
<h4 id="集线器（hub）"><a href="#集线器（hub）" class="headerlink" title="集线器（hub）"></a>集线器（hub）</h4><p><strong> 工作在物理层，主要作用还是信号放大和中转，实际上是一个多端口的中继器</strong></p>
<ul>
<li><p>集线器不具备自动转发和自动寻址的功能，所有端口属于一个冲突域</p>
</li>
<li><p>10base-T hub 可以层层级联扩充网络，但每级联一层带宽会相对降低，堆叠式的 hub 可以不减低带宽的情况下扩充网络</p>
</li>
</ul>
<p><br></p>
<h4 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h4><p><strong>工作在数据链路层，链接两个局域网进行存储转发</strong></p>
<ul>
<li><p>网桥截获所有的网络信息，读取每一个帧的目的地址，并建立已知目标的地址表</p>
</li>
<li><p>网桥的主要优点是限制传输到某些网段的通讯量</p>
</li>
</ul>
<p><br></p>
<h4 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h4><p><strong>工作在数据链路层，是高级的网桥</strong></p>
<p><br></p>
<h4 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h4><p><strong>工作在网络层，用于连接各局域网、广域网</strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Dart & Flutter 环境搭建]]></title>
      <url>/2018/10/27/EnvDartFlutter/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><strong>安装 Flutter 和 Dart 环境遇到很多坑，记录一下</strong></p>
<p><br></p>
<h4 id="Flutter-SDK"><a href="#Flutter-SDK" class="headerlink" title="Flutter SDK"></a>Flutter SDK</h4><ul>
<li>下载 Flutter Sdk 并解压</li>
</ul>
<pre><code>https://flutter.io/sdk-archive/#macos
</code></pre><ul>
<li>添加路径</li>
</ul>
<pre><code>export PATH=pwd/flutter/bin:$PATH
</code></pre><ul>
<li>执行 flutter doctor，查看需要安装的依赖，按提示安装</li>
</ul>
<pre><code>Doctor summary (to see all details, run flutter doctor -v):
[✓] Flutter (Channel beta, v0.9.4, on Mac OS X 10.14 18A391, locale zh-Hans-CN)
[✓] Android toolchain - develop for Android devices (Android SDK 27.0.3)
[!] iOS toolchain - develop for iOS devices (Xcode 10.0)
    ✗ CocoaPods installed but not initialized.
        CocoaPods is used to retrieve the iOS platform side&apos;s plugin code that responds to your plugin usage on the Dart side.
        Without resolving iOS dependencies with CocoaPods, plugins will not work on iOS.
        For more info, see https://flutter.io/platform-plugins
      To initialize CocoaPods, run:
        pod setup
      once to finalize CocoaPods&apos; installation.
[✓] Android Studio (version 3.1)
[✓] IntelliJ IDEA Ultimate Edition (version 2018.1)
[✓] Connected devices (1 available)
</code></pre><ul>
<li>注意 osx 版本需要大于 10.11，OSX 版本 需要大于 9，系统我直接从 10.11.16 更新到了 mojave，暂时没有发现什么不兼容的地方，至于 xcode，appstore 怎么都下不下来，建议去开发者官网下载</li>
</ul>
<pre><code>https://developer.apple.com/xcode/
</code></pre><ul>
<li>插件中查找 flutter ，安装后重启可以创建 flutter project</li>
</ul>
<p><br></p>
<h4 id="Android-Studio"><a href="#Android-Studio" class="headerlink" title="Android Studio"></a>Android Studio</h4><p><br></p>
<h5 id="initializing-gradle"><a href="#initializing-gradle" class="headerlink" title="initializing gradle"></a>initializing gradle</h5><ul>
<li>编译时永远停留在 initializing gradle，查看gradle 使用版本，很坑的是，flutter 只支持 4.5.x 的版本的 gradle，大了小了都不行，下载 gradle 时建议翻墙</li>
</ul>
<pre><code>distributionUrl=https\://services.gradle.org/distributions/gradle-4.5.1-all.zip
</code></pre><p><br></p>
<h5 id="Could-not-resolve-com-android-tools-lint-lint-gradle-26-1-2"><a href="#Could-not-resolve-com-android-tools-lint-lint-gradle-26-1-2" class="headerlink" title="Could not resolve com.android.tools.lint:lint-gradle:26.1.2."></a>Could not resolve com.android.tools.lint:lint-gradle:26.1.2.</h5><ul>
<li>这依赖在 google 仓库里翻墙都下不了，然后 gradle 会自动去 jcenter 上下载，jcenter 上只有25及以下的版本导致 404。GFW 真的牛逼。参考<a href="https://www.jianshu.com/p/2178ed233361" target="_blank" rel="external">这里</a>将镜像改为阿里云的就可以了</li>
</ul>
<p><br></p>
<h4 id="Dart"><a href="#Dart" class="headerlink" title="Dart"></a>Dart</h4><ul>
<li>在 idea 或者 webstorm 中编写 dart，可以像 AS 一样添加 dart 插件</li>
</ul>
<ul>
<li>dart sdk，使用 homebrew 可以下载，但我怎么都下不了</li>
</ul>
<pre><code>$ brew tap dart-lang/dart
$ brew install dart
</code></pre><ul>
<li>最后直接用了 flutter 的 dart sdk，flutter的dart版本是 dev 的最新版本，目前是 2.1 的，也就是高于 dart 的稳定版本 2.0，位置如下</li>
</ul>
<pre><code>/Users/alberthumbert/flutter/bin/cache/dart-sdk
</code></pre><ul>
<li>2.1 和 2.0 的区别我就不太清楚了，不过最要命的其实是现在所有教程基本都是基于 1.0 的，The Dart Programming Language 都可以用来考古了，建议直接学习官网上的<a href="https://www.dartlang.org/guides/get-started" target="_blank" rel="external">tour</a></li>
</ul>
<p><br><br><strong>完</strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 注解进阶]]></title>
      <url>/2018/10/21/AndroidAnnotation/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><br></p>
<h2 id="Java-注解基础"><a href="#Java-注解基础" class="headerlink" title="Java 注解基础"></a>Java 注解基础</h2><p><strong>简单回顾一下注解，加入了一些Java 8中的新特性</strong></p>
<p><br></p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>注解 (Annotation)，也叫元数据。一种代码级别的说明。它是 JDK1.5 及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释</li>
</ul>
<ul>
<li>注解中的数据可以在编译、运行时进行解析和使用，也可以单纯为编码人员提供很多的信息</li>
</ul>
<p><br></p>
<h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><ul>
<li>元注解是使用在注解上的注解，它为注解提供构成信息，是最基本的注解，Java中的元注解包括，@Retention, @Documented, @Target, @Inherited，@Repeatable（Java 8）</li>
</ul>
<p><br></p>
<h4 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h4><p><strong>Retention用于指示注解的生命周期，即存活时间</strong></p>
<pre><code>@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
public @interface Retention {
    /**
     * Returns the retention policy.
     * @return the retention policy
     */
    RetentionPolicy value();
}
</code></pre><ul>
<li>RetentionPolicy.SOURCE, 注解会被编译器抛弃，即注解只在源码阶段中使用，一般用于程序员阅读</li>
</ul>
<ul>
<li>RetentionPolicy.CLASS，注解会被记录在class文件中，但不会被JVM加载，即注解可以在编译期使用</li>
</ul>
<ul>
<li>RetentionPolicy.RUNTIME，注解会被JVM加载，即注解可以在运行时使用</li>
</ul>
<pre><code>public enum RetentionPolicy {
    /**
     * Annotations are to be discarded by the compiler.
     */
    SOURCE,

    /**
     * Annotations are to be recorded in the class file by the compiler
     * but need not be retained by the VM at run time.  This is the default
     * behavior.
     */
    CLASS,

    /**
     * Annotations are to be recorded in the class file by the compiler and
     * retained by the VM at run time, so they may be read reflectively.
     *
     * @see java.lang.reflect.AnnotatedElement
     */
    RUNTIME
}
</code></pre><p><br></p>
<h4 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h4><p><strong> Target用于指示注解的标注对象，如类，方法，变量等</strong></p>
<pre><code>@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
public @interface Target {
    /**
     * Returns an array of the kinds of elements an annotation type
     * can be applied to.
     * @return an array of the kinds of elements an annotation type
     * can be applied to
     */
    ElementType[] value();
}
</code></pre><ul>
<li>ElementType.CONSTRUCTOR: 作用于构造方法</li>
<li>ElementType.ANNOTATION_TYPE:  作用于注解</li>
<li>ElementType.FIELD: 作用于域（包括枚举）</li>
<li>ElementType.LOCAL_VARIABLE: 作用于局部变量</li>
<li>ElementType.METHOD: 作用于方法</li>
<li>ElementType.PACKAGE: 作用于包，一般使用在编译器生成的package-info.java类当中</li>
<li>ElementType.PARAMETER: 作用于方法参数</li>
<li>ElementType.TYPE: 作用于类、接口、枚举</li>
<li>ElementType.TYPE_PARAMETER: 作用于提供给泛型的类型参数（Java 8）</li>
<li>ElementType.TYPE_USE：作用于变量类型（Java 8）</li>
</ul>
<pre><code>public enum ElementType {
    /** Class, interface (including annotation type), or enum declaration */
    TYPE,

    /** Field declaration (includes enum constants) */
    FIELD,

    /** Method declaration */
    METHOD,

    /** Formal parameter declaration */
    PARAMETER,

    /** Constructor declaration */
    CONSTRUCTOR,

    /** Local variable declaration */
    LOCAL_VARIABLE,

    /** Annotation type declaration */
    ANNOTATION_TYPE,

    /** Package declaration */
    PACKAGE,

    /**
     * Type parameter declaration
     *
     * @since 1.8
     */
    TYPE_PARAMETER,

    /**
     * Use of a type
     *
     * @since 1.8
     */
    TYPE_USE
}
</code></pre><p><br></p>
<h4 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h4><p><strong> Inherited用于指示使用了某个注解的类，其子类是否继承该注解</strong></p>
<pre><code>@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
public @interface Inherited {
}
</code></pre><p><br></p>
<h4 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h4><p><strong> Documented用于指示注解是否被javadoc等文档工具记录</strong></p>
<pre><code>@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
public @interface Documented {
}
</code></pre><p><br></p>
<h4 id="Repeatable（Java-8）"><a href="#Repeatable（Java-8）" class="headerlink" title="@Repeatable（Java 8）"></a>@Repeatable（Java 8）</h4><p><strong> Documented用于指示注解可以在同一个元素中多次使用</strong></p>
<pre><code>@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
public @interface Repeatable {
    /**
         * Indicates the &lt;em&gt;containing annotation type&lt;/em&gt; for the
     * repeatable annotation type.
     * @return the containing annotation type
     */
    Class&lt;? extends Annotation&gt; value();
}
</code></pre><p><br></p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul>
<li>注解的属性也叫做成员变量，使用无参方法声明的形式来声明，可以设置默认值</li>
</ul>
<pre><code>public @interface Test {
    int testInt() default 1;
    String testStr();
}
</code></pre><ul>
<li>没有设置默认值的属性必须在使用时赋值，设置了值的属性可以在使用时覆盖</li>
</ul>
<pre><code>@Test(testInt = 2,testStr = &quot;test&quot;)
public class Xxx{
}
</code></pre><p><br></p>
<h2 id="处理注解的时机"><a href="#处理注解的时机" class="headerlink" title="处理注解的时机"></a>处理注解的时机</h2><ul>
<li><p>根据注解的处理时机我们可以将注解分为如下三类</p>
</li>
<li><p>运行时处理，这一类注解拥有 RetentionPolicy.RUNTIME 生命周期，并且只使用反射处理</p>
</li>
</ul>
<ul>
<li>编译时处理，这一类注解至少拥有 RetentionPolicy.CLASS 生命周期，需要使用注解解释器处理,通常在这个阶段会使用注解生成java代码</li>
</ul>
<ul>
<li>不处理，这里指的是程序员无需使用代码去解析注解，这些注解通常只提供一些简单的信息</li>
</ul>
<p><br></p>
<h2 id="运行时处理"><a href="#运行时处理" class="headerlink" title="运行时处理"></a>运行时处理</h2><ul>
<li>运行时处理注解即通过反射获取需要解析的注解和注解的属性</li>
</ul>
<pre><code>public void process(Class clazz) {

    for (Method method : clazz.getMethods()) {
        Test annotation = method.getAnnotation(Test.class);
        handleMethodAnnotation(annotation);
    }

    for (Field field : clazz.getDeclaredFields()) {
        Test annotation = field.getAnnotation(Test.class);
        handleFieldAnnotation(annotation);
    }
}

public void handleMethodAnnotation(Test test) {
    int intValue = test.testInt();
    String strValue = test.testStr();
    //...

}

public void handleFieldAnnotation(Test test) {
    int intValue = test.testInt();
    String strValue = test.testStr();
    //...
}
</code></pre><ul>
<li>这种处理方法非常简单，很好上手，但问题是反射比较耗性能，不需要运行时处理的注解理应尽量在编译器处理</li>
</ul>
<p><br></p>
<h2 id="编译时处理"><a href="#编译时处理" class="headerlink" title="编译时处理"></a>编译时处理</h2><p><br></p>
<h3 id="两种方案"><a href="#两种方案" class="headerlink" title="两种方案"></a>两种方案</h3><ul>
<li>APT(Annotation Processing Tool) 是 Android 过去通用的注解框架，现已退出历史舞台，这里只是提一下，有兴趣的可以看一下<a href="https://blog.csdn.net/Ru_Zhan/article/details/78232851?locationNum=8&amp;fps=1" target="_blank" rel="external">这篇文档</a></li>
</ul>
<ul>
<li>Annotation Processor 是谷歌新推出的方案，减少了很多配置方面的工作，本文选用该方案进行讲解</li>
</ul>
<p><br></p>
<h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><ul>
<li>一般来说，使用 Annotation Processor 的框架会将编译期执行的代码单独出来，这样可以使用gradle 的 annotationProcessor 使这部分代码和相关依赖不会被打包</li>
</ul>
<ul>
<li>因此框架至少包含两个模块 ，一个用于实现框架的主体功能，该模块自然也存放了注解，另一个用于解析注解并生成代码，后者依赖前者，这两个模块要么都是 Android Library 要么都是 Java Library</li>
</ul>
<ul>
<li>这里我创建两个 java 模块，test 和 testCompiler,在 app 和 testCompiler中添加如下依赖，Annotation Processor相对于apt来说添加依赖非常简单，只需要在gradle中使用 annotationProcessor 即可</li>
</ul>
<pre><code>//in app
implementation project(&apos;:test&apos;)
annotationProcessor project(&apos;:testCompiler&apos;)
//in testCompiler
implementation project(&apos;:test&apos;)
</code></pre><p><br></p>
<h3 id="AbstractProcessor"><a href="#AbstractProcessor" class="headerlink" title="AbstractProcessor"></a>AbstractProcessor</h3><ul>
<li>AbstractProcessor 是注解处理器的抽象类，我们需要实现它来处理我们的注解</li>
</ul>
<pre><code>public class TestProcessor extends AbstractProcessor
</code></pre><ul>
<li>我们先来看第一个需要重写的方法 getSupportedAnnotationTypes , 该方法需要返回包含我们的注解处理器想要处理的注解的名称 的集合，这里的名称使用的是 getCanonicalName 这个和我们平时使用的 getName 不同的是不会有 $ 或 ；等符号</li>
</ul>
<pre><code>@Override
public Set&lt;String&gt; getSupportedAnnotationTypes() {
    Set&lt;String&gt; types = new LinkedHashSet&lt;&gt;();
    types.add(TestAno.class.getCanonicalName());
    return types;
}
</code></pre><ul>
<li>getSupportedSourceVersion 这个方法是可选的，返回最低兼容的Java版本</li>
</ul>
<pre><code>@Override
public SourceVersion getSupportedSourceVersion() {
    return SourceVersion.RELEASE_7;
}
</code></pre><ul>
<li>我们也可以使用注解一次实现这两个方法</li>
</ul>
<pre><code>@SupportedAnnotationTypes(&quot;com.example.annotation.SetContentView&quot;)
@SupportedSourceVersion(SourceVersion.RELEASE\_7)
public class TestProcessor extends AbstractProcessor {
</code></pre><ul>
<li>init方法，这是 processor 的初始化方法，这个方法的目的是让我们实现 processor 时可以获取到 ProcessingEnvironment，我们之后会详细讲解它</li>
</ul>
<pre><code>@Override
public synchronized void init(ProcessingEnvironment processingEnvironment) {
}
</code></pre><ul>
<li>Processor类最核心的方法是Processor方法，在编译时，处理编译器收集到的所有我们需要的注解后会执行这个方法, 怎么知道是在编译时呢，我们可以简单测试一下，使用sout，在 build 窗口，也就是 gradle 构建信息的输出窗口，如果 processor被成功实现了，我们可以看到打印的信息（新版的AS中这个窗口提供了图形化的界面，按一下左侧的按钮可以回到终端模式）</li>
</ul>
<pre><code>@Override
public boolean process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment) {
    System.out.println(&quot;----&quot;);
    return false;
}
</code></pre><ul>
<li>实现完 AbstractProcessor ，需要让编译器找到这个类，在 testCompiler 模块下的 main 文件夹下创建 resource/META-INF/services 目录，并创建名为 javax.annotation.processing.Processor 的文件，内容如下,是 自定义 processor 的全名，注意使用这个方法我的 processor 没有得到执行，后来改用 auto-service 了</li>
</ul>
<pre><code>com.topview.xxy.testcompiler.TestProcessor
</code></pre><p><br></p>
<h3 id="init-方法-和-process-方法"><a href="#init-方法-和-process-方法" class="headerlink" title="init 方法 和 process 方法"></a>init 方法 和 process 方法</h3><p><strong>上面我们简单讲解了怎么瞎几把写个 init 和 process，但是对于这个方法该怎么正确书写还是不太了解，现在来深入学习它</strong></p>
<p><br></p>
<h4 id="init"><a href="#init" class="headerlink" title="init"></a>init</h4><p><br></p>
<h5 id="ProcessingEnvironment"><a href="#ProcessingEnvironment" class="headerlink" title="ProcessingEnvironment"></a>ProcessingEnvironment</h5><ul>
<li>public synchronized void init(ProcessingEnvironment processingEnvironment)</li>
</ul>
<ul>
<li>ProcessingEnvironment，直译处理环境，实际上它提供了很多有用的工具，我们先来看它的声明</li>
</ul>
<pre><code>public interface ProcessingEnvironment {
    Map&lt;String, String&gt; getOptions();

    Messager getMessager();

    Filer getFiler();

    Elements getElementUtils();

    Types getTypeUtils();

    SourceVersion getSourceVersion();

    Locale getLocale();
}
</code></pre><p><br></p>
<h5 id="Messager"><a href="#Messager" class="headerlink" title="Messager"></a>Messager</h5><ul>
<li>Messager 是注解处理器的日志输出工具，它输出的信息会显示在 build 窗口中</li>
</ul>
<pre><code>public interface Messager {
    void printMessage(Kind var1, CharSequence var2);

    void printMessage(Kind var1, CharSequence var2, Element var3);

    void printMessage(Kind var1, CharSequence var2, Element var3, AnnotationMirror var4);

    void printMessage(Kind var1, CharSequence var2, Element var3, AnnotationMirror var4, AnnotationValue var5);
}

public static enum Kind {
        ERROR,
        WARNING,
        MANDATORY_WARNING,
        NOTE,
        OTHER;
}
</code></pre><ul>
<li>你可以使用如下的方法打印日志，注意 Messager 比起一般的日志工具有更高的权能，如果输出级别为 error，那么表示编译出错，build 就不会成功，我们要小心谨慎地使用这个级别</li>
</ul>
<pre><code>@Override
public boolean process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment){
    messager.printMessage(Diagnostic.Kind.WARNING,&quot;message&quot;);
    return false;
}
</code></pre><p><br></p>
<h5 id="filer"><a href="#filer" class="headerlink" title="filer"></a>filer</h5><ul>
<li>filer 主要提供我们在编译期生成代码的接口（）</li>
</ul>
<pre><code>JavaFileObject createSourceFile(CharSequence var1, Element... var2) throws IOException;

JavaFileObject createClassFile(CharSequence var1, Element... var2) throws IOException;

FileObject createResource(Location var1, CharSequence var2, CharSequence var3, Element... var4) throws IOException;

FileObject getResource(Location var1, CharSequence var2, CharSequence var3) throws IOException;
</code></pre><ul>
<li>一个简单的例子如下，使用 createSourceFile 创建文件，使用 openWriter 写入代码，这里代码 String code 的生成在后面讲解</li>
</ul>
<pre><code>private void generateCode(String className, String code) {
    try {
        JavaFileObject file = mFiler.createSourceFile(className);
        Writer writer = file.openWriter();
        writer.write(code);
        writer.close();
    } catch (IOException e) {
        e.printStackTrace();
    }
}
</code></pre><p><br></p>
<h5 id="Elements"><a href="#Elements" class="headerlink" title="Elements"></a>Elements</h5><ul>
<li>JDK 1.6 之后 javax.lang.model 中定义了 16 类 Element，包含了 Java 中最常用的元素</li>
</ul>
<pre><code>public enum ElementKind {
    PACKAGE,            //包
    ENUM,               //枚举
    CLASS,              //类
    ANNOTATION_TYPE,    //注解
    INTERFACE,          //接口
    ENUM_CONSTANT,      //枚举
    FIELD,              //字段
    PARAMETER,          //参数
    LOCAL_VARIABLE,     //局部变量
    EXCEPTION_PARAMETER,//异常
    METHOD,             //方法
    CONSTRUCTOR,        //构造器
    STATIC_INIT,        //静态域
    INSTANCE_INIT,      //实例域
    TYPE_PARAMETER,     //泛型参数
    OTHER,              //其他
    RESOURCE_VARIABLE;  //这个不清楚
}
</code></pre><ul>
<li>知道上面的信息之后 Elements 的作用就很好懂了</li>
</ul>
<pre><code>public interface Elements {

/*
* 返回包 element, 传入全限定名
*/
PackageElement getPackageElement(CharSequence var1);

/* 
* 返回类 element, 传入注解的 canonical name
*/ 
TypeElement getTypeElement(CharSequence var1);

/*
* 返回注解中的值，包含默认值
*/
 Map&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; getElementValuesWithDefaults(AnnotationMirror var1);

/*
 * 返回文档注释
 */
  String getDocComment(Element var1);
/*
 * 判断是否弃用
 */  
  boolean isDeprecated(Element var1);

/*
 * 返回二进制名称
 */
  Name getBinaryName(TypeElement var1);

/*
 * 返回类型所在的包对应的类 element
 */
 PackageElement getPackageOf(Element var1);

/**
* 返回类的所有成员对应的 element，不管是继承的还是直接声明的。
* 对于一个类，结果还包括其构造方法，但不包括局部类或匿名类。
* 注意，使用 elementfilter 中的方法可以隔离某个种类的元素。
*/
 List&lt;? extends Element&gt; getAllMembers(TypeElement var1);

/*
* 返回元素的所有注释，不管是继承的还是直接存在的
*/
 List&lt;? extends AnnotationMirror&gt; getAllAnnotationMirrors(Element var1);

/*
* 测试一个类型，方法或者字段是否隐藏了另一个类型，方法或字段
*/
 boolean hides(Element var1, Element var2);

/* 
 * 测试一个方法（作为给定类型的成员）是否重写了另一个方法。
 * 当非抽象方法重写抽象方法时，还可以说成是前者实现了后者。
 * 第三个参数为第一个方法所属的类对应的 element
 */
 boolean overrides(ExecutableElement var1, ExecutableElement var2, TypeElement var3);

/*
 * 返回表示基本值或字符串的常量表达式文本。返回文本的形式是一种适合于表示源代码中的值的形式
 */ 
 String getConstantExpression(Object var1);

/*
 *按指定顺序将元素的表示形式打印到给定 writer。此方法的主要用途是诊断。输出的具体格式没有 指定并且是可以更改的。
 */    
 void printElements(Writer var1, Element... var2);

/* 
 * 返回与参数具有相同字符序列的名称
 */
  Name getName(CharSequence var1);

/*
 * 如果类型是一个泛型接口则返回 true，否则返回 false
 */  
  boolean isFunctionalInterface(TypeElement var1);
}
</code></pre><p><br></p>
<h5 id="TypeMirror"><a href="#TypeMirror" class="headerlink" title="TypeMirror"></a>TypeMirror</h5><ul>
<li>通过 ProcessingEnvironment 我们还可以获取 Types 对象，这个对象主要提供关于 TypeMirror 的工具方法，TypeMirror 对应了java 中的类型，包括了如下几类 ，Types 很简单这里就略过了</li>
</ul>
<pre><code>public enum TypeKind {
    BOOLEAN,
    BYTE,
    SHORT,
    INT,
    LONG,
    CHAR,
    FLOAT,
    DOUBLE,
    VOID,
    NONE,
    NULL,
    ARRAY,
    DECLARED,
    ERROR,
    TYPEVAR,
    WILDCARD,
    PACKAGE,
    EXECUTABLE,
    OTHER,
    UNION,
    INTERSECTION;
}
</code></pre><ul>
<li>总结一下，init 方法主要给我们提供了一些处理注解的工具，我们将在 process 方法中用到他们</li>
</ul>
<p><br></p>
<h4 id="process"><a href="#process" class="headerlink" title="process"></a>process</h4><ul>
<li>返回值，表示是否处理了这个注解，返回 true 则该注解被当前 processor 消耗，不再处理</li>
</ul>
<ul>
<li>Set\&lt;? extends TypeElement> set</li>
</ul>
<ul>
<li>RoundEnvironment</li>
</ul>
<pre><code>public interface RoundEnvironment {

    boolean processingOver();

    //上一轮注解处理器是否产生错误
    boolean errorRaised();

    //返回上一轮注解处理器生成的根元素
    Set&lt;? extends Element&gt; getRootElements();

    //返回包含指定注解类型的元素的集合
    Set&lt;? extends Element&gt; getElementsAnnotatedWith(TypeElement var1);

    //返回包含指定注解类型的元素的集合
    Set&lt;? extends Element&gt; getElementsAnnotatedWith(Class&lt;? extends Annotation&gt; var1);
}
</code></pre><p><br></p>
<h3 id="原生动态编译-api"><a href="#原生动态编译-api" class="headerlink" title="原生动态编译 api"></a>原生动态编译 api</h3><p><strong>我们先不用 javapoet 去编写注解处理器，这里的重点在收集注解信息，网上有很多文章这部分写得虎头蛇尾，前面给你复习一堆注解的基本知识，后面要动真格了就单单生成个 hello world，看完了还是什么都不会，注解都不处理，还叫什么注解处理器？</strong></p>
<ul>
<li>从 Java 6 开始 Java 提供了JavaFileObject等一系列动态编译 api，说了这么多，我们现在就开始用代码生成代码</li>
</ul>
<ul>
<li>这里建议先将需要生成的代码手写一遍，然后尽量复制粘贴</li>
</ul>
<p><br></p>
<h3 id="AutoService"><a href="#AutoService" class="headerlink" title="AutoService"></a>AutoService</h3><ul>
<li>auto-service 是谷歌提供的一套工具，可以自动生成我们刚刚提到的 META-INF/services/ 下的文件</li>
</ul>
<ul>
<li>网络上很多文章对 auto-service 的作用不了解，以为为了生成代码就必须要依赖它，结果到最后根本就没有使用 auto-service</li>
</ul>
<ul>
<li>使用起来很简单，只需要添加依赖之后给自己的processor 这样加上注解既可</li>
</ul>
<pre><code>compileOnly &quot;com.google.auto.service:auto-service:1.0-rc4&quot;
@AutoService(Processor.class)
public class TestProcessor extends AbstractProcessor {
}
</code></pre><p><br></p>
<h2 id="Javapoet"><a href="#Javapoet" class="headerlink" title="Javapoet"></a>Javapoet</h2><ul>
<li>在 gradle 中添加依赖</li>
</ul>
<pre><code>dependencies {
    compileOnly &quot;com.squareup:javapoet:1.11.1&quot;
    annotationProcessor &quot;com.google.auto.service:auto-service:1.0-rc4&quot;
}
</code></pre><p><br></p>
<h2 id="注解框架实例"><a href="#注解框架实例" class="headerlink" title="注解框架实例"></a>注解框架实例</h2><p><strong>未完待续</strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入JVM系列 4 - Class 文件]]></title>
      <url>/2018/10/19/JVMClassFile/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><a href="https://tocreate.app/2018/09/05/jvm/" target="_blank" rel="external">本文为深入JVM系列的一部分</a></p>
<p><a href="https://tocreate.app/2018/10/17/JVMOopKlass/" target="_blank" rel="external">可能需要阅读前文</a></p>
<p><br></p>
<h3 id="Class-文件结构"><a href="#Class-文件结构" class="headerlink" title="Class 文件结构"></a>Class 文件结构</h3><ul>
<li>下面是class文件的格式，class文件是以字节为单位的二进制流，包含无符号数和表两种数据项，所有数据项紧密排列没有空隙，大于1字节的数据以高位在前的形式存储，class文件不依赖于实际的存储形式，不管是在内存中还是硬盘中，只要可以用流读取就可以</li>
</ul>
<pre><code>//in https://docs.oracle.com/javase/specs/jvms/se7/jvms7.pdf
ClassFile { //编译后的class文件格式
       u4             magic; //魔数，固定值为 0xCAFEBABE
       u2             minor_version; //次版本号
       u2             major_version; //主版本号
       u2             constant_pool_count; //常量池大小
       cp_info        constant_pool[constant_pool_count-1]; //常量池
       u2             access_flags; //访问标识符
       u2             this_class; //当前类
       u2             super_class; //父类
       u2             interfaces_count; //接口数量
       u2             interfaces[interfaces_count]; //接口
       u2             fields_count; //字段数量
       field_info     fields[fields_count]; //字段表
       u2             methods_count; //方法数
       method_info    methods[methods_count]; //方法表
       u2             attributes_count; //属性数量
       attribute_info attributes[attributes_count]; //属性表
}
</code></pre><ul>
<li>在 linux 下可以使用 od 命令以16形式查看，不过个人觉得有个概念就行了</li>
</ul>
<pre><code>od -t xCc 文件名 #用16进制来输出文件的内容，同时用ASCII字符对照显示
od -t xC 文件名 #纯16进制显示
</code></pre><p><br></p>
<h3 id="常量池类型"><a href="#常量池类型" class="headerlink" title="常量池类型"></a>常量池类型</h3><ul>
<li>constant_pool，即存储所有常量的地方，包括字符串常量，类名，接口名，方法名等等，虚拟机是围绕符号引用设计的，也就是指令执行时只引用了常量池表中的符号信息, 常量池的所有类型都有自己的结构</li>
</ul>
<table>
<thead>
<tr>
<th>Constant Type</th>
<th>Value</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>CONSTANT_Class</td>
<td>7</td>
<td>类常量</td>
</tr>
<tr>
<td>CONSTANT_Fieldref</td>
<td>9</td>
<td>字段符号引用</td>
</tr>
<tr>
<td>CONSTANT_Methodref</td>
<td>10</td>
<td>类方法符号引用</td>
</tr>
<tr>
<td>CONSTANT_InterfaceMethodref</td>
<td>11</td>
<td>接口方法符号引用</td>
</tr>
<tr>
<td>CONSTANT_String</td>
<td>8</td>
<td>String 常量</td>
</tr>
<tr>
<td>CONSTANT_Integer</td>
<td>3</td>
<td>int常量</td>
</tr>
<tr>
<td>CONSTANT_Float</td>
<td>4</td>
<td>float常量</td>
</tr>
<tr>
<td>CONSTANT_Long</td>
<td>5</td>
<td>long 常量</td>
</tr>
<tr>
<td>CONSTANT_Double</td>
<td>6</td>
<td>double 常量</td>
</tr>
<tr>
<td>CONSTANT_NameAndType</td>
<td>12</td>
<td>字段或方法的部分符号引用</td>
</tr>
<tr>
<td>CONSTANT_Utf8</td>
<td>1</td>
<td>UTF-8 编码字符串</td>
</tr>
<tr>
<td>CONSTANT_MethodHandle</td>
<td>15</td>
<td>方法句柄</td>
</tr>
<tr>
<td>CONSTANT_MethodType</td>
<td>16</td>
<td>标识方法类型</td>
</tr>
<tr>
<td>CONSTANT_InvokeDynamic</td>
<td>18</td>
<td>表示一个动态方法的调用点</td>
</tr>
</tbody>
</table>
<ul>
<li>例如，CONSTANT_Class_info，tag用于区分类型，其值如上表所述，name_index指向CONSTANT_Utf8_info常量，该常量是类的全限定名，下面是其他所有类型的定义</li>
</ul>
<pre><code>CONSTANT_Class_info {
      u1 tag;
      u2 name_index; //类全限定名的CONSTANT_Utf8_info索引
 }

CONSTANT_Fieldref_info {
      u1 tag;
      u2 class_index; //声明该字段的类或接口的CONSTANT_Class_info索引
      u2 name_and_type_index;//字段描述符的CONSTANT_NameAndType_info索引
 }

 CONSTANT_Methodref_info {
      u1 tag;
      u2 class_index; //声明该方法的类或接口的CONSTANT_Class_info索引
      u2 name_and_type_index; //指向名称及类型的CONSTANT_NameAndType_info索引
 }

 CONSTANT_InterfaceMethodref_info {
      u1 tag;
      u2 class_index;
      u2 name_and_type_index;
 }

 CONSTANT_Utf8_info {
      u1 tag;
      u2 length;//长度
      u1 bytes[length];//内容
 }

 CONSTANT_String_info {
      u1 tag;
      u2 string_index;//CONSTANT_Utf8_info
 }

 CONSTANT_Integer_info {
      u1 tag;
      u4 bytes; 
 }

 CONSTANT_Float_info {
      u1 tag;
      u4 bytes; 
 }

 CONSTANT_Long_info {
      u1 tag;
      u4 high_bytes;
      u4 low_bytes;
 }

 CONSTANT_Double_info {
      u1 tag;
      u4 high_bytes;
      u4 low_bytes;
 }

 CONSTANT_NameAndType_info {
      u1 tag;
      u2 name_index; //名称常量索引
      u2 descriptor_index;//描述符常量索引
 }


 CONSTANT_MethodHandle_info {
  u1 tag;
  u1 reference_kind;//句柄类型
  u2 reference_index;
 }

 CONSTANT_MethodType_info {
  u1 tag;
  u2 descriptor_index;
 }

 CONSTANT_InvokeDynamic_info {
  u1 tag;
  u2 bootstrap_method_attr_index;
  u2 name_and_type_index;
 }
</code></pre><p><br></p>
<h3 id="字段表"><a href="#字段表" class="headerlink" title="字段表"></a>字段表</h3><ul>
<li>包含静态字段和实例字段</li>
</ul>
<pre><code> //in https://docs.oracle.com/javase/specs/jvms/se7/jvms7.pdf 
 field_info {
       u2             access_flags;
       u2             name_index;
       u2             descriptor_index;
       u2             attributes_count;
       attribute_info attributes[attributes_count];
}
</code></pre><p><br></p>
<h3 id="方法表"><a href="#方法表" class="headerlink" title="方法表"></a>方法表</h3><ul>
<li>包含实例初始化方法和类初始化方法的所有方法</li>
</ul>
<pre><code>//in https://docs.oracle.com/javase/specs/jvms/se7/jvms7.pdf
   method_info {
       u2             access_flags;
       u2             name_index;
       u2             descriptor_index;
       u2             attributes_count;
       attribute_info attributes[attributes_count];
}
</code></pre><p><br></p>
<h3 id="属性表"><a href="#属性表" class="headerlink" title="属性表"></a>属性表</h3><ul>
<li>字段表，方法表都可以拥有自己的属性表集合，用来描述特定场景的信息</li>
</ul>
<pre><code> //in https://docs.oracle.com/javase/specs/jvms/se7/jvms7.pdf 
 attribute_info {
       u2 attribute_name_index;
       u4 attribute_length;
       u1 info[attribute_length];
}
</code></pre><p><strong>未完待续</strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入JVM系列 3 - OOP-Klass]]></title>
      <url>/2018/10/17/JVMOopKlass/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><a href="https://tocreate.app/2018/09/05/jvm/" target="_blank" rel="external">本文为深入JVM系列的一部分</a></p>
<p><a href="https://tocreate.app/2018/10/17/JVMUseGdb/" target="_blank" rel="external">可能需要阅读前文</a></p>
<p><strong>注意本文中若没有特别指明 java 类与 java 对象，则所有类和对象都是指 c++ 中的类和对象</strong></p>
<p><br></p>
<h3 id="OOP-Klass"><a href="#OOP-Klass" class="headerlink" title="OOP-Klass"></a>OOP-Klass</h3><p><strong>OOP-Klass 是 HotSpot 中对象实现的模型</strong></p>
<ul>
<li><p>实现 OOP-Klass 的动机，是为了避免每个对象都持有一个虚函数表的指针</p>
</li>
<li><p>OOP：普通对象指针，用来描述对象实例信息</p>
</li>
<li><p>Klass：Java 类的 c++ 对等实体，用来描述 Java 类，持有 VTBL, OOP 对象可以使用它来找到所有虚函数</p>
</li>
</ul>
<pre><code>对于第一点，实现 OOP-Klass 的动机，很多人说&quot;OOP-Klass 是为了避免每个对象都 生成/含有 一个虚函数表”
实际上在 c++ 中如果一个类有虚函数，那么这个类的所有对象共享一个虚函数表，每个对象的指针 \_vptr 指向了虚函数表
OOP-Klass 模型是了避免每个对象都 生成/含有 一个虚函数表指针 \_vptr

下面 klass.hpp 中的这段注释正好证实了这一点
//in http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/87ee5ee27509/src/share/vm/oops/klass.hpp
// One reason for the oop/klass dichotomy in the implementation is
// that we don&apos;t want a C++ vtbl pointer in every object.  Thus,
// normal oops don&apos;t have any virtual functions.  Instead, they
// forward all &quot;virtual&quot; functions to their klass, which does have
// a vtbl and does the C++ dispatch depending on the object&apos;s
// actual type.  (See oop.inline.hpp for some of the forwarding code.)
// ALL FUNCTIONS IMPLEMENTING THIS DISPATCH ARE PREFIXED WITH &quot;oop\_&quot;!
</code></pre><p><br></p>
<h3 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h3><p><br></p>
<h4 id="OOP-框架"><a href="#OOP-框架" class="headerlink" title="OOP 框架"></a>OOP 框架</h4><pre><code>//in hotspot/src/share/vm/oops/oop.hpp
class oopDesc {
  friend class VMStructs;
 private:
  volatile markOop  _mark;
  union _metadata {
    wideKlassOop    _klass;
    narrowOop       _compressed_klass;
  } _metadata;
</code></pre><ul>
<li>oop类的共同基类为 oopDesc,每一个 oopDesc 子类对应一种对象类型</li>
</ul>
<pre><code>instanceOopDesc 描述java类的实例，对象头
methodOopDesc 描述java方法
arrayOopDesc 描述数组
klassOopDesc 描述java类
markOopDesc 描述对象头
...
</code></pre><p><br></p>
<h4 id="对象与对象头"><a href="#对象与对象头" class="headerlink" title="对象与对象头"></a>对象与对象头</h4><ul>
<li><p>虚拟机中对象的内存布局分为连续的两部分，instanceOopDesc(对象头)和实例数据（算上对齐填充是三部分）</p>
</li>
<li><p>对象头又分为两部分，mark word 和 元数据指针(继承自oopDesc，见上文)</p>
</li>
<li><p>mark word，占用大小与虚拟机字长一致，存储 hashCode，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等</p>
</li>
<li><p>元数据指针，指向 klassInstance 的指针， klassInstance 包含了类的元数据可以定位到位于方法区的类型信息</p>
</li>
</ul>
<pre><code>//对象头的定义
//in hotspot/src/share/vm/oops/markOop.hpp
// Bit-format of an object header (most significant first, big endian layout below):
//
//  32 bits:
//  --------
//             hash:25 ------------\&gt;| age:4    biased\_lock:1 lock:2 (normal object)
//             JavaThread\*:23 epoch:2 age:4    biased\_lock:1 lock:2 (biased object)
//             size:32 ------------------------------------------\&gt;| (CMS free block)
//             PromotedObject\*:29 ----------\&gt;| promo\_bits:3 -----\&gt;| (CMS promoted object)
//
//  64 bits:
//  --------
//  unused:25 hash:31 --\&gt;| unused:1   age:4    biased\_lock:1 lock:2 (normal object)
//  JavaThread\*:54 epoch:2 unused:1   age:4    biased\_lock:1 lock:2 (biased object)
//  PromotedObject\*:61 ---------------------\&gt;| promo\_bits:3 -----\&gt;| (CMS promoted object)
//  size:64 -----------------------------------------------------\&gt;| (CMS free block)
//
//  unused:25 hash:31 --\&gt;| cms\_free:1 age:4    biased\_lock:1 lock:2 (COOPs &amp;&amp; normal object)
//  JavaThread\*:54 epoch:2 cms\_free:1 age:4    biased\_lock:1 lock:2 (COOPs &amp;&amp; biased object)
//  narrowOop:32 unused:24 cms\_free:1 unused:4 promo\_bits:3 -----\&gt;| (COOPs &amp;&amp; CMS promoted object)
//  unused:21 size:35 --\&gt;| cms\_free:1 unused:7 ------------------\&gt;| (COOPs &amp;&amp; CMS free block)

//元数据的定义
\&apos;&apos;   union \_metadata {
\&apos;&apos;     wideKlassOop    \_klass; //klassInstance指针
\&apos;&apos;     narrowOop       \_compressed\_klass; //klassInstance指针的压缩形式32位，在 64 位机上使用它可以提高效率
\&apos;&apos;   } \_metadata;
</code></pre><p><br></p>
<h3 id="Klass"><a href="#Klass" class="headerlink" title="Klass"></a>Klass</h3><p><br></p>
<h4 id="Klass-类"><a href="#Klass-类" class="headerlink" title="Klass 类"></a>Klass 类</h4><p><strong>对象访问机制: new -> 堆中分配对象头和实例数据 -> java 中引用 -> 访问 instanceOop -> 元数据指针 -> instanceKlass </strong></p>
<ul>
<li>Klass 是所有 Klass 类的共同父类，定义了 Klass 类的共同行为</li>
</ul>
<ul>
<li><p>Klass 类包含 layout_helper 字段，对于instance类型用于表示instance大小，对于数组类型，它是数组描述的位图，被分割为如下四部分，tag（OOP或基本类型），hsz（头不大行，即第一个元素的偏移），ebt（基本类型的元素），esz（元素大小）</p>
</li>
<li><p>name 字段,是类的名称</p>
</li>
</ul>
<ul>
<li>java_mirror 字段，是java的class类的实例</li>
</ul>
<ul>
<li>super，first subklass，next_sibling，为父类，第一子类，和兄弟类，这些的字段足以构成一棵树_</li>
</ul>
<pre><code>//klassOop 对象的布局
//in hotspot/src/share/vm/oops/klass.hpp
//  Klass layout:
//    [header        ] klassOop
//    [klass pointer ] klassOop
//    [C++ vtbl ptr  ] (contained in Klass\_vtbl)
//    [layout\_helper ]
//    [super\_check\_offset   ] for fast subtype checks
//    [secondary\_super\_cache] for fast subtype checks
//    [secondary\_supers     ] array of 2ndary supertypes
//    [primary\_supers 0]
//    [primary\_supers 1]
//    [primary\_supers 2]
//    ...
//    [primary\_supers 7]
//    [java\_mirror   ]
//    [super         ]
//    [name          ]
//    [first subklass]
//    [next\_sibling  ] link to chain additional subklasses
//    [modifier\_flags]
//    [access\_flags  ]
//    [verify\_count  ] - not in product
//    [alloc\_count   ]
//    [last\_biased\_lock\_bulk\_revocation\_time] (64 bits)
//    [prototype\_header]
//    [biased\_lock\_revocation\_count]
//    [trace\_id]
</code></pre><p><br></p>
<h4 id="instanceKlass-类"><a href="#instanceKlass-类" class="headerlink" title="instanceKlass 类"></a>instanceKlass 类</h4><ul>
<li>每个已加载的 Java 类对应一个 instanceKlass 类的对象，instanceKlass的成员可以描述一个 java 类的所有信息，它们在类解析阶段赋值</li>
</ul>
<pre><code>    //instanceKlass 对象的布局
    //hotspot/src/share/vm/oops/instanceKlass.hpp
    //instanceKlass layout:
//    [header                     ] klassOop
//    [klass pointer              ] klassOop
//    [C++ vtbl pointer           ] Klass
//    [subtype cache              ] Klass
//    [instance size              ] Klass
//    [java mirror                ] Klass
//    [super                      ] Klass
//    [access\_flags               ] Klass
//    [name                       ] Klass
//    [first subklass             ] Klass
//    [next sibling               ] Klass
//    [array klasses              ]
//    [methods                    ]
//    [local interfaces           ]
//    [transitive interfaces      ]
//    [fields                     ]
//    [constants                  ]
//    [class loader               ]
//    [protection domain          ]
//    [signers                    ]
//    [source file name           ]
//    [inner classes              ]
//    [static field size          ]
//    [nonstatic field size       ]
//    [static oop fields size     ]
//    [nonstatic oop maps size    ]
//    [has finalize method        ]
//    [deoptimization mark bit    ]
//    [initialization state       ]
//    [initializing thread        ]
//    [Java vtable length         ]
//    [oop map cache (stack maps) ]
</code></pre><p><strong>本篇完</strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入JVM系列 2 - gdb 调试 HotSpot]]></title>
      <url>/2018/10/17/JVMUseGdb/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><a href="https://tocreate.app/2018/09/05/jvm/" target="_blank" rel="external">本文为深入JVM系列的一部分</a></p>
<p><a href="https://tocreate.app/2018/09/26/JVMCompileOpenJdk7/" target="_blank" rel="external">可能需要阅读前文</a></p>
<p><br></p>
<h3 id="安装-gdb"><a href="#安装-gdb" class="headerlink" title="安装 gdb"></a>安装 gdb</h3><ul>
<li>Linux自带gdb，mac上安装<a href="https://blog.csdn.net/qq_34290780/article/details/79898696?utm_source=blogxgwz7" target="_blank" rel="external">看这里</a></li>
</ul>
<p><br></p>
<h3 id="启动-HotSpot"><a href="#启动-HotSpot" class="headerlink" title="启动 HotSpot"></a>启动 HotSpot</h3><ul>
<li>可以参考这个路径找到启动脚本，注意必须为 debug 版本，否则可能无法调试</li>
</ul>
<pre><code>/Users/alberthumbert/jdk7u-dev/build/macosx-x86\_64-debug/hotspot/outputdir/bsd\_amd64\_compiler2/jvmg
</code></pre><ul>
<li>在 env.sh 中将 JavaPath 改为编译出来的版本</li>
</ul>
<ul>
<li>使用如下命令可以启动虚拟机，其中 Test 为我们编译出来的 class 文件</li>
</ul>
<pre><code>./hotspot -gdb -classpath /Users/alberthumbert/jdk7u-dev/build/macosx-x86\_64/hotspot/outputdir/bsd\_amd64\_compiler2/product Test
</code></pre><p><br></p>
<h3 id="使用-gdb"><a href="#使用-gdb" class="headerlink" title="使用 gdb"></a>使用 gdb</h3><p><strong>gdb虽然没有可视化的调试程序直观，但提供了足够丰富的命令</strong></p>
<p><br></p>
<h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><ul>
<li>调试程序,注意文件必须是可执行文件而且是可以调试的，如果使用 gcc 编译 那么编译时带上 -g 参数即可</li>
</ul>
<pre><code>gdb &lt;file&gt;
run
</code></pre><p><br></p>
<h4 id="浏览"><a href="#浏览" class="headerlink" title="浏览"></a>浏览</h4><ul>
<li>查看代码</li>
</ul>
<pre><code># 显示 10 行
list

# 显示第 5 到 10 行
list 5,10

# 显示某个文件的第 5 到 10 行
list &lt;file&gt;:5,10
</code></pre><ul>
<li>查找代码</li>
</ul>
<pre><code># 查找关键字
search &lt;word&gt;

# 向前查找
reverse-search
</code></pre><p><br></p>
<h4 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h4><ul>
<li>设置断点</li>
</ul>
<pre><code># 按行号设置断点
break &lt;number&gt;

# 按函数名设置断点
break &lt;fun&gt;

# 按条件表达式设置断点
break7 if &lt;state&gt;
</code></pre><ul>
<li>查看断点</li>
</ul>
<pre><code>info breakpoints
</code></pre><ul>
<li>删除断点</li>
</ul>
<pre><code>&apos;Deleted breakpoint 1
</code></pre><p><br></p>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ul>
<li>打印变量 </li>
</ul>
<pre><code>print &lt;var&gt;
</code></pre><ul>
<li>查看变量或表达式类型</li>
</ul>
<pre><code>whatis &lt;var&gt;
</code></pre><ul>
<li>赋值</li>
</ul>
<pre><code>set variable &lt;var&gt; = &lt;value&gt;
</code></pre><p><br></p>
<h4 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h4><ul>
<li>单行执行</li>
</ul>
<pre><code>next
</code></pre><ul>
<li>进入函数</li>
</ul>
<pre><code>step
</code></pre><p><strong>本篇完</strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入操作系统 4 - 系统库函数]]></title>
      <url>/2018/10/15/OSBaseLib/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><a href="https://tocreate.app/2019/03/02/OperatingSystem/" target="_blank" rel="external">本文为深入操作系统系列的一部分</a></p>
<p><a href="https://tocreate.app/2018/10/15/OSBootstrap/" target="_blank" rel="external">可能需要阅读前文</a></p>
<p><strong>本文大概内容为在现有环境上搭建一个操作系统基础开发框架，包括基本的库函数，makefile等</strong></p>
<p><strong>本文中的所有代码可以在 <a href="https://github.com/AlbertHumbert/Chaos" target="_blank" rel="external">https://github.com/AlbertHumbert/Chaos</a> 获取</strong><br><strong>对应 commit版本为 ce2e1e2b27806ebbb387ed3c1285204845fa800d</strong></p>
<p><strong>题外话，今天发现一个不错的个人开发的开源操作系统 <a href="https://gitlab.com/sortix" target="_blank" rel="external"> sortix </a>, 小巧，干净，self-hosting，有完整的posix 实现，开发者是 Jonas Termansen，目前任职于 google，参与 dart 语言的开发，他在大学时期开始编写 sortix，维护至今</strong></p>
<p><br></p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p><br></p>
<h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><p><strong>下面所有的条件除了 make 以外都在前几篇文章中提及了</strong></p>
<ul>
<li><p>cross-gcc</p>
</li>
<li><p>GRUB 与 Xorriso</p>
</li>
<li><p>Qemu</p>
</li>
<li><p>make，4.0以上</p>
</li>
</ul>
<p><br></p>
<h4 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h4><ul>
<li>从现在开始，我们的项目的复杂度又上了一个台阶，之前我一直借助简单的 shell 脚本简化来编译和启动的命令，但现在这种方法已经很难行的通了</li>
</ul>
<ul>
<li>我们需要一些 makefile 的知识来管理整个编译流程，makefile 的博文，我想没有那篇写得比陈皓大神的<a href="https://blog.csdn.net/weixin_38391755/article/details/80380786" target="_blank" rel="external">这篇</a>好了吧</li>
</ul>
<p><br></p>
<h3 id="sysroot"><a href="#sysroot" class="headerlink" title="sysroot"></a>sysroot</h3><ul>
<li>在交叉编译环境中如果我们不指定 sysroot，编译器会默认在 /usr/include 和 /usr/lib 中寻找头文件和库，我们这里应该使用自己编写的库，因此需要指定 sysroot</li>
</ul>
<ul>
<li>我们需要给自己的编译器指定 –sysroot 参数，一旦指定这个参数，你就可以将 sysroot 作为目标操作系统的根目录</li>
</ul>
<pre><code>gcc --sysroot PATH
</code></pre><ul>
<li>我们将某个路径指定为 sysroot 之后，为了不让编译器去该路径查找标准库函数，我们之前使用 –without-headers 参数编译了 cross-gcc, 如果之后我们实现了自己的 libc 和用户空间，那么就需要用 –with-sysroot 重新编译，这样编译器就会去找它们了</li>
</ul>
<p><br></p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul>
<li>为了能够更好地分模块管理，这里按如下划分目录，其中 kernel 是我们内核的实现，libc则是系统库函数</li>
</ul>
<ul>
<li>我们将所有体系架构相关的实现放在 arch 目录</li>
</ul>
<pre><code>dir - kernel - arch - i386
    |       |- include - kernel
    |       |_ kernel
    |
    |_ libc --  arch - i386
            |_ include
            |_ stdio
            |_ stdib
            |_ string 
</code></pre><p><br></p>
<h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><p><strong>在目前的开发环境中，我们可以使用的头文件包括以下两部分</strong></p>
<ul>
<li>编译器自带的头文件，这些头文件一般只是声明了一些编译器目标体系架构中可以使用的数据类型和相关的宏，如 stddef.h，stdint.h，但是它们非常有用</li>
</ul>
<ul>
<li>自己编写的头文件，这是当然的，不过为了编译器能够在 sysroot 中找到这些文件，我们需要将这些文件放在 sysroot 当中</li>
</ul>
<p><br></p>
<h3 id="动工"><a href="#动工" class="headerlink" title="动工"></a>动工</h3><p><strong>现在我们来写几个简单又必要的库函数，相信学过c语言的人都能读懂，没学过的。。。大概也能读懂</strong></p>
<p><br></p>
<h4 id="stdio"><a href="#stdio" class="headerlink" title="stdio"></a>stdio</h4><ul>
<li>purchar</li>
</ul>
<pre><code># include \&lt;stdio.h\&gt;
# include \&lt;kernel/tty.h\&gt;

int putchar(int ic){
    terminal_putchar((char)ic);
    return ic;
}
</code></pre><ul>
<li>printf</li>
</ul>
<p><br></p>
<h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><ul>
<li>strlen</li>
</ul>
<pre><code># include \&lt;string.h\&gt;
size\_t strlen(const char \* str){
    size_t len = 0;
    while(str[len])
        len ++;
    return len;
}
</code></pre><p><br></p>
<h5 id="makefile-1"><a href="#makefile-1" class="headerlink" title="makefile"></a>makefile</h5><ul>
<li>makefile 我们暂时分为两步分 kernel 和 libc ，这部分都是基本语法，只是环境变量比较多而已</li>
</ul>
<ul>
<li>kernel</li>
</ul>
<pre><code>DEFAULT\_HOST!=../default-host.sh
HOST?=DEFAULT\_HOST
HOSTARCH!=../target-triplet-to-arch.sh $(HOST)

CFLAGS?=-O2 -g
CPPFLAGS?=
LDFLAGS?=
LIBS?=

DESTDIR?=
PREFIX?=/usr/local
EXEC\_PREFIX?=$(PREFIX)
BOOTDIR?=$(EXEC\_PREFIX)/boot
INCLUDEDIR?=$(PREFIX)/include

CFLAGS:=$(CFLAGS) -ffreestanding -Wall -Wextra
CPPFLAGS:=$(CPPFLAGS) -D\_\_is\_kernel -Iinclude
LDFLAGS:=$(LDFLAGS)
LIBS:=$(LIBS) -nostdlib -lk -lgcc

ARCHDIR=arch/i386

include $(ARCHDIR)/make.config

CFLAGS:=$(CFLAGS) $(KERNEL\_ARCH\_CFLAGS)
CPPFLAGS:=$(CPPFLAGS) $(KERNEL\_ARCH\_CPPFLAGS)
LDFLAGS:=$(LDFLAGS) $(KERNEL\_ARCH\_LDFLAGS)
LIBS:=$(LIBS) $(KERNEL\_ARCH\_LIBS)

KERNEL\_OBJS=\\
$(KERNEL\_ARCH\_OBJS) \\
kernel/kernel.o \\

OBJS=\\
$(ARCHDIR)/crti.o \\
$(ARCHDIR)/crtbegin.o \\
$(KERNEL\_OBJS) \\
$(ARCHDIR)/crtend.o \\
$(ARCHDIR)/crtn.o \\

LINK\_LIST=\\
$(LDFLAGS) \\
$(ARCHDIR)/crti.o \\
$(ARCHDIR)/crtbegin.o \\
$(KERNEL\_OBJS) \\
$(LIBS) \\
$(ARCHDIR)/crtend.o \\
$(ARCHDIR)/crtn.o \\

.PHONY: all clean install install-headers install-kernel
.SUFFIXES: .o .c .S

all: chaos.kernel

chaos.kernel: $(OBJS) $(ARCHDIR)/linker.ld
    $(CC) -T $(ARCHDIR)/linker.ld -o $@ $(CFLAGS) $(LINK_LIST)
    grub-file --is-x86-multiboot chaos.kernel

$(ARCHDIR)/crtbegin.o $(ARCHDIR)/crtend.o:
    OBJ=`$(CC) $(CFLAGS) $(LDFLAGS) -print-file-name=$(@F)` &amp;&amp; cp &quot;$$OBJ&quot; $@

.c.o:
    $(CC) -MD -c $&lt; -o $@ -std=gnu99 $(CFLAGS) $(CPPFLAGS)

.S.o:
    $(CC) -MD -c $&lt; -o $@ $(CFLAGS) $(CPPFLAGS)

clean:
    rm -f chaos.kernel
    rm -f $(OBJS) *.o */*.o */*/*.o
    rm -f $(OBJS:.o=.d) *.d */*.d */*/*.d

install: install-headers install-kernel

install-headers:
    mkdir -p $(DESTDIR)$(INCLUDEDIR)
    cp -R -p include/. $(DESTDIR)$(INCLUDEDIR)/.

install-kernel: chaos.kernel
    mkdir -p $(DESTDIR)$(BOOTDIR)
    cp chaos.kernel $(DESTDIR)$(BOOTDIR)

-include $(OBJS:.o=.d)
</code></pre><ul>
<li>libc</li>
</ul>
<pre><code>DEFAULT\_HOST!=../default-host.sh
HOST?=DEFAULT\_HOST

HOSTARCH!=../target-triplet-to-arch.sh $(HOST)

CFLAGS?=-O2 -g
CPPFLAGS?=
LDFLAGS?=
LIBS?=

DESTDIR?=
PREFIX?=/usr/local
EXEC\_PREFIX?=$(PREFIX)
BOOTDIR?=$(EXEC\_PREFIX)/boot
INCLUDEDIR?=$(PREFIX)/include

CFLAGS:=$(CFLAGS) -ffreestanding -Wall -Wextra
CPPFLAGS:=$(CPPFLAGS) -D\_\_is\_kernel -Iinclude
LDFLAGS:=$(LDFLAGS)
LIBS:=$(LIBS) -nostdlib -lk -lgcc

ARCHDIR=arch/i386

include $(ARCHDIR)/make.config

CFLAGS:=$(CFLAGS) $(ARCH\_CFLAGS)
CPPFLAGS:=$(CPPFLAGS) $(ARCH\_CPPFLAGS)
LIBK\_CFLAGS:=$(LIBK\_CFLAGS) $(KERNEL\_ARCH\_CFLAGS)
LIBK\_CPPFLAGS:=$(LIBK\_CPPFLAGS) $(KERNEL\_ARCH\_CPPFLAGS)

FREEOBJS=\\
$(ARCH\_FREEOBJS) \\
stdio/puts.o \\
string/strlen.o \\
stdio/printf.o \\
stdio/putchar.o \\
# stdlib/abort.o \\
# string/memcmp.o \\
# string/memcpy.o \\
# string/memmove.o \\
# string/memset.o \\


HOSTEDOBJS=\\
$(ARCH\_HOSTEDOBJS) \\

OBJS=\\
$(FREEOBJS) \\
$(HOSTEDOBJS) \\

LIBK\_OBJS=$(FREEOBJS:.o=.libk.o)

# BINARIES=libc.a libk.a # Not ready for libc yet.
BINARIES=libk.a

.PHONY: all clean install install-headers install-libs
.SUFFIXES: .o .libk.o .c .S

all: $(BINARIES)

libc.a: $(OBJS)
    $(AR) rcs $@ $(OBJS)

libk.a: $(LIBK\_OBJS)
    $(AR) rcs $@ $(LIBK_OBJS)

.c.o:
    $(CC) -MD -c $&lt; -o $@ -std=gnu99 $(CFLAGS) $(CPPFLAGS)

.c.S:
    $(CC) -MD -c $&lt; -o $@ $(CFLAGS) $(CPPFLAGS)

.c.libk.o:
    $(CC) -MD -c $&lt; -o $@ -std=gnu99 $(LIBK_CFLAGS) $(LIBK_CPPFLAGS)

.S.libk.o:
    $(CC) -MD -c $&lt; -o $@ $(LIBK_CFLAGS) $(LIBK_CPPFLAGS)

clean:
    rm -f $(BINARIES) *.a
    rm -f $(OBJS) $(LIBK_OBJS) *.o */*.o */*/*.o
    rm -f $(OBJS:.o=.d) $(LIBK_OBJS:.o=.d) *.d */*.d */*/*.d

install: install-headers install-libs

install-headers:
    mkdir -p $(DESTDIR)$(INCLUDEDIR)
    cp -R -p include/. $(DESTDIR)$(INCLUDEDIR)/.

install-libs: $(BINARIES)
    mkdir -p $(DESTDIR)$(LIBDIR)
    cp $(BINARIES) $(DESTDIR)$(LIBDIR)

-include $(OBJS:.o=.d)
-include $(LIBK\_OBJS:.o=.d)
</code></pre><ul>
<li>该脚本用于输出我们的 gcc 版本</li>
</ul>
<pre><code># !/bin/sh
echo i686-elf
</code></pre><ul>
<li>该脚本输出体系架构版本，ix86, 均输出为 1386</li>
</ul>
<pre><code># !/bin/sh
if echo &quot;$1&quot; | grep -Eq &apos;i[[:digit:]]86-&apos;; then
  echo i386
else
 echo &quot;$1&quot; | grep -Eo &apos;^[[:alnum:]\_]\*&apos;
fi
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入操作系统 3 -  GRUB 引导 & multiboot 镜像]]></title>
      <url>/2018/10/15/OSBootstrap/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><a href="https://tocreate.app/2019/03/02/OperatingSystem/" target="_blank" rel="external">本文为深入操作系统系列的一部分</a></p>
<p><a href="https://tocreate.app/2018/09/22/OSCrossGcc/" target="_blank" rel="external">可能需要阅读前文</a></p>
<p><strong>本文中我们首先编写编译一个简单的内核，使用 GRUB 制作一个镜像，然后使用 qemu 的CDROM模式启动，最后再来详细解释发生了什么</strong></p>
<p><strong>到了这一步理论上你已经可以制作一个可以在真实硬件上跑的系统了</strong></p>
<p><strong>本文中的所有代码可以在 <a href="https://github.com/AlbertHumbert/Chaos" target="_blank" rel="external">https://github.com/AlbertHumbert/Chaos</a> 获取</strong><br><strong>对应 commit版本为 835238a3761e600b7b881f5480deeb560965c3d3 </strong></p>
<p><br></p>
<h4 id="安装-GRUB"><a href="#安装-GRUB" class="headerlink" title="安装 GRUB"></a>安装 GRUB</h4><p><strong>准确地说是 GRUB2 ，如果是使用 Linux 由于其自带了 GRUB ，所以这一步可以跳过</strong></p>
<ul>
<li>首先需要编译 objconv 库</li>
</ul>
<pre><code>https://github.com/vertis/objconv
</code></pre><ul>
<li>使用 g++ 编译, 编译过程中遇到一个变量溢出的问题，看起来是 windows 相关的问题，我是直接注释掉了，编译完之后将文件夹添加到环境变量</li>
</ul>
<pre><code>g++ -o objconv -O2 src/\*.cpp
</code></pre><ul>
<li>下载源码，注意被不是所有版本都适合在 osx 上使用,建议使用 commit id 为 77063f4cb6 的版本</li>
</ul>
<pre><code>git clone git://git.savannah.gnu.org/grub.git
</code></pre><ul>
<li>执行目录中的 autogen.sh 脚本，然后执行 config</li>
</ul>
<pre><code>../grub/configure --disable-werror TARGET\_CC=i386-elf-gcc TARGET\_OBJCOPY=i386-elf-objcopy TARGET\_STRIP=i386-elf-strip TARGET\_NM=i386-elf-nm TARGET\_RANLIB=i386-elf-ranlib --target=i386-elf
</code></pre><ul>
<li><p>然后 make 和 make install 即可，注意一定要 install，否则制作出来的镜像是损坏的</p>
</li>
<li><p>安装 xorriso</p>
</li>
</ul>
<pre><code>brew install xorriso
</code></pre><p><br></p>
<h4 id="bootloader-file"><a href="#bootloader-file" class="headerlink" title="bootloader file"></a>bootloader file</h4><pre><code>/* Declare constants for the multiboot header. */
.set ALIGN,    1&lt;&lt;0             /* align loaded modules on page boundaries */
.set MEMINFO,  1&lt;&lt;1             /* provide memory map */
.set FLAGS,    ALIGN | MEMINFO  /* this is the Multiboot &apos;flag&apos; field */
.set MAGIC,    0x1BADB002       /* &apos;magic number&apos; lets bootloader find the header */
.set CHECKSUM, -(MAGIC + FLAGS) /* checksum of above, to prove we are multiboot */

/*
 Declare a multiboot header that marks the program as a kernel. These are magic
 values that are documented in the multiboot standard. The bootloader will
 search for this signature in the first 8 KiB of the kernel file, aligned at a
 32-bit boundary. The signature is in its own section so the header can be
 forced to be within the first 8 KiB of the kernel file.
 */
.section .multiboot
.align 4
.long MAGIC
.long FLAGS
.long CHECKSUM

/*
 The multiboot standard does not define the value of the stack pointer register
 (esp) and it is up to the kernel to provide a stack. This allocates room for a
 small stack by creating a symbol at the bottom of it, then allocating 16384
 bytes for it, and finally creating a symbol at the top. The stack grows
 downwards on x86. The stack is in its own section so it can be marked nobits,
 which means the kernel file is smaller because it does not contain an
 uninitialized stack. The stack on x86 must be 16-byte aligned according to the
 System V ABI standard and de-facto extensions. The compiler will assume the
 stack is properly aligned and failure to align the stack will result in
 undefined behavior.
 */
.section .bss
.align 16
stack_bottom:
.skip 16384 # 16 KiB
stack_top:

/*
 The linker script specifies _start as the entry point to the kernel and the
 bootloader will jump to this position once the kernel has been loaded. It
 doesn&apos;t make sense to return from this function as the bootloader is gone.
 */
.section .text
.global _start
.type _start, @function
_start:
/*
    The bootloader has loaded us into 32-bit protected mode on a x86
    machine. Interrupts are disabled. Paging is disabled. The processor
    state is as defined in the multiboot standard. The kernel has full
    control of the CPU. The kernel can only make use of hardware features
    and any code it provides as part of itself. There&apos;s no printf
    function, unless the kernel provides its own &lt;stdio.h&gt; header and a
    printf implementation. There are no security restrictions, no
    safeguards, no debugging mechanisms, only what the kernel provides
    itself. It has absolute and complete power over the
    machine.
    */

/*
    To set up a stack, we set the esp register to point to the top of the
    stack (as it grows downwards on x86 systems). This is necessarily done
    in assembly as languages such as C cannot function without a stack.
    */
mov $stack_top, %esp

/*
    This is a good place to initialize crucial processor state before the
    high-level kernel is entered. It&apos;s best to minimize the early
    environment where crucial features are offline. Note that the
    processor is not fully initialized yet: Features such as floating
    point instructions and instruction set extensions are not initialized
    yet. The GDT should be loaded here. Paging should be enabled here.
    C++ features such as global constructors and exceptions will require
    runtime support to work as well.
    */

/*
    Enter the high-level kernel. The ABI requires the stack is 16-byte
    aligned at the time of the call instruction (which afterwards pushes
    the return pointer of size 4 bytes). The stack was originally 16-byte
    aligned above and we&apos;ve since pushed a multiple of 16 bytes to the
    stack since (pushed 0 bytes so far) and the alignment is thus
    preserved and the call is well defined.
    */
call kernel_main

/*
    If the system has nothing more to do, put the computer into an
    infinite loop. To do that:
    1) Disable interrupts with cli (clear interrupt enable in eflags).
 They are already disabled by the bootloader, so this is not needed.
 Mind that you might later enable interrupts and return from
 kernel_main (which is sort of nonsensical to do).
    2) Wait for the next interrupt to arrive with hlt (halt instruction).
 Since they are disabled, this will lock up the computer.
    3) Jump to the hlt instruction if it ever wakes up due to a
 non-maskable interrupt occurring or due to system management mode.
    */
cli
1:  hlt
jmp 1b

/*
 Set the size of the _start symbol to the current location &apos;.&apos; minus its start.
 This is useful when debugging or when you implement call tracing.
 */
.size _start, . - _start
</code></pre><ul>
<li>上面是一份引导文件,使用汇编编写，有足够的注释，这里简单讲解一下这个文件，建议之后再倒回来阅读</li>
</ul>
<ul>
<li>首先考虑一个问到烂了的问题，我们平时编写的 main 函数是由谁来调用的，答案自然是操作系统，那么再问一个问题，现在我们准备使用 c 来编写操作系统，那么操作系统的入口又由谁来调用？</li>
</ul>
<ul>
<li>Bootloader 就解决了这个问题，它是在操作系统之前启动的一段程序，它将内核带入内存，为内核提供合适的环境并将控制权交给内核</li>
</ul>
<ul>
<li>但真正如何启动操作系统还需要有开发者来决定，在这份文件中我们首先设置了 multiboot header，这是给 GRUB multiboot 强制要求的文件头结构，如果要使用 GRUB 就必须这么做。然后我们创建大小为 16k 的栈并将 esp 寄存器指向栈顶（这也就是 esp是栈顶指针寄存器的由来），准备工作完毕，我们调用我们编写的 c 文件的入口函数，这里将其命名为 kernel_main</li>
</ul>
<ul>
<li>从某种角度来说，操作系统就是一个巨大的，永无止境的函数，它不会返回。不过还是来处理一下 kernel_main 返回的情况，开启一个没有实际意义的无限循环即可，毕竟我们没别的事情可做了</li>
</ul>
<p><br></p>
<h4 id="简单-VGA-输出"><a href="#简单-VGA-输出" class="headerlink" title="简单 VGA 输出"></a>简单 VGA 输出</h4><ul>
<li>下一步，来编写一个 VGA 输出函数库，这将是除了编译器内置的库以外，我们操作系统的第一个函数库，头文件定义如下</li>
</ul>
<pre><code># include \&lt;stdbool.h\&gt;
# include \&lt;stddef.h\&gt;
# include \&lt;stdint.h\&gt;
void terminal\_initialize(void);
void terminal\_setcolor(uint8\_t color);
void terminal\_putentryat(char c, uint8\_t color, size\_t x, size\_t y) ;
void terminal\_putchar(char c) ;
void terminal\_write(const char\* data, size\_t size) ;
void terminal\_writestring(const char\* data) ;
</code></pre><ul>
<li>在 intel PCI 总线 VGA 显示模式的编址为 0xA0000 -> 0xBFFFF，其中 0xB8000 开始为彩色字符模式，每字节前4位为背景色后4位为字符色（也就是只支持16色），我们要做的只是通过  0xB8000 这个地址拿到缓冲区，并填入数据即可，实现起来很简单不多说了</li>
</ul>
<pre><code># include &quot;tty.h&quot;
enum vga\_color {
    VGA_COLOR_BLACK = 0,
    VGA_COLOR_BLUE = 1,
    VGA_COLOR_GREEN = 2,
    VGA_COLOR_CYAN = 3,
    VGA_COLOR_RED = 4,
    VGA_COLOR_MAGENTA = 5,
    VGA_COLOR_BROWN = 6,
    VGA_COLOR_LIGHT_GREY = 7,
    VGA_COLOR_DARK_GREY = 8,
    VGA_COLOR_LIGHT_BLUE = 9,
    VGA_COLOR_LIGHT_GREEN = 10,
    VGA_COLOR_LIGHT_CYAN = 11,
    VGA_COLOR_LIGHT_RED = 12,
    VGA_COLOR_LIGHT_MAGENTA = 13,
    VGA_COLOR_LIGHT_BROWN = 14,
    VGA_COLOR_WHITE = 15,
};
static inline uint8\_t vga\_entry\_color(enum vga\_color fg, enum vga\_color bg) 
{
    return fg | bg &lt;&lt; 4;
}
static inline uint16\_t vga\_entry(unsigned char uc, uint8\_t color) 
{
    return (uint16_t) uc | (uint16_t) color &lt;&lt; 8;
}
size\_t strlen(const char\* str) 
{
    size_t len = 0;
    while (str[len])
        len++;
    return len;
}
static const size\_t VGA\_WIDTH = 80;
static const size\_t VGA\_HEIGHT = 25;
size\_t terminal\_row;
size\_t terminal\_column;
uint8\_t terminal\_color;
uint16\_t\* terminal\_buffer;
void terminal\_initialize(void) 
{
    terminal_row = 0;
    terminal_column = 0;
    terminal_color = vga_entry_color(VGA_COLOR_LIGHT_GREY, VGA_COLOR_BLACK);
    terminal_buffer = (uint16_t*) 0xB8000;
    for (size_t y = 0; y &lt; VGA_HEIGHT; y++) {
        for (size_t x = 0; x &lt; VGA_WIDTH; x++) {
            const size_t index = y * VGA_WIDTH + x;
            terminal_buffer[index] = vga_entry(&apos; &apos;, terminal_color);
        }
    }
}
void terminal\_setcolor(uint8\_t color) 
{
    terminal_color = color;
}
void terminal\_putentryat(char c, uint8\_t color, size\_t x, size\_t y) 
{
    size_t index;
    if(c == &apos;\n&apos;){
        terminal_column = VGA_WIDTH-1;
    }else{
        index = y * VGA_WIDTH + x;
        terminal_buffer[index] = vga_entry(c, color);
    }
}
void terminal\_putchar(char c) 
{
    terminal_putentryat(c, terminal_color, terminal_column, terminal_row);
    if (++terminal_column == VGA_WIDTH) {
        terminal_column = 0;
        ++terminal_row;
        if (++terminal_row == VGA_HEIGHT)
            terminal_row = 0;
    }
}
void terminal\_write(const char\* data, size\_t size) 
{
    for (size_t i = 0; i &lt; size; i++)
        terminal_putchar(data[i]);
}
void terminal\_writestring(const char\* data) 
{
    terminal_write(data, strlen(data));
}
</code></pre><p><br></p>
<h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><ul>
<li>现在调用我们刚刚实现的函数，编写一个内核，它除了在屏幕上打印 hello world 之外什么也不干</li>
</ul>
<pre><code># include &quot;tty.h&quot;
void kernel\_main()
{
    terminal_initialize();
    terminal_writestring(&quot;          \n\n\n&quot;);
    terminal_writestring(&quot;          Hello, World!\n&quot;);
    terminal_writestring(&quot;          \n\n\n&quot;);
}
</code></pre><p><br></p>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><ul>
<li>核心代码已经实现了，现在需要一份连接脚本，然后使用交叉编译器编译它们</li>
</ul>
<pre><code>/\* The bootloader will look at this image and start execution at the symbol
   designated as the entry point. \*/
ENTRY(\_start)
/\* Tell where the various sections of the object files will be put in the final
   kernel image. \*/
SECTIONS
{
    /* Begin putting sections at 1 MiB, a conventional place for kernels to be
       loaded at by the bootloader. */
    . = 1M;

    /* First put the multiboot header, as it is required to be put very early
       early in the image or the bootloader won&apos;t recognize the file format.
       Next we&apos;ll put the .text section. */
    .text BLOCK(4K) : ALIGN(4K)
    {
        *(.multiboot)
        *(.text)
    }

    /* Read-only data. */
    .rodata BLOCK(4K) : ALIGN(4K)
    {
        *(.rodata)
    }

    /* Read-write data (initialized) */
    .data BLOCK(4K) : ALIGN(4K)
    {
        *(.data)
    }

    /* Read-write data (uninitialized) and stack */
    .bss BLOCK(4K) : ALIGN(4K)
    {
        *(COMMON)
        *(.bss)
    }

    /* The compiler may produce other sections, by default it will put them in
       a segment with the same name. Simply add stuff here as needed. */
}
</code></pre><ul>
<li><p>注意文件的先后依赖，这里为将产出文件放到 build 目录下</p>
<p>  i686-elf-as ./src/start.s -o ./build/start.o<br>  i686-elf-gcc -std=gnu99 -ffreestanding -g -c ./src/kernel.c -o ./build/kernel.o<br>  i686-elf-gcc -std=gnu99 -ffreestanding -g -c ./src/tty.c -o ./build/tty.o<br>  i686-elf-gcc -ffreestanding -nostdlib -g -T ./src/linker.ld ./build/start.o ./build/kernel.o ./build/tty.o -o ./build/chaos.bin -lgcc</p>
</li>
</ul>
<p><br></p>
<h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><ul>
<li>上面最后生成的 chaos.bin 就是符合 multiboot 规范的文件，你可以使用 grub-file<br>文件来检验它</li>
</ul>
<pre><code>grub-file --is-x86-multiboot chaos.bin
# 什么都没发生，意味着一切正常
</code></pre><ul>
<li>qemu 支持你不使用任何媒介之前引导镜像，执行下面命令，如无意外，你的第一个操作系统就会运行起来，输出 hello world</li>
</ul>
<pre><code>qemu-system-i386 -kernel chaos.bin
</code></pre><ul>
<li>下面我们让其能在 CD-ROM 上启动,编写grub.cfg，指明镜像位置</li>
</ul>
<pre><code>menuentry &quot;chaos&quot; {
    multiboot /boot/chaos.bin
}
</code></pre><ul>
<li>然后按照grub.cfg的配置准备好目录</li>
</ul>
<pre><code>mkdir -p isodir/boot/grub
cp build/chaos.bin isodir/boot/chaos.bin
cp src/grub.cfg isodir/boot/grub/grub.cfg
</code></pre><ul>
<li>使用 grub 创建镜像</li>
</ul>
<pre><code>grub-mkrescue -o ./build/chaos.iso isodir
</code></pre><ul>
<li>使用 qemu CD-ROM 模式启动 </li>
</ul>
<pre><code>qemu-system-i386 -cdrom ./build/chaos.iso
</code></pre><p>* </p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入JVM系列 1 - mac平台编译调试 OpenJdk7 & HotSpot]]></title>
      <url>/2018/09/26/JVMCompileOpenJdk7/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><a href="https://tocreate.app/2018/09/05/jvm/" target="_blank" rel="external">本文为深入JVM系列的一部分</a></p>
<p><br></p>
<h3 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h3><ul>
<li>系统环境 ：osx 10.11.6</li>
<li>c 编译器 ：clang</li>
<li>openJdk ：jdk7u-dev</li>
<li>boostrap JDK ：oracle JDK 7u40</li>
<li>xcode version ：8.0 (8A218a)</li>
<li>ant version ：1.8.0</li>
<li>make 命令，请根据编译环境自行调整</li>
</ul>
<pre><code>sudo make ALT\_BOOTDIR=/Library/Java/JavaVirtualMachines/jdk1.7.0\_40.jdk/contents/home SPOT\_OS\_VERSION\_CHECK=OK LANG=C ANT\_HOME=/Users/alberthumbert/Downloads/apache-ant-1.8.0 WARNINGS\_ARE\_ERRORS=false ALLOW\_DOWNLOADS=true CC=clang COMPILER\_WARNINGS\_FATAL=false LFLAGS=&apos;-Xlinker -lstdc++&apos; USE\_CLANG=true LP64=1 LANG=C  ARCH\_DATA\_MODEL=64 HOTSPOT\_BUILD\_JOBS=8
</code></pre><p><br></p>
<h3 id="获取源码"><a href="#获取源码" class="headerlink" title="获取源码"></a>获取源码</h3><ul>
<li>本文不会有安装和配置 brew , xcode 和 boostrap jdk（oracle jdk） 的内容，对于打算动手编译jdk的人，这部分内容太基础了，就不废话了</li>
</ul>
<ul>
<li>首先确保 mercurial 已经安装，mercurial 和 git 的作用差不多</li>
</ul>
<pre><code>sudo easy\_install mercurial
</code></pre><ul>
<li>使用 mercurial 提供的 hg 工具拉取远程仓库, 这里我拉取的是 jdk 7</li>
</ul>
<pre><code>hg clone http://hg.openjdk.java.net/jdk7u/jdk7u-dev
</code></pre><ul>
<li>现在还未真正获取到所有源码，在进行下一步之前，建议先确保你有足够的权限，在trust.rc中添加当前的用户名</li>
</ul>
<pre><code>sudo vim /etc/mercurial/hgrc.d/trust.rc
</code></pre><ul>
<li>一个可供参考的版本如下</li>
</ul>
<pre><code>[trusted]
users = alberthumbert 
groups = root
</code></pre><ul>
<li>接着正式获取源码,使用任何shell都可以, 如果执行后出现 xxx not trusted，说明上一步没有设置好 </li>
</ul>
<pre><code>sudo zsh ./get\_source.sh
</code></pre><ul>
<li>如果出现 abort: stream ended unexpectedly ，可能是网络的问题，我这里试了很多次都没有拉取成功，没办法只好走代理，在当前终端中设置代理，只需执行如下命令，只在当前终端生效</li>
</ul>
<pre><code>export all_proxy=socks5://[host]:[port] # 同时配置 http 和 https代理
</code></pre><ul>
<li>如无意外，corba，jaxp，jaxws，langtools，jdk，hotspot 这些过程都将以 xxx files updated, 0 files merged, 0 files removed, 0 files unresolved 结束，不行就再试几次</li>
</ul>
<p><br></p>
<h3 id="编译环境-1"><a href="#编译环境-1" class="headerlink" title="编译环境"></a>编译环境</h3><ul>
<li>安装llvm</li>
</ul>
<pre><code>brew install llvm
</code></pre><ul>
<li>安装 freetype</li>
</ul>
<pre><code>brew install freetype
</code></pre><ul>
<li>安装完freetype和llvm后需要设置链接</li>
</ul>
<pre><code>sudo ln -s /usr/bin/llvm-g++ /Applications/Xcode.app/Contents/Developer/usr/bin/llvm-g++


sudo ln -s /usr/bin/llvm-gcc /Applications/Xcode.app/Contents/Developer/usr/bin/llvm-gcc
</code></pre><ul>
<li>安装 ant , 编译过程中提示ant版本太旧，在apache官网上下载新版本，然后设置链接，建议不要使用版本太高的ant，最好不要跟你的 OpenJdk 版本有太大差距</li>
</ul>
<pre><code>sudo ln -s Users/alberthumbert/Desktop/apache-ant-1.8.0/bin/ant /usr/bin/ant
</code></pre><ul>
<li>安装 XQuartz，在￼官网￼下载dmg并手动安装 ，然后添加链接</li>
</ul>
<pre><code>sudo ln -s /opt/X11/include/X11 /usr/local/include/X11
</code></pre><ul>
<li>注意如果上一步出现 operation not permitted ，说明你的os版本比较高，有些操作被系统保护，需要重启 Command + R 进入 recover 模式，在终端中关闭保护, 输入如下命令然后重启即可</li>
</ul>
<pre><code>csrutil disable
</code></pre><p><br></p>
<h3 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h3><ul>
<li>下面是一份可供参考的参数配置，可以写在目录的build.sh当中然后执行，注意jdk路径和ant路径需要根据实际情况自行设置</li>
</ul>
<pre><code># 语言选项，必须设置，否则编译好后会出现一个 HashTable 的 NPE错
export LANG=C
# Bootstrap JDK 解压路径，必须设置
export ALT\_BOOTDIR=/Library/Java/JavaVirtualMachines/jdk1.7.0\_40.jdk/Contents/Home
export ANT\_HOME=/Users/alberthumbert/Desktop/apache-ant-1.8.0
export ANT\_VERSION=1.7.1
# 允许自动下载
export ALLOW\_DOWNLOADS=true
# 并行编译线程数
export HOTSPOT\_BUILD\_JOBS=4
export ALT\_PARALLEL\_COMPILE\_JOBS=4
# 比较本次 build 出来的映像与先前版本的差异，对我们没有意义
# 必须设置为 false，否则 sanity 检查为报缺少先前版本 JDK 的映像的错误提示
export SKIP\_COMPARE\_IMAGE=false
# 使用预编译头文件，不加这个编译会变慢
export USE\_PRECOMPILED\_HEADER=true
# 要编译的内容
export BUILD\_LANGTOOLS=true
export BUILD\_HOTSPOT=true
export BUILD\_JDK=true
# export BUILD\_JAXWS=false
# export BUILD\_JAXP=false
# export BUILD\_CORBA=false
# 要编译的版本
# export SKIP\_DEBUG\_BUILD=false
# export SKIP\_FASTDEBUG\_BUILD=true
# export DEBUG\_NAME=debug
# 把它设置为 false 可以避开 javaws 和浏览器 Java 插件之类的部分的 build
BUILD\_DEPLOY=false
# 把它设置为 false 就不会 build 出安装包，因为安装包里有奇怪的依赖
# 但即使不 build 出它也能得到完整的 JDK 映像，所以还是别 build
BUILD\_INSTALL=false
export WARNINGS\_ARE\_ERRORS=false
export COMPILER\_WARNINGS\_FATAL=false
# 编译结果所存放的路径
export ALT\_OUTPUTDIR=/Users/alberthumbert/jdk7u-dev/build\_result
# 这两个环境变量必须去掉，不然会发生奇怪的事情
# Makefile 检查到这两个变量就会提示警告
unset JAVA\_HOME
unset CLASSPATH
make sanity
</code></pre><p><br></p>
<h3 id="开始编译"><a href="#开始编译" class="headerlink" title="开始编译"></a>开始编译</h3><p><br></p>
<h4 id="no-boostrap-dir"><a href="#no-boostrap-dir" class="headerlink" title="no boostrap dir"></a>no boostrap dir</h4><ul>
<li>执行 make 进行编译，编译过程中可能提示找不到可用的 boostrap jdk ，虽然在上面已经配置过了，不太清楚为什么，只能再手动加上参数，注意这里也需要权限</li>
</ul>
<pre><code>sudo make ALT\_BOOTDIR=/Library/Java/JavaVirtualMachines/jdk1.7.0\_71.jdk/content/home
</code></pre><p><br></p>
<h4 id="ant-版本过低"><a href="#ant-版本过低" class="headerlink" title="ant 版本过低"></a>ant 版本过低</h4><ul>
<li>如果提示 ant 版本过低，但实际上你的 ant 又高于提示中的 ant 版本，有可能实际上是 boostrap jdk 版本太低，建议使用 oracle jdk 7u40 ，详见后面踩坑记录</li>
</ul>
<pre><code>ERROR: 
The version of ant being used is older than
the required version of &apos;1.7.1&apos;.
The version of ant found was &apos;1.7.0&apos;.
</code></pre><p><br></p>
<h4 id="中文-与-ascii-乱码"><a href="#中文-与-ascii-乱码" class="headerlink" title="中文 与 ascii 乱码"></a>中文 与 ascii 乱码</h4><ul>
<li>自动生成的代码（主要是AIDL文件）中注释会带有中文，这个时候由于配置中规定了使用 ascii ，这会导致编译器无法识别而编译不通过，解决办法主要有两种，一种使用shell命令或脚本，另一种直接修改文件</li>
</ul>
<ul>
<li>使用shell命令替换可以参考下面, 有可能不成功</li>
</ul>
<pre><code>sudo find /Users/alberthumbert/jdk7u-dev/build/macosx-x86\_64/corba/gensrc/com/sun/ -name &apos;\*.java&apos; | while read p; do native2ascii -encoding UTF-8 $p \&gt; tmpj; mv tmpj $p ; done
</code></pre><ul>
<li>比较稳的做法是像这位<a href="http://0x9e370001.iteye.com/blog/1729802" target="_blank" rel="external">老哥</a>一样修改文件，看上去很多其实也没几个文件，善用字符搜索很快就能搞定</li>
</ul>
<p><br></p>
<h4 id="clang-不支持-fpch-deps"><a href="#clang-不支持-fpch-deps" class="headerlink" title="clang 不支持 -fpch-deps"></a>clang 不支持 -fpch-deps</h4><ul>
<li>参考这一位<a href="https://blog.csdn.net/j754379117/article/details/53695426" target="_blank" rel="external">老哥</a>的做法，修改 hotspot/make/bsd/makefiles/gcc.make</li>
</ul>
<pre><code># 注释216-218行
# Flags for generating make dependency flags.
# ifneq (&quot;${CC\_VER\_MAJOR}&quot;, &quot;2&quot;)
# DEPFLAGS = -fpch-deps -MMD -MP -MF $(DEP\_DIR)/$(@:%=%.d)
# endif
# 在218行下添加下面代码
DEPFLAGS = -MMD -MP -MF $(DEP\_DIR)/$(@:%=%.d)
ifeq ($(USE\_CLANG),)
  ifneq ($(CC\_VER\_MAJOR), 2)
    DEPFLAGS += -fpch-deps
  endif
endif
</code></pre><p><br></p>
<h4 id="clang-error-no-such-file-or-directory-‘false’"><a href="#clang-error-no-such-file-or-directory-‘false’" class="headerlink" title="clang: error: no such file or directory: ‘false’"></a>clang: error: no such file or directory: ‘false’</h4><ul>
<li>仔细看发现是makefile生成的编译命令中某个参数只剩了一个false，不知道是哪个参数，很蛋疼，顺藤摸瓜找到生成参数的makefile</li>
</ul>
<pre><code>sudo vim /Users/alberthumbert/jdk7u-dev/hotspot/make/bsd/makefiles/vm.make
</code></pre><ul>
<li>注释掉下面个参数配置</li>
</ul>
<pre><code># CFLAGS\_WARN holds compiler options to suppress/enable warnings.
CFLAGS += $(CFLAGS\_WARN/BYFILE)
# Do not use C++ exception handling
CFLAGS += $(CFLAGS/NOEX)
</code></pre><p><br></p>
<h4 id="形参默认值问题"><a href="#形参默认值问题" class="headerlink" title="形参默认值问题"></a>形参默认值问题</h4><ul>
<li>还是参考这位<a href="https://blog.csdn.net/j754379117/article/details/53695426" target="_blank" rel="external">老哥</a>，修改 hotspot/src/share/vm/code/relocInfo.hpp</li>
</ul>
<pre><code>//修改374行
inline friend relocInfo prefix\_relocInfo(int datalen);
//修改469行
inline relocInfo prefix\_relocInfo(int datalen = 0) {
   assert(relocInfo::fits\_into\_immediate(datalen), &quot;datalen in limits&quot;);
   return relocInfo(relocInfo::data\_prefix\_tag, relocInfo::RAW\_BITS, relocInfo::datalen\_tag | datalen);
}
</code></pre><p><br></p>
<h4 id="Undefined-symbols-for-architecture-x86-64-“-attachCurrentThread”"><a href="#Undefined-symbols-for-architecture-x86-64-“-attachCurrentThread”" class="headerlink" title="Undefined symbols for architecture x86_64: “_attachCurrentThread”"></a>Undefined symbols for architecture x86_64: “_attachCurrentThread”</h4><ul>
<li><p>这个错误是在 debug_build 时才出现的，没有保存出错信息，简单说一下情况，提示说 ThreadUtilities中的 getJNIEnv 和 getJNIEnvUncached 函数引用了一个不存在的函数 attachCurrentThread，之前写过一点jni，感觉大概是一个封装了jni线程调度函数的工具类出了问题</p>
</li>
<li><p>在osxapp目录找到这个文件</p>
</li>
</ul>
<pre><code>cd /Users/alberthumbert/jdk7u-dev/jdk/src/macosx//native/sun/osxapp
</code></pre><ul>
<li>实际上 ThreadUtilities.m 文件中可以找到这个函数,感觉是内联出了问题，把 inline 关键字去掉即可通过编译</li>
</ul>
<pre><code>inline void attachCurrentThread(void\*\* env) {
    if ([NSThread isMainThread]) {
        JavaVMAttachArgs args;
        args.version = JNI_VERSION_1_4;
        args.name = &quot;AppKit Thread&quot;;
        args.group = appkitThreadGroup;
        (*jvm)-&gt;AttachCurrentThreadAsDaemon(jvm, env, &amp;args);
    } else {
        (*jvm)-&gt;AttachCurrentThreadAsDaemon(jvm, env, NULL);
    }
}
</code></pre><p><br></p>
<h3 id="编译通过"><a href="#编译通过" class="headerlink" title="编译通过"></a>编译通过</h3><p><br></p>
<ul>
<li>任务完成，耗时将近20分钟，纪念一下</li>
</ul>
<p><br></p>
<pre><code>&gt;&gt;&gt;Finished making images @ Sat Apr  7 14:22:59 CST 2018 ...
########################################################################
##### Leaving jdk for target(s) sanity all docs images             #####
########################################################################
##### Build time 00:12:41 jdk for target(s) sanity all docs images #####
########################################################################

#-- Build times ----------
Target all_product_build
Start 2018-04-07 14:03:57
End   2018-04-07 14:22:59
00:00:16 corba
00:05:57 hotspot
00:00:02 jaxp
00:00:03 jaxws
00:12:41 jdk
00:00:03 langtools
00:19:02 TOTAL
-------------------------
</code></pre><p><br><br><br></p>
<ul>
<li>下面让我们来验证一下编译是否真的成功了</li>
</ul>
<pre><code>cd /Users/alberthumbert/jdk7u-dev/build/macosx-x86\_64/j2sdk-image/bin
</code></pre><ul>
<li>验证一下版本</li>
</ul>
<pre><code>./java -version
# 输出
openjdk version &quot;1.7.0-internal&quot;
OpenJDK Runtime Environment (build 1.7.0-internal-root\_2018\_04\_07\_14\_03-b00)
OpenJDK 64-Bit Server VM (build 24.80-b07, mixed mode)
</code></pre><ul>
<li>写个 hello world, 用 ./javac Hello.java 编译</li>
</ul>
<pre><code> public class Hello{
    public static void main(String[] args){
       System.out.println(&quot;Hello World !&quot;);
    }
}
</code></pre><ul>
<li>用 ./java Hello 运行</li>
</ul>
<pre><code>Hello World !
</code></pre><p><br><br><br></p>
<h3 id="调试源码"><a href="#调试源码" class="headerlink" title="调试源码"></a>调试源码</h3><p><strong>不单纯为了编译而去编译，在学习jvm的同时能跟着代码走才是最终目的</strong></p>
<p><br></p>
<h4 id="build-debug-build-fastdebug-build"><a href="#build-debug-build-fastdebug-build" class="headerlink" title="build debug_build fastdebug_build"></a>build debug_build fastdebug_build</h4><ul>
<li>注意 在普通的编译模式下编译出来的jdk是不能调试的，它跟你平时使用的普通jdk是一个东西，为了能够支持调试 在make 命令后面需要加上 build_debug 参数，这时在 build/macosx-x86_64-debug/ 目录可以找到另一个编译版本，这里面的 jdk 和 hotspot是可调试的</li>
</ul>
<ul>
<li>细心的玩家可能还会发现一个 macosx-x86_64-fastdebug 目录，如果你在配置文件中设置了 fastdebug 参数，那么就会有这个版本 jdk，简单说一下 fastdebug 是什么，它是由于 jdk 的开发人员无法忍受编译器极度缓慢的调试速度而打造的新调试版本，它的调试速度会比普通的 debug 快，不过替换掉了一些命令，所以它的表现和普通的 jdk 不太一样_ </li>
</ul>
<p><br></p>
<h4 id="使用-Xcode-调试运行"><a href="#使用-Xcode-调试运行" class="headerlink" title="使用 Xcode 调试运行"></a>使用 Xcode 调试运行</h4><p><strong>本来是打算使用 Clion 调试的，无奈 cmake 太难配，看了别人使用 xcode 很顺畅，于是打开了万年不用的 xcode</strong></p>
<ul>
<li>新建项目，名称随意，右键工作目录，点击 add files to (projectname)，导入整个 jdk7u-dev，注意就是你用 hg 命令拉下来的整个仓库，不是 macosx-x86_64-debug 目录</li>
</ul>
<ul>
<li>点击 product->scheme->edit scheme ，在 run -> info 中配置 executable 如下</li>
</ul>
<pre><code>/Users/alberthumbert/jdk7u-dev/build/macosx-x86\_64-debug/bin/java
</code></pre><ul>
<li>同时在这个 executable 的目录下新建一个测试用的java文件，这里用回之前的 hello world</li>
</ul>
<pre><code> public class Hello{
    public static void main(String[] args){
       System.out.println(&quot;Hello World !&quot;);
    }
}
</code></pre><ul>
<li>在 run-> arguements 中配置参数为 hello，那么效果就是 ./java hello，所以你需要先 javac 一下</li>
</ul>
<ul>
<li>在运行之前找到 main.c ，没错，这个就是你所以 java 程序的入口,路径在 /jdk/src/share/bin/main.c 找不到就 find . -iname main.c 一下</li>
</ul>
<pre><code>int
main(int argc, char \*\*argv)
{
    int margc;
    char** margv;
    const jboolean const_javaw = JNI_FALSE;
# endif /\* JAVAW \*/
# ifdef \_WIN32
    {
        int i = 0;
        if (getenv(JLDEBUG_ENV_ENTRY) != NULL) {
            printf(&quot;Windows original main args:\n&quot;);
            for (i = 0 ; i &lt; __argc ; i++) {
                printf(&quot;wwwd_args[%d] = %s\n&quot;, i, __argv[i]);
            }
        }
    }
    JLI_CmdToArgs(GetCommandLine());
    margc = JLI_GetStdArgc();
    // add one more to mark the end
    margv = (char **)JLI_MemAlloc((margc + 1) * (sizeof(char *)));
    {
        int i = 0;
        StdArg *stdargs = JLI_GetStdArgs();
        for (i = 0 ; i &lt; margc ; i++) {
            margv[i] = stdargs[i].arg;
        }
        margv[i] = NULL;
    }
# else /\* *NIXES */
    margc = argc;
    margv = argv;
# endif /\* WIN32 \*/
    return JLI_Launch(margc, margv,
                   sizeof(const_jargs) / sizeof(char *), const_jargs,
                   sizeof(const_appclasspath) / sizeof(char *), const_appclasspath,
                   FULL_VERSION,
                   DOT_VERSION,
                   (const_progname != NULL) ? const_progname : *margv,
                   (const_launcher != NULL) ? const_launcher : *margv,
                   (const_jargs != NULL) ? JNI_TRUE : JNI_FALSE,
                   const_cpwildcard, const_javaw, const_ergo_class);
}
</code></pre><ul>
<li>随便打几个断点，点击运行,先不要急着一头扎进源码，快速让调试结束，如果终端输出如下，恭喜你已经完成了所有任务</li>
</ul>
<pre><code>Hello World !
Program ended with exit code: 0
</code></pre><p><br></p>
<p><img src="https://ws1.sinaimg.cn/large/987832a0gy1fq4aw6xhmdj21kk17m1bi.jpg" alt=""></p>
<p><br></p>
<h4 id="start-the-world"><a href="#start-the-world" class="headerlink" title="start the world"></a>start the world</h4><ul>
<li>接下来我们来调试 HotSpot，在hotspot目录下的jni.cpp中找到 JNI_CreateJavaVM</li>
</ul>
<pre><code>/Users/alberthumbert/jdk7u-dev/hotspot/src/share/vm/prims/jni.cpp
</code></pre><ul>
<li><p>也是随便打上断点，如果你上一步已经成功，那么现在所有的配置参数都不需要改变，直接调试即可</p>
</li>
<li><p><strong> 现在，开始你的深入理解 java 虚拟机之旅吧 ！</strong></p>
</li>
</ul>
<p><br><br><br><br><br></p>
<h3 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h3><p><strong> 废话很多，如果运气好，上面的流程都通过了，下面就不用看了</strong></p>
<p><br></p>
<h4 id="ant-版本过低-1"><a href="#ant-版本过低-1" class="headerlink" title="ant 版本过低"></a>ant 版本过低</h4><pre><code>ERROR: The version of ant being used is older than
   the required version of &apos;1.7.1&apos;.
   The version of ant found was &apos;1.7.0&apos;.
</code></pre><ul>
<li>使用 ant -version ，如果发现版本确实过低，那么下载新版 ant 即可</li>
</ul>
<ul>
<li>然而我的机器上原先就没有 1.7.0 版本的 ant，反复使用 homebrew 安装了 ant，可以确定运行的 ant 版本是最新的，网上的说法是使用软连接将ant链接过去，看了一下源码，确实 openjdk 里面将 ant 目录写死在了/usr/bin/ant，问题是这个 ‘1.7.0’ 的ant到底是哪来的，为什么能找到这个版本的ant</li>
</ul>
<pre><code>sudo ln -s Users/alberthumbert/Desktop/apache-ant-1.10.3/bin/ant /usr/bin/ant
</code></pre><ul>
<li>再看一下make sanity的输出, 上面是我下载的ant，1.10.3 ,但下面的 ANT_VER 却是 1.7.0，这么说来这个 ant 的版本可能跟我指定的 ant 没有关系</li>
</ul>
<pre><code>ANT_HOME = /Users/alberthumbert/Desktop/apache-ant-1.10.3
…
ANT_VER = 1.7.0 [requires at least 1.7.1]
</code></pre><ul>
<li>使用 mdfind 查找 这个ant version 是怎么来的，直接 mdfind “ANT_VER”</li>
</ul>
<pre><code>/Users/alberthumbert/jdk7u-dev/build.sh
/Users/alberthumbert/jdk7u-dev/jaxp/src/com/sun/org/apache/xalan/internal/xslt/EnvironmentCheck.java
/Users/alberthumbert/Desktop/apache-ant-1.10.3/manual/api/org/apache/tools/ant/MagicNames.html
/Users/alberthumbert/Desktop/apache-ant-1.10.3/manual/api/index-all.html
/Users/alberthumbert/Desktop/apache-ant-1.10.3/manual/api/constant-values.html
</code></pre><ul>
<li>上面这个 EnvironmentCheck.java 很可疑，打开看下，有个检查 ant 版本的方法，这里用到反射，理论上查找的就是 ANT_HOME 当中 ant.jar 里的类，还是不明所以</li>
</ul>
<pre><code>/\**    * Report product version information from Ant.
  *    * @param h Hashtable to put information in
  \*/
 protected void checkAntVersion(Hashtable h)
 {
   if (null == h)
     h = new Hashtable();

   try
   {
     final String ANT_VERSION_CLASS = &quot;org.apache.tools.ant.Main&quot;;
     final String ANT_VERSION_METHOD = &quot;getAntVersion&quot;; // noArgs
     final Class noArgs[] = new Class[0];

     Class clazz = ObjectFactory.findProviderClass(ANT_VERSION_CLASS, true);

     Method method = clazz.getMethod(ANT_VERSION_METHOD, noArgs);
     Object returnValue = method.invoke(null, new Object[0]);

     h.put(VERSION + &quot;ant&quot;, (String)returnValue);
   }
   catch (Exception e)
   {
     h.put(VERSION + &quot;ant&quot;, CLASS_NOTPRESENT);
   }
   }
</code></pre><ul>
<li>尝试更换 boostrap jdk 版本，这次使用 1.8.0 然后发现 make sanity 通过了，而输出的配置列表中 ANT_VER 就等于 1.8.0  </li>
</ul>
<pre><code>ANT_VER = 1.8.0 [requires at least 1.7.1]
</code></pre><ul>
<li>下意识的想起之前使用的boostrap jdk 是1.7.0 而提示的 ANT_VER 就是1.7.0，看了下我的机子里还有 1.6.0 的 jdk ，那么用它来编译一下… 黑人问号.jpg ，所以这个 ant 版本就等于 jdk 版本 ？？？WTF ？？？</li>
</ul>
<pre><code>ERROR: The version of ant being used is older than
   the required version of &apos;1.7.1&apos;.
   The version of ant found was &apos;1.6.0.&apos;.
</code></pre><ul>
<li>总结一下，boostrap jdk 版本接近或者大于指定的ant版本，否则设定 ANT_HOME 没有作用，但是网上很多解决办法都是使用后者，可能是平台差异，具体原因不明, 推荐使用Oracle JDK 7u40</li>
</ul>
<p><br></p>
<h4 id="Bootstrap-JDK-版本过高"><a href="#Bootstrap-JDK-版本过高" class="headerlink" title="Bootstrap JDK 版本过高"></a>Bootstrap JDK 版本过高</h4><ul>
<li>如果你尝试使用 JDK 8 去编译 OpenJDK 7 ，那么肯定是行不通的，在 OpenJDK 7 当中，许多 ant 的配置中都指定了 -werror 参数，这个参数意味着参与编译的文件在编译过程中导致的 warnning 都会被视为 error ，而在用 javac 编译 java 文件时又由于 Bootstrap JDK 过高而出现大量的 warnning ，最典型的比如下面这个</li>
</ul>
<pre><code>主版本 52 比 51 新, 此编译器支持最新的主版本。建议升级此编译器
</code></pre><ul>
<li>个人推荐 Oracle JDK 7u40 ，使用这个版本搭配 1.7.1 以上并接近这个版本的 ant</li>
</ul>
<p><br></p>
<h4 id="OS-X-10-10-以上无法安装-Oracle-JDK"><a href="#OS-X-10-10-以上无法安装-Oracle-JDK" class="headerlink" title="OS X 10.10 以上无法安装 Oracle JDK"></a>OS X 10.10 以上无法安装 Oracle JDK</h4><ul>
<li>本来是觉得不需要写这部分内容的，但mac上的 Oracle JDK 有个bug ，在安装旧版本的 jdk 时你可能会收到这样一条提示</li>
</ul>
<pre><code>Java from Oracle requires Mac OS X 10.7.3 or later.
Your system has Mac OS X Version 10.11.6. This product can be installed on Version 10.7.3 or later.
Visit java.com/help for more information.
</code></pre><ul>
<li><p>MDZZ，多么清奇的脑回路，而且这个问题直到 JDK 8 的一些版本都存在，但是我们说过 Bootstrap JDK 版本不能过高，那么怎么安装这个JDK呢，无奈只好帮Oracle 修一波 bug</p>
</li>
<li><p>在 dmg 加载上来之后，用下面命令解压安装包, 第一个路径是你的 dmg 文件，第二个路径是解压目录的目标地址，命名随意</p>
</li>
</ul>
<pre><code>pkgutil --expand /Volumes/JDK\ 7\ Update\ 40/JDK\ 7\ Update\ 40.pkg
</code></pre><ul>
<li>进入解压目录在 Distribution 文件中找到 pm_instal_check() 函数，用什么方法都好，总之让它返回 true</li>
</ul>
<pre><code>function pm\_install\_check() {
//就是这么粗暴
  return true;
}
</code></pre><ul>
<li>重新打包, 然后用这个新的dmg进行安装即可</li>
</ul>
<pre><code>pkgutil --flatten /Users/alberthumbert/Desktop/740.unpkg /Users/alberthumbert/Desktop/jdk740.pkg
</code></pre><p><strong>本篇完</strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[近期的一些计划]]></title>
      <url>/2018/09/22/Early/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><strong>这个学期准备笔试面试要系统地开始复习了，我大概准备从操作系统，计网，Jvm，并发，Android系统，Android常用框架 这几方面开始入手，笔记会按照下面几个系列来整理，应该会更新得比较勤快，不过基本看心情，所以完全不按顺序</strong></p>
<ul>
<li><p><a href="https://tocreate.app/2018/09/21/OperatingSystem/" target="_blank" rel="external">深入操作系统 系列</a></p>
</li>
<li><p><a href="https://tocreate.app/2018/09/05/net-0/" target="_blank" rel="external">深入计算机网络 系列</a></p>
</li>
<li><p><a href="https://tocreate.app/2018/09/05/jvm/" target="_blank" rel="external">深入 JVM 系列</a></p>
</li>
<li><p><a href="https://tocreate.app/2018/09/05/concurrent/" target="_blank" rel="external">深入 Java 并发 系列</a></p>
</li>
<li><p><a href="https://tocreate.app/2018/09/05/androidSource/" target="_blank" rel="external">深入 Android 系统 系列</a></p>
</li>
<li><p><a href="https://tocreate.app/2018/09/21/ReadAndroidLib/" target="_blank" rel="external">深入 Android 框架源码 系列</a></p>
</li>
</ul>
<p><strong>还有时间可能会去学习Android方面一些进阶的知识，比如模块化，推送等，另外算法方面打算放到寒假开始准备</strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入操作系统 2 - 交叉环境编译 & GCC]]></title>
      <url>/2018/09/22/OSCrossGcc/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><a href="https://tocreate.app/2019/03/02/OperatingSystem/" target="_blank" rel="external">本文为深入操作系统系列的一部分</a></p>
<p><a href="https://tocreate.app/2018/09/21/OSEnv/" target="_blank" rel="external">可能需要阅读前文</a></p>
<p><strong>不需要编写和编译相关例程的非硬核玩家无需阅读此文</strong></p>
<p><br></p>
<h2 id="what-amp-why"><a href="#what-amp-why" class="headerlink" title="what &amp; why"></a>what &amp; why</h2><p><strong>什么是交叉编译器，为什么需要交叉编译器，需要什么样的交叉编译器？</strong></p>
<ul>
<li><p>简单来说，交叉编译器是可以在生产平台上编译可以运行在目标平台上的程序的编译器，这里的生产平台和目标平台可以使用<strong>不同的cpu，不同的操作系统，不同的文件格式</strong></p>
</li>
<li><p>系统：注意上面提到的不同操作系统，不管选择任何操作系统作为开发平台（*nix,win）, 我们编写的系统都不会与选择的系统完全一致（当然前提是有心写一个<strong>自己</strong>的操作系统）</p>
</li>
<li><p>引导：每个操作系统都需要一套启动机制，你完全可以自己去编写引导，但是考虑一下如果每个操作系统都有一套完全不同的机制那将会带来多少麻烦，因此 GRUP 的 mutiboot 规范应运而生，我们的编译器最好能产出复合该规范的文件</p>
</li>
<li><p>文件格式：mutiboot主要面向elf 文件格式并且允许兼容各种 a.out 格式，但是使用 elf 是最省时省力的, 另外 GRUB 只允许引导 32 位的 mutiboot 内核</p>
</li>
<li><p>CPU：目标平台的 cpu 不同使用的编译器也不一样，举例来说同样是intel的 cpu 如果我们的机器比较旧你可能会需要 i386 的编译器，反之则可能是 i686</p>
</li>
</ul>
<p><br></p>
<h2 id="搭建跨平台-GCC"><a href="#搭建跨平台-GCC" class="headerlink" title="搭建跨平台 GCC"></a>搭建跨平台 GCC</h2><p><br></p>
<h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p><br></p>
<h4 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h4><ul>
<li>从源码编译 gcc 首先需要一个 gcc，就像编译 openjdk 需要一个oracle jdk 一样 鸡和蛋的问题，建议用最新的 gcc</li>
</ul>
<pre><code>brew install gcc
</code></pre><ul>
<li>mac 上 gcc 默认指向的是 clang，其实不是gcc所以你需要用别名替换替换掉</li>
</ul>
<pre><code>alias gcc=&apos;gcc-8&apos;
alias g++=&apos;g++-8&apos;
alias c++=&apos;c++-8&apos;
</code></pre><p><br></p>
<h4 id="GMP"><a href="#GMP" class="headerlink" title="GMP"></a>GMP</h4><ul>
<li><p>用于高精度计算的c函数库，这个我用 homebrew 没有安装成功，就手动编译了，不过可能是因为当时 homebrew 版本比较旧，更新之后没试过，估计现在用 homebrew 也行吧</p>
</li>
<li><p>在下面网站下载 bz2 的压缩包，注意是 bz2</p>
</li>
</ul>
<pre><code>https://gmplib.org/
</code></pre><ul>
<li>执行</li>
</ul>
<pre><code>sudo cp gmp-6.1.2.tar.bz2 /usr/local/lib
cd /usr/local/lib
bzip2 -d -k gmp-6.1.2.tar.bz2
tar -xvf gmp-6.1.2.tar
 cd gmp-6.1.2
./configure
make
make check
make install
</code></pre><ul>
<li>如果要测试是否安装成功可以试着写个小程序 #include \<gmp.h\>，然后用 gcc -lgmp 编译一下</gmp.h\></li>
</ul>
<p><br></p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li>接下来的依赖我就不一一描述了，用 homebrew 就可以安装</li>
</ul>
<pre><code>brew install bison
brew install flex
brew install libmpc
brew install texinfo
brew install CLooG
brew install binutils
brew install libiconv
</code></pre><p><br></p>
<h4 id="ISL"><a href="#ISL" class="headerlink" title="ISL"></a>ISL</h4><ul>
<li>使用 homebrew安装的 ISL 过于新，和 gcc 源码不兼容，虽然可以用很骚的方法指定 homebrew 安装版本，但是从源码安装会方便很多</li>
</ul>
<ul>
<li>这里推荐使用 <a href="http://isl.gforge.inria.fr/" target="_blank" rel="external">0.18</a> ，最好不要低于 0.15</li>
</ul>
<pre><code>./config
make
</code></pre><p><br></p>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><ul>
<li>在下面这个网站中下载源码，建议源码版本不要比现在使用的gcc版本新</li>
</ul>
<pre><code>https://ftp.gnu.org/gnu/gcc/
</code></pre><ul>
<li>下载 Binutils 源码, gcc 版本最好与 binutils相近</li>
</ul>
<pre><code>https://ftp.gnu.org/gnu/binutils/
</code></pre><p><br></p>
<h4 id="编译-cross-compile-gcc"><a href="#编译-cross-compile-gcc" class="headerlink" title="编译 cross-compile gcc"></a>编译 cross-compile gcc</h4><ul>
<li>设置编译目录</li>
</ul>
<pre><code>export PREFIX=&quot;$HOME/opt/cross&quot;
export TARGET=i686-elf
export PATH=&quot;$PREFIX/bin:$PATH&quot;
</code></pre><ul>
<li>编译 binutils</li>
</ul>
<pre><code>cd $HOME/src
mkdir build-binutils
cd build-binutils
../binutils-x.y.z/configure --target=$TARGET --prefix=&quot;$PREFIX&quot; --with-sysroot --disable-nls --disable-werror
make
make install
</code></pre><ul>
<li>编译 gcc</li>
</ul>
<pre><code>cd $HOME/src
# The $PREFIX/bin dir _must_ be in the PATH. We did that above.
which -- $TARGET-as || echo $TARGET-as is not in the PATH
mkdir build-gcc
cd build-gcc
../gcc-x.y.z/configure --target=$TARGET --prefix=&quot;$PREFIX&quot; --disable-nls --enable-languages=c,c++ --without-headers
make all-gcc
make all-target-libgcc
make install-gcc
make install-target-libgcc
</code></pre><ul>
<li>注意如果是使用上面建议的手动编译 ISL，需要在 configure 后面加入参数</li>
</ul>
<pre><code>--with-isl=...(编译目录)
</code></pre><p><br></p>
<h4 id="使用-cross-gcc"><a href="#使用-cross-gcc" class="headerlink" title="使用 cross-gcc"></a>使用 cross-gcc</h4><ul>
<li>真个系列极为重要的第一步已经完成了</li>
</ul>
<pre><code>$HOME/opt/cross/bin/$TARGET-gcc --version


    i686-elf-gcc (GCC) 8.1.0
Copyright (C) 2018 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
</code></pre><ul>
<li>也可以添加到环境变量</li>
</ul>
<pre><code>export PATH=&quot;$HOME/opt/cross/bin:$PATH&quot;
</code></pre><p><strong>本篇完</strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入操作系统 1 - 源码获取 & 编译调试]]></title>
      <url>/2018/09/21/OSEnv/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><a href="https://tocreate.app/2019/03/02/OperatingSystem/" target="_blank" rel="external">本文为深入操作系统系列的一部分</a></p>
<p><strong>通过下面的xv6编译可以了解一个操作系统从编译到bochs和qemu调试运行的整个流程，这里的编译环境其实是提供好的了，只是下载下来而已，如果你不是硬核玩家，那么走这个流程就足够了</strong></p>
<p><strong>调试linux内核的流程则有些不同，因为linux允许你在boot阶段选择不同的内核，所以你需要做的是编译内核并将其放到指定的位置</strong></p>
<p><strong> 另外，如果你就是那位打算手写操作系统的硬核玩家，那么你需要了解为什么需要交叉编译，怎么编译一个gcc交叉编译器，什么是 bootstrap 等等 ，这部分内容我会慢慢补充</strong></p>
<p><br></p>
<h2 id="xv6"><a href="#xv6" class="headerlink" title="xv6"></a>xv6</h2><p><br></p>
<h3 id="安装配置-bochs"><a href="#安装配置-bochs" class="headerlink" title="安装配置 bochs"></a>安装配置 bochs</h3><ul>
<li><p>bochs 是一个用于执行与调试内核镜像的虚拟机</p>
</li>
<li><p>安装 bochs</p>
</li>
</ul>
<pre><code>$ brew install bochs
</code></pre><ul>
<li>可能会遇到如下错误</li>
</ul>
<pre><code>/usr/local/share/man/man5 is not writable
</code></pre><ul>
<li>出现该错误时 bochs 已经成功安装，但需要另外执行</li>
</ul>
<pre><code>$ sudo chown -R $(whoami):admin /usr/local/share/man/man5
$ brew link bochs
</code></pre><ul>
<li>如无意外现在可执行 bochs</li>
</ul>
<pre><code>$ bochs
1. Restore factory default configuration
2. Read options from...
3. Edit options
4. Save options to...
5. Restore the Bochs state from...
6. Begin simulation
7. Quit now
</code></pre><p><br></p>
<h3 id="安装-qemu"><a href="#安装-qemu" class="headerlink" title="安装 qemu"></a>安装 qemu</h3><pre><code>$ brew install qemu
</code></pre><ul>
<li>同样可能出现如下错误</li>
</ul>
<pre><code>/usr/local/share/man/man8 is not writable.
</code></pre><ul>
<li>对于该错误，你应该知道该怎么做了</li>
</ul>
<pre><code>$ sudo chown -R $(whoami):admin /usr/local/share/man/man8
</code></pre><ul>
<li>如无意外现在可执行</li>
</ul>
<pre><code>$ qemu-system-x86\_64
</code></pre><p><br></p>
<h3 id="获取源码"><a href="#获取源码" class="headerlink" title="获取源码"></a>获取源码</h3><ul>
<li>在github 上可获取 xv6 的代码仓库,注意这里是 git://而不是 https:// ，使用 ssh 来 clone 是为了防止 tag 太大而出错，在某些版本的git会出现这个问题 </li>
</ul>
<pre><code>$ git clone git://github.com/mit-pdos/xv6-public.git
</code></pre><p><br></p>
<h3 id="安装-MacPorts"><a href="#安装-MacPorts" class="headerlink" title="安装 MacPorts"></a>安装 MacPorts</h3><ul>
<li>请在该页面下载对应版本的 pkg 并安装  </li>
</ul>
<pre><code>https://www.macports.org/install.php
</code></pre><ul>
<li>安装过程可能会卡死，强制关闭下载器，找到相关进程 kill -9 杀死，重启，断网，再安装，具体原因不清楚</li>
</ul>
<pre><code>ps aux | grep install
</code></pre><ul>
<li>在 /etc/profile 中加入</li>
</ul>
<pre><code>export PATH=/opt/local/bin:$PATH
export PATH=/opt/local/sbin:$PATH
</code></pre><ul>
<li>更新 port, 时间比较长</li>
</ul>
<pre><code>sudo port -v selfupdate
</code></pre><h3 id="安装交叉编译器编译器"><a href="#安装交叉编译器编译器" class="headerlink" title="安装交叉编译器编译器"></a>安装交叉编译器编译器</h3><ul>
<li>安装 i386-elf-gcc</li>
</ul>
<pre><code>sudo port install i386-elf-gcc
</code></pre><p><br></p>
<h3 id="编译-xv6"><a href="#编译-xv6" class="headerlink" title="编译 xv6"></a>编译 xv6</h3><ul>
<li>老实说，到上一步我就没往下走了，因为打算自己编译交叉环境的gcc，这里就留个大致流程</li>
</ul>
<pre><code>$ cd xv6-public
$ make
</code></pre><p><br></p>
<h3 id="调试运行"><a href="#调试运行" class="headerlink" title="调试运行"></a>调试运行</h3><pre><code>$ make qemu-nox
</code></pre><p><br></p>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p><br></p>
<h3 id="获取内核源码"><a href="#获取内核源码" class="headerlink" title="获取内核源码"></a>获取内核源码</h3><ul>
<li>你可以在这个网站中获取 linux 内核进十年的各个版本（分支）</li>
</ul>
<pre><code>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git
</code></pre><ul>
<li>本人使用的是v2.6, –depth=1是只下载最近的commit，不然仓库太大会导致出错，说实在也不需要整个仓库下载下来</li>
</ul>
<pre><code>git clone --depth=1 git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6.git
</code></pre><p><br></p>
<h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><ul>
<li>Linux的编译比较简单，坑也比较好找到解决反正，网上文章非常多，这里就不写了</li>
</ul>
<p><br></p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p><br></p>
<h3 id="Android-源码获取"><a href="#Android-源码获取" class="headerlink" title="Android 源码获取"></a>Android 源码获取</h3><ul>
<li>我并不打算下载或编译 Android 系统源码，这里只给一个方便阅读源码的地方</li>
</ul>
<pre><code>http://androidxref.com/
</code></pre><p><br></p>
<h3 id="minix-源码获取"><a href="#minix-源码获取" class="headerlink" title="minix 源码获取"></a>minix 源码获取</h3><pre><code>git clone git://github.com/Stichting-MINIX-Research-Foundation/minix.git
</code></pre><p><strong>本篇完</strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 系统相关 0]]></title>
      <url>/2018/09/05/androidSource/</url>
      <content type="html"><![CDATA[<a id="more"></a>
<p><strong>android系统涵盖方面太多了，说深入理解一个内核，一个虚拟机的实现还是可以的，说深入理解一个现代操作系统就有点太笼统了，这个系列只包含一些个人认为重要的内容</strong></p>
<p><br></p>
<h3 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h3><ul>
<li>系统启动流程</li>
</ul>
<p><a href="https://tocreate.app/2019/01/03/AOSInit/" target="_blank" rel="external">详见</a></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[计算机网络 系列]]></title>
      <url>/2018/09/05/net-0/</url>
      <content type="html"><![CDATA[<ul>
<li>假装深入</li>
</ul>
<a id="more"></a>
<h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p><strong><a href="http://tocreate.app/2018/10/30/NetLayer" target="_blank" rel="external">详见</a></strong></p>
<p><br></p>
<h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p><strong><a href="http://tocreate.app/2018/10/31/NetEthernet" target="_blank" rel="external">详见</a></strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入 Jvm 系列 0]]></title>
      <url>/2018/09/04/jvm/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><br></p>
<h3 id="编译与调试"><a href="#编译与调试" class="headerlink" title="编译与调试"></a>编译与调试</h3><ul>
<li><p><strong>编译与ide调试</strong><br><a href="http://tocreate.app/2018/09/26/JVMCompileOpenJdk7/" target="_blank" rel="external">详见</a></p>
</li>
<li><p><strong>gdb 调试</strong><br><a href="https://tocreate.app/2018/10/17/JVMUseGdb/" target="_blank" rel="external">详见</a></p>
</li>
</ul>
<p><br></p>
<h3 id="对象与类-OOP-Klass-模型"><a href="#对象与类-OOP-Klass-模型" class="headerlink" title="对象与类(OOP-Klass 模型)"></a>对象与类(OOP-Klass 模型)</h3><ul>
<li><strong>HotSpot中的对象表示机制</strong><br><a href="https://tocreate.app/2018/10/17/JVMOopKlass" target="_blank" rel="external">详见</a></li>
</ul>
<p><br></p>
<h3 id="Class文件"><a href="#Class文件" class="headerlink" title="Class文件"></a>Class文件</h3><ul>
<li><strong>解析Class文件</strong><br><a href="https://tocreate.app/2018/10/19/JVMClassFile/" target="_blank" rel="external">详见</a></li>
</ul>
<p><br></p>
<h3 id="运行时数据"><a href="#运行时数据" class="headerlink" title="运行时数据"></a>运行时数据</h3><ul>
<li><p><strong>对象内存布局和创建过程</strong><br><a href="https://tocreate.app/2018/11/26/JVMObjectMemo/" target="_blank" rel="external">详见</a></p>
</li>
<li><p><strong>Class对象和静态变量的存储</strong><br><a href="https://tocreate.app/2018/11/29/JVMClassStatic/" target="_blank" rel="external">详见</a></p>
</li>
</ul>
<p><br></p>
<h3 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h3><ul>
<li><strong>类的加载与链接</strong><br><a href="https://tocreate.app/2018/11/29/JVMLoadLink/" target="_blank" rel="external">详见</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 模块化开发指南]]></title>
      <url>/2018/05/31/GitSubmoduleForAndroid/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><strong>本文主要内容</strong></p>
<ul>
<li>git submodule 的使用入门</li>
<li>在 android 项目中使用 git submodule</li>
<li>配置 module 以支持组件化开发</li>
</ul>
<p><strong>ARouter的使用方法不是本文主要内容，想了解 ARounter 的使用方法直接去看官方文档更快</strong></p>
<p><br></p>
<h2 id="submodule-命令概览"><a href="#submodule-命令概览" class="headerlink" title="submodule 命令概览"></a>submodule 命令概览</h2><p><strong>这一部分是通用的 git 命令，因为对新手来说这部分命令基本不常用甚至没有听说过，所以在这里先介绍一下</strong></p>
<p><br></p>
<h3 id="添加子模块-git-submodule-add"><a href="#添加子模块-git-submodule-add" class="headerlink" title="添加子模块 git submodule add"></a>添加子模块 git submodule add</h3><ul>
<li>添加一个子模块 使用 git submodule add 仓库地址</li>
</ul>
<pre><code>git submodule add https://github.com/AlbertHumbert/submodule-test-1.git
</code></pre><ul>
<li>不出意外当前仓库会出现子模块的目录和一份 .gitModule 文件,它保存了远程仓库与本地目录之间的映射，注意它和 .gitignore 文件一样会收到版本控制的影响</li>
</ul>
<pre><code>[submodule &quot;submodule-test-1&quot;]
    path = submodule-test-1
    url = https://github.com/AlbertHumbert/submodule-test-1.git
</code></pre><ul>
<li>这里继续添加两个仓库</li>
</ul>
<pre><code>[submodule &quot;submodule-test-1&quot;]
    path = submodule-test-1
    url = https://github.com/AlbertHumbert/submodule-test-1.git
[submodule &quot;submodule-test-2&quot;]
    path = submodule-test-2
    url = https://github.com/AlbertHumbert/submodule-test-2.git
[submodule &quot;submodule-test-3&quot;]
    path = submodule-test-3
    url = https://github.com/AlbertHumbert/submodule-test-3.git
</code></pre><ul>
<li>被添加的仓库会作为特殊的提交记录，而不是一个硬盘快照,这里的 160000 是这种特殊类型的标记</li>
</ul>
<pre><code>    $ git commit -m &quot;add module 1 2 3&quot;
[master 3fc2889] add module 1 2 3
 5 files changed, 12 insertions(+)
 create mode 100644 .DS\_Store
 create mode 100644 .gitmodules
 create mode 160000 submodule-test-1
 create mode 160000 submodule-test-2
 create mode 160000 submodule-test-3
</code></pre><p><br></p>
<h3 id="初始化子模块"><a href="#初始化子模块" class="headerlink" title="初始化子模块"></a>初始化子模块</h3><ul>
<li>一个模块化管理的 git 项目同样使用 clone 命令拉取</li>
</ul>
<pre><code>git clone https://github.com/AlbertHumbert/module-test-main.git
</code></pre><ul>
<li>克隆之后直属于该项目的文件会被直接拉取，但子模块只是一个空目录，需要手动拉取，首先初始化子模块仓库</li>
</ul>
<pre><code>git submodule init
</code></pre><ul>
<li>然后拉取子仓库的提交记录,现在子模块就不为空了</li>
</ul>
<pre><code>git submodule update
</code></pre><ul>
<li>上面的三条命令可以简化为下面这一条，命令提示中给出的 –recursive 的作用是 initialize all contained submodules,初始化所有被囊括的子模块</li>
</ul>
<pre><code>git clone --recursive https://github.com/AlbertHumbert/module-test-main.git
</code></pre><p><br></p>
<h3 id="更新子模块"><a href="#更新子模块" class="headerlink" title="更新子模块"></a>更新子模块</h3><ul>
<li>使用 git submodule update 可以更新所有子模块，但这个命令实际上非常的坑，很让人费解，它的实际作用是直接 checkout 本地的指定远程分支上最新的 commit ，这样会导致当前工作区处于游离状态</li>
</ul>
<pre><code>$ git status
HEAD detached at 2a70dd5
nothing to commit, working directory clean
</code></pre><ul>
<li>如果本地的指定远程分支状态和远程仓库上的一致，那么只需要在当前游离的指针创建一个分支,然后将其合并到需要的分支即可，这里不再赘述了</li>
</ul>
<pre><code>git branch tmp 2a70dd5
</code></pre><ul>
<li>正确的做法是使用 git submodule update –remote –merge , 它可以自动拉取和合并指定分支</li>
</ul>
<pre><code>git submodule update --remote --merge #更新所有子模块
git submodule update --remote --merge 子模块名 #更新指定模块
</code></pre><ul>
<li>刚刚多次提到指定分支这个概念，在没有配置的情况下，这个指定分支就是 master ，可以通过 .gitmodule 进行配置</li>
</ul>
<pre><code>[submodule &quot;submodule-test-1&quot;]
    path = submodule-test-1
    url = https://github.com/AlbertHumbert/submodule-test-1.git
    branch = master
[submodule &quot;submodule-test-2&quot;]
    path = submodule-test-2
    url = https://github.com/AlbertHumbert/submodule-test-2.git
    branch = dev
[submodule &quot;submodule-test-3&quot;]
    path = submodule-test-3
    url = https://github.com/AlbertHumbert/submodule-test-3.git
    branch = release
</code></pre><ul>
<li>如果有多个分支需要更新，可以使用 foreach 操作</li>
</ul>
<pre><code>git submodule foreach git checkout master 
git submodule foreach git pull
</code></pre><p><br></p>
<h3 id="删除子模块"><a href="#删除子模块" class="headerlink" title="删除子模块"></a>删除子模块</h3><ul>
<li>删除 gitmodules 和 .git/config,</li>
<li>然后执行 git rm –cached 模块名</li>
<li>最后执行 rm -rf .git/modules/模块名</li>
</ul>
<p><br></p>
<h2 id="在-Android-项目中创建-module"><a href="#在-Android-项目中创建-module" class="headerlink" title="在 Android 项目中创建 module"></a>在 Android 项目中创建 module</h2><p><strong>从这里开始，本文中的 module 即指 git 中的 submodule 也指 Android 项目中的 module、模块、组件</strong></p>
<ul>
<li>首先在 AS 中创建一个 module ，注意如果弹出询问是否跟踪这些新文件的弹窗，直接取消，因为我们只要把这些文件添加到新的远程仓库（对于子模块依赖的远程仓库，下文直接称之为子仓库）</li>
</ul>
<ul>
<li>在 github，gitlab，coding 或者任意服务器上创建子仓库，注意项目名应该与子模块的目录名一致，某则 git 无法识别其为子模块的仓库</li>
</ul>
<ul>
<li>然后在本地添加依赖，常见操作就不解释了</li>
</ul>
<pre><code>git init
git commit -m &quot;init&quot; 
git remote add origin https://git.coding.net/AlbertHumbert/basemodule.git  
git push -u origin master   
</code></pre><ul>
<li>在项目根目录添加这个子模块的信息，这里我们看到这里将已有的远程仓库添加到记录当中了</li>
</ul>
<pre><code>$ git submodule add https://git.coding.net/AlbertHumbert/basemodule.git 
Adding existing repo at &apos;basemodule&apos; to the index
</code></pre><p><br></p>
<h2 id="组件化环境配置"><a href="#组件化环境配置" class="headerlink" title="组件化环境配置"></a>组件化环境配置</h2><p><br></p>
<h3 id="设置编译模式"><a href="#设置编译模式" class="headerlink" title="设置编译模式"></a>设置编译模式</h3><ul>
<li>在项目根目录的 gradle.properties 中添加全局标志位，当需要单独编译某个模块，设其为真，当需要集成整个项目时设其为假,同时在各个模块的 build.gradle 中判断该模块应该当做 Library 还是 Application</li>
</ul>
<pre><code># gradle.properties
isSingleBuildModule = false

\# 
if (isSingleBuildModule.toBoolean()) {
    apply plugin: &apos;com.android.application&apos;
} else {
    apply plugin: &apos;com.android.library&apos;
}
</code></pre><p><br></p>
<h3 id="不同模式下的-manifest-文件配置"><a href="#不同模式下的-manifest-文件配置" class="headerlink" title="不同模式下的 manifest 文件配置"></a>不同模式下的 manifest 文件配置</h3><ul>
<li>每一个 android module 都可以有自己 androidmanifest 文件，但需要注意的是有些属性是不能在多分 manifest 中重复声明的，比如 launchActivity，Application</li>
</ul>
<ul>
<li>当我们单独开发某个模块的时候需要定义自己的 launchActivity，Application等信息，但集成编译时不希望产生冲突，那么我们可以借鉴上一步的思路，根据不同的编译模式，使用不同的 manifest</li>
</ul>
<ul>
<li>首先在模块的 main 目录下创建 manifest 目录，该目录下再分别创建 release 和 debug 目录，存放单独编译和集成编译时使用的 manifest 文件</li>
</ul>
<pre><code>&lt;!--单独编译使用的manifest--&gt;
\&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?\&gt;
\&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    package=&quot;com.topview.basemodule&quot;&gt;

    &lt;application
        android:allowBackup=&quot;true&quot;
        android:icon=&quot;@mipmap/ic_launcher&quot;
        android:label=&quot;@string/app_name&quot;
        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;
        android:supportsRtl=&quot;true&quot;
        android:theme=&quot;@style/AppTheme&quot;&gt;
        &lt;activity android:name=&quot;.MainActivity&quot;&gt;
            &lt;intent-filter&gt;
                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;

                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
            &lt;/intent-filter&gt;
        &lt;/activity&gt;
    &lt;/application&gt;

&lt;/manifest&gt;

&lt;!--______________________________________________--&gt;

\&lt;--集成编译使用的 manifest-\&gt;
\&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    package=&quot;com.topview.basemodule&quot; /&gt;
</code></pre><ul>
<li>在该模块的android闭包下添加判断即可</li>
</ul>
<pre><code>sourceSets {
    main {
        jniLibs.srcDirs = [&apos;libs&apos;]
        if (isSingleBuildModule.toBoolean()) {
            manifest.srcFile &apos;src/main/manifest/debug/AndroidManifest.xml&apos;
        } else {
            manifest.srcFile &apos;src/main/manifest/release/AndroidManifest.xml&apos;
        }
    }
}
</code></pre><p><br></p>
<h3 id="全局资源管理"><a href="#全局资源管理" class="headerlink" title="全局资源管理"></a>全局资源管理</h3><ul>
<li>在上一个环节中我们的manifest文件中包含了 appName,icon 这样的资源，这个 manifest 是我直接从app模块下复制过来的，但是在其他 module 不能直接使用，因为其他的 module 无法获取这部分资源</li>
</ul>
<ul>
<li>为解决这些问题，我们不妨创建一个单独的 module 用来存放公用的 字符串，图片，style 等资源，然后所有的module 都在 gradle 中依赖这个 module 即可</li>
</ul>
<pre><code>dependencies {
    //...
    api project(&quot;:commonres&quot;)
    //...
}
</code></pre><p><br></p>
<h3 id="全局-gradle-配置"><a href="#全局-gradle-配置" class="headerlink" title="全局 gradle 配置"></a>全局 gradle 配置</h3><ul>
<li>远程依赖的管理和资源文件的管理类似，没必要在每个 module 中进行重复依赖，虽然重复的依赖声明不会导致多份相同的文件被打包进 apk，但最好还是使用一个单独的 module 进行统一管理，做法跟上个环节一样，这里不再赘述</li>
</ul>
<ul>
<li>对于 compileSdkVersion，buildToolsVersion，这些配置最好能够做到全局的修改，为此可以创建一个 gradle 专门管理,对于并非所有模块都需要的远程依赖，也可以在这里管理版本号</li>
</ul>
<pre><code># congig.gradle
ext {

    COMPILE_SDK_VERSION = 27
    MIN_SDK_VERSION = 16
    TARGET_SDK_VERSION = 26

    APPCOMPAT_VERSION = &apos;27.1.1&apos;
    RXJAVA_2_VERSION = &apos;2.1.13&apos;
    RXANDROID_VERSION = &apos;2.0.2&apos;
}

# build.gradle
    compileSdkVersion COMPILE_SDK_VERSION
</code></pre><p><br></p>
<h3 id="导入-module-与-activity-模板"><a href="#导入-module-与-activity-模板" class="headerlink" title="导入 module 与 activity 模板"></a>导入 module 与 activity 模板</h3><ul>
<li>可以看到我们现在的没创建一个模块逻辑都会有很多重复的操作，其实 android studio 为简化这种重复的操作提供了一个解决途径，模板</li>
</ul>
<ul>
<li>一般比较有经验的开发者应该都知道怎么自己编写一个 Activity 的模板，达到简单点击几下按钮就能准备一个已近有了样板代码的Activity，其实 module 也是这样</li>
</ul>
<ul>
<li>最简单的实现方法，我们只需要复制 AS 目录 下的 contents -> plugins -> android -> lib -> templates -> gradle-project -> NewAndroidProject 进行修改即可</li>
</ul>
<ul>
<li>比如这里的是其中一份gradle文件,我们可以直接在这里添加相关配置，最终这些代码会出现在自动生成的文件当中，当然还有许多相关的配置需要输入或者动态获取，这方面的语法可以参考<a href="https://www.jianshu.com/p/c76facb61d69" target="_blank" rel="external">这篇文章</a>，这里就不详细介绍了</li>
</ul>
<pre><code>// Top-level build file where you can add configuration options common to all sub-projects/modules.

buildscript {
    &lt;#if includeKotlinSupport!false&gt;ext.kotlin_version = &apos;${kotlinVersion}&apos;&lt;/#if&gt;
    repositories {
        google()
        jcenter()
    }
    dependencies {
        classpath &apos;com.android.tools.build:gradle:${gradlePluginVersion}&apos;
        &lt;#if includeKotlinSupport!false&gt;classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;&lt;/#if&gt;

        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
}

allprojects {
    repositories {
        google()
        jcenter()
    }
}

task clean(type: Delete) {
    delete rootProject.buildDir
}
</code></pre><ul>
<li>我正在根据自己的项目来实现资源，底层和业务模块的模块，如果有需要可以参考<a href="https://github.com/AlbertHumbert/AndroidModuleTemplate" target="_blank" rel="external">这里</a></li>
</ul>
<p><br></p>
<h2 id="使用-ARouter"><a href="#使用-ARouter" class="headerlink" title="使用 ARouter"></a>使用 ARouter</h2><ul>
<li>在 basemodule 中添加 ARouter 的依赖,这里使用 exclude，避免与我们的 support 库产生冲突，ARouter 只由一个模块去依赖就好</li>
</ul>
<pre><code>implementation (&apos;com.alibaba:arouter-api:1.2.4&apos;){
    exclude module: &apos;support-v4&apos;
}
</code></pre><ul>
<li>在需要使用 arouter 的模块添加注解依赖</li>
</ul>
<pre><code>dependencies {
    annotationProcessor &apos;com.alibaba:arouter-compiler:1.1.4&apos;
}
</code></pre><ul>
<li>在 defaultConfig 闭包中添加</li>
</ul>
<pre><code>defaultConfig{
        javaCompileOptions {
            annotationProcessorOptions {
                arguments = [ moduleName : project.getName() ]
            }
        }
}
</code></pre><ul>
<li>在 Application 中初始化 arouter </li>
</ul>
<pre><code>@Override
public void onCreate() {
    super.onCreate();
    if (BuildConfig.DEBUG) {
        ARouter.openLog();
        ARouter.openDebug();
    }
    ARouter.init(this);
}
</code></pre><ul>
<li>在需要跳转的 Activity 中添加注解</li>
</ul>
<pre><code>@Route(path = &quot;/feature1/main&quot;)
</code></pre><ul>
<li>使用 arouter 进行跳转</li>
</ul>
<pre><code>ARouter.getInstance().build(&quot;/feature1/main&quot;).navigation();
</code></pre><p><strong>本篇完</strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基于 Git Flow 模型的工作流程]]></title>
      <url>/2018/05/25/GitFlowModel/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><br></p>
<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p><br></p>
<h3 id="长期分支-amp-辅助分支"><a href="#长期分支-amp-辅助分支" class="headerlink" title="长期分支 &amp; 辅助分支"></a>长期分支 &amp; 辅助分支</h3><ul>
<li><p>在 git-flow 中最主要的五个分支是 master，release，develop，feature，hotfix</p>
</li>
<li><p>长期分支包括 master，develop</p>
</li>
<li><p>辅助分支包括 feature，release，hotfix</p>
</li>
<li><p>长期分支是相对稳定的分支，所有被认可的提交最终都会被合并到它们当中</p>
</li>
<li><p>辅助分支是临时开辟的短期分支，在完成它们的工作之后通常可以删除</p>
</li>
</ul>
<p><br></p>
<h3 id="分支概述"><a href="#分支概述" class="headerlink" title="分支概述"></a>分支概述</h3><ul>
<li><p>master，对外发布产品使用的分支，该分支的最新提交必须是一个已近对外提供的版本，不允许直接在该分支上开发，因为它必须永远保持最稳定的状态</p>
</li>
<li><p>develop，内部开发产品使用的分支，该分支的最新提交必须是一个相对稳定的测试版本，同样不允许直接在该分支上开发</p>
</li>
<li><p>feature，功能特性分支，直接在 develop 上创建的分支，feature 是不确定数量的分支的统称（如feature/a, feature/b），可以在这些分支上直接开发新特性，如果需要多人协作，则将分支推送到远程仓库，不允许在一个功能未完成之前将其合并到 develop 分支</p>
</li>
<li><p>release，测试分支，develop 分支上创建的分支，用于产品对外发布之前（即更新 master 分支）的测试工作，在创建完该分支之后最好立即推送到远程仓库</p>
</li>
<li><p>hotfix，修复分支，在 master 上创建的分支，用于对线上版本的bug的修复，每一个特定的问题创建一个分支</p>
</li>
</ul>
<p><br></p>
<h2 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h2><p><br></p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul>
<li><p>创建本地仓库，并推送到远程，这部分太基础所有略过</p>
</li>
<li><p>由于 master 分支是默认创建的，所以只需创建另一个长期分支 ——develop 并推送到远程</p>
</li>
</ul>
<pre><code>git checkout -b develop
git push origin develop:develop
</code></pre><ul>
<li>其他成员克隆后需要拉取 develop 分支,并指定好跟踪的远程分支，注意最好远程分支和本地分支使用相同的命名</li>
</ul>
<pre><code>git fetch origin develop:develop
git branch --set-upstream-to=origin/develop develop
</code></pre><p><br></p>
<h3 id="开发新特性"><a href="#开发新特性" class="headerlink" title="开发新特性"></a>开发新特性</h3><ul>
<li>开发特性a，在 develop 分支上创建新特性分支 feature/a ，注意不要在 develop 分支上直接开发</li>
</ul>
<pre><code>git checkout develop
git checkout -b feature/a
</code></pre><ul>
<li>如果有必要，将该特性分支推送到远程</li>
</ul>
<pre><code>git push origin feature/a:feature/a
</code></pre><ul>
<li>如果有必要，其他成员拉取特性分支</li>
</ul>
<pre><code>git fetch origin feature/a:feature/a
</code></pre><p><br></p>
<h3 id="完成新特性"><a href="#完成新特性" class="headerlink" title="完成新特性"></a>完成新特性</h3><ul>
<li>新特性完成之后需要将 feature 分支合并到 develop 分支</li>
</ul>
<pre><code>git checkout develop
git merge feature/a
git push origin develop
</code></pre><ul>
<li>合并完成并确定无人使用该 feature 分支之后，将其删除</li>
</ul>
<pre><code>git branch -d feature/a  #删除本地分支
git push origin --delete feature/a #删除远程分支
</code></pre><p><br></p>
<h3 id="测试新版本"><a href="#测试新版本" class="headerlink" title="测试新版本"></a>测试新版本</h3><ul>
<li>重复上面的流程完成多个新特性之后，我们开始在 release 分支上测试,用版本号创建 release 分支，版本号根据 master 分支当前最新的 tag 来确定即可，根据改动的情况选择要增加的位</li>
</ul>
<pre><code>git checkout -b release/1.0.0
git push origin release/1.0.0:release/1.0.0
</code></pre><p><br></p>
<h3 id="发布新版本"><a href="#发布新版本" class="headerlink" title="发布新版本"></a>发布新版本</h3><ul>
<li>在确定当前版本足够完善时，就可以进行发布了,注意发布前确定本地的release分支处于最新的状态</li>
</ul>
<pre><code>git pull origin release/1.0.0
</code></pre><ul>
<li>将 release 分支合并到 develop 分支</li>
</ul>
<pre><code>git checkout develop
git merge release/1.0.0
</code></pre><ul>
<li>将 release 分支合并到 maseter 分支</li>
</ul>
<pre><code>git checkout master
git merge release/1.0.0
</code></pre><ul>
<li>根据命名的tag进行真正的标签记录</li>
</ul>
<pre><code>git checkout master
git tag -a &quot;1.0.0&quot; HEAD -m &quot;新版本改动描述&quot;
</code></pre><ul>
<li>删除 release 分支</li>
</ul>
<pre><code>git branch -d release/1.0.0
git push origin --delete release/1.0.0
</code></pre><p><br></p>
<h3 id="修复线上-bug"><a href="#修复线上-bug" class="headerlink" title="修复线上 bug"></a>修复线上 bug</h3><ul>
<li><p>注意如果不是线上的版本而是开发过程中的 develop 的 bug 则在 develop 中创建分支进行修复，如果是在 release 分支上的 bug 则直接在 release 分支上修改即可</p>
</li>
<li><p>有些问题在上线之后才会被发现，那么我们需要创建 hotfix 分支进行处理,注意不要直接在 feature 上进行修复，而是在 master 分支上根据具体的问题创建分支并推到远程</p>
</li>
</ul>
<pre><code>git checkout master
git checkout -b hotfix/typo
git push origin hotfix/typo:hotfix/typo
</code></pre><ul>
<li>修改完成后重新发版,确定当前 hotfix 分支版本是最新的，再将hotfix 分支合并到 develope 分支</li>
</ul>
<pre><code>git pull origin hotfix/typo
git checkout develop
git merge hotfix/typo
</code></pre><ul>
<li>然后将 hotfix 分支合并到 master 分支,注意改动了 master 分支之后 tag 也要更新，因为是修复 bug，一般最后一位加一即可</li>
</ul>
<pre><code>git checkout master
git merge hotfix/typo
git tag -a &quot;1.0.1&quot; HEAD -m &quot;fix typo&quot;
</code></pre><ul>
<li>到这里我们从创建项目，添加特性，测试发布，修改bug的流程就走完一遍了</li>
</ul>
<p><br><br><br><br><br> </p>
<p><strong>全文完</strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[git-flow 工作流 上手指南]]></title>
      <url>/2018/05/25/git-flow/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><strong>本文中指的git-flow是一个基于git flow工作流模型的git工具，它可以使开发者更加规范地进行版本控制，使你的仓库更加clean</strong></p>
<p><strong>本来觉得这个工具已经将git flow模型简化得很好了，而且以前也或多或少了解过git flow 模型，以为使用git-flow来掌握这个模型的学习成本几乎为0，但后来确实发觉自己对很多细节了解不透，于是又从头开始学习了git flow 模型，如果需要了解这部分前期知识，请看<a href="https://tocreate.app/2018/05/25/GitFlowModel/" title="这里" target="_blank" rel="external">这里</a></strong></p>
<p><strong>主要参考</strong></p>
<p><strong><a href="http://danielkummer.github.io/git-flow-cheatsheet/index.zh_CN.html" title="备忘清单  " target="_blank" rel="external"> 备忘清单 </a></strong></p>
<p><strong><a href="https://www.git-tower.com/learn/git/ebook/cn/command-line/advanced-topics/git-flow" title="Learn Version Control with Git" target="_blank" rel="external"> Learn Version Control with Git </a></strong></p>
<p><br></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><br></p>
<h3 id="在-mac-上安装-git-flow"><a href="#在-mac-上安装-git-flow" class="headerlink" title="在 mac 上安装 git-flow"></a>在 mac 上安装 git-flow</h3><blockquote>
<p>brew install git-flow</p>
</blockquote>
<p><br></p>
<h3 id="在-linux-上安装-git-flow"><a href="#在-linux-上安装-git-flow" class="headerlink" title="在 linux 上安装 git-flow"></a>在 linux 上安装 git-flow</h3><blockquote>
<p>sudo apt-get install git-flow</p>
</blockquote>
<p><br></p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p><br></p>
<h3 id="git-flow-init"><a href="#git-flow-init" class="headerlink" title="git flow init"></a>git flow init</h3><ul>
<li>使用 git flow init 取代 git init 进行初始化操作，flow（下文中的git-flow全部简称为flow）初始化时会询问分支类别的命名规范，建议使用默认的master，develop，feature/, release/, hotfix/, support/，master和develop是默认的长期分支</li>
</ul>
<pre><code>Initialized empty Git repository in /Users/alberthumbert/Desktop/AircraftDemo/aircraft/.git/
No branches exist yet. Base branches must be created now.
Branch name for production releases: [master] 
Branch name for &quot;next release&quot; development: [develop] 

How to name your supporting branch prefixes?
Feature branches? [feature/] 
Release branches? [release/] 
Hotfix branches? [hotfix/] 
Support branches? [support/] 
Version tag prefix? [] 
</code></pre><ul>
<li><p>初始化之后，flow会为你自动创建master和develop分支，并且切换到develop分支</p>
</li>
<li><p>注意这个init操作可以在已有的git仓库上使用</p>
</li>
</ul>
<p><br></p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p><br></p>
<h3 id="git-flow-feature-start-特性名"><a href="#git-flow-feature-start-特性名" class="headerlink" title="git flow feature start (特性名)"></a>git flow feature start (特性名)</h3><ul>
<li>开发新特性（功能，接口…）请在develope分支上创建新分支，git flow feature start 特性名，特性名应该能够概括整个新特性</li>
</ul>
<pre><code>$ git flow feature start transparent-init  

Switched to a new branch &apos;feature/transparent-init&apos;

Summary of actions:
- A new branch &apos;feature/transparent-init&apos; was created, based on &apos;develop&apos;
- You are now on branch &apos;feature/transparent-init&apos;

Now, start committing on your feature. When done, use:

     git flow feature finish transparent-init
</code></pre><ul>
<li>git flow 的输出比git本身更加好懂</li>
<li>这个操作创建了一个新的 feature/transparent-init 分支，然后切换的该分支</li>
</ul>
<p><br></p>
<h3 id="git-flow-feature-finish-特性名"><a href="#git-flow-feature-finish-特性名" class="headerlink" title="git flow feature finish (特性名)"></a>git flow feature finish (特性名)</h3><pre><code>commit 08e027ba6be8bc04e1615307c4d2f1c6ce41baac
Author: AlbertHumbert &lt;709913148@qq.com&gt;
Date:   Fri May 18 23:05:22 2018 +0800

    chore(.gitignore):添加忽略文件

commit b39a7e7894844b4d593d3ae7dd522e097cd1c96a
Author: AlbertHumbert &lt;709913148@qq.com&gt;
Date:   Fri May 18 23:02:44 2018 +0800
</code></pre><ul>
<li>经过一段时间的初始化，我们有了最终成果,使用git flow feature finish 特性名</li>
</ul>
<pre><code>$ git flow feature finish transparent-init
...
Summary of actions:
- The feature branch &apos;feature/transparent-init&apos; was merged into &apos;develop&apos;
- Feature branch &apos;feature/transparent-init&apos; has been removed
- You are now on branch &apos;develop&apos;
</code></pre><ul>
<li>现在特性分支被合并到了 develop 分支，并且自动切回了develop 分支，临时的 feature/transparent-init 分支已被删除</li>
</ul>
<p><br></p>
<h3 id="git-flow-feature-publish-特性名"><a href="#git-flow-feature-publish-特性名" class="headerlink" title="git flow feature publish (特性名)"></a>git flow feature publish (特性名)</h3><ul>
<li>使用 git flow feature publish 特性名，可以将特性分支推送到远程</li>
</ul>
<pre><code>$ git flow feature publish a
Counting objects: 3, done.
Writing objects: 100% (3/3), 244 bytes | 0 bytes/s, done.
Total 3 (delta 0), reused 0 (delta 0)
To https://github.com/AlbertHumbert/git-flow-test.git
 * [new branch]      feature/a -\&gt; feature/a
Already on &apos;feature/a&apos;
Your branch is up-to-date with &apos;origin/feature/a&apos;.

Summary of actions:
- A new remote branch &apos;feature/a&apos; was created
- The local branch &apos;feature/a&apos; was configured to track the remote branch
- You are now on branch &apos;feature/a&apos;
</code></pre><ul>
<li>这个操作根据本地分支名创建并跟踪了远程分支，并切换到了本地分支</li>
</ul>
<p><br></p>
<h3 id="git-flow-feature-pull-origin-特性名"><a href="#git-flow-feature-pull-origin-特性名" class="headerlink" title="git flow feature pull origin (特性名)"></a>git flow feature pull origin (特性名)</h3><ul>
<li>使用 git flow feature pull origin 特性名，可以获取远程的提交，并自动切换到特性分支</li>
</ul>
<pre><code> $ git flow feature pull origin a
Created local branch feature/a based on origin&apos;s feature/a.
</code></pre><ul>
<li><p>注意git flow 对于远程仓库是透明的，在本地调用git flow init并进行了推送，在其他目录clone仓库之后也需要再次执行git flow init</p>
</li>
<li><p>但是这个时候init时设定的命名必须统一，一般来说一个小组也应该使用约定好的命名，基本上使用默认的就行了</p>
</li>
<li><p>在分支已经拉取之后，使用git原本的 push pull fetch 即可</p>
</li>
</ul>
<p><br></p>
<h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p><br></p>
<h3 id="git-flow-release-start-版本号"><a href="#git-flow-release-start-版本号" class="headerlink" title="git flow release start (版本号)"></a>git flow release start (版本号)</h3><ul>
<li>使用 git flow release start 版本号创建一个发布版本，注意请规范地使用版本号</li>
</ul>
<pre><code>git flow release start 1.0.0
Switched to a new branch &apos;release/1.0.0&apos;

Summary of actions:
- A new branch &apos;release/1.0.0&apos; was created, based on &apos;develop&apos;
- You are now on branch &apos;release/1.0.0&apos; 
</code></pre><ul>
<li>该操作创建并切换到了新的 release 分支</li>
</ul>
<ul>
<li>注意在一条 release 分支已经创建了且未发布的情况下是不能使用flow再创建release分支的,这也很合理</li>
</ul>
<pre><code>git flow release start 1.1.0
There is an existing release branch (1.0.0). Finish that one first.
</code></pre><p><br></p>
<h3 id="git-flow-release-publish-版本号"><a href="#git-flow-release-publish-版本号" class="headerlink" title="git flow release publish (版本号)"></a>git flow release publish (版本号)</h3><ul>
<li>和其他分支一样创建分支时，flow不会自动将分支推送到远程，这里使用 git flow release publish 版本号 进行推送</li>
</ul>
<pre><code>git push origin release/1.0.0:release/1.0.0
</code></pre><p><br></p>
<h3 id="git-flow-release-track-版本号"><a href="#git-flow-release-track-版本号" class="headerlink" title="git flow release track (版本号)"></a>git flow release track (版本号)</h3><ul>
<li>从远程仓库拉取一个release分支，使用 git flow release track 版本号</li>
</ul>
<p><br></p>
<h3 id="git-flow-release-finish-版本号"><a href="#git-flow-release-finish-版本号" class="headerlink" title="git flow release finish (版本号)"></a>git flow release finish (版本号)</h3><ul>
<li>确定一个可发布的版本已近完成之后，我们使用 git flow release finish 版本号 来将成果合并到 master 分支</li>
</ul>
<pre><code>$ git flow release finish 1.0.0
Switched to branch &apos;master&apos;
Your branch is up-to-date with &apos;origin/master&apos;.
Merge made by the &apos;recursive&apos; strategy.
 test | 2 ++
 1 file changed, 2 insertions(+)
 create mode 100644 test
Switched to branch &apos;develop&apos;
Merge made by the &apos;recursive&apos; strategy.
 test | 2 ++
 1 file changed, 2 insertions(+)
 create mode 100644 test
Deleted branch release/1.0.0 (was 5054d9b).

Summary of actions:
- Latest objects have been fetched from &apos;origin&apos;
- Release branch has been merged into &apos;master&apos;
- The release was tagged &apos;1.0.0&apos;
- Release branch has been back-merged into &apos;develop&apos;
- Release branch &apos;release/1.0.0&apos; has been deleted
</code></pre><ul>
<li>该操作拉取了最新的release分支，并且将 release 合并到 develop 和 master 分支，打上了标签后删除了release分支</li>
</ul>
<p><br></p>
<h2 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h2><p><br></p>
<h3 id="git-flow-hotfix-start-错误名"><a href="#git-flow-hotfix-start-错误名" class="headerlink" title="git flow hotfix start (错误名)"></a>git flow hotfix start (错误名)</h3><ul>
<li>有些潜在的问题会在新版本正式发布之后才显现出来，这个时候我们需要使用hotfix分支进行紧急修复工作，使用git flow hotfix start 错误名 开启一个新分支</li>
</ul>
<pre><code>$ git flow hotfix start some-bug
Switched to a new branch &apos;hotfix/some-bug&apos;

Summary of actions:
- A new branch &apos;hotfix/some-bug&apos; was created, based on &apos;master&apos;
- You are now on branch &apos;hotfix/some-bug&apos;

Follow-up actions:
- Bump the version number now!
- Start committing your hot fixes
- When done, run:

     git flow hotfix finish ‘some-bug’
</code></pre><ul>
<li>该操作创建并切换到了 hotfix 分支</li>
</ul>
<p><br></p>
<h3 id="git-flow-hotfix-finish-错误名"><a href="#git-flow-hotfix-finish-错误名" class="headerlink" title="git flow hotfix finish (错误名)"></a>git flow hotfix finish (错误名)</h3><ul>
<li>在不懈的努力下，这个顽固的bug终于被排除了，这个使用使用git flow hotfix finish 错误名 进行提交，将错误合并到master和develop分支</li>
</ul>
<pre><code>$ git flow hotfix finish some-bug
^[[ASwitched to branch &apos;master&apos;
Your branch is ahead of &apos;origin/master&apos; by 4 commits.
  (use &quot;git push&quot; to publish your local commits)
Merge made by the &apos;recursive&apos; strategy.
 test | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
Switched to branch &apos;develop&apos;
Merge made by the &apos;recursive&apos; strategy.
 test | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
Deleted branch hotfix/some-bug (was 77b7eec).

Summary of actions:
- Latest objects have been fetched from &apos;origin&apos;
- Hotfix branch has been merged into &apos;master&apos;
- The hotfix was tagged &apos;some-bug&apos;
- Hotfix branch has been back-merged into &apos;develop&apos;
- Hotfix branch &apos;hotfix/1.0.1’ has been deleted
</code></pre><ul>
<li>该操作拉取了最新的远程分支，将hotfix分支合并到 master 和 develop 然后打上标签再将 hotfix 分支删除</li>
</ul>
<p><br><br><br><br><br><br><strong>全文完</strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[gradle 3.x 依赖方式]]></title>
      <url>/2018/05/20/gradle3/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><br></p>
<p><strong>简单记录一下 gradle 3.x 中的依赖模式</strong></p>
<h3 id="新旧对比"><a href="#新旧对比" class="headerlink" title="新旧对比"></a>新旧对比</h3><ul>
<li>gradle 3.x 与 2.x 的依赖方式有了很大区别，具体来说，有了下面这样的改动</li>
</ul>
<table>
<thead>
<tr>
<th>2.x</th>
<th>3.x</th>
</tr>
</thead>
<tbody>
<tr>
<td>无</td>
<td>implementation </td>
</tr>
<tr>
<td>compile</td>
<td>api </td>
</tr>
<tr>
<td>provided</td>
<td>compileOnly </td>
</tr>
<tr>
<td>apk</td>
<td>runtimeOnly</td>
</tr>
<tr>
<td>debugCompile</td>
<td>debugImplementation </td>
</tr>
<tr>
<td>releaseCompile</td>
<td>releaseImplementation</td>
</tr>
<tr>
<td>androidTestCompile</td>
<td>androidTestImplementation</td>
</tr>
</tbody>
</table>
<p><br></p>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><ul>
<li><p>在详述3.x依赖方法之前，我们先创建一个场景，在我们的测试项目 组件app依赖了a库和c库，另一个aar组件叫test，它依赖了b库和c库，其中 app依赖的c库为1.0版本，test库依赖的c库则为1.1版本</p>
</li>
<li><p>在 app 中我们依赖了test</p>
</li>
</ul>
<pre><code>compile project(path: &apos;:test&apos;)
</code></pre><p><br></p>
<h3 id="api"><a href="#api" class="headerlink" title="api"></a>api</h3><ul>
<li><p>api 和 compile 没有区别，也就是说 api会向外暴露它的依赖</p>
</li>
<li><p>如果 app 和 test 都是使用 api 来依赖各自的库，在 app 中可以调用到b库,但在 test 中无法调用 a 库，同时由于c库版本不同又重复依赖，所以会报错</p>
</li>
</ul>
<ul>
<li>被编译组件依赖的组件如果又含有api依赖，那么所有这些 依赖都要被gradle检查，这会增加编译时间，同时使用api时需要注意重复的库版本必须一致</li>
</ul>
<p><br></p>
<h3 id="implementation"><a href="#implementation" class="headerlink" title="implementation"></a>implementation</h3><ul>
<li>implementation，和 compile 相反，它会对外屏蔽依赖</li>
</ul>
<ul>
<li>如果场景中全部使用 implementation ，则 app 可以使用 a 库，但不能使用b库，app 和 test 都能使用各自的c库而不报错</li>
</ul>
<ul>
<li>被编译组件依赖的组件如果又含有implementation依赖，这些依赖会被忽略，因为它们对外是不可见的，准确的说编译时不可见，运行时可见</li>
</ul>
<p><br></p>
<h3 id="compileOnly"><a href="#compileOnly" class="headerlink" title="compileOnly"></a>compileOnly</h3><ul>
<li>compileOnly 和 provided 一致，编译时可见，运行时不可见</li>
</ul>
<ul>
<li>test使用compileOnly依赖b库时，app不可以调用b库，同时如果test运行时调用了b库会崩溃，compileOnly主要用于只在编译期使用的库，如注解解释器</li>
</ul>
<ul>
<li><p>compileOnly也可用于一些可配置的组件，需要某些功能时将compileOnly改为api对外开放，不需要时则使用compileOnly，不影响该组件的开发</p>
</li>
<li><p>compileOnly只在编译期存在不会将整个库打包到apk，合理使用compileOnly可以减小apk体积</p>
</li>
</ul>
<p><br></p>
<h3 id="runtimeOnly"><a href="#runtimeOnly" class="headerlink" title="runtimeOnly"></a>runtimeOnly</h3><ul>
<li>这个就厉害了，运行时可见，编译时不可见，在开发时，使用runtimeOnly依赖的库和调用者是完全解耦的</li>
</ul>
<ul>
<li>runtimeOnly主要用于组件化开发，本文不涉及这部分内容，所以略过</li>
</ul>
<p><br></p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>debugImplementation，releaseImplementation，testImplementation，这三个就好懂了，使用这三者进行依赖，被依赖的库只会在debug包，release包，和单元测试时有效</li>
</ul>
<p><br></p>
<p><br></p>
<p><strong>全文完</strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Architecture Components 系列 - Lifecycle]]></title>
      <url>/2018/03/29/Lifecycle/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><strong> 这几个月总被项目耽搁，很久没学过什么东西了，文章也没怎么写，翻翻博客，前面的几篇文章都太监了，再早一点的连链接都挂了。感觉很羞愧，赶紧开几个系列文章压压惊。</strong></p>
<p><strong> Architecture Components 是安卓官方推出的数据驱动组件全家桶，包括 Lifecycle，LiveData，ViewModel，Room，Paging等，使用该全家桶最直观的效果就是，你更新数据库的时候，UI可以自动更新并且再也不用担心复杂的生命周期对app产生的负面影响。另外 LiveData是目前MVVM架构的核心依赖库，如果你想学习MVVM架构，也应该将Architecture Components作为入门基础</strong></p>
<p><strong>在入门之前，推荐先观看官方的<a href="https://www.youtube.com/watch?v=vOJCrbr144o" target="_blank" rel="external">介绍视频</a></strong></p>
<p><br></p>
<h2 id="啥是Lifecycle啊"><a href="#啥是Lifecycle啊" class="headerlink" title="啥是Lifecycle啊"></a>啥是Lifecycle啊</h2><ul>
<li>Lifecycle是 Architecture Components 组件的基础，它允许我们使用观察者模式监听Activity和Fragment的生命周期，LiveData的生命周期感知能力实际上就来自Lifecycle</li>
</ul>
<ul>
<li>熟悉MVP模式的开发者肯定都有一套MVP基类的封装，其中的Activity和Fragment完成了与presenter的生命周期绑定，这是很自然的</li>
</ul>
<pre><code>@Override
@CallSuper
protected void onResume() {
    super.onResume();
    if (mPresenter != null)
        mPresenter.onResume();
}

@Override
@CallSuper
protected void onStop() {
    super.onStop();
    if (mPresenter != null)
        mPresenter.onStop();
}
</code></pre><ul>
<li>而Lifecycle为我们提供了继承以外的切入点，我们先来看看怎么使用它们</li>
</ul>
<pre><code>//实现一个LifecycleObserver
//使用注解监听生命周期时间，这有点像eventbus
public class MyObserver implements LifecycleObserver {
    private static final String TAG = &quot;MyObserver&quot;;

    @OnLifecycleEvent(Lifecycle.Event.ON_CREATE)
    public void onCreate() {
        Log.d(TAG, &quot;onCreate: &quot;);
    }

    … 

    //在Activity或Fragmet中
    getLifecycle().addObserver(new MyObserver())；

    //启动Activity，LifecycleObserver被注解的方法被执行了
    //logcat中
    D/MyObserver: onCreate: 
</code></pre><p><br></p>
<h2 id="为啥要Lifecycle啊"><a href="#为啥要Lifecycle啊" class="headerlink" title="为啥要Lifecycle啊"></a>为啥要Lifecycle啊</h2><ul>
<li>确实可以感觉到Lifecycle的用法非常简洁，但是既然我们都已经封装好了自己的库，还有必要使用LifeCycle吗。实际上是有的，我们这样实现的生命周期感知实际上是被动的，试问你怎么知道当前的view处于什么周期呢，写在onCreate中的代码一定在onCreate中执行吗，如果我在其中执行异步操作呢？为了这个解决这个问题，你可以添加一个标记，然后在不同的回调方法中维护它，但是Lifecycle提供了更好的解决方案，让我们主动查询生命周期</li>
</ul>
<pre><code>if(getLifecycle().getCurrentState() == Lifecycle.State.STARTED){
        //do something
    }

if(getLifecycle().getCurrentState().isAtLeast(Lifecycle.State.RESUMED)){
        //do something
    }
</code></pre><ul>
<li>使用Lifecycle也可以使得代码更加解耦，比如说我们的项目中有一个监听遥感的模块，那么我们可以在onResume和onDestroy中开始和解除监听，假如我们现在又要加入一个监听地理位置的功能呢，这些模块都是独立的但是目前它们的生命周期都落在负责这个界面的人的手上，由那个人去调用，而使用Lifecycle之后，你只需要像下面这样就可以分离职责，一个LifeCycle可以有多个Observer</li>
</ul>
<pre><code>getLifecycle().addObserver(new MyObserver());
getLifecycle().addObserver(new YourObserver());
getLifecycle().addObserver(new HisObserver());
getLifecycle().addObserver(new HerObserver());
</code></pre><ul>
<li>学过一点设计模式应该都清楚，组合优先于继承，下面是一个我参与的项目中十分常见的Fragment的继承关系,每当添加一个新特性都有可能需要加一层继承关系，而java又不支持多继承，引入Lifecycle之后功能特性可以写到Observer当中，如果某个组件需要这个特性只需要调用addObserver即可完成绑定工作，逻辑也就更加清晰了</li>
</ul>
<pre><code>public class DeviceDetailFragment extends BaseMvpFragment\&lt;DeviceDetailContract.Presenter\&gt; implements DeviceDetailContract.View

public abstract class BaseMvpFragment\&lt;P extends MSBaseContract.BasePresenter\&gt; extends MSBaseMvpFragment&lt;P&gt;

public abstract class MSBaseMvpFragment\&lt;P extends MSBaseContract.BasePresenter\&gt; extends MSBaseFragment

public abstract class MSBaseFragment extends MSLazyFragment

public class MSLazyFragment extends MSBaseLazyFragment 

public class MSBaseLazyFragment extends Fragment
</code></pre><ul>
<li>其实我觉得最重要的理由其实是官方已经把LifeCycle植入到SupportActivity等组件当中了，只要你的support库在26以上，那么你就已经依赖了Lifecycle，不管你如何强调不要重复造轮子，既然官方强制导入了Lifecycle，那么现在重复的就是你的轮子</li>
</ul>
<pre><code>public class SupportActivity extends Activity implements LifecycleOwner
</code></pre><p><br></p>
<h2 id="在support-26以下使用Lifecycle"><a href="#在support-26以下使用Lifecycle" class="headerlink" title="在support 26以下使用Lifecycle"></a>在support 26以下使用Lifecycle</h2><ul>
<li>之前提到，对于活动而言 Lifecycle是在SupportActivity当中实现的，那么看一下我们怎么让Activity也支持Lifecycle，我们只需要让其实现LifecycleOwner接口，这个接口只有一个getLifecycle方法，返回一个生命周期的提供者</li>
</ul>
<pre><code>public interface LifecycleOwner {
    /**
     * Returns the Lifecycle of the provider.
     *
     * @return The lifecycle of the provider.
     */
    Lifecycle getLifecycle();
}
</code></pre><ul>
<li>这个get方法实现起来也很简单，只要返回LifecycleRegistry即可</li>
</ul>
<pre><code>@NonNull
@Override
public Lifecycle getLifecycle() {
    if(lifecycle == null)lifecycle = new LifecycleRegistry(this);
    return new LifecycleRegistry(this);
}
</code></pre><ul>
<li>在support 26以下，情况则有小小的不同，首先你需要依赖Lifecycle，注意Lifecycle版本不能太高，否则会与support库冲突</li>
</ul>
<pre><code>    compile &quot;android.arch.lifecycle:runtime:1.0.0-alpha1&quot;
compile &quot;android.arch.lifecycle:extensions:1.0.0-alpha1&quot;
    annotationProcessor &quot;android.arch.lifecycle:compiler:1.0.0-alpha1&quot;
</code></pre><ul>
<li>然后让Activity或Fragment实现 LifecycleRegistryOwner 接口，该接口同样只有一个getLifecycle方法,但返回的是LifecycleRegistry</li>
</ul>
<pre><code>@NonNull
@Override
public LifecycleRegistry getLifecycle() {
    if(lifecycle == null)lifecycle = new LifecycleRegistry(this);
    return new LifecycleRegistry(this);
}
</code></pre><p><br></p>
<h2 id="Lifecycle-实现细节"><a href="#Lifecycle-实现细节" class="headerlink" title="Lifecycle 实现细节"></a>Lifecycle 实现细节</h2><p><br></p>
<h3 id="透明初始化"><a href="#透明初始化" class="headerlink" title="透明初始化"></a>透明初始化</h3><ul>
<li>Lifecycle中非常值得学习的一点就是它的透明初始化，什么是透明呢，不妨从反面说起，我们在使用第三方库时常常要手动调用初始化操作，最常见的做法是在Application的onCreate中调用各种init，而Lifecycle巧用provider，将初始化操作交给了android框架和库本身</li>
</ul>
<ul>
<li>Lifecycle注册了一个专门用于初始化的provider，称其为木马</li>
</ul>
<pre><code>\&lt;provider
        android:name=&quot;android.arch.lifecycle.LifecycleRuntimeTrojanProvider&quot;
        android:authorities=&quot;${applicationId}.lifecycle-trojan&quot;
        android:exported=&quot;false&quot;
        android:multiprocess=&quot;true&quot; /&gt;
</code></pre><ul>
<li>这个provider中只有onCreate是有实际意义的，它从getContext中获得了Application的Context并调用需要context的初始化方法，由于provider的onCreate总是早于Activity的onCreate执行，所以这个方法是可行的</li>
</ul>
<pre><code>public class LifecycleRuntimeTrojanProvider extends ContentProvider {
    @Override
    public boolean onCreate() {
        LifecycleDispatcher.init(getContext());
        ProcessLifecycleOwner.init(getContext());
        return true;
    }

    @Nullable
    @Override
    public Cursor query(@NonNull Uri uri, String[] strings, String s, String[] strings1,
            String s1) {
        return null;
    }

    @Nullable
    @Override
    public String getType(@NonNull Uri uri) {
        return null;
    }

    @Nullable
    @Override
    public Uri insert(@NonNull Uri uri, ContentValues contentValues) {
        return null;
    }

    @Override
    public int delete(@NonNull Uri uri, String s, String[] strings) {
        return 0;
    }

    @Override
    public int update(@NonNull Uri uri, ContentValues contentValues, String s, String[] strings) {
        return 0;
    }
}
</code></pre><p><br><br><br><br><strong>全文完</strong></p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[译文：对匈牙利命名法说不]]></title>
      <url>/2017/12/30/Hungarian-translate/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><br></p>
<pre><code>译者：

本文来自 Android 大神 Jake Wharton,他是 ButerKnife 和 RxBinding 的开发者,
OkHttp，RxJava，Retrofit 等流行的 Android 开发库的重要贡献者，对安卓编程风格的演进具有不可磨灭的影响
</code></pre><ul>
<li><a href="http://jakewharton.com/just-say-no-to-hungarian-notation/" target="_blank" rel="external">原文博客地址</a></li>
<li><a href="https://alberthumbert.github.io/2017/12/30/Hungarian-translate/">译文地址</a></li>
<li><a href="https://www.jianshu.com/p/3dcc81d3e937" target="_blank" rel="external">简书地址</a></li>
</ul>
<p><br></p>
<p><strong>每一天都会有为安卓应用和库编写的java代码携带着一种传染病诞生，这种传染病的名字就叫做匈牙利命名法。</strong><br><strong>匈牙利命名法在安卓领域的推广纯粹是个意外，然而它依然受到错误的辩护。让我们先来推垮几个常见的主张：</strong></p>
<p><br></p>
<ul>
<li><strong>“《安卓 java 代码风格指南》推荐使用匈牙利命名法”</strong></li>
</ul>
<p>根本就不存在所谓指导程序员如何编写java代码的《安卓java代码风格指南》，绝大部分人口中子虚乌有的编码风格指南来自于 <a href="https://source.android.com/source/code-style#follow-field-naming-conventions" title="面向贡献者的 AOSP 代码样式指南&gt;" target="_blank" rel="external"> 《面向贡献者的 AOSP 代码样式指南》 </a></p>
<p>你可不是在为AOSP项目编写代码，因此你并不需要遵循他们的指南。</p>
<p>即便你正在编写未来可能纳入AOSP的代码，你也不需要遵循这份指南,<br>几乎所有AOSP所导入的java库都没有遵循它，甚至AOSP项目中的一部分开发人员都没有这么做</p>
<p><br></p>
<ul>
<li><strong>“Android 样例使用匈牙利命名法”</strong></li>
</ul>
<p>一些样例诞生于AOSP项目的开发平台所以它们奉行AOSP的风格。而那些不来自AOSP的样例，它们的作者要么错误地相信了别的主张，要么只是单纯地忘了纠正编写这些样例时所使用的风格</p>
<p><br></p>
<ul>
<li><strong>“那些额外的信息为 code review 提供了帮助”</strong></li>
</ul>
<p>使用变量名前缀m和s分别可以声明变量是private/package的非静态成员或静态成员①，不然进行code review时将无法得知这些信息。这种方式能够推断那些代码改动②中不可见的变量。从而，不管怎样，一个变量的可见性都可以被显而易见地得知。</p>
<p>在我反驳这种观点之前，我们先来定义一下匈牙利命名法。根据维基百科，匈牙利命名法有两种：</p>
<ul>
<li><p>1.</p>
<pre><code>系统命名法将变量的数据类型加入到变量名当中。
一个long类型的用户id在java中将被一个名为lUser的变量代表，以此来表示它的用途和数据类型
</code></pre></li>
<li><p>2.</p>
<pre><code>应用命名法将变量在语义上的用途而不是逻辑上的用途或目的加入到变量名中。
保存私有信息的变量带有某种前缀（如mUserId）而保存公有信息的变量则有另一种前缀，或者压根没有前缀
</code></pre></li>
</ul>
<p>那么当你看见一个成员变量被使用时，究竟哪一种信息对code review来说更重要，是它的可见性还是数据类型？</p>
<p>可见性在code review当中是一种无需关注的属性。成员变量已经出现并且能够被使用，而且它的可见性大概也已经在上一个改动中被审阅过了<br>然而，成员变量的类型对于其在代码改动中如何被使用有更加直接的影响。被正确调用的方法名，参数的位置，可以被调用的方法，这些全都与变量的类型直接相关。</p>
<p>因此提出应用匈牙利命名法是错误的不单只是因为它没有用处，还因为系统匈牙利命名法能提供更多有关的信息。这可不是在说你应该使用系统匈牙利命名法，数据类型和可见性时常改动，而你将会忘记修改它们的名字。毕竟并不难发现静态的mContext成员变量</p>
<p><br></p>
<ul>
<li><strong>“额外的信息有助于开发”</strong></li>
</ul>
<p>Android Studio和IntelliJ IDEA会根据成员身份（静态或非静态）在视觉上区分非成员变量</p>
<p>IDE默认强制使用正确的可见性和数据类型，所以一个命名规定不会带来任何东西。简单敲击键盘，就会有弹窗显示变量的那三种（以及更多）属性。</p>
<p><img src="http://jakewharton.com/static/post-image/hungarian-idea.png" alt=""></p>
<p><br></p>
<ul>
<li><strong>“我想像谷歌官方一样编写java代码”</strong></li>
</ul>
<p>尽管安卓和AOSP都是该公司的一部分，谷歌在他们的<a href="https://google.github.io/styleguide/javaguide.html#s5.1-identifier-names" target="_blank" rel="external">编码风格指南</a>中积极明确地禁止了匈牙利命名法的使用。公开的java风格指南是AOSP经年累月的内部习惯固化的产物。</p>
<p>安卓起源于谷歌之外，AOSP团队早已染上了匈牙利命名的顽疾。现在对其进行修改将是一种无用的扰乱并且会给分支和第三方合作者带来冲突。</p>
<p>但你对下面这个观点的持续支持与实践能够让我们在人生中根除这种疾病</p>
<p><strong>朋友就不该再让朋友使用匈牙利命名法③</strong></p>
<p><br></p>
<p><strong>— Jake Wharton</strong></p>
<p><br><br><br></p>
<pre><code>译者注：

① field(成员): 根据oracle提供的文档，field这个词在未特指的情况下指的是非静态的成员变量，
    而在本文单纯指成员变量，没有额外的限定

② change(代码改动)：在该文中应指git等svn中的提交差异

③ 该文中标题中的“不”以及结尾处的两个“朋友”在原文中使用的分别是 mNo,mFriends,sFriends,
    这里直接舍弃了匈牙利命名法的前缀来翻译，至于作者使用这些前缀的意图，感兴趣的读者可以自行借助原文进行思考
</code></pre><ul>
<li><a href="http://jakewharton.com/just-say-no-to-hungarian-notation/" target="_blank" rel="external">原文博客地址</a></li>
<li><a href="https://github.com/JakeWharton/" target="_blank" rel="external">作者GitHub地址</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/information/glossary.html" target="_blank" rel="external">翻译参考资料</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 交叉编译 Shape/KML/GeoJSON 文件读写库 Gdal 注意事项]]></title>
      <url>/2017/12/09/makeFuckingGdalSo/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><br></p>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><ul>
<li>目前编译出来的so包只能兼容 Android 5.0 及以上的系统</li>
</ul>
<ul>
<li>网络上有编译好并且兼容Android 4.4的so包可以直接拿来用，这些so包都是armeabi-v7a的，目前绝大部分手机都是ARMv7架构，当前项目使用的设备也是ARMv7的，因此暂时没有问题</li>
</ul>
<ul>
<li>由于pc端一般是x86或x86_64架构的处理器，因此虚拟机也是x86或x86_64架构，因此调试阶段先加入x86的so，正式版本中会移除</li>
</ul>
<p><br></p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><br></p>
<h3 id="为什么使用Gdal"><a href="#为什么使用Gdal" class="headerlink" title="为什么使用Gdal"></a>为什么使用Gdal</h3><ul>
<li>就目前所知Java平台的地理数据文件的处理工具主要有GeoTools，ArcGIS Runtime SDK 以及 Gdal</li>
</ul>
<ul>
<li>GeoTools的jar文件至少有70mb，虽然可以精简，但核心部分依赖了Java的awt库，awt库无法再Android上使用直接导致crash</li>
</ul>
<ul>
<li>ArcGIS Runtime SDK 的大小没有了解过，估计也小不到哪里去，ArcGIS 可以读取shp文件，但是不能直接修改和创建shp，而且ArcGIS 读取shp也是通过Gdal实现的</li>
</ul>
<ul>
<li>Gdal 精简并且支持多种地理数据文件的操作，社区活跃度也很高，就在写这篇文章的上个月还发布了新的稳定版，但是和其他工具一样，Gdal并不针对 Android开发，因此为了能够在Android平台上使用，编译过程比较复杂</li>
</ul>
<p><br></p>
<h3 id="关于Shape"><a href="#关于Shape" class="headerlink" title="关于Shape"></a>关于Shape</h3><ul>
<li>Shape文件至少包含三个后缀不同的文件，.shp .dbf .shx</li>
</ul>
<ul>
<li>类似 Gdal和GeoTools等工具可以只读取其中一个文件，如shp和dbf，但是导入文件的时候注意全部导入，否则某些数据将会缺失</li>
</ul>
<ul>
<li>Gdal 支持 shp 和 KML，GeoJson 直接互换，KML实际上是一种专门的XML规范，GeoJson则是Json的规范，如果自行解析，可以直接将其视为XML和Json</li>
</ul>
<p><br></p>
<h3 id="关于编译"><a href="#关于编译" class="headerlink" title="关于编译"></a>关于编译</h3><ul>
<li>请在Linux上按照<a href="http://www.jianshu.com/p/b6899345d18e" title="这篇文章" target="_blank" rel="external">这篇文章</a>的流程进行编译，作者写得十分详细</li>
</ul>
<ul>
<li>x86 交叉编译的配置参考如下,其他abi请自行推断CC 和CXX参数</li>
</ul>
<pre><code>export NDK\_HOME=/home/parallels/albert/Android/android-ndk-r14b
 export PATH=$NDK\_HOME:$PATH
 export TOOLCHAIN\_HOME=/home/parallels/Android/android-toolchain/x86
 export PATH=$TOOLCHAIN\_HOME/bin:$PATH
 export LIBS=&quot;-lstdc++ -lgnustl\_shared&quot;
 export CC=/home/parallels/Android/android-toolchain/x86/bin/i686-linux-android-gcc-4.9
 export CXX=/home/parallels/Android/android-toolchain/x86/bin/i686-linux-android-g++
 export CXXFLAGS=&quot;-march=i686&quot;
 export CFLAGS=&quot;-march=i686&quot;
 export LDFLAGS=&quot;-march=i686&quot;
</code></pre><ul>
<li>./configure 阶段如果报错，务必在configure.log中查看详细的错误信息</li>
</ul>
<ul>
<li>在 gdal 2.0.3版本以下会出现  x86_64-unknown-linux-gnu 错误，无法检测到编译平台，这里需要更新 gdal源文件的config.guess和config.sub文件，可以在<a href="http://git.savannah.gnu.org/gitweb/?p=config.git;a=tree" title="这里" target="_blank" rel="external">这里</a>获取</li>
</ul>
<ul>
<li>使用APP_PLATFORM = 19 编译无法通过，这是由于signal和atof等库或函数在21以下不存在，将APP_PLATFORM下调至8可以通过，但是运行时可能出现链接错误，暂时没有找到解决办法</li>
</ul>
<ul>
<li>其中由于库或函数不存在而出错的源文件如下,可以考虑直接修改源文件，如atof可以修改strtod(nptr, NULL)</li>
</ul>
<pre><code>gxf\_ogcwkt.c

hf2dataset.cpp

tif\_luv.c

cpl\_strtod.cpp

gdalwarper.cpp

gdalnodatamaskband.cpp

ilwisdataset.cpp

cpl\_spawn.cpp
</code></pre><ul>
<li>使用低版本源码有时在swig目录中make出错，本人是直接忽略的，gdal社区中有人给出的建议是调低swig版本，实际使用发现一般swig正常生成jar包可以通用，可能是由于绝大部分接口的定义都是一致的</li>
</ul>
<ul>
<li>正式发版时记得将x86的so文件移除</li>
</ul>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Jni ，从入门到入坟]]></title>
      <url>/2017/11/17/Jni/</url>
      <content type="html"><![CDATA[<a id="more"></a>
<p><br></p>
<h2 id="如何使用jni进行开发"><a href="#如何使用jni进行开发" class="headerlink" title="如何使用jni进行开发"></a>如何使用jni进行开发</h2><p><strong>本文主要针对Android环境进行NDK\Native\Jni开发进行介绍</strong></p>
<p><strong>使用2.2版本之前的Android Studio进行ndk开发是比较繁琐的，如果你还在使用旧版本的Android Studio，那么建议更新到3.0，现阶段3.0已经比较稳定了(虽然旧项目的gradle升级可能需要折腾一下)。下面介绍旧版本的开发流程只是为了能够更加详细地介绍jni。</strong></p>
<p><strong>jni并不是android框架内的概念，所以也会提及其他环境使用jni开发的方法，基本上大同小异，不过你可能还需要查阅其他文章来处理一些细节问题（如Windows下生成dll文件）</strong></p>
<p><br></p>
<h3 id="AS-2-2之前的做法"><a href="#AS-2-2之前的做法" class="headerlink" title="AS 2.2之前的做法"></a>AS 2.2之前的做法</h3><p><br></p>
<h4 id="1-编写C-C"><a href="#1-编写C-C" class="headerlink" title="1.编写C/C++"></a>1.编写C/C++</h4><ul>
<li>首先创建一个java文件，声明一个自定义的native方法，对我们来说，这个方法就是java层到native层的入口，另外，还需要使用静态域将so包加载进来</li>
</ul>
<pre><code>package com.linjiamin.jnishare;

/**
* Created by Albert on 17/11/16.
*/

public class JniUtil {

    static {
        System.loadLibrary(&quot;sotest&quot;);
    }

    public static native int sum(int num1,int num2);
}
</code></pre><ul>
<li>开始编写 C/C++代码之前我们需要两个头文件。其中一个是 jni.h，该头文件包含了对jni数据类型和接口的定义（之后还会介绍），现在开始你所编写的所有C/C++代码都需要引入这个头文件。另外你还需要一个根据刚刚编写的native方法签名及类信息生成的头文件。对前者，简单地include进来即可，而对于后者，可以使用javah命令生成，当然你也可以选择亲自编写，使用命令生成的方法如下</li>
</ul>
<pre><code>//在终端中
cd app/src/main/java
javac com/linjiamin/jnishare/JniUtil.java
javah com.linjiamin.jnishare.JniUtil

//生成的头文件如下

/* DO NOT EDIT THIS FILE - it is machine generated */
#include &lt;jni.h&gt;
/* Header for class com_linjiamin_jnishare_JniUtil */

#ifndef _Included_com_linjiamin_jnishare_JniUtil
#define _Included_com_linjiamin_jnishare_JniUtil
#ifdef __cplusplus
extern &quot;C&quot; {
#endif
/*
* Class:     com_linjiamin_jnishare_JniUtil
* Method:    sum
* Signature: (II)I
*/
JNIEXPORT jint JNICALL Java_com_linjiamin_jnishare_JniUtil_sum 
(JNIEnv *, jclass, jint, jint);

#ifdef __cplusplus
}
#endif
#endif
</code></pre><ul>
<li>简单说一下如何手写这个头文件，预处理指令的写法都是相同的，将完整类名替换进去即可，对于函数签名，从左到右按以下顺序编写，当然还是使用javah方法生成更好</li>
</ul>
<pre><code>JNIEXPORT： 在android和linux中是空定义的宏，而在windows下被定义为__declspec(dllexport)，具体的作用我们不需要关心

jni数据类型：如jint，jboolean，jstring，它们对应于本地方法的返回类型（int，boolean，String）之后会进一步介绍、

JNICALL ： 这是__stdcall等函数调用约定（calling conventions）的宏，这些宏用于提示编译器该函数的参数如何入栈（从左到右，从右到左），以及清理堆栈的方式等

方法名： Java + 完整类名 + 方法名

参数列表：JNIEnv * + jclass\jobject + 所有你定义的参数所对应的jni数据类型 ，JNIEnv*是指向jvm函数表的指针，如果该方法为静态方法则第二个参数为class否则为jobject，它是含有该方法的class对象或实例

注意JNIEXPORT和JNICALL是固定的
</code></pre><ul>
<li>函数具体实现如下，相信大家都能看懂</li>
</ul>
<pre><code>#include &quot;jni.h&quot;
#include &quot;com_linjiamin_jnishare_JniUtil.h&quot;
//
// Created by Albert Humbert on 17/11/17.
//

JNIEXPORT jint JNICALL Java_com_linjiamin_jnishare_JniUtil_sum
(JNIEnv * env, jclass obj, jint num1, jint num2){
  return num1 + num2;
}
</code></pre><p><br>       </p>
<h4 id="2-使用ndk编译so包"><a href="#2-使用ndk编译so包" class="headerlink" title="2.使用ndk编译so包"></a>2.使用ndk编译so包</h4><p><br>   </p>
<h5 id="包结构"><a href="#包结构" class="headerlink" title="包结构"></a>包结构</h5><ul>
<li>现在在main包下创建一个jni包，将你的头文件和c/c++文件放进去，然后，你还需要两份mk文件，mk文件是makefile文件的一部分，makefile包含c/c++编译器的编译命令、顺序和规则，如果你不了解makefile是什么，那也没什么关系，后面会讲解Android.mk和Application.mk文件的书写规范</li>
</ul>
<ul>
<li>注意请在Android Library中进行ndk开发，不要使用Java Library，前者会生成aar包，可以包含so以及其他资源文件，后者会生成jar，jar通常只能调用外部so包，网上也有文章将jar当中的so包用文件流写到本地调用的，建议不要尝试这种骚操作</li>
</ul>
<p><br>       </p>
<h5 id="编写Android-mk"><a href="#编写Android-mk" class="headerlink" title="编写Android.mk"></a>编写Android.mk</h5><ul>
<li>你可以直接登录 <a href="http://android.mk" target="_blank" rel="external">http://android.mk</a> ，查看相关文档</li>
</ul>
<ul>
<li>一个最基本的Android.mk如下</li>
</ul>
<pre><code>LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)
LOCAL_MODULE := libsotest
LOCAL_SRC_FILES := com_linjiamin_jnishare_JniUtil.cpp
include $(BUILD_SHARED_LIBRARY)
</code></pre><ul>
<li>LOCAL_PATH := $(call my-dir)，Android.mk必须以该属性开头，它用于指定源文件的路径，my-dir是一个返回Android.mk文件所在目录的宏</li>
</ul>
<ul>
<li>include $(CLEAR_VARS) ，指定负责文件的清理的makefile文件，一般固定这么写就好</li>
</ul>
<ul>
<li>LOCAL_SRC_FILES，需要编译的c/c++文件，如无后缀则默认为cpp文件</li>
</ul>
<ul>
<li>include $(BUILD_SHARED_LIBRARY) ，收集上次清理后的源文件信息，并决定如何编译</li>
</ul>
<ul>
<li>LOCAL_C_INCLUDES，头文件的搜索路径</li>
</ul>
<ul>
<li>TARGET_ARCH，指定CPU，如armeabi，armeabi-v7a</li>
</ul>
<p><br>       </p>
<h5 id="编写Application-mk"><a href="#编写Application-mk" class="headerlink" title="编写Application.mk"></a>编写Application.mk</h5><ul>
<li>一个典型的Application.mk文件如下</li>
</ul>
<pre><code>APP_PLATFORM = android-24
APP_ABI := armeabi,armeabi-v7a,x86_64,arm64-v8a
APP_STL := stlport_static
APP_OPTIM := debug
</code></pre><ul>
<li>APP_PLATFORM，ndk版本号，你可以在ndk-bundle文件夹中查看所本地ndk版本</li>
</ul>
<pre><code># for mac
/Users/alberthumbert/Library/Android/sdk/ndk-bundle/platforms
</code></pre><ul>
<li>APP_ABI，指定APP_ABI版本，这会决定ndk编译出的so包数量，关于ABI的介绍见下文，推荐至少包含armeabi或armeabi-v7a</li>
</ul>
<ul>
<li>APP_STL 如何连接c++标准库 ，包括 stlport_static ，stlport_shared ，system，分别表示静态，动态，系统默认</li>
</ul>
<ul>
<li>APP_OPTIM，包括debug，和release，这会决定so中是否包含调试信息</li>
</ul>
<ul>
<li>APP_MODULES，填写so包的名字，如果没有这个属性，则按照Android.mk中的进行命名，注意如果文件中含有多个该属性，则会按照先后顺序为你编译出来的so文件命名</li>
</ul>
<ul>
<li>填写完这两个mk文件之后，需要在gradle中指定so库的路径，gradle会自动将so文件打包进来，在andorid闭包中添加</li>
</ul>
<pre><code>sourceSets.main {
jniLibs.srcDir &apos;src/main/libs&apos;
jni.srcDirs = []
}
</code></pre><ul>
<li>如无意外这个时候我们的项目就可以运行起来了，打印log如下</li>
</ul>
<pre><code>11-17 16:33:37.563 3824-3824/? D/JniUtil: test: 2
</code></pre><p><br></p>
<h3 id="人生苦短，我用AS-3-0"><a href="#人生苦短，我用AS-3-0" class="headerlink" title="人生苦短，我用AS 3.0"></a>人生苦短，我用AS 3.0</h3><p><br></p>
<h4 id="自动生成函数"><a href="#自动生成函数" class="headerlink" title="自动生成函数"></a>自动生成函数</h4><ul>
<li>如果出于不幸、粗心、经验不足等原因，你的项目无法运行，请不要怀疑你的智商，下面为你带来傻瓜式的ndk开发流程</li>
</ul>
<ul>
<li>最新版的AS，可以为你使用ndk开发提供很大的方便，请确保你在SDK Tools中下载了CMake、LLDB、NDK</li>
</ul>
<ul>
<li>首先创建一个新项目，并勾选Include C++ support</li>
</ul>
<ul>
<li>C++ Standard中可以选择使用的C++标准，默认是CMake所使用的标准，Exceptions Support可以启用C++异常处理，一般这些选项使用默认的就可以了</li>
</ul>
<ul>
<li>项目创建完毕之后你可以看见官方已经为你做好了很多工作，并且带了一个c++的hello world示例，你需要关注的主要有cpp和External Build Files 两个目录，前者用于放置你的C++源文件，后者根据不同的ABI版本放置了CMake脚本</li>
</ul>
<ul>
<li>接着我们直接在MainActivity中添加一个native方法，然后选中该方法，按下alt+enter，让IDE为我们自动生成C++函数</li>
</ul>
<pre><code>public native boolean booleanFromJNI();
</code></pre><ul>
<li>在native-lib.cpp中可以看见自动生成的函数，我们只需要实现该函数即可</li>
</ul>
<pre><code>JNIEXPORT jboolean JNICALL
Java_com_linjiamin_myapplication_MainActivity_booleanFromJNI(JNIEnv *env, jobject instance) {

    // TODO

}
</code></pre><ul>
<li>注意使用上面的方法你可以在任意一个java文件中声明native方法，IDE会自动在native-lib.cpp中为你生成对应的函数签名，当然，你也不是非要把所有的C/C++代码都写在一个文件里，下面来讲解一下CMakeList的基本写法</li>
</ul>
<p><br></p>
<h4 id="编写CMakeList"><a href="#编写CMakeList" class="headerlink" title="编写CMakeList"></a>编写CMakeList</h4><ul>
<li>下面是一份官方写好的CMakeList.txt，这个文件可以在你当前项目的app目录下看到</li>
</ul>
<pre><code>add_library( # 设置编译出来的so包的名字. 不需要添加lib前缀
             native-lib

             # 设置为共享链接库. 有SHARED，STATIC两种可选
             SHARED

             # 设置源文件的相对路径，可将多个源文件进行编译
             src/main/cpp/native-lib.cpp )

# Searches for a specified prebuilt library and stores the path as a
# variable. Because CMake includes system libraries in the search path by
# default, you only need to specify the name of the public NDK library
# you want to add. CMake verifies that the library exists before
# completing its build.

find_library( # 设置外部引用库.这个库支持你在c/c++中打印log，具体请见  android/log.h
            log-lib
            # 外部引用库的名称
            log )

# Specifies libraries CMake should link to your target library. You
# can link multiple libraries, such as libraries you define in this
# build script, prebuilt third-party libraries, or system libraries.

target_link_libraries( # 指定被链接的库.
                    native-lib

                    # 链接log-lib到native-lib
                    ${log-lib} )
</code></pre><ul>
<li>现在我们想要将不同的源文件编译成多份so包，例如我在cpp目录下添加一份test-lib.cpp文件，代码如下</li>
</ul>
<pre><code>extern &quot;C&quot;
JNIEXPORT jboolean JNICALL
Java_com_linjiamin_myapplication_JniUtil_booleanFromJNI(JNIEnv *env, jobject instance) {

//上面提到的log库可以这么使用，而且你应该使用宏让它好看些
__android_log_print(ANDROID_LOG_DEBUG,&quot;stringFromJNI&quot;,&quot;%d&quot;,0);
return (jboolean) true;

}
</code></pre><ul>
<li>那么可以在刚刚的CMakeList中设定我们的so包，在最后加上</li>
</ul>
<pre><code>add_library( test-lib SHARED src/main/cpp/test-lib.cpp )
</code></pre><ul>
<li>编译之后 可以看到 build/intermediates/cmake/debug/obj/ 路径下不同的ABI目录中都有了两份so文件，分别是libnative-lib.so，libtest-lib.so</li>
</ul>
<ul>
<li>如果你在不同的路径下放置了源文件，并且希望对于每一个特定的路径都有一份自己特定的CMakeList文件来描述这些源文件的打包规则（这看起来是个好习惯），可以使用add_subdirectory(“目录名”)方法指定子路径，子路径当中的放置CMakeList会被执行</li>
</ul>
<p><br></p>
<h3 id="使用g-编译so包"><a href="#使用g-编译so包" class="headerlink" title="使用g++编译so包"></a>使用g++编译so包</h3><ul>
<li>对于非安卓开发者，这里再简单介绍一个使用g++编译so包的方法，使用这种方法你无需ndk环境，也不用编写mk、CMakeList文件，完全使用命令行进行编译，当然我更推荐你去学习cmake</li>
</ul>
<ul>
<li>编写java文件并用javah指令生成头文件，再编写cpp文件，这个流程对于不同平台的jni开发都是相同的（虽然Intelligent Idea这种IDE可以为你自动生成头文件），那么现在需要一份对应平台下的jni.h文件，可以在你的jdk当中查找，编译器可能还会提示你需要一份jni_md.h文件，它也在jdk当中</li>
</ul>
<pre><code>$ cd /Library/Java/JavaVirtualMachines/jdk1.7.0_71.jdk
$ find . -iname jni.h
./Contents/Home/include/jni.h
</code></pre><ul>
<li>我这里用的是ndk当中的jni.h文件，下载ndk之后在sdk当中可以找到</li>
</ul>
<pre><code>$ cd /Users/alberthumbert/Library/Android/sdk/ndk-bundle
$ find . -iname jni.h
./sysroot/usr/include/jni.h
</code></pre><ul>
<li>现在假定你以及有了一份java文件，两份头文件，一份cpp或c文件，那么可以使用如下命令将他们编译成so文件，注意最后的参数不一定是必要的，如果你想编译安卓平台可用的so包那么建议加上</li>
</ul>
<pre><code>g++ com_linjiamin_jnishare_JniUtil.cpp -fPIC -shared -o libsotest.so -Wl,--hash-style=sysv
</code></pre><p>*<em>注意，</em>nix平台使用lib表示一个so库，所以so文件必须以lib开头，但加载时请将lib前缀去掉**</p>
<ul>
<li>你可以用绝对路径加载一个so文件</li>
</ul>
<pre><code>System.load(&quot;\***\***\***.so&quot;)
</code></pre><ul>
<li>你也可以将so文件放入系统加载路径当中，调用  System.getProperty(“java.library.path”)方法得到系统加载路径，想要修改这个路径，可以在修改.bashrc（或者当前使用的其他shell）中添加</li>
</ul>
<pre><code>export PATH=PATH:/XXX
</code></pre><ul>
<li>运行jar时动态指定路径也是可以的，这样会暂时覆盖上面写入的属性</li>
</ul>
<pre><code>java -jar -Djava.library.path=/**/**   **.jar
</code></pre><ul>
<li>重新在java代码中加载so文件，*nix平台注意去掉lib前缀</li>
</ul>
<pre><code>System.loadLibrary (&quot;***&quot;);
</code></pre><p><br></p>
<h3 id="ABI与so"><a href="#ABI与so" class="headerlink" title="ABI与so"></a>ABI与so</h3><ul>
<li>这里再啰嗦一下别的东西，可以先跳过，之后再倒回来看</li>
</ul>
<ul>
<li>由于目前我们的项目很简单，没有用到第三方so库和也没有去除多余so库为apk瘦身，因此不用考虑兼容问题，但实际开发项目时通常没这么简单。我们知道，编译出来的so是二进制文件，由于不同的CPU支持不同的指令集，所以我们需要考虑兼容性的问题。一个包含多种指令集及其相关约定的实现被称之为ABI，一个CPU架构支持一种到多种ABI。安卓平台就是针对ABI进行编译和打包的。</li>
</ul>
<ul>
<li>可能看了上面这一段会比较晕，那么我就举一个例子来说明，比如ARMv7架构的CUP，支持 armeabi和armeabi-v7a两种ABI，而armeabi这种ABI支持Thumb-1，ARMV5TE等指令集，armeabi-v7a这种ABI又支持Thumb-2和VFPv3-D16等指令集，也就是说，一种CPU架构对应多种ABI类型，一种ABI类型对于多种指令集</li>
<li>一个so文件只支持一种ABI，因此你会发现在lib下每一个包都是以ABI来命名的，同名的so文件被按照其支持的ABI进行分类</li>
<li>目前ABI一共有七种，那么是不是意味者我们的每一个so都需要编译成七种，然后全都打包进apk当中呢，答案是否定的。目前CUP流行的架构主要有ARM系列，x86，x86_64，而这些架构全部都支持armeabi这种ABI，因此类似淘宝、微信、饿了么的国内大厂通常只使用armeabi一种ABI，Facebook，Twitter等外国大厂则是只保留了armeabi-v7a，这是十分合理的，apk只保留一种通用的ABI，而最适应的so可以在外部去下载</li>
</ul>
<ul>
<li>那么是不是只要编译一种so文件就可以了呢？不完全正确，如果你引用了第三方的ndk，而第三方在兼容性做得比较好的情况下适配了多种ABI，又或者目前你的lib下so包的数量参差不齐。当一个apk安装时就有可能查找到了最适用的ABI的路径存在，但里面又没有想要的so，这时它不会自动去查找其他ABI版本的so，而是会crash，为了解决这个问题，请在lib包下只保留一个包（通常是armeabi或者armeabi-v7a），或者每个名字的so在不同包下都存在对应版本，并且在app的gradle的defaultConfig闭包中添加你所适配好的ABI，这样安装时只会从你所指定的ABI中查找so包</li>
</ul>
<pre><code>ndk{
    abiFilters  &quot;armeabi-v7a&quot;, &quot;x86&quot;, &quot;armeabi&quot;
}
</code></pre><p><br></p>
<h2 id="什么是jni"><a href="#什么是jni" class="headerlink" title="什么是jni"></a>什么是jni</h2><p><strong>现在我们已经可以进行简单的ndk开发了，但为了加深理解认识，让我再来啰嗦一下jni</strong></p>
<p><strong>看过这一部分之后你对jni应该会有更近一步的感性认识</strong></p>
<p><br></p>
<h2 id="jni-h"><a href="#jni-h" class="headerlink" title="jni.h"></a>jni.h</h2><p><br></p>
<h3 id="jni数据类型"><a href="#jni数据类型" class="headerlink" title="jni数据类型"></a>jni数据类型</h3><ul>
<li>现在来看看c/c++层的数据类型是怎么对应到java层的</li>
</ul>
<ul>
<li>首先是基本类型，根据java中的定义定义了j*类型</li>
</ul>
<pre><code>/* Primitive types that match up with Java equivalents. */
typedef uint8_t  jboolean; /* unsigned 8 bits */
typedef int8_t   jbyte;    /* signed 8 bits */
typedef uint16_t jchar;    /* unsigned 16 bits */
typedef int16_t  jshort;   /* signed 16 bits */
typedef int32_t  jint;     /* signed 32 bits */
typedef int64_t  jlong;    /* signed 64 bits */
typedef float    jfloat;   /* 32-bit IEEE 754 */
typedef double   jdouble;  /* 64-bit IEEE 754 */
</code></pre><ul>
<li>对于引用类型，c和c++有区别，在c++中 jobject是类，而jstring和各种类型的数组都是jobject的子类的指针，在c中jobject是一个void*指针，而其他引用类型其实都是jobject</li>
</ul>
<pre><code>class _jobject {};
class _jclass : public _jobject {};
class _jstring : public _jobject {};
class _jarray : public _jobject {};
class _jobjectArray : public _jarray {};
class _jbooleanArray : public _jarray {};
class _jbyteArray : public _jarray {};
class _jcharArray : public _jarray {};
class _jshortArray : public _jarray {};
class _jintArray : public _jarray {};
class _jlongArray : public _jarray {};
class _jfloatArray : public _jarray {};
class _jdoubleArray : public _jarray {};
class _jthrowable : public _jobject {};

typedef _jobject*       jobject;
typedef _jclass*        jclass;
typedef _jstring*       jstring;
typedef _jarray*        jarray;
typedef _jobjectArray*  jobjectArray;
typedef _jbooleanArray* jbooleanArray;
typedef _jbyteArray*    jbyteArray;
typedef _jcharArray*    jcharArray;
typedef _jshortArray*   jshortArray;
typedef _jintArray*     jintArray;
typedef _jlongArray*    jlongArray;
typedef _jfloatArray*   jfloatArray;
typedef _jdoubleArray*  jdoubleArray;
typedef _jthrowable*    jthrowable;
typedef _jobject*       jweak;


/*
 * Reference types, in C.
 */
typedef void*           jobject;
typedef jobject         jclass;
typedef jobject         jstring;
typedef jobject         jarray;
typedef jarray          jobjectArray;
typedef jarray          jbooleanArray;
typedef jarray          jbyteArray;
typedef jarray          jcharArray;
typedef jarray          jshortArray;
typedef jarray          jintArray;
typedef jarray          jlongArray;
typedef jarray          jfloatArray;
typedef jarray          jdoubleArray;
typedef jobject         jthrowable;
typedef jobject         jweak;
</code></pre><ul>
<li>jvalue是一个比较特殊的联合体，一般在需要调用java层方法时做为方法参数传入，如 void CallVoidMethodA(jobject obj, jmethodID methodID, jvalue* args) ，通过jobject和表示其方法的jmethodID即可特定一个具体的方法，然后将我们的jvalue作为函数列表传入</li>
</ul>
<pre><code>typedef union jvalue {
        jboolean    z;
        jbyte       b;
        jchar       c;
        jshort      s;
        jint        i;
        jlong       j;
        jfloat      f;
        jdouble     d;
        jobject     l;
    } jvalue;
</code></pre><ul>
<li>在这一方面我们可以讨论的内容比较少，总的来说，由于C/C++ 中基本类型的字节数依赖与实现，所以在native层转换到java层是不能直接使用原本的int，long等类型而是根据java中的约定使用jni.h指定了相同长度与有符号的类型，而java中的类则可以使用类或结构体的指针来解决</li>
</ul>
<p><br></p>
<h3 id="常用的接口"><a href="#常用的接口" class="headerlink" title="常用的接口"></a>常用的接口</h3><p><strong>在讲解JNIEnv和JavaVM之前先来尝试一下各种jni的基本操作，版本较新的AS已经支持了对C/C++ 的智能提示和代码补全功能，你可以很方便地试用JNIEnv提供的接口</strong></p>
<p><strong>这里只介绍几个例子，以后有时间我会另写文章介绍这些接口，强烈推荐你使用AS把可调用的函数浏览并选择性地使用一遍</strong></p>
<p><br></p>
<h4 id="修改成员变量"><a href="#修改成员变量" class="headerlink" title="修改成员变量"></a>修改成员变量</h4><ul>
<li>通过之前的例子你应该已经知道怎么从native层中获取一个变量了，现在再进一步，我们使用native方法直接改变成员变量的值，在MainActivity中定义一个native方法</li>
</ul>
<pre><code>public class MainActivity extends AppCompatActivity {

    public String mString = null;

static {
        System.loadLibrary(&quot;native-lib&quot;);
    }

    private static final String TAG = &quot;MainActivity&quot;;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        Log.d(TAG, &quot;onCreate: &quot;+mString);
        getFieldFromJNI();
        Log.d(TAG, &quot;onCreate: &quot;+ mString);
    }

    public native String getFieldFromJNI();

}
</code></pre><ul>
<li>在来看C++实现，注意你可能在阅览其他文章时发现调用jni函数时有两种不同的写法 env-> 和 (*env)->，这是由于C与C++的实现有所差异，不影响我们使用。如果你使用过反射改变成员变量的值，应该可以毫不费力地理解下面这段代码</li>
</ul>
<pre><code>extern &quot;C&quot;
JNIEXPORT jstring JNICALL
Java_com_linjiamin_jnilearning_MainActivity_getFieldFromJNI(JNIEnv *env, jobject instance) {

    jclass clazz = env-&gt;GetObjectClass(instance);
    //获取调用者的class对象
    jfieldID  jfID = env -&gt;GetFieldID(clazz,&quot;mString&quot;,&quot;Ljava/lang/String;&quot;);
    //获取成员变量的键
    jstring strValue = (jstring) env-&gt;GetObjectField(instance, jfID);
    //获取成员变量的值，不做操作
    char chars[10] = &quot;whatever&quot;；
    jstring newValue = env-&gt;NewStringUTF(chars);
    //创建一个String对象
    env-&gt;SetObjectField(instance,jfID,newValue);
    //设置新的值
    return strValue;
}
</code></pre><p><br></p>
<h4 id="创建引用"><a href="#创建引用" class="headerlink" title="创建引用"></a>创建引用</h4><p><br></p>
<h5 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h5><ul>
<li>了解jni中的引用类型，有助于你编写高效的代码并且解决内存泄漏等问题，jni中的引用类型可以分为三种，局部引用，全局引用，弱（全局）引用，通常jvm会在函数返回后自动为你释放局部引用，但你需要自行管理全局引用的生命周期</li>
</ul>
<p><br></p>
<h5 id="局部引用"><a href="#局部引用" class="headerlink" title="局部引用"></a>局部引用</h5><ul>
<li>其实我们之前已经接触过局部引用了，调用jni函数通常会创建新对象的实例并返回一个局部引用，局部引用只在一次native函数的调用周期中存在，在函数结束时被释放</li>
</ul>
<ul>
<li>通常我们需要避免返回全局引用，而是返回创建出来的局部引用，例如这样</li>
</ul>
<pre><code>return (jstring) env-&gt;NewLocalRef(someValue);
</code></pre><ul>
<li>我们刚刚说过，局部引用在函数的调用过程中存在，也就是说如果不进行人为的销毁操作，它将一直存在，在任意native函数中执行下面这段代码，你将接受到一个异常，跟java不同，gc不会及时回收通过这种方法创建出来的变量</li>
</ul>
<pre><code>for(int i = 0;i&lt;1000000000;i++){
    jstring newValue = env-&gt;NewStringUTF(chars);
}
</code></pre><ul>
<li>你可以调用 DeleteLocalRef函数销毁一个局部引用，这个函数现在就可以执行了，不过他会比一般函数耗时些</li>
</ul>
<pre><code>for(int i = 0;i&lt;1000000000;i++){
    jstring newValue = env-&gt;NewStringUTF(chars);
    env-&gt;DeleteLocalRef(newValue);
}
</code></pre><p><br></p>
<h5 id="全局引用"><a href="#全局引用" class="headerlink" title="全局引用"></a>全局引用</h5><ul>
<li>之前说过局部引用在函数的调用过程中存在，我们不能直接使用显式赋值的方式将局部引用强行将其缓存起来</li>
</ul>
<pre><code>jobject gInstance;

…

extern &quot;C&quot; JNIEXPORT void JNICALL 
Java_com_linjiamin_jnilearning_MainActivity_useCPlusThread(JNIEnv *env, jobject instance) {
methodID = env-&gt;GetMethodID(clazz,&quot;sayHello&quot;,&quot;()V&quot;);
gInstance = instance;
...
}
</code></pre><ul>
<li>上面的例子将会报错，不过对于jni开发，你可能常常只能收到含糊的报错信息，甚至收不到报错信息</li>
</ul>
<pre><code>JNI DETECTED ERROR IN APPLICATION: native code passing in reference to invalid stack indirect reference table or invalid reference: 0x7fff871642e0
</code></pre><ul>
<li>我们可以使用 NewGlobalRef 函数来创建一个全局引用，但是注意，你需要对自己的行为负责，全局引用只有在你的手动调用 DeleteGlobalRef 函数之后才会被释放，你可以在JNI_OnLoad 中进行缓存工作，在JNI_OnUnload函数中进行缓存的清除</li>
</ul>
<pre><code>jobject gInstance;

…
extern &quot;C&quot; JNIEXPORT void JNICALL 
Java_com_linjiamin_jnilearning_MainActivity_useCPlusThread(JNIEnv *env, jobject instance) {

methodID = env-&gt;GetMethodID(clazz,&quot;sayHello&quot;,&quot;()V&quot;);
gInstance = env-&gt;NewGlobalRef(instance);
...
}

…

void fun() {
...
...
env-&gt;DeleteGlobalRef(gInstance);
}
</code></pre><p><br></p>
<h5 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h5><ul>
<li>弱引用和全局引用大体上类似，但是当内存不足时它会被GC回收，通过 NewWeakGlobalRef 函数可以创建一个弱引用，和Java层的弱引用一致，它不会阻止自己所指向的对象被GC回收</li>
</ul>
<pre><code>gInstance = env-&gt;NewWeakGlobalRef(instance);
</code></pre><ul>
<li>但是这不意味着你可以不用管理弱引用的生命周期，在不需要它时请主动释放弱引用，注意，弱引用的释放不会导致它所指向的对象被GC回收</li>
</ul>
<pre><code>env-&gt;DeleteWeakGlobalRef(gInstance)
</code></pre><ul>
<li>最好在使用弱引用时判断它的对象是否已被释放，你可能会理所当然地使用 == 进行判断，这种方法是错误的，除非这个引用从来就没有被初始化过，不然表达式将永远为真，解决方案是使用jni提供的接口进行比较，有的文章也推荐再次使用NewWeakGlobalRef来达到这样的效果，个人认为这两种方案除了在可读性上的区别外没什么不同</li>
</ul>
<pre><code>if (env-&gt;IsSameObject(gInstance,NULL)) {
    __android_log_print(ANDROID_LOG_DEBUG,&quot;fun&quot;,&quot;%s&quot;,&quot;instance is NULL&quot;);
}

    //或者

if (!gInstance || !env-&gt;NewWeakGlobalRef(gInstance)) {
    __android_log_print(ANDROID_LOG_DEBUG,&quot;fun&quot;,&quot;%s&quot;,&quot;instance is NULL&quot;);
}
</code></pre><p><br></p>
<h4 id="JNIEnv，JavaVM-以及多线程"><a href="#JNIEnv，JavaVM-以及多线程" class="headerlink" title="JNIEnv，JavaVM 以及多线程"></a>JNIEnv，JavaVM 以及多线程</h4><ul>
<li>你可能已经意识到，目前为止我们都是通过JNIEnv来使用jni的，实际上JNIEnv提供了Native函数的基础环境，具体来说，它包含了一个指向函数表的指针，这也就是为什么我们需要通过JNIEnv才能调用native方法，JNIEnv也代表了具体的进程环境，因此不允许跨进程调用，最好的做法是永远不要缓存JNIEnv，你可以通过JavaVM来创造它的实例</li>
</ul>
<p><img src="https://s1.ax1x.com/2017/11/22/2xj2T.png" alt="" title="JNIEnv"></p>
<ul>
<li>JavaVM是java虚拟机的代表，它可以跨线程调用，它是一个全局对象，典型的jni环境中一个进程可以有多个JavaVM,但是在安卓环境当中他在每个进程中只有一个实例，通常你可以在JNI_OnLoad 函数，或其可以获取JNIEnv的地方得到它_</li>
</ul>
<pre><code>env-&gt;GetJavaVM(&amp;gVm);
</code></pre><ul>
<li>下面在C++线程中模仿耗时操作，并调用Java层方法传回数据，首先定义接受数据的方法和一个native方法，这里的参数列表稍微定义得复杂一点，方便之后演示jvalue的使用方法</li>
</ul>
<pre><code>public void resultCallback(boolean isSuccess,int result,String data){
    Log.d(TAG, &quot;resultCallback: &quot;+ isSuccess + &quot; &quot;+result + &quot; &quot; +data);
}

public native void useCPlusThread();
</code></pre><ul>
<li>native方法的实现如下,这里我们通过GetJavaVM方法得到了JavaVM对象，JavaVM用于我们之后获取JNIEnv，同时我们把调用者通过全局引用缓存起来，注意这里的methodID不需要使用NewGlobalRef，它是一个结构体，直接赋值即可，由于java支持重载，需要输入方法函数列表的标识才可以特定一个方法，每个基本类型都有其对应的缩写，而对于类我们需要通过包名和类名来指定。然后我们开启五个线程进行耗时操作</li>
</ul>
<pre><code>extern &quot;C&quot;
JNIEXPORT void JNICALL
Java_com_linjiamin_jnilearning_MainActivity_useCPlusThread(JNIEnv *env, jobject instance) {

env-&gt;GetJavaVM(&amp;gVm);
jclass clazz = env-&gt;GetObjectClass(instance);


methodID = env-&gt;GetMethodID(clazz, &quot;resultCallback&quot;, &quot;(ZILjava/lang/String;)V&quot;);
gInstance = env-&gt;NewGlobalRef(instance);

pthread_t pthread[5];

for(int i = 0;i&lt;5;i++){
    pthread_create(&amp;pthread[i], NULL, &amp;fun, NULL);
}
}
</code></pre><ul>
<li>线程方法的实现如下,linux系统的sleep函数定义在unistd.h文件中，我们使用它来模仿耗时操作，像刚刚说过的一样JNIEnv不能跨进程调用，那么这里使用AttachCurrentThread函数得到实例，这个函数同时也会将当前线程绑定到JavaVM上，然后我们使用CallVoidMethodA来调用刚刚缓存起来的实例的方法，也就是java层的resultCallback方法，jvalue数组可以作为参数列表传入，另外你也可以使用更为简便的CallVoidMethod函数，最后记得使用DetachCurrentThread函数解绑，除非你使用DeleteLocalRef函数释放引用，不然你通过JNIEnv获取的局部引用在你调用DetachCurrentThread之前都不会被销毁，并且在函数结束后造成内存泄漏</li>
</ul>
<pre><code>void *fun(void *arg) {
sleep(3);

JNIEnv *env;
if (gVm-&gt;AttachCurrentThread(&amp;env, NULL) != JNI_OK) {
    __android_log_print(ANDROID_LOG_DEBUG, &quot;callJniInDifferentThread&quot;, &quot;%s&quot;, &quot;attach failed&quot;);
    return NULL;
}

jvalue * args = new jvalue[3];
args[0].z = (jboolean) true;
args[1].i = 1000;
args[2].l = env-&gt;NewStringUTF(&quot;some data&quot;);

env-&gt;CallVoidMethodA(gInstance, methodID, args);

if (gVm-&gt;DetachCurrentThread() != JNI_OK) {
    __android_log_print(ANDROID_LOG_DEBUG, &quot;callJniInDifferentThread&quot;, &quot;%s&quot;, &quot;detach failed&quot;);
}

return NULL;

}
</code></pre><ul>
<li>注，各种类型对应的缩写如下，请使用一下的缩写特定具体的方法</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>缩写       </th>
</tr>
</thead>
<tbody>
<tr>
<td>Boolean</td>
<td>Z</td>
</tr>
<tr>
<td>Byte</td>
<td>B</td>
</tr>
<tr>
<td>Char</td>
<td>C</td>
</tr>
<tr>
<td>Short</td>
<td>S</td>
</tr>
<tr>
<td>Int</td>
<td>I</td>
</tr>
<tr>
<td>Long</td>
<td>L</td>
</tr>
<tr>
<td>Float</td>
<td>F</td>
</tr>
<tr>
<td>Double</td>
<td>D</td>
</tr>
<tr>
<td>Void</td>
<td>V</td>
</tr>
<tr>
<td>Object</td>
<td>以”L”开头，以”;”结尾，中间是用”/“ 隔开的包及类名。比如：Ljava/lang/String;如果是嵌套类，则用$来表示嵌套。例如 “(Ljava/lang/String;Landroid/os/FileUtils$FileStatus;)Z”</td>
</tr>
<tr>
<td>返回值与参数</td>
<td>例 (IB)L 表示返回类型为long，参数为int和byte的函数</td>
</tr>
</tbody>
</table>
<p><br></p>
<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p><br></p>
<h3 id="局部引用的内存模型"><a href="#局部引用的内存模型" class="headerlink" title="局部引用的内存模型"></a>局部引用的内存模型</h3><ul>
<li>刚刚提到JVM在一定程度上会为你管理局部引用的生命周期，但这不意味着局部引用等于局部变量。每当线程从Java层切换到native层时，JVM会创建局部引用表，它们维系了你的C/C++变量和Java层变量。</li>
</ul>
<ul>
<li>下图中出现的本地方法栈是和虚拟机栈类似的一种概念，但它用于运行native方法，注意，规范只约定了jni的操作和使用方法，对实现没有明确的要求，有些虚拟机会将虚拟机栈与本地方法栈合并实现，这里只大致地描绘本地方法栈的结构。当java层切入到native层（以下简称J2N过程，反之为N2J），或者在native函数中调用了jni接口时会导致本地方法栈的入栈操作，本地引用表在J2N时创建，并在N2J时销毁，在这个过程中，每当局部引用被合法创建，该局部引用都会被添加到表中并映射到java堆中的一个对象</li>
</ul>
<p><img src="https://s1.ax1x.com/2017/11/22/2zSr4.png" alt="" title="NativeMethodStack"></p>
<ul>
<li>看回前面这个例子，我们在循环中不断创建新的局部引用，并且赋值给变量newValue，这些不断创建的引用并不会立即释放，并且我们之后也无法获取到这些还留在表中的引用，所以他们都导致了内存泄漏。一般情况下局部引用表分配到的内存空间很小，这种内存泄漏很容易就会导致内存溢出，虚拟机崩溃。为了编写更加安全流畅的代码，我建议你遵循下面几个规范</li>
</ul>
<pre><code>for(int i = 0;i&lt;1000000000;i++){
    jstring newValue = env-&gt;NewStringUTF(chars);
}
</code></pre><p><br></p>
<h3 id="引用的使用规范"><a href="#引用的使用规范" class="headerlink" title="引用的使用规范"></a>引用的使用规范</h3><ul>
<li>native编程首先需要遵循C/C++自身的内存管理机制，除了局部引用以外，JVM不会为你做更多的内存释放工作，所以当你使用malloc函数分配内存空间后必须使用free函数进行释放，这和其他平台上的C/C++编程没什么不同</li>
</ul>
<ul>
<li>全局变量对java层对象的引用一直有效，请在不用时进行删除，否它所指向的对象将一直留在堆中</li>
</ul>
<ul>
<li>和刚刚介绍局部引用时说的一样，在函数返回之前，局部引用不会自动释放，如果创建过多的引用将会导致内存溢出的风险，如果你的函数只会创建为数不多的局部引用，那么完全可以将删除引用的操作交给JVM去处理，但如果你的函数会创建大量的引用，特别是在开启循环的请况下，请自行调用DeleteLocalRef函数</li>
</ul>
<p><br></p>
<h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul>
<li><a href="https://www.ibm.com/Search/?q=jni&amp;v=18&amp;en=utf&amp;lang=zh&amp;cc=cn&amp;sn=dw&amp;dws=cndw&amp;hpp=20" target="_blank" rel="external">IBM developerWorks 相关文章</a></li>
<li><a href="https://www.zybuluo.com/cxm-2016/note/563686" target="_blank" rel="external">JNI 完全指南</a></li>
<li><a href="http://blog.csdn.net/a345017062/article/details/8068928" target="_blank" rel="external">JNI 官方规范中文版</a></li>
<li><a href="http://blog.csdn.net/guojin08/article/details/9964579" target="_blank" rel="external">Android JNI 编程提高篇</a></li>
<li><a href="http://blog.guorongfei.com/2017/01/24/android-jni-tips-md/" target="_blank" rel="external">Android JNI 使用总结</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RemoteView 使用详解与实现原理]]></title>
      <url>/2017/09/11/RemoteView/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<h2 id="RemoteView-详解"><a href="#RemoteView-详解" class="headerlink" title="RemoteView 详解"></a>RemoteView 详解</h2><ul>
<li>RemoteView，是一种用于跨进程显示View的工具，使用场景一般为显示通知和实现桌面控件</li>
<li>相对于Binder，RemoteView效率更高但限制也更多</li>
<li>下面以桌面控件 AppWidget 为例，讲解RemoteView的使用</li>
</ul>
<h3 id="AppWidget"><a href="#AppWidget" class="headerlink" title="AppWidget"></a>AppWidget</h3><ul>
<li>AppWidget 虽然是一种可选的界面，但是它能够十分方便地为用户提供信息，更重要的是它为整个应用提供了快捷的入口，网上关于AppWidget的文章虽然多但是写得都不是很清晰，忽略了一些需要注意的坑，希望这篇文章能够提供更全面的讲解，写AppWidget主要分为以下几个步骤</li>
</ul>
<pre><code>1.使用XML文件为控件提供元数据（AppWidgetProviderInfo）
2.使用XML文件为控件提供布局信息
3.实现AppWidgetProvider管理控件的生命周期和提供数据
4.使用Service更新界面（可选）
5.实现RemoteViewsService和RemoteViewsFactory为控件提供更复杂的布局及其点击事件的响应（可选）
6.在manifest文件中注册AppWidgetProvider和用到的service 
</code></pre><ul>
<li>我们首先来观察manifest文件，下面是一个简单的例子，从这个例子我们可以知道 AppWidgetProvider 虽然名字比较有误导性，但它其实是一个BroadcastReceiver，标签中的meta-data就是刚刚说的AppWidgetProviderInfo，intent-filter中必须要有android.appwidget.action.APPWIDGET_UPDATE 这个ACTION，如果有其他需求还可以添加自定义的ACTION， \<action android:name="com.linjiamin.UPDATE" \=""> 就是我定义的广播，用于更新这个AppWidget</action></li>
</ul>
<pre><code>&lt;receiver android:name=&quot;.widget.WidgetProvider&quot;&gt;
    &lt;intent-filter&gt;

        &lt;action android:name=&quot;android.appwidget.action.APPWIDGET_UPDATE&quot;/&gt;
        &lt;action android:name=&quot;com.linjiamin.UPDATE&quot;/&gt;
    &lt;/intent-filter&gt;
    &lt;meta-data
        android:name=&quot;android.appwidget.provider&quot;
        android:resource=&quot;@xml/app_widget&quot;/&gt;
&lt;/receiver&gt; 
</code></pre><h4 id="AppWidgetProviderInfo"><a href="#AppWidgetProviderInfo" class="headerlink" title="AppWidgetProviderInfo"></a>AppWidgetProviderInfo</h4><ul>
<li>meta-data中的resource属性指向的布局文件应该写在res的xml包下，如果没有这个包则新建即可，这个xml对应于AppWidgetProviderInfo类的类属性，包含了整个AppWidget的配置信息</li>
</ul>
<pre><code>&lt;!--in app_widget.xml--&gt;
&lt;appwidget-provider xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:initialLayout=&quot;@layout/app_widget&quot;
    android:minHeight=&quot;120dp&quot;
    android:minWidth=&quot;120dp&quot;
    android:previewImage=&quot;@mipmap/ic_launcher&quot;
    android:resizeMode=&quot;horizontal|vertical&quot;
    android:updatePeriodMillis=&quot;3000&quot;
    android:widgetCategory=&quot;home_screen|keyguard&quot;&gt;
&lt;/appwidget-provider&gt;
</code></pre><ul>
<li>AppWidgetProviderInfo 有如下几个属性可供配置</li>
</ul>
<pre><code>minWidth 和 minHeight：AppWidget最小的布局宽高，但不是确切的布局宽高，AppWidget的尺寸的最小单位为桌面每个网格的尺寸，如果不足整数个网格将向上取整，手机上不建议大于4*4个网格

minResizeWidth 和 minResizeHeight ，允许用户重新调整尺寸，minResizeWidth可以小于minWidth，但实际尺寸不能小于minResizeWidth，minResizeHeight同理

updatePeriodMillis ：widget的更新频率，即是更新的回调方法onUpdate粗略的调用频率，在1.6以后，频率不能高于30分钟一次，否则会被设定为30分钟一次，由于更新会唤醒设备所以会有一定的能耗，如果使用 alarm来替代该属性，alarm应设置为 ELAPSED_REALTIME 或 RTC，同时将 updatePeriodMillis 设为 0。

initialLayout : widget 的布局资源文件，只能包含特定的控件

configure：当 widget 创建时，会自动启动填写的Activity，这个Activity应用于进行配置信息

previewImage：预览图，如果没有提供则使用应用图标。

utoAdvanceViewId ：指定一个子view ID，表明该子 view 会自动更新

resizeMode ： horizontal, vertical, none，分别为可拉伸的方向

widgetCategory：home_screen，keyguard，指定widget是否在桌面和锁屏界面上显示

initialKeyguardLayout ： 锁屏界面的布局资源文件
</code></pre><h4 id="主布局"><a href="#主布局" class="headerlink" title="主布局"></a>主布局</h4><ul>
<li>布局，RemoteView只能支持一下几种布局，这个例子中只用到了TextView和ListView，和普通控件的布局没有差别</li>
</ul>
<pre><code>//可供使用的布局
Layout: FrameLayout,LinearLayout,RelativeLayout，GridLayout

View：AnalogClock，Button，Chronometer，ImageButton，ImageView，ProgressBar ，TextView，ViewFlipper，ListView，GridView，StackView，AdapterViewFilter，ViewStub

&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot;
android:gravity=&quot;center_horizontal&quot;
android:orientation=&quot;vertical&quot;&gt;

&lt;TextView
android:id=&quot;@+id/widget_tv&quot;
android:layout_width=&quot;wrap_content&quot;
android:layout_height=&quot;wrap_content&quot;
android:text=&quot;0&quot;
android:textSize=&quot;36sp&quot;
android:textStyle=&quot;bold&quot;/&gt;

&lt;ListView
android:id=&quot;@+id/widget_lv&quot;
android:layout_width=&quot;wrap_content&quot;
android:layout_height=&quot;wrap_content&quot;&gt;
&lt;/ListView&gt;
&lt;/LinearLayout&gt;
</code></pre><h4 id="AppWidgetProvider"><a href="#AppWidgetProvider" class="headerlink" title="AppWidgetProvider"></a>AppWidgetProvider</h4><ul>
<li>AppWidgetProvider，AppWidgetProvider的onReceive中会接收诸如 APPWIDGET_UPDATE，APPWIDGET_DELETED等ACTION，然后调用相应的生命周期方法，如果我们要接收自定义的广播，需要重写onReceive然后调用自己的方法</li>
</ul>
<ul>
<li>onReceive使用的几个回调方法为，onUpdate() ，RemoteView在需要更新数据时调用，onDeleted()，AppWidget被移除时调用  ，onEnabled，AppWidget被实例化时调用，重复实例化时不会反复调用该方法，onDisabled()，AppWidget的最后一个实例被delete时调用</li>
</ul>
<ul>
<li>由于XML中配置的更新频率不能大于30分钟一次，所以这里实现一个Service来更新，在onReceive中接受到自定义的ACTION，然后调用自定义的update方法，在onEnabled中启动发送广播的service，</li>
</ul>
<pre><code>public class WidgetProvider extends AppWidgetProvider {

public static int mIndex = 0;
@Override
public void onReceive(Context context, Intent intent) {
super.onReceive(context, intent);
if(intent.getAction().equals(UpdateService.ACTION_UPDATE)){
    Update(context);
    Log.d(TAG, &quot;onReceive: &quot;);
    }
}

@Override
public void onEnabled(Context context) {

Intent intent = new Intent(context, UpdateService.class);
context.startService(intent);
Log.d(TAG, &quot;onEnabled: &quot;);
super.onEnabled(context);
}

@Override
public void onAppWidgetOptionsChanged(Context context, AppWidgetManager appWidgetManager, int appWidgetId, Bundle
    newOptions) {
super.onAppWidgetOptionsChanged(context, appWidgetManager, appWidgetId, newOptions);
}

@Override
public void onRestored(Context context, int[] oldWidgetIds, int[] newWidgetIds) {
super.onRestored(context, oldWidgetIds, newWidgetIds);
}

@Override
public void onDeleted(Context context, int[] appWidgetIds) {
super.onDeleted(context, appWidgetIds);
}

@Override
public void onDisabled(Context context) {
Intent intent = new Intent(context,UpdateService.class);
context.stopService(intent);
super.onDisabled(context);
}
</code></pre><ul>
<li>更新RemoteView需要获取AppWidgetManager的实例并调用updateAppWidget方法传入包名或id和新的remoteViews</li>
</ul>
<pre><code>private void Update(Context context) {
    RemoteViews remoteViews = new RemoteViews(context.getPackageName(), R.layout.app_widget);
    remoteViews.setTextViewText(R.id.widget_tv, &quot;&quot;+mIndex);
    AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(CurriculumApplication.getContext());
    appWidgetManager.updateAppWidget(new ComponentName(CurriculumApplication.getContext(), WidgetProvider.class), remoteViews);
mIndex ++;
    }
}
</code></pre><ul>
<li>发送广播的service这里用计时器来实现，这里每隔一秒发送一次广播，当然最好是使用AlarmManager的ELAPSED_REALTIME 或 RTC来实现，避免不必要地唤醒设备</li>
</ul>
<pre><code>public class UpdateService extends Service{

private Timer mTimer;
private TimerTask mTimerTask;
public static final int UPDATE_TIME = 1000;
public static final String ACTION_UPDATE = &quot;com.linjiamin.UPDATE&quot;;

@Override
public int onStartCommand(Intent intent, int flags, int startId) {
return super.onStartCommand(intent, flags, startId);
}

@Nullable
@Override
public IBinder onBind(Intent intent) {
return null;
}

@Override
public void onCreate() {
super.onCreate();

Log.d(TAG, &quot;onCreate: &quot;);
mTimer = new Timer();
mTimerTask = new TimerTask() {
    @Override
    public void run() {
        Intent updateIntent = new Intent(ACTION_UPDATE);
        sendBroadcast(updateIntent);
    }
};
mTimer.schedule(mTimerTask, 1000, UPDATE_TIME);
    }

        @Override
    public void onDestroy() {
    super.onDestroy();
    mTimer.cancel();
    }
}
</code></pre><ul>
<li>现在来看回我们的AppWidgetProvider，还有一个很重要的方法没有讲解——onUpdate()，onUpdate()是系统每次决定更新时调用的方法，我们刚刚通过service实现的界面更新是不会调用到这个方法的，如果更新的频率不高于30分钟一次，那么在这个方法中实现更新的逻辑即可，注意对于ListView，StackView这些包含Item的复杂控件需要使用RemoteViewService获取Adapter，这些稍后再讲解</li>
</ul>
<ul>
<li>通常onUpdate()还会做两件事，设置点击事件和PendingIntent的模板，在这里我们为TextView设定了一个启动Activity的PendingIntent，跟Notification类似，没有什么好讲的，接着为ListView设置了适配器和PendingIntent的模板，为ListView的每一个Item设置PendingIntent是很浪费的，为了提高效率，必须在AppWidgetProvider中调用setPendingIntentTemplate，传入的PendingIntent作为模板，之后RemoteViewsFactory可以利用这个模板和新的Intent进行合成</li>
</ul>
<pre><code>@Override
public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {

for(int id:appWidgetIds) {
    Log.d(TAG, &quot;onUpdate: &quot;);

    Intent updateIntent = new Intent(context, RemoteService.class);
    Intent openIntent = new Intent(context,CourseView.class);
    PendingIntent pendingIntent = PendingIntent.getActivity(context, 0, openIntent, PendingIntent.FLAG_UPDATE_CURRENT);

    RemoteViews remoteViews = new RemoteViews(context.getPackageName(), R.layout.app_widget);
    remoteViews.setRemoteAdapter(R.id.widget_lv, updateIntent);
    remoteViews.setOnClickPendingIntent(R.id.widget_tv,pendingIntent);
    remoteViews.setPendingIntentTemplate(R.id.widget_lv,pendingIntent);
    appWidgetManager.updateAppWidget(id, remoteViews);
}
super.onUpdate(context, appWidgetManager, appWidgetIds);
}
</code></pre><h4 id="RemoteViewService-amp-amp-RemoteViewsFactory"><a href="#RemoteViewService-amp-amp-RemoteViewsFactory" class="headerlink" title="RemoteViewService &amp;&amp; RemoteViewsFactory"></a>RemoteViewService &amp;&amp; RemoteViewsFactory</h4><ul>
<li>RemoteViewService用于返回 RemoteViewsFactory，通常RemoteViewsFactory实现在RemoteViewService中即可</li>
</ul>
<ul>
<li>RemoteViewsFactory是ListView和StackView等子View的工厂，从这个角度来说它很像一种适配器，其中getViewAt方法相当于getView，但是需要返回的是一个RemoteView，其他方法可以参考ListView或RecycleView的适配器来写</li>
</ul>
<ul>
<li>可以看到这个例子中调用了RemoteView的setOnClickFillInIntent方法，传入一个新的Intent，由于这里没有什么特殊的需求，所以没有对这个intent进行额外的操作，这个Intent和刚刚的PendingIntent模板组合就能启动Activity了 ，另外如果要实现View的onClickListener的效果则需要使用PendingIntent.getBroadcast来设置模板，并且在getViewAt创建的Intent中传入具体的ACTION，后面就和刚刚的UpdateService是一个套路了</li>
</ul>
<pre><code>public class RemoteService extends RemoteViewsService {


private static final String TAG = &quot;RemoteService&quot;;


@Override
public void onCreate() {
super.onCreate();
Log.d(TAG, &quot;onCreate: &quot;);
}

@Override
public IBinder onBind(Intent intent) {
return super.onBind(intent);
}

@Override
public RemoteViewsFactory onGetViewFactory(Intent intent) {
return new RemoteFactory();
}

public class RemoteFactory implements RemoteViewsService.RemoteViewsFactory {

public List&lt;Integer&gt; mDataList = new ArrayList&lt;&gt;();


public RemoteFactory() {
    for (int i = 0; i &lt; 20; i++) {
        mDataList.add(i);
    }
    Log.d(TAG, &quot;onCreate: &quot;);
}

private static final String TAG = &quot;RemoteFactory&quot;;

@Override
public void onCreate() {

}

@Override
public void onDataSetChanged() {

}

@Override
public void onDestroy() {

}

@Override
public int getCount() {
    return mDataList.size();
}

@Override
public RemoteViews getViewAt(int position) {

    if (position &lt; 0 || position &gt; mDataList.size())
        return null;

    Intent intent = new Intent();
    RemoteViews remoteViews = new RemoteViews(CurriculumApplication.getContext().getPackageName(), R.layout.item_lv_course);
    remoteViews.setTextViewText(R.id.widget_tv_course, mDataList.get(position) + &quot;&quot;);
    remoteViews.setOnClickFillInIntent(R.id.item_lv_course,intent);

    return remoteViews;
}

@Override
public RemoteViews getLoadingView() {
    return null;
}

@Override
public int getViewTypeCount() {
    return 1;
}

@Override
public long getItemId(int position) {
    return position;
}

@Override
public boolean hasStableIds() {
    return true;
}

}
}
</code></pre><ul>
<li>最后注意非常重要的一点，既然RemoteViewService是Service，那么就必须注册，其中permission是一定要设置的，否则这个Service无法启动，这种情况下是不会有异常的，但是ListView等子控件将无法显示</li>
</ul>
<pre><code>&lt;service
    android:name=&quot;.widget.RemoteService&quot;
    android:permission=&quot;android.permission.BIND_REMOTEVIEWS&quot;
    android:enabled=&quot;true&quot;
    android:exported=&quot;true&quot; &gt;
&lt;/service&gt;
</code></pre><h3 id="RemoteViews"><a href="#RemoteViews" class="headerlink" title="RemoteViews"></a>RemoteViews</h3><ul>
<li>现在，我们来研究RemoteView是怎么更新的，我们知道需要更新RemoteViews中的控件时，由于我们获取不到需要的View，所以应该通过RemoteViews的方法来实现更新，比如下面的setImageViewBitmap方法对应的就是ImageView的setBitmap方法</li>
</ul>
<pre><code>remoteViews.setImageViewBitmap()    
</code></pre><ul>
<li>setImageViewBitmap调用setBitmap在第二个参数中传入了方法名，这个方法名是为了后面通过反射调用控件的方法而准备的，RemoteViews的Action表示我们想要对控件进行的操作，RemoteView会通过Binder传到Launcher的线程执行这些操作，从BitmapReflectionAction的名字很容易看出它使用了反射机制</li>
</ul>
<pre><code>public void setImageViewBitmap(int viewId, Bitmap bitmap) {
setBitmap(viewId, &quot;setImageBitmap&quot;, bitmap);
}

public void setBitmap(int viewId, String methodName, Bitmap value) {
addAction(new BitmapReflectionAction(viewId, methodName, value));
}
</code></pre><ul>
<li>接着来看RemoteViews的apply方法，这个方法通过LayoutInflater获取到了我们的AppWidget的布局，有了布局就可以进行更新操作了</li>
</ul>
<pre><code>public View apply(Context context, ViewGroup parent, OnClickHandler handler) {
RemoteViews rvToApply = getRemoteViewsToApply(context);

View result = inflateView(context, rvToApply, parent);
loadTransitionOverride(context, handler);

rvToApply.performApply(result, parent, handler);

return result;
}


private View inflateView(Context context, RemoteViews rv, ViewGroup parent) {
    LayoutInflater inflater = (LayoutInflater)

    ...
        context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);

// Clone inflater so we load resources from correct context and
// we don&apos;t add a filter to the static version returned by getSystemService.
inflater = inflater.cloneInContext(inflationContext);
inflater.setFilter(this);
View v = inflater.inflate(rv.getLayoutId(), parent, false);
v.setTagInternal(R.id.widget_frame, rv.getLayoutId());
return v;
}
</code></pre><ul>
<li>performApply遍历了所有的Action，执行其apply方法，在ReflectionAction中apply方法使用findViewById得到需要更新的布局，findViewById返回的是一个View，这里我们并不知道需要更新的View的具体类型，由于之前传入了方法名所以这里通过反射获取到了需要使用的方法并直接调用，理论上也可以通过使用instanceOf关键字然后再用类型转换来实现，实际setRemoteAdapter的apply方法就是这么做的，但是如果对于所有的View都使用instanceOf，RemoteViews支持的View一共有十几种，相比之下还是使用反射会更加简洁易维护</li>
</ul>
<pre><code>private void performApply(View v, ViewGroup parent, OnClickHandler handler) {
if (mActions != null) {
    handler = handler == null ? DEFAULT_ON_CLICK_HANDLER : handler;
    final int count = mActions.size();
    for (int i = 0; i &lt; count; i++) {
        Action a = mActions.get(i);
        a.apply(v, parent, handler);
    }
}
}   

           @Override
public void apply(View root, ViewGroup rootParent, OnClickHandler handler) {
    final View view = root.findViewById(viewId);
    if (view == null) return;

    Class&lt;?&gt; param = getParameterType();
    if (param == null) {
        throw new ActionException(&quot;bad type: &quot; + this.type);
    }

    try {
        getMethod(view, this.methodName, param).invoke(view, wrapArg(this.value));
    } catch (ActionException e) {
        throw e;
    } catch (Exception ex) {
        throw new ActionException(ex);
    }
}
</code></pre><h3 id="AppWidget-与-binder"><a href="#AppWidget-与-binder" class="headerlink" title="AppWidget 与 binder"></a>AppWidget 与 binder</h3><ul>
<li>AppWidget是利用binder机制实现的，那么就来看看binder接口是怎么实现的，由于部分代码属于internal包，在Android Studio上可能无法查看，可以选择查看<a href="http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/5.1.1_r1/com/android/server/SystemService.java#SystemService.publishBinderService(java.lang.String,android.os.IBinder)" target="_blank" rel="external">这里</a>，如果有更方便的办法，请告诉我</li>
<li>这里先讲解一下Luncher 是什么，为此首先明确一点，Android系统上所谓的桌面本身也是一个应用，这个系统应用我们管他叫启动器或者Luncher，更准确地说Luncher其实是一个Activity，我们的桌面的主视图是一个继承自PagedView的Workspace，每一页就是一个CellLayout，看看下面这一段，是不是觉得很熟悉？</li>
</ul>
<pre><code>public final class Launcher extends Activity implements View.OnClickListener, OnLongClickListener 
</code></pre><ul>
<li>我们知道Activity默认运行在Application指定的进程中，Launcher的Manifest文件我就懒得翻源码了，有需要可以看<a href="http://quanminchaoren.iteye.com/blog/898647" target="_blank" rel="external">这里</a></li>
</ul>
<ul>
<li>刚刚提到 AppWidgetManager 是在SystemServer进程中的，那么加上我们的自己应用的进程和Launcher所在的进程RemoteView就需要在三个进程之间传递，在一个应用中更新另一个应用的Activity，是不是很刺激？</li>
</ul>
<ul>
<li>在需要更新AppWidget时，我们调用了AppWidgetManager.updateAppWidget方法，查看下列源码，调用到了mService的同名方法，而这个mService 的类型是<a href="\* [IAppWidgetService][3]">IAppWidgetService</a>，源码很长，我就不贴出来了，用过AIDL的应该会觉得很熟悉，和我们AS生成的 **AIDL.java的结构是一致的，mServie就是一个binder的代理（Proxy）类，调用它的方法会走Transaction过程，那么我们调用的方法最终就会在AppWidgetManager所在的进程中也就是SystemServer的进程中被调用了</li>
</ul>
<pre><code>public void updateAppWidget(int[] appWidgetIds, RemoteViews views) {
if (mService == null) {
    return;
}
try {
    mService.updateAppWidgetIds(mPackageName, appWidgetIds, views);
} catch (RemoteException e) {
    throw e.rethrowFromSystemServer();
}
}
</code></pre><ul>
<li>看完了Proxy，当然就轮到我们的Binder类了，Binder的实现类为AppWidgetServiceImpl，这里忽略一部分代码，这里主要是通过传入的id拿到了widget对象，widget对象是对每个appWidget的封装，结构很简单</li>
</ul>
<pre><code>private void updateAppWidgetIds(String callingPackage, int[] appWidgetIds,
    RemoteViews views, boolean partially) {
    ...
    synchronized (mLock) {
    ensureGroupStateLoadedLocked(userId);

    final int N = appWidgetIds.length;
    for (int i = 0; i &lt; N; i++) {
        final int appWidgetId = appWidgetIds[i];

        // NOTE: The lookup is enforcing security across users by making
        // sure the caller can only access widgets it hosts or provides.
        Widget widget = lookupWidgetLocked(appWidgetId,
                Binder.getCallingUid(), callingPackage);

        if (widget != null) {
            updateAppWidgetInstanceLocked(widget, views, partially);
        }
    }
}
}


    private static final class Widget {
int appWidgetId;
int restoredId;  // tracking &amp; remapping any restored state
Provider provider;
RemoteViews views;
Bundle options;
Host host;

@Override
public String toString() {
    return &quot;AppWidgetId{&quot; + appWidgetId + &apos;:&apos; + host + &apos;:&apos; + provider + &apos;}&apos;;
}
}
</code></pre><ul>
<li>找到 Widget之后会调用 updateAppWidgetInstanceLocked来进行更新,这里将Widget进行拆解之后使用Handler了回到了主线程</li>
</ul>
<pre><code>    private void updateAppWidgetInstanceLocked(Widget widget, RemoteViews views,
    boolean isPartialUpdate) {
if (widget != null &amp;&amp; widget.provider != null
        &amp;&amp; !widget.provider.zombie &amp;&amp; !widget.host.zombie) {

    if (isPartialUpdate &amp;&amp; widget.views != null) {
        // For a partial update, we merge the new RemoteViews with the old.
        widget.views.mergeRemoteViews(views);
    } else {
        // For a full update we replace the RemoteViews completely.
        widget.views = views;
    }

    scheduleNotifyUpdateAppWidgetLocked(widget, views);
}
}


    private void scheduleNotifyUpdateAppWidgetLocked(Widget widget, RemoteViews updateViews) {
if (widget == null || widget.provider == null || widget.provider.zombie
        || widget.host.callbacks == null || widget.host.zombie) {
    return;
}

SomeArgs args = SomeArgs.obtain();
args.arg1 = widget.host;
args.arg2 = widget.host.callbacks;
args.arg3 = updateViews;
args.argi1 = widget.appWidgetId;

mCallbackHandler.obtainMessage(
        CallbackHandler.MSG_NOTIFY_UPDATE_APP_WIDGET,
        args).sendToTarget();
}
</code></pre><ul>
<li>handleMessage中会调用到了handleNotifyUpdateAppWidget，这个callBack即是IAppWidgetHost，IAppWidgetHost又是一个Proxy类，这里我们就进入了另一个Binder机制了，这一个Binder用于与远程的Launcher进行通讯，同样地我们需要找到Binder的实现类</li>
</ul>
<pre><code>private void handleNotifyUpdateAppWidget(Host host, IAppWidgetHost callbacks,
    int appWidgetId, RemoteViews views) {
try {
    callbacks.updateAppWidget(appWidgetId, views);
} catch (RemoteException re) {
    synchronized (mLock) {
        Slog.e(TAG, &quot;Widget host dead: &quot; + host.id, re);
        host.callbacks = null;
    }
}
}
</code></pre><ul>
<li>Launcher这个Activity中含有LauncherAppWidgetHost对象这个类继承自AppWidgetHost，AppWidgetHost中含有Binder的实现类Callbacks</li>
</ul>
<pre><code>public final class Launcher extends Activity
implements View.OnClickListener, OnLongClickListener, LauncherModel.Callbacks,
           View.OnTouchListener {
           ...
private LauncherAppWidgetHost mAppWidgetHost;
</code></pre><ul>
<li>这里使用Handler回到主线程，接下来自然是Launcher这个Activity要更新界面了</li>
</ul>
<pre><code>static class Callbacks extends IAppWidgetHost.Stub {
private final WeakReference&lt;Handler&gt; mWeakHandler;

public Callbacks(Handler handler) {
    mWeakHandler = new WeakReference&lt;&gt;(handler);
}

public void updateAppWidget(int appWidgetId, RemoteViews views) {
    if (isLocalBinder() &amp;&amp; views != null) {
        views = views.clone();
    }
    Handler handler = mWeakHandler.get();
    if (handler == null) {
        return;
    }
    Message msg = handler.obtainMessage(HANDLE_UPDATE, appWidgetId, 0, views);
    msg.sendToTarget();
}
</code></pre><ul>
<li>updateAppWidgetView中的applyRemoteViews其实就是调用RemoteViews的Apply方法，也就是我们刚刚提到的根据反射去得到View的具体方法然后调用，这样我们的界面就在Launcher上面更新了</li>
</ul>
<pre><code>void updateAppWidgetView(int appWidgetId, RemoteViews views) {
AppWidgetHostView v;
synchronized (mViews) {
    v = mViews.get(appWidgetId);
}
if (v != null) {
    v.updateAppWidget(views);
}
}


public void updateAppWidget(RemoteViews remoteViews) {
applyRemoteViews(remoteViews);
}
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Bug 合集]]></title>
      <url>/2017/09/06/BUG/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><strong>不定期收录自己遇到的一些问题和解决方案，希望不要日更</strong></p>
<h2 id="2017-09-07-Android-Studio-无法添加远程依赖"><a href="#2017-09-07-Android-Studio-无法添加远程依赖" class="headerlink" title="2017.09.07 - Android Studio 无法添加远程依赖"></a>2017.09.07 - Android Studio 无法添加远程依赖</h2><ul>
<li>不知道从什么时候开始无法添加远程依赖，因为之前没有用的新的库所以一直没有察觉，添加远程依赖时会出现如下错误，似乎是下载时出错了，用了梯子也没有解决，并且在Chrome中打开Gradle Console里面的链接发现可以下载到pom文件</li>
</ul>
<pre><code>Error:(50, 17) Failed to resolve: ...
</code></pre><ul>
<li>根据网上的文章在 Android Studio 的HTTP Proxy 中勾选 No Proxy，在Builder Tools -> Gradle 中取消Offline work …然并卵，本来就是这么配置的</li>
</ul>
<ul>
<li>试了很多解决方案后，发现只需要在project的build.gradle 中添加阿里云的maven仓库即可</li>
</ul>
<pre><code>allprojects {
    repositories {
        jcenter()
     maven{ url &apos;http://maven.aliyun.com/nexus/content/groups/public/&apos;}
    }
}
</code></pre><h2 id="2017-09-07-RemoteViewsService-无法启动-amp-amp-RemoteViews-无法定时更新"><a href="#2017-09-07-RemoteViewsService-无法启动-amp-amp-RemoteViews-无法定时更新" class="headerlink" title="2017.09.07 - RemoteViewsService 无法启动 &amp;&amp; RemoteViews 无法定时更新"></a>2017.09.07 - RemoteViewsService 无法启动 &amp;&amp; RemoteViews 无法定时更新</h2><ul>
<li>在manifest文件中需要注明 RemoteViewsService 的权限，缺少 android:permission 属性 该类service将无法启动</li>
</ul>
<pre><code>&lt;service
    android:name=&quot;.widget.RemoteService&quot;
    android:permission=&quot;android.permission.BIND_REMOTEVIEWS&quot;
    android:enabled=&quot;true&quot;
    android:exported=&quot;true&quot; &gt;
&lt;/service&gt;
</code></pre><ul>
<li>1.6以后 updatePeriodMillis 属性少于30分钟时，会被系统直接设定为30分钟，为实现定时效果可以使用计时器</li>
</ul>
<pre><code>public class UpdateService extends Service{

private Timer mTimer;
private TimerTask mTimerTask;
public static final int UPDATE_TIME = 1000;
public static final String ACTION_UPDATE = &quot;com.linjiamin.UPDATE&quot;;

@Override
public int onStartCommand(Intent intent, int flags, int startId) {
return super.onStartCommand(intent, flags, startId);
}

@Nullable
@Override
public IBinder onBind(Intent intent) {
return null;
}

private static final String TAG = &quot;UpdateService&quot;;

@Override
public void onCreate() {
super.onCreate();

Log.d(TAG, &quot;onCreate: &quot;);
mTimer = new Timer();
mTimerTask = new TimerTask() {
    @Override
    public void run() {
        Intent updateIntent = new Intent(ACTION_UPDATE);
        sendBroadcast(updateIntent);
    }
};
//mTimer.schedule(mTimerTask, 1000, UPDATE_TIME);
}
}
</code></pre><ul>
<li>重写 AppWidgetProvider 的 onReceive方法，接受由定时器发来的广播</li>
</ul>
<pre><code>@Override
public void onReceive(Context context, Intent intent) {
super.onReceive(context, intent);
if(intent.getAction().equals(UpdateService.ACTION_UPDATE)){
    Update(context);
    Log.d(TAG, &quot;onReceive: &quot;);
}
}
</code></pre><h2 id="2017-09-08-AIDL-报错-Error-错误-程序包-不存在"><a href="#2017-09-08-AIDL-报错-Error-错误-程序包-不存在" class="headerlink" title="2017.09.08 - AIDL 报错 : Error:(   * , * ) 错误: 程序包 ** 不存在"></a>2017.09.08 - AIDL 报错 : Error:(   * , * ) 错误: 程序包 ** 不存在</h2><ul>
<li>使用自定义类型时，该类型的文件在aidl和java包中的路径必须一致，如果包结构不同，请创建相应的包以补全路径</li>
</ul>
<ul>
<li>注意java文件不能放在aidl包下</li>
</ul>
<h2 id="2017-09-22-ViewPager加载图片缓慢"><a href="#2017-09-22-ViewPager加载图片缓慢" class="headerlink" title="2017.09.22 - ViewPager加载图片缓慢"></a>2017.09.22 - ViewPager加载图片缓慢</h2><ul>
<li><p>使用ViewPager时加载图片速度很慢，原本以为是图片太大，后来发现是解析耗时太多</p>
</li>
<li><p>如果Item是动态创建的，建议设定通过LayoutParams设定的宽度或高度，如果使用布局文件应尽量减少布局层次，可以的情况下请尽量使用 Exactly模式</p>
</li>
<li><p>使用Picasso时发现 ImageView 的 scaleType 属性使用FitXY 时解析耗时远大于 CenterCrop</p>
</li>
</ul>
<h2 id="2017-10-06-Parcelable-包装类-NullPointerException"><a href="#2017-10-06-Parcelable-包装类-NullPointerException" class="headerlink" title="2017.10.06 - Parcelable 包装类 NullPointerException"></a>2017.10.06 - Parcelable 包装类 NullPointerException</h2><ul>
<li>使用快捷键实现Parcelable接口可能会遇上这个坑</li>
<li>自动生成代码可能不会（至少本人使用的AS版本不会，算是个Bug）为包装类生成调用Parcel的read和writer代码，请注意检查</li>
<li>我们知道包装类没有默认的初始值（准确地说，初始值为null），因此writeToParcel可能抛出NullPointerException，一般情况下使用 Long long = 0L 这种形式为类属性赋初值即可</li>
<li>特殊情况下，例如使用Gson这种会修改类属性的工具需要特别注意，在Gson的情况下，没有解析到的类属性为null，请考虑在writeToParcel，构造器或使用Gson的地方进行检查</li>
</ul>
<h2 id="2018-02-XX-横向-RecycleView-高度-wrap-content-时显示空白"><a href="#2018-02-XX-横向-RecycleView-高度-wrap-content-时显示空白" class="headerlink" title="2018.02.XX - 横向 RecycleView 高度 wrap_content 时显示空白"></a>2018.02.XX - 横向 RecycleView 高度 wrap_content 时显示空白</h2><ul>
<li>onBindViewHolder执行但是视图空白</li>
<li>网上出现这种情况一般是RecycleView外套了一层ScrollView，改用NestedScrollView可以解决问题</li>
<li>在其他复杂布局中也可能出现这种情况，具体原因不清楚，但是在RecycleView外再套一层LinearLayout，并将这个LinearLayout的宽高指定得跟RecycleView完全一致，可以解决问题</li>
</ul>
<h2 id="2018-02-XX-GreenDao-获取数据不正常"><a href="#2018-02-XX-GreenDao-获取数据不正常" class="headerlink" title="2018.02.XX - GreenDao 获取数据不正常"></a>2018.02.XX - GreenDao 获取数据不正常</h2><ul>
<li>GreenDao中，对同一个dao进行删除和查询操作，得出结果可能与数据库中的不同，可能是内部缓存的问题，调用XXXdao.detachAll可以清楚缓存</li>
<li>在某种情况下，也可能出现清理缓存后仍然获取不到正确数据的情况，具体原因不清楚</li>
</ul>
<h2 id="2018-02-XX-Intent-隐式跳转系统应用无法识别-mimeType"><a href="#2018-02-XX-Intent-隐式跳转系统应用无法识别-mimeType" class="headerlink" title="2018.02.XX - Intent 隐式跳转系统应用无法识别 mimeType"></a>2018.02.XX - Intent 隐式跳转系统应用无法识别 mimeType</h2><ul>
<li><p>在小米和某些系统的手机下直接使用文件路径作为跳转的data会出现无法弹出匹配的应用供选择的情况，应该是国内厂商改系统造成的</p>
</li>
<li><p>uri类型一般可以正常使用，即content://开头的类型</p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> error </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[GC 基础知识]]></title>
      <url>/2017/08/14/GC/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><br></p>
<h3 id="JVM内存组成"><a href="#JVM内存组成" class="headerlink" title="JVM内存组成"></a>JVM内存组成</h3><ul>
<li>java的内存结构分为三大块，堆空间，方法区，栈</li>
<li>在环境变量或Eclipse等集成环境的设置选项或配置文件中可以设置JVM的内存分配大小</li>
</ul>
<pre><code>-XX:newSize：表示新生代初始内存的大小，应该小于 -Xms的值
-XX:MaxnewSize：表示新生代可被分配的内存的最大上限，应该小于 -Xmx的值
-Xmn：同时配置 -XX:newSize，-XX:MaxnewSize，使-XX:newSize = -XX:MaxnewSize = -Xmn，JDK1.4版本可用
-XX:PermSize：表示非堆区permanent 初始内存分配
-XX:MaxPermSize：表示对非堆区分配的最大内存
</code></pre><p><br></p>
<h3 id="堆区与GC"><a href="#堆区与GC" class="headerlink" title="堆区与GC"></a>堆区与GC</h3><ul>
<li>通常来说，堆Heap是Java虚拟机管理内存中最大的一块，是垃圾回收器管理的主要区域，因此也被称为GC堆</li>
<li>GC机制通常基于以下两个前提实现，Sun推出的HotSpot虚拟机中将堆中的对象分为两类，新生代和老生代，分别对应以下两者</li>
</ul>
<pre><code>大多数对象会很快变得不可达
只有很少的由创建时间较长的对象指向的新对象的引用
</code></pre><ul>
<li>生代仅仅只是一种实现，例如Dalvik使用的是不分代的标记清除算法</li>
</ul>
<p><br>   </p>
<h4 id="新生代-Young-generation"><a href="#新生代-Young-generation" class="headerlink" title="新生代 Young generation"></a>新生代 Young generation</h4><ul>
<li>绝大多数刚创建的对象会被分配到这里，然后变得不可达并被回收，这个区域的垃圾回收称为Minor GC</li>
</ul>
<ul>
<li>新生代又被分为Eden区和Survivor区，Survivor区又由两个相同大小并且不断互换身份的分区组成，在同一时刻将两者称为FromSpace和ToSpace</li>
</ul>
<ul>
<li>当创建对象时 JVM会为对象在Eden区划分内存区域，在初始状态之后，如果Eden空间足够则操作结束，否则触发第一次GC，回收Eden中的不可达对象，并将Eden区中存活的对象放入FromSpace区，操作结束。之后创建对象时如果Eden区再次不足，GC会清空Eden区和FromSpace区的所有不可达对象，并将存活的对象转移到ToSpace区，并且清空FromSpace，分区完成互换</li>
</ul>
<ul>
<li>当Eden区和FromSpace区的存活对象向ToSpace区转移时，存活次数超过一定值的对象会被转移到Old generation，另外如果ToSpace区空间不足，无法存放的对象也会被同时转移</li>
</ul>
<p><br></p>
<h4 id="老生代-Old-generation"><a href="#老生代-Old-generation" class="headerlink" title="老生代 Old generation"></a>老生代 Old generation</h4><ul>
<li>多次存活的对象会被放置到这里，Old generation一般在空间不足时发生GC，只清理该区域的GC被称为Major GC</li>
<li>如果GC之后仍发现空间不足则会出现Out of memory异常</li>
</ul>
<p><br></p>
<h3 id="方法区与GC"><a href="#方法区与GC" class="headerlink" title="方法区与GC"></a>方法区与GC</h3><p><br></p>
<h4 id="告别永久代"><a href="#告别永久代" class="headerlink" title="告别永久代"></a>告别永久代</h4><ul>
<li>方法区常常被称为永久代，但实际上只有HotSpot的虚拟机实现将方法区划入了永久代，并且在很长一段时间内强调永久代的概念，JDK 6开始HotSpot自己也开始计划取消永久代，在JDK 8 中永久代终于被元空间所取代</li>
</ul>
<ul>
<li>方法区用于存放各个线程之间共享的信息，包括被加载的类的信息，final常量，静态变量，编译器即使编译的代码等，方法区不需要时连续的，并且可以设定大小</li>
</ul>
<ul>
<li>方法区之所以被称为永久区是由于方法区可以通过-Xnoclassgc 选择是否进行垃圾收集，而且这种垃圾收集通常由于条件严苛，执行的机会较少</li>
</ul>
<ul>
<li>方法区GC主要回收常量与无用类，包括字面量，类，接口，方法，字段的符号引用等，无用类必须满足三个条件，没有该类的任何实例存在，加载该类的ClassLoader已经被回收，该类的Class对象不可达从而无法在任何地方访问该类的方法</li>
</ul>
<p><br></p>
<h4 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h4><ul>
<li>类所拥有的类信息被称为元数据，包括如类的层级信息，方法数据和方法信息（如字节码，栈和变量大小），运行时常量池，已确定的符号引用和虚方法表</li>
<li>永久代的设计存在一定的缺陷，由于其大小和是否GC都是可选的，这意味着永久代很有可能内存不足抛出OOM异常</li>
<li>每一个类加载器的储存空间都是一个元空间，所有的元空间加在一起就是我们所说的元空间，一个类的元空间的生命周期和它的类加载器的生命周期相同，虚拟机中存在一个全局的空闲组块列表，当类加载器需要空间时会从这个列表中申请用以储存元信息，当类加载器不再存活，将会返回这部分内存给列表 </li>
</ul>
<p><br></p>
<h3 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h3><p><br></p>
<h4 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h4><ul>
<li>标记阶段，从根对象对开始遍历，为所有可以访问的对象打上标记</li>
<li>清除阶段，从堆内存开始线性遍历，回收所有没有被标记的对象</li>
<li>这种算法会产生内存碎片，并且效率不高</li>
</ul>
<p><br></p>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><ul>
<li>新生代采用的算法，只处理正在使用的对象，将其转移到另一区域并将原来的区域清空</li>
<li>不会产生内存碎片，效率较高，但是比较占用内存</li>
</ul>
<p><br></p>
<h4 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h4><ul>
<li>在标记阶段之后不直接对可回收对象进行清理，而是将所有标记对象向一段移动然后清理</li>
</ul>
<p><br></p>
<h3 id="Dalvik-GC"><a href="#Dalvik-GC" class="headerlink" title="Dalvik GC"></a>Dalvik GC</h3><ul>
<li>Dalvik的堆结构不同于常见的JVM的堆结构，Dalvik将堆分为Active堆和Zygote堆，Zygote堆主要保留预加载的类、资源和对象，其余对象都存放在Active堆，Dalvik虚拟机进行部分垃圾收集时，实际上就是只收集在Active堆上分配的对象</li>
<li>Dalvik使用的是标记清除算法，在标记阶段使用两个Bitmap来描述对象，一个为Live Bitmap，另一个为Mark Bitmap，前者标记上一次GC时被引用的对象，后者标记当前GC被引用的对象。被Live Bitmap标记，但不被Mark Bitmap标记的对象会被回收</li>
<li>标记阶段分为两个子阶段，第一个子阶段只负责标记根对象，也就是GC开始瞬间被全局变量，栈变量和寄存器变量引用的对象，这个阶段除了垃圾回收线程之外的线程全部被挂起，第二个子阶段会对所有被根对象直接或间接引用的对象，这个阶段允许其他线程执行</li>
<li>清除Dalvik同样需要挂起所有线程，同时Dalvik的标记清除算法会导致内存碎片化严重，寻址困难，所以GC会带来明显的卡顿</li>
</ul>
<p><br></p>
<h3 id="ART-GC"><a href="#ART-GC" class="headerlink" title="ART GC"></a>ART GC</h3><ul>
<li>ART的堆被分为四个部分Image Space、Zygote Space、Allocation Space和Large Object Space，其中Allocation Space和Large Object Space和Dalvik虚拟机的Zygote堆和Active堆作用是一样的，Large Object Space是离散地址的集合，用来分配大的对象，Image Space永远不需要回收</li>
</ul>
<ul>
<li>ART对Dalvik的GC算法进行了改进，只在回收对象时暂停所有线程一次，并且ART采用力度从小到大的垃圾回收策略，例如Sticky Mark Sweep的垃圾回收只会回收Allocation Stack的垃圾，Partial Mark Sweep只会同时回收Allocation Space和Large Object Space的垃圾</li>
</ul>
<ul>
<li>在垃圾回收之后ART会将不连续的物理内存对齐以解决碎片化的问题</li>
</ul>
<p><br>   </p>
<h3 id="GC-root"><a href="#GC-root" class="headerlink" title="GC root"></a>GC root</h3><ul>
<li>GC root就是所有根对象的引用的集合，GC root是遍历的起点，所有没有被遍历到的对象会被判断为死亡，随后被GC回收</li>
</ul>
<ul>
<li>原本GC root应该包含如下部分</li>
</ul>
<pre><code>Class 由系统类加载器加载的对象，这些类是不能够被回收的，他们可以以静态字段的方式保存持有其它对象
Thread  活着的线程
Stack Local Java方法的local变量或参数
JNI Local JNI方法的local变量或参数
JNI Global 全局JNI引用
Monitor Used 用于同步的监控对象
Held by JVM 用于JVM特殊目的由GC保留的对象
</code></pre><ul>
<li>上面分代式的GC所定义的GC root有部分不同，分代式GC采用部分搜集的做法，并不是完全的遍历，所以分代式GC中非收集部分指向收集部分的引用也应该作为GC root的一部分例如minor GC只收集Young Generation的对象，那么从 Old generation指向Young Generation的引用就属于GC root</li>
</ul>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java泛型 注意事项]]></title>
      <url>/2017/08/14/TypeErasue/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<h2 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h2><p><strong>避免代码膨胀的泛型实现</strong></p>
<ul>
<li>JVM 中不存在泛型，所有的对象都属于普通类，Java通过泛型擦除让泛型实例能够使用一份适应不同类型的字节码，而不需要为每一个泛型实例创建不同的字节码</li>
</ul>
<ul>
<li>泛型擦除的基本逻辑是将类型参数替换为原始类型，例如类Test<t>中类型参数T会被替换为Object，如果泛型中含有限定类型，则会把第一个限定类型作为原始类型，如\<t extends="" comparable="" &="" serializable\=""> 中的类型参数T 会被替换为 Comparable。泛型擦除的各种细节将在下面提及</t></t></li>
</ul>
<ul>
<li>当我们使用泛型方法时，由于类型擦除，编译器会自动为我们进行强制类型转换，确保泛型在一般情况下能达到其设计的初衷</li>
</ul>
<h2 id="桥方法"><a href="#桥方法" class="headerlink" title="桥方法"></a>桥方法</h2><ul>
<li>由于泛型擦除，方法中的类型参数被替换为原始类型，编译器需要避免重写被错误变为重载的问题，例如下面这段代码，子类想要重写父类的test(T t)方法，在当前指明了类型参数的情况下也可以说是test(String str)方法，但是由于这里的父类的T会被替换为Object，因此子类的test(String str)无法重写父类的方法</li>
</ul>
<pre><code>public class Father&lt;T&gt;{

public void test(T t){
//do something
    }
}


public class Son extends  Father&lt;String&gt;{

public void test(String str){
//do something
    }
}
</code></pre><ul>
<li>为了解决这个问题，编译器会自动生成桥方法，当调用test方法时，会调用生成的test(Object t)桥方法，该方法将参数进行强制类型转换后调用我们实现的方法，这样就产生了覆盖的效果</li>
</ul>
<pre><code>public void test(Object t){
    test((String) t)
}  
</code></pre><ul>
<li>不过桥方法会产生一种奇怪的效果，我们知道方法签名由方法名和参数类型组成，不包括返回类型，并且方法签名不能被多个方法共用，也就是说我们不能编写如下的代码，但是如果在父类中含有T get()方法时，编译器为我们自动生成Object get()桥方法却能够通过编译并解决泛型擦除带来的问题。其实这是因为JVM通过参数类型和返回类型确定一个方法，JVM可以处理仅有返回类型不同的方法</li>
</ul>
<pre><code>public String get(){
    //do something
};

public Object get(){
    //do something
};
</code></pre><h2 id="正确使用泛型"><a href="#正确使用泛型" class="headerlink" title="正确使用泛型"></a>正确使用泛型</h2><h3 id="不能使用类型参数实例化类型参数"><a href="#不能使用类型参数实例化类型参数" class="headerlink" title="不能使用类型参数实例化类型参数"></a>不能使用类型参数实例化类型参数</h3><ul>
<li>不能使用 Pair&lt; double &gt; 来实例化类型参数，这是由于泛型擦除后类型参数将变为Object或Object的子类，显然使用基本类型会造成类型不匹配</li>
</ul>
<ul>
<li>这种情况下应该使用包装类型或其它的类</li>
</ul>
<h3 id="运行时类型查询只适用于原始类型"><a href="#运行时类型查询只适用于原始类型" class="headerlink" title="运行时类型查询只适用于原始类型"></a>运行时类型查询只适用于原始类型</h3><ul>
<li>instanceof 只能查询是否为原始类型，若使用instanceof查询某个对象是否为某个泛型类型时编译不会通过</li>
</ul>
<h3 id="不能创建参数化类型的数组"><a href="#不能创建参数化类型的数组" class="headerlink" title="不能创建参数化类型的数组"></a>不能创建参数化类型的数组</h3><ul>
<li>假定参数化类型的数组可以创建，那么 Pair&lt; String &gt;[ ] 在类型擦除后相当于Pair[]，可以将其转换为Objec[]类型，这时数组的类型检查机制将会失效，因为数组只能保证它当中存储的是Pair对象，但是 Pair&lt; String &gt;，Pair&lt; Double &gt;，Pair&lt; Integer &gt;显然是不同的类型，出于这个原因如果new了参数化类型的数组将不能通过编译</li>
</ul>
<ul>
<li>我们应该考虑使用ArrayList等支持泛型的容器来存放参数化类型的对象</li>
</ul>
<h3 id="不能实例化类型变量"><a href="#不能实例化类型变量" class="headerlink" title="不能实例化类型变量"></a>不能实例化类型变量</h3><ul>
<li>不要使用 new T()这样的方法实例化类型变量，这是不能通过编译的，泛型擦除后，它就相当于new Object()，new Object()显然没有什么意义</li>
</ul>
<ul>
<li>在java 8 中可以使用Lambda解决这个问题，Supplier&lt; T &gt;函数式接口返回一个T类型的实例</li>
</ul>
<pre><code>Pair&lt;String&gt; pair = Pair.makePair(String::new);

public class Pair&lt;T&gt;{

        T t1;
        T t2;

public Pair(T t1, T t2){
    this.t1 = t1;
    this.t2 = t2;

}

public static &lt;T&gt;Pair&lt;T&gt; makePair(Supplier&lt;T&gt; constr){

    return new Pair&lt;&gt;(constr.get(),constr.get());

    }
}
</code></pre><ul>
<li>也可以使用反射来实现，注意不能直接使用 T.class.newInstance，这也相当于new一个原始类型，我们应该从外部传入Class对象</li>
</ul>
<pre><code>public static &lt;T&gt;Pair&lt;T&gt; makePair(Class&lt;T&gt; cl){

    try {
        return new Pair&lt;&gt;(cl.newInstance(),cl.newInstance());
    } catch (InstantiationException | IllegalAccessException e) {
        e.printStackTrace();
    }
    return null;
}   
</code></pre><h3 id="不要使用带有类型变量的静态域和方法"><a href="#不要使用带有类型变量的静态域和方法" class="headerlink" title="不要使用带有类型变量的静态域和方法"></a>不要使用带有类型变量的静态域和方法</h3><ul>
<li>由于类型擦除，所有传入的类型变量实际上只相当于原始类型，所有的静态变量都是共享的</li>
</ul>
<pre><code>public class Singleton&lt;T&gt;{
    private static T singleInstance;
    public static  T getSingleInstance(){
        if(singleInstance == null)
                construct new instanceof T

        return singleInstance;
    }
</code></pre><h3 id="不能抛出或者捕获泛型类的实例"><a href="#不能抛出或者捕获泛型类的实例" class="headerlink" title="不能抛出或者捕获泛型类的实例"></a>不能抛出或者捕获泛型类的实例</h3><ul>
<li>不能抛出或者捕获泛型类的实例，也不能使用泛型扩展Throwable，由于泛型擦拭，这里的T替换为Throwable，实际上失去了泛型的作用，因此编译不通过，另外通常来说处理异常需要有足够的运行时信息，因此也没有理由catch泛型的异常</li>
</ul>
<pre><code>    public static &lt;T extends Throwable&gt; void dowork(Class&lt;T&gt; t){
...
    catch(T e)
    }
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Loader 机制详解]]></title>
      <url>/2017/08/13/Loader/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<h2 id="什么是Loader"><a href="#什么是Loader" class="headerlink" title="什么是Loader"></a>什么是Loader</h2><p><img src="https://ws1.sinaimg.cn/large/987832a0gy1fiiicfa8ehj21fe0mstgh.jpg" alt=""></p>
<ul>
<li>写app最重要的一个部分就是与数据打交道，回顾我们平时处理数据的套路，通常我们在Activity启动或响应用户触摸事件时开启线程获取数据，然后通过Handler切换到主线程中更新UI，在这过程中还需要通过onSaveInstanceState保留数据，有时甚至还需要实时监控数据源更新数据</li>
<li>使用AsyncTask或者Thread + Handler 完全可以实现我们的需求，但是随着Task的增多，我们可能发现自己管理线程，UI，回调接口比较繁琐，而且不同的Task当中又有很多相似的操作</li>
<li>为了满足和解决以上的需求和问题，在Android 3.0中加入了LoaderManager，统一管理异步任务</li>
<li>学习如何使用Loader其实不是很重要的，一般我们只会在使用ContentProvider时用到Loader，最重要的是学习官方如何根据Activity和Fragment的生命周期管理数据，以及使用统一的接口传递数据</li>
</ul>
<h2 id="简单使用Loader"><a href="#简单使用Loader" class="headerlink" title="简单使用Loader"></a>简单使用Loader</h2><h3 id="AsyncTaskLoader"><a href="#AsyncTaskLoader" class="headerlink" title="AsyncTaskLoader"></a>AsyncTaskLoader</h3><ul>
<li>AsyncTaskLoader是一个对AsyncTask的封装，我们可以实现这个抽象类自定义Loader，它需要实现下面五个方法</li>
<li>public void deliverResult(D data)</li>
<li>protected D doInBackground(Void… params)    </li>
<li>protected void onStartLoading()</li>
<li>protected void onStopLoading()</li>
<li>protected void onReset()</li>
<li>通常我们不应该主动调用这几个方法以免扰乱Loader的生命周期</li>
</ul>
<h3 id="LoaderCallbacks"><a href="#LoaderCallbacks" class="headerlink" title="LoaderCallbacks"></a>LoaderCallbacks</h3><ul>
<li>LoaderCallbacks，这是与LoaderManager进行交互的接口，需要实现以下三个方法</li>
<li>public Loader<d> onCreateLoader(int id, Bundle args)</d></li>
<li>public void onLoadFinished(Loader<d> loader, D data)</d></li>
<li>public void onLoaderReset(Loader<d> loader)</d></li>
</ul>
<h3 id="使用自定义Loader"><a href="#使用自定义Loader" class="headerlink" title="使用自定义Loader"></a>使用自定义Loader</h3><ul>
<li>下面通过 AsyncTaskLoader 简单过一遍使用Loader的流程，将我们的数据类型定义为 List<dirinfo>，它是一个手机中所有含有图片的文件夹的信息的列表</dirinfo></li>
</ul>
<pre><code>public class MyLoader extends AsyncTaskLoader&lt;List&lt;DirInfo&gt;&gt; 
</code></pre><ul>
<li>onStartLoading，这个方法在主线程被调用，在这里开始获取我们的数据，通常来说有两种情况，如果我们的数据可缓存并且已经缓存，使用deliverResult()方法直接投递数据即可，如果需要开启线程异步加载数据则调用forceLoad()方法</li>
</ul>
<pre><code>protected void onStartLoading() {
if(mData != null)
    deliverResult(mData);
else 
    forceLoad();
}
</code></pre><ul>
<li>loadInBackground，相当于AsyncTask中的doInBackground，在这里进行耗时操作并返回所需的数据，具体的过程和主题无关就不讲解了</li>
</ul>
<pre><code> @Override
 public List&lt;DirInfo&gt; loadInBackground() {

 SparseArray&lt;DirInfo&gt; array = new SparseArray&lt;&gt;();

 ContentResolver resolver = mContext.getContentResolver();
 Cursor cursor;
 try{

     cursor = resolver.query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,new String[]{&quot;_id&quot;,&quot;_data&quot;,&quot;_display_name&quot;,&quot;bucket_id&quot;,&quot;bucket_display_name&quot;},null,null,&quot;_id desc&quot;);
     if(cursor!=null){

         DirInfo allPic = new DirInfo(ALL_PIC_ID,&quot;全部图片&quot;);
         array.put(ALL_PIC_ID,allPic);

         while (cursor.moveToNext()) {

             //图片对象
             int imageId = cursor.getInt(cursor.getColumnIndex(&quot;_id&quot;));
             String imageUrl = cursor.getString(cursor.getColumnIndex(&quot;_data&quot;));
             String imageName = cursor.getString(cursor.getColumnIndex(&quot;_display_name&quot;));
             ImageInfo imageInfo = new ImageInfo(imageId,imageName,imageUrl);
             allPic.addImageInfo(imageInfo);

             //文件夹对象
             DirInfo dirInfo;
             int dirId = cursor.getInt(cursor.getColumnIndex(&quot;bucket_id&quot;));
             String dirName = cursor.getString(cursor.getColumnIndex(&quot;bucket_display_name&quot;));

             if((dirInfo = array.get(dirId))==null) {

                 dirInfo = new DirInfo(dirId,dirName);
                 dirInfo.addImageInfo(imageInfo);
                 array.put(dirId,dirInfo);

             }else dirInfo.addImageInfo(imageInfo); //如果文件夹对象已创建，直接加入图片对象
         }
     }

     if(cursor!=null) cursor.close();

 }catch (Exception e){
     e.printStackTrace();
 }

 ArrayList&lt;DirInfo&gt; list = new ArrayList&lt;&gt;();
 list.add(array.get(ALL_PIC_ID));
 Log.d(TAG, &quot;loadInBackground: &quot;+array.get(ALL_PIC_ID).getImageList().size());
 array.remove(ALL_PIC_ID);

 //转换容器类型
 for(int i = 0;i&lt;array.size();i++){
     DirInfo dirInfo = array.get(array.keyAt(i));
     list.add(dirInfo);
 }

 return list;
}
</code></pre><ul>
<li>deliverResult，通过这个方法可以得到我们刚刚返回给LoaderManager的数据，根据实际需求在这里缓存我们的数据，之后如果没有必要，就无需重复加载了，可以参考一下<a href="https://stackoverflow.com/questions/25234581/what-does-asynctaskloader-deliverresult-actually-do" target="_blank" rel="external">StackOverflow</a>上面的建议</li>
</ul>
<pre><code>@Override
public void deliverResult(List&lt;DirInfo&gt; data) {
super.deliverResult(data);
mData = data;
}
</code></pre><ul>
<li>onStopLoading，当Activity或Fragment处于stop状态时会调用这个方法，通常在这个方法中使用 cancelLoad 终止正在执行的任务，注意这里只关乎当前的任务，当数据源变化时还是会再次加载数据的</li>
</ul>
<pre><code>@Override
protected void onStopLoading() {
cancelLoad();
} 
</code></pre><ul>
<li>onReset，执行这个方法之后LoaderManager会重新初始化Loader的所有标志位，通常在这里进行资源的释放</li>
</ul>
<pre><code>@Override
protected void onReset() {
super.onReset();
mData = null;
}
</code></pre><h3 id="实现-LoaderCallbacks"><a href="#实现-LoaderCallbacks" class="headerlink" title="实现 LoaderCallbacks"></a>实现 LoaderCallbacks</h3><ul>
<li>为了处理数据，需要实现LoaderCallbacks，下面在Activity中实现这个接口</li>
</ul>
<ul>
<li>onCreateLoader，该方法用于根据id返回我们的需要用到的Loader，args是在调用initLoader时我们传入的参数，可以用于存放一些必要的信息</li>
</ul>
<pre><code>@Override
public Loader&lt;List&lt;DirInfo&gt;&gt; onCreateLoader(int id, Bundle args) {
return new MyLoader(this);
}
</code></pre><ul>
<li>onLoadFinished，当数据加载完后会调用onLoadFinished方法，在这里可以更新UI</li>
</ul>
<pre><code>@Override
public void onLoadFinished(Loader&lt;List&lt;DirInfo&gt;&gt; loader, List&lt;DirInfo&gt; dataList) {

mPicAdapter.setDataList((dataList.get(0)).getImageList());
Log.d(TAG, &quot;onLoadFinished: &quot;+dataList.size());

}
</code></pre><ul>
<li>onLoaderReset，之前提到Loader的onReset方法会初始化Loader，这时onLoaderReset就会被调用，通常可以在该方法中将Activity，Fragment或Adapter中的数据置为null，如果使用了CursorLoader，这一步非常重要，Cursor被close之后会调用该方法，所以要确保在这里将数据置空，避免出现异常</li>
</ul>
<pre><code>@Override
public void onLoaderReset(Loader&lt;List&lt;DirInfo&gt;&gt; loader) {

}    
</code></pre><ul>
<li>在onCreate方法中调用initLoader开始获取数据            </li>
</ul>
<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);

initView();
getLoaderManager().initLoader(111,null,this);

}

public void initView() {

mRvPic = (RecyclerView)findViewById(R.id.rv_image);
mPicAdapter = new PicAdapter(mImageInfoList, this);
mRvPic.setLayoutManager(new LinearLayoutManager(this,LinearLayoutManager.VERTICAL,false));
mRvPic.addItemDecoration(new DividerItemDecoration(this,DividerItemDecoration.VERTICAL));
mRvPic.setAdapter(mPicAdapter);
mRvPic.setItemAnimator(new DefaultItemAnimator());

}       
</code></pre><h3 id="使用CursorLoader"><a href="#使用CursorLoader" class="headerlink" title="使用CursorLoader"></a>使用CursorLoader</h3><ul>
<li>Loader被用得最多的情况就是从ContentProvider中获取数据，如联系人列表，手机图片等等，Android提供了CursorLoader，顾名思义是对cursor和loader的封装，如果只需要得到手机中的数据，用CursorLoader来实现是非常方便的</li>
</ul>
<ul>
<li>在onCreateLoader方法中，根据不同的id调用CursorLoader的构造器得到Loader</li>
</ul>
<pre><code>@Override
public Loader&lt;Cursor&gt; onCreateLoader(int id, Bundle args) {

Log.d(TAG, &quot;onCreateLoader: &quot;);

switch (id){

    case IMAGE:
        return new CursorLoader(this, MediaStore.Images.Media.EXTERNAL_CONTENT_URI,new String[]{&quot;_id&quot;,&quot;_data&quot;},null,null,&quot;_id desc&quot;);

    case RESET_IMAGE:
        return new CursorLoader(this, MediaStore.Images.Media.EXTERNAL_CONTENT_URI,new String[]{&quot;_id&quot;,&quot;_data&quot;},null,null,&quot;_id asc&quot;);

    default:
        return null;
    }
} 
</code></pre><ul>
<li>每次数据源发生改变时就会重新获取cursor，在这个例子当中，我们在手机图库中删除一张图片然后回到这个应用时onLoadFinish就会被调用，说明我们自行处理数据源的变化</li>
</ul>
<pre><code>    @Override
    public void onLoadFinished(Loader&lt;Cursor&gt; loader, Cursor cursor) {

    switch (loader.getId()){

        case IMAGE:
        case RESET_IMAGE:

            mPicAdapter.swapCursor(cursor);
            break;

        default:
            Log.d(TAG, &quot;onLoadFinished: a Loader might be ignored&quot;);
            break;
    }
}

    @Override
    public void onLoaderReset(Loader&lt;Cursor&gt; loader) {
        mPicAdapter.swapCursor(null);
    } 
</code></pre><ul>
<li>如果我们使用的是自定义的Loader，需要如下注册观察者。如果不使用cursor的话，Loader能够帮助我们的地方不多，需要利用广播监听数据源并使用Loader的onContentChanged()方法更新数据</li>
</ul>
<pre><code>private ForceLoadContentObserver mObserver = new ForceLoadContentObserver();
...

   cursor.registerContentObserver(mObserver);
   cursor.setNotificationUri(resolver,MediaStore.Images.Media.EXTERNAL_CONTENT_URI);
</code></pre><h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><ul>
<li>首先找到我们分析的入口，我们最初调用的getLoaderManager()方法，每一个Activity或Fragment都有一个LoaderManager，LoaderManager用于同一管理不同Loader的生命周期</li>
</ul>
<ul>
<li>Activity和Fragment的getLoaderManager最终调用到Activity->FragmentController->FragmentHostCallback类的下面这个方法。所有的LoaderManager都保存在mAllLoaderManagers当中，它是一个ArrayMap，ArrayMap和SparseArray一样是官方推荐用于替代HashMap的数据结构，实际上在更早期的实现中mAllLoaderManagers用的就是HashMap。当没有获取到需要的LoaderManager时就会创建LoaderManagerImpl实例</li>
</ul>
<pre><code>LoaderManagerImpl getLoaderManager(String who, boolean started, boolean create) {
if (mAllLoaderManagers == null) {
    mAllLoaderManagers = new ArrayMap&lt;String, LoaderManager&gt;();
}
LoaderManagerImpl lm = (LoaderManagerImpl) mAllLoaderManagers.get(who);
if (lm == null) {
    if (create) {
        lm = new LoaderManagerImpl(who, this, started);
        mAllLoaderManagers.put(who, lm);
    }
} else {
    lm.updateHostController(this);
}
return lm;
}
</code></pre><ul>
<li>LoaderManagerImpl中我们可以看到initLoader方法的实现，同样是从集合中获取实例，mLoaders是一个LoaderInfo<br>类型的稀疏数组，LoaderInfo是对Loader的一层封装，它是一个非常重要的类，不仅仅包含了单独的Loader和这个Loader相关的信息，还会调用Loader和LoaderCallbacks中onLoaderFinish等回调方法，这些会在后面提到</li>
</ul>
<pre><code>@Override
@SuppressWarnings(&quot;unchecked&quot;)
public &lt;D&gt; Loader&lt;D&gt; initLoader(int id, Bundle args, LoaderManager.LoaderCallbacks&lt;D&gt; callback) {
    if (mCreatingLoader) {
        throw new IllegalStateException(&quot;Called while creating a loader&quot;);
    }

LoaderInfo info = mLoaders.get(id);

if (DEBUG) Log.v(TAG, &quot;initLoader in &quot; + this + &quot;: args=&quot; + args);

if (info == null) {
    // Loader doesn&apos;t already exist; create.
    info = createAndInstallLoader(id, args,  (LoaderManager.LoaderCallbacks&lt;Object&gt;)callback);
    if (DEBUG) Log.v(TAG, &quot;  Created new loader &quot; + info);
} else {
    if (DEBUG) Log.v(TAG, &quot;  Re-using existing loader &quot; + info);
    info.mCallbacks = (LoaderManager.LoaderCallbacks&lt;Object&gt;)callback;
}

if (info.mHaveData &amp;&amp; mStarted) {
    // If the loader has already generated its data, report it now.
    info.callOnLoadFinished(info.mLoader, info.mData);
}

return (Loader&lt;D&gt;)info.mLoader;
}
</code></pre><ul>
<li>从上面可以看出，当没有指定的LoaderInfo可以复用时就会调用createAndInstallLoader方法创建实例，再看下面，获取封装的Loader时最终会调用我们实现的onCreateLoader方法以及一个installLoader方法</li>
</ul>
<pre><code>private LoaderInfo createAndInstallLoader(int id, Bundle args,
    LoaderManager.LoaderCallbacks&lt;Object&gt; callback) {
try {
    mCreatingLoader = true;
    LoaderInfo info = createLoader(id, args, callback);
    installLoader(info);
    return info;
} finally {
    mCreatingLoader = false;
}
}

    private LoaderInfo createLoader(int id, Bundle args,
    LoaderManager.LoaderCallbacks&lt;Object&gt; callback) {
LoaderInfo info = new LoaderInfo(id, args,  callback);
Loader&lt;Object&gt; loader = callback.onCreateLoader(id, args);
info.mLoader = loader;
return info;
}
</code></pre><ul>
<li>在installLoader方法中调用了info.start方法，显然这里启动了Loader，但是根据注释我们知道，Activity的onStart方法会启动所有已存在的Loader，这里启动的只是后面创建的Loader，可能是数据源发生了变化，或者主动调用了restartLoader</li>
</ul>
<pre><code>void installLoader(LoaderInfo info) {
mLoaders.put(info.mId, info);
if (mStarted) {
    // The activity will start all existing loaders in it&apos;s onStart(),
    // so only start them here if we&apos;re past that point of the activity&apos;s
    // life cycle
    info.start();
}
}

//Activity的onStart方法最终会调用这个doStart方法
//与installLoader方法不同，doStart会启动所有未启动的Loader

void doStart() {
if (DEBUG) Log.v(TAG, &quot;Starting in &quot; + this);
if (mStarted) {
    RuntimeException e = new RuntimeException(&quot;here&quot;);
    e.fillInStackTrace();
    Log.w(TAG, &quot;Called doStart when already started: &quot; + this, e);
    return;
}

mStarted = true;

// Call out to sub classes so they can start their loaders
// Let the existing loaders know that we want to be notified when a load is complete
for (int i = mLoaders.size()-1; i &gt;= 0; i--) {
    mLoaders.valueAt(i).start();
}
}
</code></pre><ul>
<li>接着来看LoaderInfo的start方法，下面省略了一些条件判断，可以看到这里注册了两个监听器，一个用于接受加载完的数据，另一个用于接受被取消加载的Loader，注册完监听器后调用了Loader的onStartLoading方法，onStartLoading是我们实现Loader时需要实现的方法，还记得刚刚说的在onStartLoading中需要使用forceLoad方法来开始加载吗，Loader基类中这个方法调用了onForceLoad方法，而onForceLoad是一个空实现，所以接下来就要到子类AsyncTaskLoader登场了</li>
</ul>
<pre><code>        void start() {

...

    mStarted = true;

    if (DEBUG) Log.v(TAG, &quot;  Starting: &quot; + this);
    if (mLoader == null &amp;&amp; mCallbacks != null) {
       mLoader = mCallbacks.onCreateLoader(mId, mArgs);
    }

    if (mLoader != null) {

...

        if (!mListenerRegistered) {
            mLoader.registerListener(mId, this);
            mLoader.registerOnLoadCanceledListener(this);
            mListenerRegistered = true;
        }
        mLoader.startLoading();
    }
}

    public interface OnLoadCompleteListener&lt;D&gt; {
/**
 * Called on the thread that created the Loader when the load is complete.
 *
 * @param loader the loader that completed the load
 * @param data the result of the load
 */
public void onLoadComplete(Loader&lt;D&gt; loader, D data);
}

    public interface OnLoadCanceledListener&lt;D&gt; {
/**
 * Called on the thread that created the Loader when the load is canceled.
 *
 * @param loader the loader that canceled the load
 */
public void onLoadCanceled(Loader&lt;D&gt; loader);
}
</code></pre><ul>
<li>AsyncTaskLoader是对AsyncTask的抽象封装，包含一个AsyncTask内部类，这个AsyncTask同时也是一个Runnable，在onForceLoad方法中调用了executePendingTask方法，executePendingTask中需要关心的只有executeOnExecutor这个步骤，这是AsyncTask新增的接口，允许开发者提供线程池并行的处理Task，而我们用的比较多的Excute方法是串行的</li>
</ul>
<pre><code>@Override
protected void onForceLoad() {
    super.onForceLoad();
    cancelLoad();
    mTask = new LoadTask();
    if (DEBUG) Log.v(TAG, &quot;Preparing load: mTask=&quot; + mTask);
    executePendingTask();
}

void executePendingTask() {
    ...
    mTask.executeOnExecutor(mExecutor, (Void[]) null);
    }
}
</code></pre><ul>
<li>既然是AsyncTask，那么就先来看doInBackground，这里一大串注释想表达的是任务被LoaderManger以外的对象取消时需要抛出异常，毕竟所有Task应该由LoaderManager来管理，故手动调用AsyncTask的cancel方法是不应该的，正常情况下这里会调用我们实现的onLoadInBackground方法来获取数据</li>
</ul>
<pre><code>final class LoadTask extends AsyncTask&lt;Void, Void, D&gt; implements Runnable {
private final CountDownLatch mDone = new CountDownLatch(1);

// Set to true to indicate that the task has been posted to a handler for
// execution at a later time.  Used to throttle updates.
boolean waiting;

/* Runs on a worker thread */
@Override
protected D doInBackground(Void... params) {
    if (DEBUG) Log.v(TAG, this + &quot; &gt;&gt;&gt; doInBackground&quot;);
    try {
        D data = AsyncTaskLoader.this.onLoadInBackground();
        if (DEBUG) Log.v(TAG, this + &quot;  &lt;&lt;&lt; doInBackground&quot;);
        return data;
    } catch (OperationCanceledException ex) {
        if (!isCancelled()) {
            // onLoadInBackground threw a canceled exception spuriously.
            // This is problematic because it means that the LoaderManager did not
            // cancel the Loader itself and still expects to receive a result.
            // Additionally, the Loader&apos;s own state will not have been updated to
            // reflect the fact that the task was being canceled.
            // So we treat this case as an unhandled exception.
            throw ex;
        }
        if (DEBUG) Log.v(TAG, this + &quot;  &lt;&lt;&lt; doInBackground (was canceled)&quot;, ex);
        return null;
    }
}

    protected D onLoadInBackground() {
return loadInBackground();
}
</code></pre><ul>
<li>在onPostExecute我们进入到了数据的分发阶段，如果任务没有被取消，那么调用deliverResult方法获取数据，通常我们可以重写这个方法来实现数据缓存，而deliverResult调用了OnLoadCompleteListener.onLoadComplete方法，这个监听器就是我们先前提到的LoaderInfo实现的接口</li>
</ul>
<pre><code>    /* Runs on the UI thread */
    @Override
    protected void onPostExecute(D data) {
        if (DEBUG) Log.v(TAG, this + &quot; onPostExecute&quot;);
        try {
            AsyncTaskLoader.this.dispatchOnLoadComplete(this, data);
        } finally {
            mDone.countDown();
        }
    }

        void dispatchOnLoadComplete(LoadTask task, D data) {
    if (mTask != task) {
        if (DEBUG) Log.v(TAG, &quot;Load complete of old task, trying to cancel&quot;);
        dispatchOnCancelled(task, data);
    } else {
        if (isAbandoned()) {
            // This cursor has been abandoned; just cancel the new data.
            onCanceled(data);
        } else {
            commitContentChanged();
            mLastLoadCompleteTime = SystemClock.uptimeMillis();
            mTask = null;
            if (DEBUG) Log.v(TAG, &quot;Delivering result&quot;);
            deliverResult(data);
        }
    }
}
    public void deliverResult(D data) {
    if (mListener != null) {
        mListener.onLoadComplete(this, data);
    }
}
</code></pre><ul>
<li>onLoadComplete主要有三个步骤</li>
</ul>
<ul>
<li>一，处理新请求：当我们调用restartLoader方法时，为了避免启动过多的Task或是新Task的数据被旧的Task返回的数据覆盖，这里采用的做法是让LoaderInfo持有一个mPendingLoader，在旧的Loader执行完后让这个mPendingLoader启动</li>
</ul>
<pre><code>...
    LoaderInfo pending = mPendingLoader;
    if (pending != null) {
        // There is a new request pending and we were just
        // waiting for the old one to complete before starting
        // it.  So now it is time, switch over to the new loader.
        if (DEBUG) Log.v(TAG, &quot;  Switching to pending loader: &quot; + pending);
        mPendingLoader = null;
        mLoaders.put(mId, null);
        destroy();
        installLoader(pending);
        return;
    }
</code></pre><ul>
<li>二，当没有等待的请求，调用callOnLoadFinished，这个方法会调用到我们实现的onLoadFinished，这样就可以更新UI了</li>
</ul>
<pre><code>// Notify of the new data so the app can switch out the old data before
// we try to destroy it.
if (mData != data || !mHaveData) {
    mData = data;
    mHaveData = true;
    if (mStarted) {
        callOnLoadFinished(loader, data);
    }
}
</code></pre><ul>
<li>三，restartLoader时会把旧Loader放入mInactiveLoaders当中，现在可以清除旧的Loader了</li>
</ul>
<pre><code>    //if (DEBUG) Log.v(TAG, &quot;  onLoadFinished returned: &quot; + this);

    // We have now given the application the new loader with its
    // loaded data, so it should have stopped using the previous
    // loader.  If there is a previous loader on the inactive list,
    // clean it up.
    LoaderInfo info = mInactiveLoaders.get(mId);
    if (info != null &amp;&amp; info != this) {
        info.mDeliveredData = false;
        info.destroy();
        mInactiveLoaders.remove(mId);
    }

    if (mHost != null &amp;&amp; !hasRunningLoaders()) {
        mHost.mFragmentManager.startPendingDeferredFragments();
    }
}
</code></pre><ul>
<li>到目前为止我们从获取LoaderManager，启动Loader，数据传递都已经分析完了，但是还有很关键的一点，就是监听数据源，自动启动任务。在Loader基类中我们可以找到这个内部类</li>
</ul>
<pre><code>/**
* An implementation of a ContentObserver that takes care of connecting
* it to the Loader to have the loader re-load its data when the observer
* is told it has changed.  You do not normally need to use this yourself;
* it is used for you by {@link CursorLoader} to take care of executing
* an update when the cursor&apos;s backing data changes.
*/
    public final class ForceLoadContentObserver extends ContentObserver {

    public ForceLoadContentObserver() {
    super(new Handler());
    }

    @Override
    public boolean deliverSelfNotifications() {
    return true;
    }

    @Override
    public void onChange(boolean selfChange) {
    onContentChanged();
    }
}

public void onContentChanged() {
if (mStarted) {
    forceLoad();
} else {
    // This loader has been stopped, so we don&apos;t want to load
    // new data right now...  but keep track of it changing to
    // refresh later if we start again.
    mContentChanged = true;
}
}
</code></pre><ul>
<li>在CursorLoader的实现中loadInBackground方法为cursor注册了观察者当数据发送变化时ContentResolver会调用观察者的onChange方法，而onChange会onContentChanged方法最终重新加载数据，至于ContentResolver如何实现监听则涉及较多系统层的问题，有兴趣可以看<a href="http://www.cnblogs.com/bastard/archive/2012/06/02/2531663.html" target="_blank" rel="external">这篇文章</a>，这里就不再深入地谈四大组件方面的内容了</li>
</ul>
<pre><code>    @Override
public Cursor loadInBackground() {
synchronized (this) {
    if (isLoadInBackgroundCanceled()) {
        throw new OperationCanceledException();
    }
    mCancellationSignal = new CancellationSignal();
}
try {
    Cursor cursor = ContentResolverCompat.query(getContext().getContentResolver(),
            mUri, mProjection, mSelection, mSelectionArgs, mSortOrder,
            mCancellationSignal);
    if (cursor != null) {
        try {
            // Ensure the cursor window is filled.
            cursor.getCount();
            cursor.registerContentObserver(mObserver);
        } catch (RuntimeException ex) {
            cursor.close();
            throw ex;
        }
    }
    return cursor;
} finally {
    synchronized (this) {
        mCancellationSignal = null;
    }
}
}
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Volley 事件派发机制]]></title>
      <url>/2017/08/09/VolleyDispatcher/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<ul>
<li>之前大致浏<a href="https://alberthumbert.github.io/2017/07/19/aboutVolley/">览过</a>一遍Volley的源码，对事件派发的部分有不少缺漏，下面进行补充</li>
</ul>
<h2 id="请求容器"><a href="#请求容器" class="headerlink" title="请求容器"></a>请求容器</h2><ul>
<li>我们知道，Volley将所有请求都存放在RequestQueue当中，虽然叫做Queue但实际上RequestQueue并不是collection类，Volley暂存请求的容器有四个，mCacheQueue 用于存放可以访问缓存的请求，mNetworkQueue用于存放需要访问网络的请求，mWaitingRequests用于存放等待的处理的请求，mCurrentRequests用于存放正在处理的请求，之前对mWaitingRequests的存在意义不是很理解，后来发现它的设计还是很巧妙的，下面会进行详细的分析</li>
</ul>
<pre><code>private final Map&lt;String, Queue&lt;Request&lt;?&gt;&gt;&gt; mWaitingRequests =
    new HashMap&lt;String, Queue&lt;Request&lt;?&gt;&gt;&gt;();

    private final Set&lt;Request&lt;?&gt;&gt; mCurrentRequests = new HashSet&lt;Request&lt;?&gt;&gt;();            

    private final PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mCacheQueue =
new PriorityBlockingQueue&lt;Request&lt;?&gt;&gt;();

    private final PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mNetworkQueue =
new PriorityBlockingQueue&lt;Request&lt;?&gt;&gt;();
</code></pre><ul>
<li>来看RequestQueue的add方法，首先是调用request的setRequestQueue将请求与RequestQueue绑定。然后将请求放入mCurrentRequests，正在处理的请求的容器当中，mCurrentRequests是一个HashSet，线程不安全，所以使用了锁</li>
</ul>
<pre><code>public &lt;T&gt; Request&lt;T&gt; add(Request&lt;T&gt; request) {
    // Tag the request as belonging to this queue and add it to the set of current requests.
    request.setRequestQueue(this);
    synchronized (mCurrentRequests) {
        mCurrentRequests.add(request);
    }

    // Process requests in the order they are added.
    request.setSequence(getSequenceNumber());
    request.addMarker(&quot;add-to-queue&quot;);
</code></pre><ul>
<li>如果请求不能缓存，直接放入mNetworkQueue网络队列</li>
</ul>
<pre><code>// If the request is uncacheable, skip the cache queue and go straight to the network.
if (!request.shouldCache()) {
    mNetworkQueue.add(request);
    return request;
}
</code></pre><ul>
<li>接着对mWaitingRequests的操作是关键，我们先看看文档中对mWaitingRequests的描述。mWaitingRequests是一个HashMap，这个HashMap的每个value值都是一个队列，每个队列当中都是相同的请求，这是因为mWaitingRequests是专门用于存放重复的请求的<pre><code>/**
* Staging area for requests that already have a duplicate request in flight.
*
* &lt;ul&gt;
*     &lt;li&gt;containsKey(cacheKey) indicates that there is a request in flight for the given cache
*          key.&lt;/li&gt;
*     &lt;li&gt;get(cacheKey) returns waiting requests for the given cache key. The in flight request
*          is &lt;em&gt;not&lt;/em&gt; contained in that list. Is null if no requests are staged.&lt;/li&gt;
* &lt;/ul&gt;
*/
    private final Map&lt;String, Queue&lt;Request&lt;?&gt;&gt;&gt; mWaitingRequests =
    new HashMap&lt;String, Queue&lt;Request&lt;?&gt;&gt;&gt;();
</code></pre></li>
</ul>
<ul>
<li>继续看add方法，HashMap线程不安全所以也开启了锁，我们发现这里检查mWaitingRequests中是否存在给定的key，如果存在则说明先前已有相同的请求被提交了，但是最初已被提交的请求并不会创建队列，而是放入一个null值，当下一个相同的请求到来，发现Map中有了这个Key值，才会创建队列并且将请求放进队列之后就暂时再不处理，Volley就是利用这种方法避免请求被重复执行的</li>
</ul>
<pre><code>    // Insert request into stage if there&apos;s already a request with the same cache key in flight.
    synchronized (mWaitingRequests) {
        String cacheKey = request.getCacheKey();
        if (mWaitingRequests.containsKey(cacheKey)) {
            // There is already a request in flight. Queue up.
            Queue&lt;Request&lt;?&gt;&gt; stagedRequests = mWaitingRequests.get(cacheKey);
            if (stagedRequests == null) {
                stagedRequests = new LinkedList&lt;Request&lt;?&gt;&gt;();
            }
            stagedRequests.add(request);
            mWaitingRequests.put(cacheKey, stagedRequests);
            if (VolleyLog.DEBUG) {
                VolleyLog.v(&quot;Request for cacheKey=%s is in flight, putting on hold.&quot;, cacheKey);
            }
        } else {
            // Insert &apos;null&apos; queue for this cacheKey, indicating there is now a request in
            // flight.
            mWaitingRequests.put(cacheKey, null);
            mCacheQueue.add(request);
        }
        return request;
    }
}
</code></pre><ul>
<li>进过一段时间，当一个Request被处理完毕时，它的finish方法会被执行，之前Volley将Request与RequestQueue进行了绑定，在这里回调RequestQueue的finish()方法并传入自身</li>
</ul>
<pre><code> void finish(final String tag) {
if (mRequestQueue != null) {
    mRequestQueue.finish(this);
    onFinish();
}
if (MarkerLog.ENABLED) {
    final long threadId = Thread.currentThread().getId();
    if (Looper.myLooper() != Looper.getMainLooper()) {
        // If we finish marking off of the main thread, we need to
        // actually do it on the main thread to ensure correct ordering.
        Handler mainThread = new Handler(Looper.getMainLooper());
        mainThread.post(new Runnable() {
            @Override
            public void run() {
                mEventLog.add(tag, threadId);
                mEventLog.finish(this.toString());
            }
        });
        return;
    }

    mEventLog.add(tag, threadId);
    mEventLog.finish(this.toString());
    }
}    
</code></pre><ul>
<li>下面来看RequestQueue的finish方法，一开始在mCurrentRequests移除了Request，这里比较好理解，接着在等待队列waitingRequests中取出了所有相同的请求，并把这些请求全部加入到mCacheQueue当中，这样做是因为刚刚只是把这些相同的Request放入waitingRequests而没有去处理，现在最初的Request对象被处理完毕了，所有与它相同的请求都可以保证能从缓存中拿到结果了，故将其加入到缓存队列当中。通过这个机制，相同的请求同时进入到RequestQueue中时，只会从网络获取一次（假设Response不需要更新），很好地节约了时间</li>
</ul>
<pre><code>    /**
    * Called from {@link Request#finish(String)}, indicating that processing of the given request
    * has finished.
    *
    * &lt;p&gt;Releases waiting requests for &lt;code&gt;request.getCacheKey()&lt;/code&gt; if
    *      &lt;code&gt;request.shouldCache()&lt;/code&gt;.&lt;/p&gt;
    */
    &lt;T&gt; void finish(Request&lt;T&gt; request) {
// Remove from the set of requests currently being processed.
synchronized (mCurrentRequests) {
    mCurrentRequests.remove(request);
}
synchronized (mFinishedListeners) {
  for (RequestFinishedListener&lt;T&gt; listener : mFinishedListeners) {
    listener.onRequestFinished(request);
    }
    }

if (request.shouldCache()) {
    synchronized (mWaitingRequests) {
        String cacheKey = request.getCacheKey();
        Queue&lt;Request&lt;?&gt;&gt; waitingRequests = mWaitingRequests.remove(cacheKey);
        if (waitingRequests != null) {
            if (VolleyLog.DEBUG) {
                VolleyLog.v(&quot;Releasing %d waiting requests for cacheKey=%s.&quot;,
                        waitingRequests.size(), cacheKey);
            }
            // Process all queued up requests. They won&apos;t be considered as in flight, but
            // that&apos;s not a problem as the cache has been primed by &apos;request&apos;.
            mCacheQueue.addAll(waitingRequests);
        }
    }
}
} 
</code></pre><h2 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h2><ul>
<li>再来看start方法，这里开启了处理和分发请求的线程，网上普遍说这里处理网络请求的线程<strong>默认</strong>是四个，但实际上由于外部调用RequestQueue的构造方法没有意义，所以定死了就是四个</li>
</ul>
<pre><code>    public void start() {
    stop();  // Make sure any currently running dispatchers are stopped.
    // Create the cache dispatcher and start it.
    mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);
    mCacheDispatcher.start();

    // Create network dispatchers (and corresponding threads) up to the pool size.
    for (int i = 0; i &lt; mDispatchers.length; i++) {
        NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork,
                mCache, mDelivery);
        mDispatchers[i] = networkDispatcher;
        networkDispatcher.start();
    }
}

    ...

    RequestQueue queue;
    if (maxDiskCacheBytes &lt;= -1)
            {
        // No maximum size specified
        queue = new RequestQueue(new DiskBasedCache(cacheDir), network);
    }
    else
        {
            // Disk cache size specified
            queue = new RequestQueue(new DiskBasedCache(cacheDir, maxDiskCacheBytes), network);
        }

    ...

    public RequestQueue(Cache cache, Network network) {
            this(cache, network, DEFAULT_NETWORK_THREAD_POOL_SIZE);
        }

    ...

    public RequestQueue(Cache cache, Network network, int threadPoolSize,
        ResponseDelivery delivery) {
    mCache = cache;
    mNetwork = network;
    mDispatchers = new NetworkDispatcher[threadPoolSize];
    mDelivery = delivery;
    }

    ...
</code></pre><ul>
<li>我们来看处理缓存请求的CacheDispatcher线程的run方法，具体的分析写在注释里</li>
</ul>
<pre><code>    @Override
    public void run() {
if (DEBUG) VolleyLog.v(&quot;start new dispatcher&quot;);
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);

// Make a blocking call to initialize the cache.
mCache.initialize();
//初始化缓存

Request&lt;?&gt; request;
while (true) {
//开启一个死循环处理请求
    // release previous request object to avoid leaking request object when mQueue is drained.
    request = null;
    try {
        // Take a request from the queue.
        request = mCacheQueue.take();
        //重置请求，BlockingQueue的take()方法会阻塞线程直到有一个元素被拿出为止

    } catch (InterruptedException e) {
        // We may have been interrupted because it was time to quit.
        if (mQuit) {
            return;
            //当关闭线程时会在这里抛出异常，检查是否需要停止
        }
        continue;
    }
    try {
        request.addMarker(&quot;cache-queue-take&quot;);

        // If the request has been canceled, don&apos;t bother dispatching it.
        if (request.isCanceled()) {
            request.finish(&quot;cache-discard-canceled&quot;);
            continue;
            //如果请求被取消，直接放过
        }

        // Attempt to retrieve this item from cache.
        Cache.Entry entry = mCache.get(request.getCacheKey());
        if (entry == null) {
            request.addMarker(&quot;cache-miss&quot;);
            // Cache miss; send off to the network dispatcher.
            mNetworkQueue.put(request);
            //拿不到缓存，放入网络队列
            continue;
        }

        // If it is completely expired, just send it to the network.
        if (entry.isExpired()) {
            request.addMarker(&quot;cache-hit-expired&quot;);
            request.setCacheEntry(entry);
            mNetworkQueue.put(request);
            //请求过期，也放入网络队列
            continue;
        }

        // We have a cache hit; parse its data for delivery back to the request.
        request.addMarker(&quot;cache-hit&quot;);
        Response&lt;?&gt; response = request.parseNetworkResponse(
                new NetworkResponse(entry.data, entry.responseHeaders));
        request.addMarker(&quot;cache-hit-parsed&quot;);

        if (!entry.refreshNeeded()) {
            // Completely unexpired cache hit. Just deliver the response.
            mDelivery.postResponse(request, response);
            //从缓存中拿到了结果，如果不需要更新内容，则直接投递结果
        } else {
            // Soft-expired cache hit. We can deliver the cached response,
            // but we need to also send the request to the network for
            // refreshing.
            request.addMarker(&quot;cache-hit-refresh-needed&quot;);
            request.setCacheEntry(entry);

            // Mark the response as intermediate.
            response.intermediate = true;

            // Post the intermediate response back to the user and have
            // the delivery then forward the request along to the network.
            final Request&lt;?&gt; finalRequest = request;

           //如果内容需要更新，也同样会投递结果，不同的是之后这里的run方法会执行，进行更新
            mDelivery.postResponse(request, response, new Runnable() {
                @Override
                public void run() {
                    try {
                        mNetworkQueue.put(finalRequest);
                    } catch (InterruptedException e) {
                        // Not much we can do about this.
                    }
                }
            });
        }
    } catch (Exception e) {
        VolleyLog.e(e, &quot;Unhandled exception %s&quot;, e.toString());
            }
        }
    }
}
</code></pre><ul>
<li>接着再看NetworkDispatcher的run方法，逻辑是差不多的</li>
</ul>
<pre><code>@Override
    public void run() {
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
Request&lt;?&gt; request;
while (true) {
//开启死循环处理请求
    long startTimeMs = SystemClock.elapsedRealtime();
    // release previous request object to avoid leaking request object when mQueue is drained.
    request = null;
    try {
        // Take a request from the queue.
        request = mQueue.take();
        //阻塞直到获得对象
    } catch (InterruptedException e) {
        // We may have been interrupted because it was time to quit.
        if (mQuit) {
            return;
        }
        continue;
    }

    try {
        request.addMarker(&quot;network-queue-take&quot;);

        // If the request was cancelled already, do not perform the
        // network request.
        if (request.isCanceled()) {
            request.finish(&quot;network-discard-cancelled&quot;);
            continue;
        }

        addTrafficStatsTag(request);

        // Perform the network request.
        NetworkResponse networkResponse = mNetwork.performRequest(request);
        //从网络获取Response
        request.addMarker(&quot;network-http-complete&quot;);

        // If the server returned 304 AND we delivered a response already,
        // we&apos;re done -- don&apos;t deliver a second identical response.
        if (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) {
            request.finish(&quot;not-modified&quot;);
            continue;
        }

        // Parse the response here on the worker thread.
        Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse);
        request.addMarker(&quot;network-parse-complete&quot;);

        // Write to cache if applicable.
        // TODO: Only update cache metadata instead of entire record for 304s.
        if (request.shouldCache() &amp;&amp; response.cacheEntry != null) {
            mCache.put(request.getCacheKey(), response.cacheEntry);
            //将结果放入缓存
            request.addMarker(&quot;network-cache-written&quot;);
        }

        // Post the response back.
        request.markDelivered();
        mDelivery.postResponse(request, response);
        //投递结果
    } catch (VolleyError volleyError) {
        volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);
        parseAndDeliverNetworkError(request, volleyError);
    } catch (Exception e) {
        VolleyLog.e(e, &quot;Unhandled exception %s&quot;, e.toString());
        VolleyError volleyError = new VolleyError(e);
        volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);
        mDelivery.postError(request, volleyError);
    }
}
} 
</code></pre><h2 id="ExecutorDelivery"><a href="#ExecutorDelivery" class="headerlink" title="ExecutorDelivery"></a>ExecutorDelivery</h2><ul>
<li>mDelivery是真正用于投递结果的对象，是ExecutorDelivery的实例，持有一个主线程的handler</li>
</ul>
<pre><code>    public RequestQueue(Cache cache, Network network, int threadPoolSize) {
this(cache, network, threadPoolSize,
        new ExecutorDelivery(new Handler(Looper.getMainLooper())));
    }

    public ExecutorDelivery(final Handler handler) {                // Make an Executor that just wraps the handler.
    mResponsePoster = new Executor() {
        @Override
        public void execute(Runnable command) {
            handler.post(command);
        }
    };
}
</code></pre><ul>
<li>ExecutorDelivery内部有一个实现了Runnable接口的类，它用于将请求结构返回给我们实现的监听器，这样我们就能接收到数据了，注意这里还调用到了Request的finish方法，这之后就回到刚刚讲到的RequestQueue的finish方法了</li>
</ul>
<pre><code>        /**
        * A Runnable used for delivering network responses to a listener on the
        * main thread.
        */
        @SuppressWarnings(&quot;rawtypes&quot;)
        private class ResponseDeliveryRunnable implements Runnable {
            private final Request mRequest;
            private final Response mResponse;
            private final Runnable mRunnable;

    public ResponseDeliveryRunnable(Request request, Response response, Runnable runnable) {
        mRequest = request;
        mResponse = response;
        mRunnable = runnable;
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public void run() {
        // If this request has canceled, finish it and don&apos;t deliver.
        if (mRequest.isCanceled()) {
            mRequest.finish(&quot;canceled-at-delivery&quot;);
            return;
        }

        // Deliver a normal response or error, depending.
        if (mResponse.isSuccess()) {
            mRequest.deliverResponse(mResponse.result);
        } else {
            mRequest.deliverError(mResponse.error);
        }

        // If this is an intermediate response, add a marker, otherwise we&apos;re done
        // and the request can be finished.
        if (mResponse.intermediate) {
            mRequest.addMarker(&quot;intermediate-response&quot;);
        } else {
            mRequest.finish(&quot;done&quot;);
        }

        // If we have been provided a post-delivery runnable, run it.
        if (mRunnable != null) {
            mRunnable.run();
        }
   }
}
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Picasso 源码分析]]></title>
      <url>/2017/08/08/Picasso/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<ul>
<li>使用<a href="https://github.com/square/picasso" target="_blank" rel="external">Picasso</a>主要包括四步，创建单例（with / Builder），传入链接（load），配置属性（centerCrop，resize … ），加载图片（into），下面就大致按照这个顺序来解析Picasso的源码</li>
</ul>
<pre><code>Picasso.with(context)
        .load(uri)
        .centerCrop()
        .into(imageView);
</code></pre><h2 id="with"><a href="#with" class="headerlink" title="with"></a>with</h2><ul>
<li>with方法是一种全部使用内部默认组件进行初始化的方法，所以并不会很复杂，这里主要用到了单例模式，通过Builder对象创建Picasso的单例，注意这里的Builder对象在创建出来之后直接调用了build()方法，其实相当于没有使用到建造者模式</li>
</ul>
<pre><code>public static Picasso with(Context context) {
    if (singleton == null) {
    synchronized (Picasso.class) {
        if (singleton == null) {
        singleton = new Builder(context).build();
        }
    }
    }
    return singleton;
}
</code></pre><ul>
<li>再来看build()方法，这里包含了Picasso中几个至关重要的成员的初始化，Downloader、Cache、ExecutorService、RequestTransformer、Stats和Dispatcher</li>
</ul>
<pre><code>    public Picasso build() {
    Context context = this.context;

    if (downloader == null) {
        downloader = Utils.createDefaultDownloader(context);
    }
    if (cache == null) {
        cache = new LruCache(context);
    }
    if (service == null) {
        service = new PicassoExecutorService();
    }
    if (transformer == null) {
        transformer = RequestTransformer.IDENTITY;
    }

    Stats stats = new Stats(cache);

    Dispatcher dispatcher = new Dispatcher(context, service, HANDLER, downloader, cache, stats);

    return new Picasso(context, dispatcher, cache, listener, transformer, requestHandlers, stats,
        defaultBitmapConfig, indicatorsEnabled, loggingEnabled);
    }
} 
</code></pre><ul>
<li>默认的downloader使用的是OkHttpClient或者UrlConnection，一般情况下会是OkHttpClient，它们是用于处理图片的网络请求工具类，如有需要我们可以进行自定义，只需实现Downloader接口即可，但一般没有这个必要</li>
</ul>
<pre><code>static Downloader createDefaultDownloader(Context context) {
    try {
    Class.forName(&quot;com.squareup.okhttp.OkHttpClient&quot;);
    //如果加载类时抛出异常，将使用UrlConnectionDownloader
    return OkHttpLoaderCreator.create(context);
    } catch (ClassNotFoundException ignored) {
    }
    return new UrlConnectionDownloader(context);
}

...
public class OkHttpDownloader implements Downloader {
private static OkHttpClient defaultOkHttpClient() {
    OkHttpClient client = new OkHttpClient();
    client.setConnectTimeout(Utils.DEFAULT_CONNECT_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
    client.setReadTimeout(Utils.DEFAULT_READ_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
    client.setWriteTimeout(Utils.DEFAULT_WRITE_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
    return client;
} 

...
public class UrlConnectionDownloader implements Downloader {
static final String RESPONSE_SOURCE = &quot;X-Android-Response-Source&quot;;
static volatile Object cache;

private static final Object lock = new Object();
private static final String FORCE_CACHE = &quot;only-if-cached,max-age=2147483647&quot;;
private static final ThreadLocal&lt;StringBuilder&gt; CACHE_HEADER_BUILDER =
new ThreadLocal&lt;StringBuilder&gt;() {
        @Override protected StringBuilder initialValue() {
        return new StringBuilder();
        }
    };

private final Context context;

public UrlConnectionDownloader(Context context) {
    this.context = context.getApplicationContext();
}       
</code></pre><ul>
<li>cache，默认LruCache，没什么好讲的，一般自定义也是封装LruCache</li>
</ul>
<ul>
<li>service，Picasso使用ThreadPoolExecutor配置的线程池，内部根据手机使用的通信标准进行了优化，核心线程数与最大线程数一致，根据网络条件优劣(wifi,4g,3g,2g)进行配置</li>
</ul>
<pre><code>private void setThreadCount(int threadCount) {
    setCorePoolSize(threadCount);
    setMaximumPoolSize(threadCount);
}
</code></pre><ul>
<li>PicassoExecutorService维护一个优先级队列，质量高的图片优先加载，质量相同的图片先进先出</li>
</ul>
<pre><code>public enum Priority {
      LOW,
      NORMAL,
      HIGH
  }

 @Override
  public int compareTo(PicassoFutureTask other) {
  Picasso.Priority p1 = hunter.getPriority();
  Picasso.Priority p2 = other.hunter.getPriority();

  // High-priority requests are &quot;lesser&quot; so they are sorted to the front.
  // Equal priorities are sorted by sequence number to provide FIFO ordering.
  return (p1 == p2 ? hunter.sequence - other.hunter.sequence : p2.ordinal() - p1.ordinal());
  }
</code></pre><ul>
<li>RequestTransformer，对Request进行转换的接口，内部提供一个空实现，一般也不做处理</li>
</ul>
<pre><code>public interface RequestTransformer {

    Request transformRequest(Request request);

    RequestTransformer IDENTITY = new RequestTransformer() {
    @Override public Request transformRequest(Request request) {
        return request;
    }
    };
}
</code></pre><ul>
<li>stats，记录图片状态，dispatcher，用于分发任务，之后会详细分析</li>
</ul>
<ul>
<li>使用Builder可以进行一些自定义配置，注意不要漏了设置单例</li>
</ul>
<pre><code>Picasso picasso = new Picasso.Builder(this)  
        .downloader(...) 
        .addRequestHandler(...)
        .build();  
        Picasso.setSingletonInstance(picasso);  
</code></pre><h2 id="load"><a href="#load" class="headerlink" title="load"></a>load</h2><ul>
<li>load用于传入的链接并创建RequestCreator对象，提供四个重载，但最终都将参数转换为uri处理，RequestCreator实际上也是一个builder模式</li>
</ul>
<pre><code>  public RequestCreator load(Uri uri) {
    return new RequestCreator(this, uri, 0);
}

  public RequestCreator load(String path) {
    if (path == null) {
    return new RequestCreator(this, null, 0);
    }
    if (path.trim().length() == 0) {
    throw new IllegalArgumentException(&quot;Path must not be empty.&quot;);
    }
    return load(Uri.parse(path));
}

  public RequestCreator load(File file) {
    if (file == null) {
    return new RequestCreator(this, null, 0);
    }
    return load(Uri.fromFile(file));
}

  public RequestCreator load(int resourceId) {
    if (resourceId == 0) {
    throw new IllegalArgumentException(&quot;Resource ID must not be zero.&quot;);
    }
    return new RequestCreator(this, null, resourceId);
}
</code></pre><ul>
<li>通过RequestCreator，我们可以对加载的图片进行一些设定，传入的参数一般保留在RequestCreator的成员变量data当中</li>
</ul>
<pre><code>public RequestCreator resize(int targetWidth, int targetHeight) {
    data.resize(targetWidth, targetHeight);
    return this;
}

public RequestCreator centerCrop() {
    data.centerCrop();
    return this;
}

    public RequestCreator rotate(float degrees) {
    data.rotate(degrees);
    return this;
}
</code></pre><h2 id="into"><a href="#into" class="headerlink" title="into"></a>into</h2><ul>
<li>into是真正加载图片的方法，这个方法中首先对刚刚传入的参数进行检查和应用，这部分不是重点</li>
</ul>
<pre><code>if (!data.hasImage()) { 
...
}

if (data.hasSize()) {
...
}

if (setPlaceholder) {
...
}
</code></pre><ul>
<li>在这之后会判断是否从内存缓存读取图片，拿到图片则关闭请求设置图片，拿不到再去加载图片</li>
</ul>
<pre><code>if (shouldReadFromMemoryCache(memoryPolicy)) {
    Bitmap bitmap = picasso.quickMemoryCacheCheck(requestKey);
    //从缓存中读取
    if (bitmap != null) {
        picasso.cancelRequest(target);
        //关闭请求
        setBitmap(target, picasso.context, bitmap, MEMORY, noFade, picasso.indicatorsEnabled);
        //设置图片
        if (picasso.loggingEnabled) {
            log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), &quot;from &quot; + MEMORY);
        //如果需要，将图片信息用log打出    
        }
        if (callback != null) {
        callback.onSuccess();
        //加载图片的监听器
        }
        return;
    }
    }

    //如果拿不到图片，则从本地或网络加载
    if (setPlaceholder) {
    setPlaceholder(target, getPlaceholderDrawable());
    //如果需要，设置占位图
    }

    Action action =
new ImageViewAction(picasso, target, request, memoryPolicy, networkPolicy, errorResId,
    errorDrawable, requestKey, tag, callback, noFade);
    //创建action对象
    picasso.enqueueAndSubmit(action);
    //投递action对象
}
</code></pre><ul>
<li>可以看到action对象几乎包含了图片的所有信息，这之后action会交由Dispatcher的dispatchSubmit方法处理，这个handler来自于HandlerThread</li>
</ul>
<pre><code>this.dispatcherThread = new DispatcherThread();  
this.handler = new DispatcherHandler(dispatcherThread.getLooper(), this);

static class DispatcherThread extends HandlerThread {
    DispatcherThread() {
    super(Utils.THREAD_PREFIX + DISPATCHER_THREAD_NAME, THREAD_PRIORITY_BACKGROUND);
    }
}

void dispatchSubmit(Action action) {
            handler.sendMessage(handler.obtainMessage(REQUEST_S     UBMIT, action));
        }
</code></pre><ul>
<li><p>如无意外现在action对象会在Dispatcher对象的performSubmit方法中被处理，</p>
<pre><code>@Override public void handleMessage(final Message msg) {
switch (msg.what) {
    case REQUEST_SUBMIT: {
    Action action = (Action) msg.obj;
    dispatcher.performSubmit(action);
    break;
    } 

... 
</code></pre></li>
</ul>
<h2 id="BitmapHunter"><a href="#BitmapHunter" class="headerlink" title="BitmapHunter"></a>BitmapHunter</h2><ul>
<li>BitmaHunter是一个Runnable对象，内部最多可持有三个Action对象</li>
</ul>
<ul>
<li>performSubmit的主要步骤是，判断请求是否被停止，判断Action是否已分配BitmapHunter，判断线程池是否被关闭，以上三个条件只要一个成立都会直接返回，如果都不成立则创建BitmapHunter，投递BimapHunter给线程池</li>
</ul>
<pre><code>    void performSubmit(Action action, boolean dismissFailed) {
        if (pausedTags.contains(action.getTag())) {
        pausedActions.put(action.getTarget(), action);
        if (action.getPicasso().loggingEnabled) {
            log(OWNER_DISPATCHER, VERB_PAUSED, action.request.logId(),
        &quot;because tag &apos;&quot; + action.getTag() + &quot;&apos; is paused&quot;);
        }
        return;
        }

        BitmapHunter hunter = hunterMap.get(action.getKey());
        if (hunter != null) {
        hunter.attach(action);
        return;
        }

        if (service.isShutdown()) {
        if (action.getPicasso().loggingEnabled) {
            log(OWNER_DISPATCHER, VERB_IGNORED, action.request.logId(), &quot;because shut down&quot;);
        }
        return;
        }

        hunter = forRequest(action.getPicasso(), this, cache, stats, action);
        hunter.future = service.submit(hunter);
        hunterMap.put(action.getKey(), hunter);
        if (dismissFailed) {
        failedActions.remove(action.getTarget());
        }

        if (action.getPicasso().loggingEnabled) {
        log(OWNER_DISPATCHER, VERB_ENQUEUED, action.request.logId());
        }
}
</code></pre><ul>
<li>创建BitmapHunter中使用到了责任链模式，在Picasso的构造函数中，初始化了一条责任链，这是一条不可变的RequestHandler的ArrayList，RequestHandler对象在BitmapHunter中用于获取Bitmap对象，RequestHandler是一个抽象类其中包含判断是否可以处理某个请求的canHandleRequest方法，图片对象的构造器，压缩图片的calculateInSampleSize方法</li>
</ul>
<pre><code>allRequestHandlers.add(new ContactsPhotoRequestHandler(context));
allRequestHandlers.add(new MediaStoreRequestHandler(context));
allRequestHandlers.add(new ContentStreamRequestHandler(context));
allRequestHandlers.add(new AssetRequestHandler(context));
allRequestHandlers.add(new FileRequestHandler(context));
allRequestHandlers.add(new NetworkRequestHandler(dispatcher.downloader, stats));
requestHandlers = Collections.unmodifiableList(allRequestHandlers);
</code></pre><ul>
<li>创建BitmapHunter时，遍历RequestHandler链表，查找可以处理Request的对象</li>
</ul>
<pre><code>  static BitmapHunter forRequest(Picasso picasso, Dispatcher dispatcher, Cache cache, Stats stats,
Action action) {
      Request request = action.getRequest();
      List&lt;RequestHandler&gt; requestHandlers = picasso.getRequestHandlers();

      // Index-based loop to avoid allocating an iterator.
      //noinspection ForLoopReplaceableByForEach
      for (int i = 0, count = requestHandlers.size(); i &lt; count; i++) {
      RequestHandler requestHandler = requestHandlers.get(i);
      if (requestHandler.canHandleRequest(request)) {
          return new BitmapHunter(picasso, dispatcher, cache, stats, action, requestHandler);
      }
      }

      return new BitmapHunter(picasso, dispatcher, cache,         stats, action, ERRORING_HANDLER);
  } 
</code></pre><ul>
<li>在BitmapHunter的run方法中执行了hunt方法，hunt方法使用requestHandler的load方法得到需要的bitmap，之后使用dispatcher来传递bitmap</li>
</ul>
<pre><code>Bitmap hunt() throws IOException {
    ...
    data.networkPolicy = retryCount == 0 ? NetworkPolicy.OFFLINE.index : networkPolicy;
    RequestHandler.Result result = requestHandler.load(data, networkPolicy);
    if (result != null) {
    loadedFrom = result.getLoadedFrom();
    exifRotation = result.getExifOrientation();

    bitmap = result.getBitmap();
    ...

    }


Run(){
    ...
    result = hunt();

    if (result == null) {
        dispatcher.dispatchFailed(this);
    } else {
        dispatcher.dispatchComplete(this);
    ...
     }
}           
</code></pre><ul>
<li>最终bitmap被传递到performBatchComplete当中，使用主线程的handler来发送信息，在handlerMessage方法中调用到了picasso对象的complete方法，这个方法最终调用到了action的complete方法</li>
</ul>
<pre><code>void performBatchComplete() {
    List&lt;BitmapHunter&gt; copy = new ArrayList&lt;BitmapHunter&gt;(batch);
    batch.clear();
    mainThreadHandler.sendMessage(mainThreadHandler.obtainMessage(HUNTER_BATCH_COMPLETE, copy));
    logBatch(copy);
} 
</code></pre><ul>
<li>在ImageViewAction的complete方法中我们可以看到bitmap已经被设置了，这样就完成了一个完整的图片加载过程</li>
</ul>
<pre><code>@Override public void complete(Bitmap result,       Picasso.LoadedFrom from) {
    if (result == null) {
    throw new AssertionError(
        String.format(&quot;Attempted to complete action with no result!\n%s&quot;, this));
 }

    ImageView target = this.target.get();
    if (target == null) {
    return;
    }

    Context context = picasso.context;
    boolean indicatorsEnabled = picasso.indicatorsEnabled;
PicassoDrawable.setBitmap(target, context, result, from, noFade, indicatorsEnabled);

    if (callback != null) {
    callback.onSuccess();
    }
} 
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Matisse 源码分析]]></title>
      <url>/2017/08/07/Matisse/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<ul>
<li>首先还是从最初使用的地方开始一步步分析，很明显这里用到了builder模式，我们在启动Activity之前进行一些基本的配置，这里主要关心的方法有三个from，choose和forResult</li>
</ul>
<pre><code>Matisse.from(SampleActivity.this)
        .choose(MimeType.ofAll(), false)
        .countable(true)
        // 是否在图片右上角显示选中的数目
        .capture(true)
        //是否开启照相功能
        .captureStrategy(new CaptureStrategy(true, &quot;com.zhihu.matisse.sample.fileprovider&quot;)) 
        .maxSelectable(9)
        //设置最大可选数量
        .addFilter(new GifSizeFilter(320, 320, 5 * Filter.K * Filter.K))
        //添加过滤器,可自定义
        .gridExpectedSize(getResources().getDimensionPixelSize(R.dimen.grid_expected_size))
        //设置期待的尺寸
        .restrictOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT)
        //设置布局的水平或垂直属性
        .thumbnailScale(0.85f)
        //缩略图的缩放尺寸，默认为0.5
        .imageEngine(new GlideEngine())
        //设置图片加载库，Matisse对Glide和Picasso做了一层封装，也可以自定义，后面会提到
        .forResult(REQUEST_CODE_CHOOSE);
        //启动选择图片的Activity
</code></pre><ul>
<li>查看from方法，这里利用重载一个静态构造方法，既可以利用Activity也可以通过Fragment来创建Matisse对象</li>
</ul>
<pre><code>public static Matisse from(Activity activity) {
    return new Matisse(activity);
}

public static Matisse from(Fragment fragment) {
    return new Matisse(fragment);
}
</code></pre><ul>
<li>查看choose方法，这里我们定义了可以获取的媒体类型，构造并返回SelectionCreator对象，SelectionCreator类是Matisse中一个类似Builder的类型，从这里开始所有的配置方法都返回这个SelectionCreator</li>
</ul>
<pre><code>    public SelectionCreator choose(Set&lt;MimeType&gt; mimeTypes) {
        return this.choose(mimeTypes, true);
    }

    public SelectionCreator choose(Set&lt;MimeType&gt; mimeTypes, boolean mediaTypeExclusive) {
return new SelectionCreator(this, mimeTypes, mediaTypeExclusive);
}
</code></pre><ul>
<li>查看SelectionCreator对象的构造器和类结构，它只持有刚刚创建的Matisse对象和SelectionSpec对象，SelectionSpec对象保存调用countable，capture等方法时传入的参数，也就是保存了我们对matisse的配置属性</li>
</ul>
<pre><code>SelectionCreator(Matisse matisse, @NonNull Set&lt;MimeType&gt; mimeTypes, boolean mediaTypeExclusive) {
mMatisse = matisse;
mSelectionSpec = SelectionSpec.getCleanInstance();
mSelectionSpec.mimeTypeSet = mimeTypes;
mSelectionSpec.mediaTypeExclusive = mediaTypeExclusive;
mSelectionSpec.orientation = SCREEN_ORIENTATION_UNSPECIFIED;
}
</code></pre><ul>
<li>mSelectionSpec是一个懒汉式单例，当被初次调用<br>时InstanceHolder才会被加载进来，同时完成INSTANCE的初始化</li>
</ul>
<pre><code>private static final class InstanceHolder {
private static final SelectionSpec INSTANCE = new SelectionSpec();
} 
</code></pre><ul>
<li>mSelectionSpec 持有了这些配置属性，作为一个第三方库，我们使用的时候只需要进行这些配置，而不需要关系Matisse的内部实现</li>
</ul>
<pre><code>public Set&lt;MimeType&gt; mimeTypeSet;
    public boolean mediaTypeExclusive;
    public boolean showSingleMediaType;
    public int themeId;
    public int orientation;
    public boolean countable;
    public int maxSelectable;
    public List&lt;Filter&gt; filters;
    public boolean capture;
    public CaptureStrategy captureStrategy;
    public int spanCount;
    public int gridExpectedSize;
    public float thumbnailScale;
    public ImageEngine imageEngine; 
</code></pre><ul>
<li>再来看看forResult方法，如果我们之前传入的是activity就会调用activity的startActivityForResult，如果传入的是fragment那就调用fragment的startActivityForResult方法，所以重写onActivityResult方法获取返回的数据即可</li>
</ul>
<pre><code>    public void forResult(int requestCode) {
Activity activity = mMatisse.getActivity();
if (activity == null) {
    return;
}

Intent intent = new Intent(activity, MatisseActivity.class);

Fragment fragment = mMatisse.getFragment();
if (fragment != null) {
    fragment.startActivityForResult(intent, requestCode);
} else {
    activity.startActivityForResult(intent, requestCode);
}
} 

...

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
super.onActivityResult(requestCode, resultCode, data);
if (requestCode == REQUEST_CODE_CHOOSE &amp;&amp; resultCode == RESULT_OK) {
    mAdapter.setData(Matisse.obtainResult(data), Matisse.obtainPathResult(data));
}
}
</code></pre><ul>
<li>刚才使用startActivityForResult启动了MatisseActivity，那么首先查看MatisseActivity的onCreate方法，这里获取到了刚刚的SelectionSpec静态常量进行初始化</li>
</ul>
<pre><code>mSpec = SelectionSpec.getInstance();
setTheme(mSpec.themeId);

...

mButtonPreview = (TextView) findViewById(R.id.button_preview);
mButtonApply = (TextView) findViewById(R.id.button_apply);

...

mAlbumsSpinner = new AlbumsSpinner(this);
mAlbumCollection.onCreate(this, this);
</code></pre><ul>
<li>比较值得学习的一点是这里的AlbumsSpinner类，它其实是将Activity左上角的一组控件进行了封装，主要包括显示文件夹名称的TextView，ListPopupWindow，Adapter等等，相当于把一个相对完整的功能抽取出来，把逻辑操作写在里面，在Activity中当做一种控件来使用，有点类似自定义View。观察整个MatisseActivity，发现内部基本只有回调方法，逻辑还是挺清晰的。</li>
</ul>
<pre><code>public class AlbumsSpinner {

private static final int MAX_SHOWN_COUNT = 6;
private CursorAdapter mAdapter;
private TextView mSelected;
private ListPopupWindow mListPopupWindow;
private AdapterView.OnItemSelectedListener mOnItemSelectedListener;
...
</code></pre><ul>
<li>Matisse的数据加载使用 <a href="http://www.jianshu.com/p/385327e35711" target="_blank" rel="external">Loader机制</a>，AlbumCollection是一个LoaderCallbacks的实现，同时提供一个接口给Activity在数据加载时更新UI</li>
</ul>
<pre><code>public interface AlbumCallbacks {
void onAlbumLoad(Cursor cursor);

void onAlbumReset();
}
</code></pre><ul>
<li>当选中文件夹时，调用Activity中的回调方法，如果没有图片就加载一个简单的布局提示用户，有图片就加载一个Fragment，并传入一个Album文件夹对象</li>
</ul>
<pre><code>    @Override
    public void onItemSelected(AdapterView&lt;?&gt; parent, View view, int position, long id) {
mAlbumCollection.setStateCurrentSelection(position);
mAlbumsAdapter.getCursor().moveToPosition(position);
Album album = Album.valueOf(mAlbumsAdapter.getCursor());
if (album.isAll() &amp;&amp; SelectionSpec.getInstance().capture) {
    album.addCaptureCount();
}
onAlbumSelected(album);
    }

    private void onAlbumSelected(Album album) {
if (album.isAll() &amp;&amp; album.isEmpty()) {
    mContainer.setVisibility(View.GONE);
    mEmptyView.setVisibility(View.VISIBLE);
} else {
    mContainer.setVisibility(View.VISIBLE);
    mEmptyView.setVisibility(View.GONE);
    Fragment fragment = MediaSelectionFragment.newInstance(album);
    getSupportFragmentManager()
            .beginTransaction()
            .replace(R.id.container, fragment, MediaSelectionFragment.class.getSimpleName())
            .commitAllowingStateLoss();
    }
} 
</code></pre><ul>
<li>进入到MediaSelectionFragment，在onAttach方法中将Activity作为监听器传来进来</li>
</ul>
<pre><code>    @Override
    public void onAttach(Context context) {
super.onAttach(context);
if (context instanceof SelectionProvider) {
    mSelectionProvider = (SelectionProvider) context;
} else {
    throw new IllegalStateException(&quot;Context must implement SelectionProvider.&quot;);
}
if (context instanceof AlbumMediaAdapter.CheckStateListener) {
    mCheckStateListener = (AlbumMediaAdapter.CheckStateListener) context;
}
if (context instanceof AlbumMediaAdapter.OnMediaClickListener) {
    mOnMediaClickListener = (AlbumMediaAdapter.OnMediaClickListener) context;
}
    }
</code></pre><ul>
<li>各种初始化的操作主要在onActivityCreated当中，比较重要的步骤是通过在Activity中传入的Album对象初始化Loader</li>
</ul>
<pre><code>mAlbumMediaCollection.onCreate(getActivity(), this);
mAlbumMediaCollection.load(album, selectionSpec.capture);

    public void load(@Nullable Album target, boolean enableCapture) {
Bundle args = new Bundle();
args.putParcelable(ARGS_ALBUM, target);
args.putBoolean(ARGS_ENABLE_CAPTURE, enableCapture);
mLoaderManager.initLoader(LOADER_ID, args, this);
}

@Override
    public void onMediaClick(Album album, Item item, int adapterPosition) {
Intent intent = new Intent(this, AlbumPreviewActivity.class);
intent.putExtra(AlbumPreviewActivity.EXTRA_ALBUM, album);
intent.putExtra(AlbumPreviewActivity.EXTRA_ITEM, item);
intent.putExtra(BasePreviewActivity.EXTRA_DEFAULT_BUNDLE, mSelectedCollection.getDataWithBundle());
startActivityForResult(intent, REQUEST_CODE_PREVIEW);
    }
</code></pre><ul>
<li>Fragment图片Item的监听器最终调用到，Activity中的方法，启动预览Activity，这后面就没什么好说的了</li>
</ul>
<pre><code>    @Override
    public void onMediaClick(Album album, Item item, int adapterPosition) {
Intent intent = new Intent(this, AlbumPreviewActivity.class);
intent.putExtra(AlbumPreviewActivity.EXTRA_ALBUM, album);
intent.putExtra(AlbumPreviewActivity.EXTRA_ITEM, item);
intent.putExtra(BasePreviewActivity.EXTRA_DEFAULT_BUNDLE, mSelectedCollection.getDataWithBundle());
startActivityForResult(intent, REQUEST_CODE_PREVIEW);
    }
</code></pre><ul>
<li>另外在RecycleView的AlbumMediaAdapter的onBindViewHolder中，可以发现Matisse将ViewHolder抽取出来，通过preBindMedia和bindMedia来设定Item信息</li>
</ul>
<pre><code>mediaViewHolder.mMediaGrid.preBindMedia(new MediaGrid.PreBindInfo(
        getImageResize(mediaViewHolder.mMediaGrid.getContext()),
        mPlaceholder,
        mSelectionSpec.countable,
        holder
));
mediaViewHolder.mMediaGrid.bindMedia(item);
</code></pre><ul>
<li>ViewHolder中只有一个MediaGrid对象，它是一个正方形的FrameLayout</li>
</ul>
<pre><code>public class MediaGrid extends SquareFrameLayout implements View.OnClickListener {

private ImageView mThumbnail;
private CheckView mCheckView;
private ImageView mGifTag;
private TextView mVideoDuration;

private Item mMedia;
private PreBindInfo mPreBindInfo;
private OnMediaGridClickListener mListener; 
</code></pre><ul>
<li>在MediaGrid中我们可以找到设定图片的方法，engine包下是真正的图片加载工具，包括了默认的GlideEngine和PicassoEngine</li>
</ul>
<pre><code>    private void setImage() {
if (mMedia.isGif()) {
    SelectionSpec.getInstance().imageEngine.loadGifThumbnail(getContext(), mPreBindInfo.mResize,
            mPreBindInfo.mPlaceholder, mThumbnail, mMedia.getContentUri());
} else {
    SelectionSpec.getInstance().imageEngine.loadThumbnail(getContext(), mPreBindInfo.mResize,
            mPreBindInfo.mPlaceholder, mThumbnail, mMedia.getContentUri());
    }
}
</code></pre><ul>
<li>GlideEngine，PicassoEngine是对两个第三方库的封装，实现了ImageEngine接口，ImageEngine中只有几个加载图片的方法，如果要使用自定义的图片加载工具，只需实现这个接口即可，可见使用接口大大地提高了可扩展性</li>
</ul>
<pre><code>    public interface ImageEngine {

    void loadThumbnail(Context context, int resize, Drawable placeholder, ImageView imageView, Uri uri);

    void loadGifThumbnail(Context context, int resize, Drawable placeholder, ImageView imageView, Uri uri);


    void loadImage(Context context, int resizeX, int resizeY, ImageView imageView, Uri uri);

    void loadGifImage(Context context, int resizeX, int resizeY, ImageView imageView, Uri uri);

    boolean supportAnimatedGif();
} 
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[GestureDetector 使用详解]]></title>
      <url>/2017/07/27/Gesture/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<h2 id="GestureDetector"><a href="#GestureDetector" class="headerlink" title="GestureDetector"></a>GestureDetector</h2><ul>
<li>GestureDetector用于识别不同的手势，Down，ShowPress，SingleTapUp，Scroll，LongPress，Fling<pre><code>Down，点击屏幕
ShowPress，短时间内点击屏幕且不抬起或拖动
SingleTapUp，轻击屏幕立即抬起
Scroll，拖动
LongPress，长按屏幕
Fling，滑屏，屏幕上的每次拖动手势最终都会触发Fling，期间Scroll可能会被调用多次，但Fling只被调用一次
</code></pre></li>
</ul>
<ul>
<li>GestureDetector只负责识别手势，创建GestureDetector需要传入监听器以实现手势的反馈</li>
</ul>
<h2 id="OnGestureListener"><a href="#OnGestureListener" class="headerlink" title="OnGestureListener"></a>OnGestureListener</h2><ul>
<li>GestureDetector包含两个接口和一个内部类，OnGestureListener是其中一个接口，有六个回调方法需要实现</li>
</ul>
<pre><code>private class GestureListener implements GestureDetector.OnGestureListener{


@Override
public boolean onDown(MotionEvent e) {

    Log.d(TAG, &quot;onDown: &quot;);
    return false;
}

@Override
public void onShowPress(MotionEvent e) {
    Log.d(TAG, &quot;onShowPress: &quot;);

}

@Override
public boolean onSingleTapUp(MotionEvent e) {
    Log.d(TAG, &quot;onSingleTapUp: &quot;);
    return false;
}

@Override
public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {
    Log.d(TAG, &quot;onScroll: &quot;);
    return false;
}

@Override
public void onLongPress(MotionEvent e) {
    Log.d(TAG, &quot;onLongPress: &quot;);

}

@Override
public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
    Log.d(TAG, &quot;onFling: &quot;);

    return false;
}

}
</code></pre><ul>
<li>构造GestureDetector，传入listener实例</li>
</ul>
<pre><code>GestureDetector detector = new GestureDetector(getContext(),new GestureListener());
</code></pre><ul>
<li>重写onTouchEvent，将事件传递给GestureDetector</li>
</ul>
<pre><code>@Override
public boolean onTouchEvent(MotionEvent event) {

detector.onTouchEvent(event);
return true;
}
</code></pre><ul>
<li>也可以使用setOnTouchListener方法传递Event</li>
</ul>
<pre><code>setOnTouchListener(new OnTouchListener() {
    @Override
    public boolean onTouch(View v, MotionEvent event) {
        return detector.onTouchEvent(event);
    }
});
</code></pre><ul>
<li>在onFling中，我们可以进行一些条件判断</li>
</ul>
<pre><code>@Override
public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
    Log.d(TAG, &quot;onFling: &quot;);
    if(e2.getX()-e1.getX()&gt;0) Log.d(TAG, &quot;onFling: right&quot;);
    if(e2.getX()-e1.getX()&lt;0) Log.d(TAG, &quot;onFling: lift&quot;);
    return false;
}
</code></pre><h2 id="OnDoubleTapListener"><a href="#OnDoubleTapListener" class="headerlink" title="OnDoubleTapListener"></a>OnDoubleTapListener</h2><ul>
<li>OnGestureListener 只能监听单次的点击事件，为了能够监听双击事件还需要OnDoubleTapListener，用法与前者类似</li>
</ul>
<pre><code>    class DoubleListener implements GestureDetector.OnDoubleTapListener{

    @Override
    public boolean onSingleTapConfirmed(MotionEvent e) {
        Log.d(TAG, &quot;onSingleTapConfirmed: &quot;);
        return false;
    }

    @Override
    public boolean onDoubleTap(MotionEvent e) {
        Log.d(TAG, &quot;onDoubleTap: &quot;);
        return false;
    }

    @Override
    public boolean onDoubleTapEvent(MotionEvent e) {
        Log.d(TAG, &quot;onDoubleTapEvent: &quot;);
        return false;
    }
}
</code></pre><ul>
<li>onSingleTapConfirmed只会在单击时被调用</li>
</ul>
<pre><code>onDown -&gt;
onSingleTapUp -&gt;
onSingleTapConfirmed
</code></pre><ul>
<li>onDoubleTap和onDoubleTapEvent会在双击的时候被调用，这里onDoubleTapEvent被调用了两次，第一次event的ACTION为ACTION_DOWN，第二次为ACTION_UP</li>
</ul>
<pre><code>onDown: 
onSingleTapUp: 
onDoubleTap: 
onDoubleTapEvent: 0
onDown: 
onDoubleTapEvent: 1
</code></pre><h2 id="SimpleOnGestureListener"><a href="#SimpleOnGestureListener" class="headerlink" title="SimpleOnGestureListener"></a>SimpleOnGestureListener</h2><ul>
<li>SimpleOnGestureListener是GestureDetector的一个内部类，它实现了前两个接口的所有方法，只不过里面都是空白，通常我们只需要使用到一两个回调方法，这时候使用SimpleOnGestureListener即可</li>
</ul>
<pre><code>    class GestureListener extends GestureDetector.SimpleOnGestureListener{

    @Override
    public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
        Log.d(TAG, &quot;onFling: &quot;);
        return super.onFling(e1, e2, velocityX, velocityY);
    }


    @Override
    public boolean onDoubleTap(MotionEvent e) {
        Log.d(TAG, &quot;onDoubleTap: &quot;);
        return super.onDoubleTap(e);
    }
}
</code></pre><h2 id="Matrix"><a href="#Matrix" class="headerlink" title="Matrix"></a>Matrix</h2><ul>
<li>matrix用于修改图片的各种属性，使用matrix可以对图片进行伸缩，旋转，倾斜，平移等操作<pre><code>Matrix matrix = new Matrix();
setScaleType(ScaleType.MATRIX);
matrix.setScale(10,10);//伸缩变换
matrix.postTranslate(0,100);//平移变换
matrix.postRotate(10);//旋转变换
matrix.postSkew(2,2);//扭曲变换
this.setImageMatrix(matrix);
</code></pre></li>
</ul>
<ul>
<li>Matrix对矩阵的处理分为pre和post两种，前者是矩阵前乘后者是矩阵后乘，但实际使用来说只需要将所有操作过程理解为一组队列，pre先执行post后执行，另外使用set方法会清空之前添加的所有操作</li>
</ul>
<h2 id="ScaleGestureDetector"><a href="#ScaleGestureDetector" class="headerlink" title="ScaleGestureDetector"></a>ScaleGestureDetector</h2><ul>
<li>ScaleGestureDetector专门用于实现放大和缩小的手势操作 </li>
</ul>
<pre><code>ScaleGestureDetector scaleGestureDetector = new ScaleGestureDetector(getContext(), new ScaleListener());
</code></pre><ul>
<li>使用ScaleGestureDetector，需要传入OnScaleGestureListener的实现类，其中有三个方法需要实现，onScaleBegin在开始缩放时调用，也就是使用了两个触控点的时候，onScaleEnd在结束缩放的时候调用，一般可以在两个方法里设置标记。onScale在期间会不断地被调用，可以在其中实现缩放的逻辑</li>
</ul>
<pre><code>@Override
 public boolean onScale(ScaleGestureDetector detector) {
        return true;
    }


@Override
public boolean onScaleBegin(ScaleGestureDetector detector) {

    return true;
}

@Override
public void onScaleEnd(ScaleGestureDetector detector) {


}
</code></pre><ul>
<li>下面来简单实现手势缩放的效果，在onScale中通过ScaleGestureDetector得到ScaleFactor缩放因子，它是ScaleGestureDetector通过当前的手势得到的Scale值，getFocusX和getFocusY是两触点之间的焦点，将这几个参数传入即可，另外可以在这之前获取当前的Scale值进行检查</li>
</ul>
<pre><code>@Override
    public boolean onScale(ScaleGestureDetector detector) {

    if(getScaleSize()&gt;2&amp;&amp;detector.getScaleFactor()&gt;1
            ||getScaleSize()&lt;0.5&amp;&amp;detector.getScaleFactor()&lt;1){
        return true;
    }

    mCurrentMatrix.postScale(detector.getScaleFactor(),detector.getScaleFactor(),detector.getFocusX(),detector.getFocusY());
    setImageMatrix(mCurrentMatrix);


    return true;
}

public float getScaleSize(){

    float[] value = new float[9];
    mCurrentMatrix.getValues(value);

    return value[Matrix.MSCALE_X];
}
</code></pre><ul>
<li>在onScaleBegin和onScaleEnd方法中简单地设置标记，提供给外界判断当前状态</li>
</ul>
<pre><code>@Override
public boolean onScaleBegin(ScaleGestureDetector detector) {

    isScaling = true;
    return true;
}

@Override
public void onScaleEnd(ScaleGestureDetector detector) {
    isScaling = false;

}   
</code></pre><h2 id="ActionEvent"><a href="#ActionEvent" class="headerlink" title="ActionEvent"></a>ActionEvent</h2><ul>
<li>在onTouch方法中我们可以通过获取Event的getAction方法得到触摸的事件类型， 事件类型代表了一系列的动作，系统不断地传进Event对象为我们动态地响应操作提供了可能，下面是主要的动作类型</li>
</ul>
<pre><code>/**
* A pressed gesture has started
* 表示用户开始触碰
*/
public static final int ACTION_DOWN             = 0;

/**
* A pressed gesture has finished
*表示用户抬起了手指
*/
public static final int ACTION_UP               = 1;

/**
* A change has happened during a
* press gesture (between {@link #ACTION_DOWN} and {@link #ACTION_UP}).
* 表示手指在移动
*/

public static final int ACTION_MOVE             = 2;

/**
* The current gesture has been aborted.
* You will not receive any more points in it.  You should treat this as
* an up event, but not perform any action that you normally would.
* 手势被取消，类似ACTION_UP但是后续的操作并不会被执行
*/

public static final int ACTION_CANCEL           = 3;

/**
* A movement has happened outside of the
* normal bounds of the UI element.
* 用户的手指超过了UI边界
*/
public static final int ACTION_OUTSIDE          = 4;

/**
* A non-primary pointer has gone down.
* 用户按下了另一只手指
*/
public static final int ACTION_POINTER_DOWN     = 5;

/**
* A non-primary pointer has gone up.
* 用户抬起了一只手指
* 
*/
public static final int ACTION_POINTER_UP       = 6; 
</code></pre><h2 id="TouchListener"><a href="#TouchListener" class="headerlink" title="TouchListener"></a>TouchListener</h2><ul>
<li>使用TouchListener，我们可以利用 ActionEvent的ACTION类型进行一些其他的操作，只有一个onTouch方法需要重写</li>
</ul>
<ul>
<li>下面实现一个拖拽图片的手势效果，首先需要将Event传递给其他监听器，接着获取ACTION类型当用户点击时记录下点击的坐标然后在移动时不断更新坐标并根据位移移动我们的图片，注意此时会和刚刚实现的缩放操作产生冲突，使用标记为进行判断，另外还可以使用控件的宽和高进行边界的设定</li>
</ul>
<pre><code>   private class TouchListener implements OnTouchListener {

   @Override
   public boolean onTouch(View v, MotionEvent event) {

       scaleGestureDetector.onTouchEvent(event);
       gestureDetector.onTouchEvent(event);

       switch (event.getAction()){
           case MotionEvent.ACTION_DOWN:

               mCurrentMatrix.set(getImageMatrix());
               moveY = event.getY();
               moveX = event.getX();

               break;
           case MotionEvent.ACTION_MOVE:

               float x = event.getX();
               float y = event.getY();

               if(!isScaling&amp;&amp;(getWidth()/5&lt;x&amp;&amp;x&lt;getWidth()*4/5
                       ||getHeight()/5&lt;y&amp;&amp;y&lt;getHeight()*4/5)) {

                   mCurrentMatrix.postTranslate(x - moveX, y - moveY);
                   setImageMatrix(mCurrentMatrix);

               }
               moveX = x;
               moveY = y;

               break;

           default:
               break;
       }
       return true;
   }
} 
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Volley 源码分析]]></title>
      <url>/2017/07/19/Volley/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><strong>Volley是一套比较完善的网络框架，它可以自动调度网络请求，实现并发的网络连接，并且可以很方便的更新UI</strong></p>
<ul>
<li>添加依赖</li>
</ul>
<pre><code>compile &apos;com.mcxiaoke.volley:library:1.0.19&apos;
</code></pre><h2 id="StringRequest，JsonRequest"><a href="#StringRequest，JsonRequest" class="headerlink" title="StringRequest，JsonRequest"></a>StringRequest，JsonRequest</h2><ul>
<li>一般使用Volley会包括三个部分，创建requestQueue对象，创建request对象，将request对象添加到requestQueue对象当中</li>
<li>requestQueue对象不需要每次都创建，它是一个请求队列</li>
</ul>
<pre><code>mQueue = Volley.newRequestQueue(NewsApplication.getNewsContext());
</code></pre><ul>
<li>创建request对象，我们需要服务器地址和两个监听器，然后将其添加到队列即可</li>
</ul>
<pre><code>public static void  getString(String url,   Response.Listener&lt;String&gt; listener,Response.ErrorListener errorListener){

    StringRequest stringRequest = new StringRequest(url,listener,errorListener);
    mQueue.add(stringRequest);

} 
</code></pre><ul>
<li>Response.Listener 和 Response.ErrorListener 中我们需要分别实现成功加载时和加载失败时的回调方法</li>
</ul>
<pre><code>    @Override
public void onErrorResponse(VolleyError error) {
Log.d(TAG, &quot;onErrorResponse: &quot;);

}

...
public void onResponse(String response) {
Log.d(TAG, &quot;onResponse:&quot;);

}
</code></pre><ul>
<li>Volley 没有提供默认的post方法，但是我们可以重写getParams方法，将POST参数放入一个map容器中返回即可</li>
</ul>
<pre><code>        protected Map&lt;String, String&gt; getParams() throws AuthFailureError {
    Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
    map.put(&quot;params1&quot;, &quot;value1&quot;);
    map.put(&quot;params2&quot;, &quot;value2&quot;);
    return map;
}
</code></pre><h2 id="ImageRequest"><a href="#ImageRequest" class="headerlink" title="ImageRequest"></a>ImageRequest</h2><ul>
<li><p>ImageRequest专门用于加载网络图片，使用方法和StringRequest和JsonRequest有小小的差别</p>
</li>
<li><p>ImageRequest的构造方法有七个参数，分别为链接，含有加载成功时的回调方法的监听器，最大的长和宽，缩放模式，颜色属性，加载失败的监听器，当不需要限制长宽时可以将参数设置为0，图片参数一般设置为 Config.RGB_565 即可</p>
</li>
</ul>
<pre><code>public ImageRequest(String url, Response.Listener&lt;Bitmap&gt; listener, int maxWidth, int maxHeight,
    ScaleType scaleType, Config decodeConfig, Response.ErrorListener errorListener)
...

ImageRequest imageRequest = new ImageRequest(url,

        new Response.Listener&lt;Bitmap&gt;() {
    @Override
    public void onResponse(Bitmap response) {
        imageView.setImageBitmap(response);
    }

}, 0,0, ImageView.ScaleType.CENTER_INSIDE, Bitmap.Config.RGB_565,

        new Response.ErrorListener() {
    @Override
    public void onErrorResponse(VolleyError error) {

    }

});
</code></pre><h2 id="ImageLoader"><a href="#ImageLoader" class="headerlink" title="ImageLoader"></a>ImageLoader</h2><ul>
<li>ImageRequest 使用起来还是比较麻烦的，使用ImageLoader会比较简洁而且它支持了缓存功能</li>
<li>创建ImageLoader对象需要请求队列和缓存对象，Imageloader为回调方法做了封装，我们只需要提供ImageView和成功及失败时使用的资源图片即可</li>
</ul>
<pre><code>public static void getImage(String url, ImageLoader.ImageCache cache, ImageView imageView){

setQueue();
ImageLoader imageLoad = new ImageLoader(mQueue,cache);
ImageLoader.ImageListener listener = ImageLoader.getImageListener(imageView, R.drawable.downing,R.drawable.failed);
imageLoad.get(url,listener);

}
</code></pre><ul>
<li>一般使用LruCache来缓存，让它实现ImageCache接口即可，这个接口只需实现将Bitmap加入缓存和取出缓存的方法</li>
</ul>
<pre><code>@Override
public Bitmap getBitmap(String url) {
return mCache.get(url);
}

@Override
public void putBitmap(String url, Bitmap bitmap) {

mCache.put(url,bitmap);
}
</code></pre><h2 id="NetworkImageView"><a href="#NetworkImageView" class="headerlink" title="NetworkImageView"></a>NetworkImageView</h2><ul>
<li>NetworkImageView是一个封装了请求操作的图片控件，我们只需要提供一个imageLoad对象和url即可</li>
</ul>
<pre><code>&lt;com.android.volley.toolbox.NetworkImageView
android:id=&quot;@+id/theme_iv_header&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;360dp&quot; /&gt;

...  
ivHeader.setImageUrl(imageUrl,new ImageLoader(DataFromVolley.getQueue(),new BitmapCache(BitmapCache.MAX_MEMORY /8)));
</code></pre><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><ul>
<li>我们使用Volley的第一步，是调用newRequestQueue方法创建请求队列，那么先来查看这个方法，它的内部经过了几次直接的return，之后我们来到这里</li>
</ul>
<pre><code>    public static RequestQueue newRequestQueue(Context context, HttpStack stack, int maxDiskCacheBytes) {


    ... 

    if (stack == null) {
        if (Build.VERSION.SDK_INT &gt;= 9) {
            stack = new HurlStack();
        } else {
            // Prior to Gingerbread, HttpUrlConnection was unreliable.
            // See: http://android-developers.blogspot.com/2011/09/androids-http-clients.html
            stack = new HttpClientStack(AndroidHttpClient.newInstance(userAgent));
        }
    }

    Network network = new BasicNetwork(stack);

    RequestQueue queue;
    if (maxDiskCacheBytes &lt;= -1)
    {
        // No maximum size specified
        queue = new RequestQueue(new DiskBasedCache(cacheDir), network);
    }
    else
    {
        // Disk cache size specified
        queue = new RequestQueue(new DiskBasedCache(cacheDir, maxDiskCacheBytes), network);
    }

    queue.start();

    return queue;
}   
</code></pre><ul>
<li>我们看到这里判断了 Build.VERSION.SDK_INT ，以此根据不同的安卓版本创建了两个Stack类的实例，查看注释这两个类分别是基于HttpURLConnection和HttpClient来实现的，在较新的版本上使用的是 HttpURLConnection。所以我们可以知道Volley真正的网络操作实际交由这两者来执行的。</li>
</ul>
<pre><code>/**
* An {@link HttpStack} based on {@link      HttpURLConnection}.
*/ 

/**
* An HttpStack that performs request over an {@link         HttpClient}.
*/
</code></pre><ul>
<li>创建完stack对象，networ对象和请求队列queue之后，queue的start方法执行了，查看这个方法的内部</li>
</ul>
<pre><code>public void start() {
stop();  // Make sure any currently running dispatchers are stopped.
// Create the cache dispatcher and start it.
mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);
mCacheDispatcher.start();

// Create network dispatchers (and corresponding threads) up to the pool size.
for (int i = 0; i &lt; mDispatchers.length; i++) {
    NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork,
            mCache, mDelivery);
    mDispatchers[i] = networkDispatcher;
    networkDispatcher.start();
}
}
</code></pre><ul>
<li>start 方法中主要有两个对象 mCacheDispatcher和networkDispatcher，查看继承关系，得知他们是 Thread 子类的实例，同一时刻会有一个CacheDispatcher线程和多个NetworkDispatcher线程在执行，从名字就可以看出CacheDispatcher用来执行缓存操作而NetworkDispatcher用来执行网络操作，找到前者的run方法</li>
</ul>
<pre><code>public void run() {
if (DEBUG) VolleyLog.v(&quot;start new dispatcher&quot;);
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);

// Make a blocking call to initialize the cache.
mCache.initialize();

Request&lt;?&gt; request;
while (true) {
    // release previous request object to avoid leaking request object when mQueue is drained.
    request = null;
    try {
        //这里从请求队列拿出了请求
        // Take a request from the queue.
        request = mCacheQueue.take();
    }

    ....

        // Attempt to retrieve this item from cache.
        Cache.Entry entry = mCache.get(request.getCacheKey());

        //查看是否有缓存，没有则交给网络队列
        if (entry == null) {
            request.addMarker(&quot;cache-miss&quot;);
            // Cache miss; send off to the network dispatcher.
            mNetworkQueue.put(request);
            continue;
        }

        // If it is completely expired, just send it to the network.
        if (entry.isExpired()) {
            request.addMarker(&quot;cache-hit-expired&quot;);
            request.setCacheEntry(entry);
            mNetworkQueue.put(request);
            continue;
        }

        // We have a cache hit; parse its data for delivery back to the request.

            // Post the intermediate response back to the user and have
            // the delivery then forward the request along to the network.
            final Request&lt;?&gt; finalRequest = request;
            mDelivery.postResponse(request, response, new Runnable() {
                @Override
                public void run() {
                    try {
                        mNetworkQueue.put(finalRequest);
                    } catch (InterruptedException e) {
                        // Not much we can do about this.
                    }
                }
            });
        }
    }
</code></pre><ul>
<li><p>可以看到CacheDispatcher缓存线程会先检查它的请求队列mCacheQueue中各个请求的数据是否在缓存中，如果缓存中没有就加入到NetworkDispatcher网络线程处理的队列mNetworkQueue，让NetworkDispatcher去处理。注意这里的循环是while (true)，所以我们调用newRequestQueue最后就是为了开启了这几个无限循环处理请求的线程，注意这里的队列都是PriorityBlockingQueue，也就是优先级队列</p>
</li>
<li><p>线程已经打开了但是这时还没有请求，那么再来看看我们调用的add方法，终于看到比较短的代码了…</p>
</li>
</ul>
<pre><code>public &lt;T&gt; Request&lt;T&gt; add(Request&lt;T&gt; request) {
// Tag the request as belonging to this queue and add it to the set of current requests.
request.setRequestQueue(this);
synchronized (mCurrentRequests) {
    mCurrentRequests.add(request);
}

// Process requests in the order they are added.
request.setSequence(getSequenceNumber());
request.addMarker(&quot;add-to-queue&quot;);

// If the request is uncacheable, skip the cache queue and go straight to the network.
if (!request.shouldCache()) {
    mNetworkQueue.add(request);
    return request;
}

// Insert request into stage if there&apos;s already a request with the same cache key in flight.
synchronized (mWaitingRequests) {
    String cacheKey = request.getCacheKey();
    if (mWaitingRequests.containsKey(cacheKey)) {
        // There is already a request in flight. Queue up.
        Queue&lt;Request&lt;?&gt;&gt; stagedRequests = mWaitingRequests.get(cacheKey);
        if (stagedRequests == null) {
            stagedRequests = new LinkedList&lt;Request&lt;?&gt;&gt;();
        }
        stagedRequests.add(request);
        mWaitingRequests.put(cacheKey, stagedRequests);
        if (VolleyLog.DEBUG) {
            VolleyLog.v(&quot;Request for cacheKey=%s is in flight, putting on hold.&quot;, cacheKey);
        }
    } else {
        // Insert &apos;null&apos; queue for this cacheKey, indicating there is now a request in
        // flight.
        mWaitingRequests.put(cacheKey, null);
        mCacheQueue.add(request);
    }
    return request;
}
} 
</code></pre><ul>
<li>add方法几乎每一步都加了注释，还是很好解读的，去掉一些判断逻辑，发现add方法其实是先检查我们传进来的请求是否需要缓存，如果不需要就直接加入上NetworkDispatcher处理的队列否则就加入CacheDispatcher的队列，一般请求都是默认可以缓存的，到了这里队列就有请求了</li>
</ul>
<ul>
<li>现在再来看看请求得到的response是怎么回到主线程处理的，reponse是由之前提到的NetWork对象操作stack对象（HttpURLConnection或者HttpClient）得到的，置于怎么操作不是很重要，不去研究。我们看到NetworkDispatcher的run方法最后使用ResponseDelivery mDelivery的一个post方法，顾名思义，response被传递了，点进去发现ResponseDelivery是一个接口，所以还得去找找他是在哪创建的</li>
</ul>
<pre><code>mDelivery.postResponse(request, response);
</code></pre><ul>
<li>找了半天发现它是在RequestQueue被创建时调用的，也就是在newRequestQueue方法的过程中，它的实现类是ExecutorDelivery，这里我们看到它持有了一个MainLooper，已经大概可以猜到内部实现了</li>
</ul>
<pre><code>public RequestQueue(Cache cache, Network network, int threadPoolSize) {
this(cache, network, threadPoolSize,
        new ExecutorDelivery(new Handler(Looper.getMainLooper())));
}
</code></pre><ul>
<li>找到之前 postResponse 方法的具体实现， 它调用了mResponsePoster 的 execute方法  <pre><code>              @Override
public void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable) {
request.markDelivered();
request.addMarker(&quot;post-response&quot;);
mResponsePoster.execute(new ResponseDeliveryRunnable(request, response, runnable));
}
</code></pre></li>
</ul>
<ul>
<li>execute其实就是handler的post方法，由于已经知道handler持有的是mainLooper，因此response可以在主线程处理了</li>
</ul>
<pre><code>mResponsePoster = new Executor() {
    @Override
    public void execute(Runnable command) {
        handler.post(command);
    }
};
</code></pre><ul>
<li>那么这里post的Runnable又是什么呢，查看ExecutorDelivery，也就是之前接受了MainLooper的那个类，看来这个Runnable是它的内部类，当请求成功时调用deliverResponse，不成功时调用deliverError，在进去阅读文档得知这两个方法最终会调用Listener的回调方法，也就是我们熟悉的onResponse方法了，值得注意的是这个Runnable的run方法里面又执行了另一个Runnable的run方法，在NetworkDispatcher中这个传入的Runnable是null，这个Runnable是用于CacheDispatcher得到缓存后可以直接回到主线程而存在的</li>
</ul>
<pre><code>    @Override
    public void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response) {
    postResponse(request, response, null);
    }

    @Override
    public void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable) {
    request.markDelivered();
    request.addMarker(&quot;post-response&quot;);
    mResponsePoster.execute(new ResponseDeliveryRunnable(request, response, runnable));
    }


    /**
    * A Runnable used for delivering network responses to a listener on the
    * main thread.
    */
@SuppressWarnings(&quot;rawtypes&quot;)
private class ResponseDeliveryRunnable implements Runnable {
    private final Request mRequest;
    private final Response mResponse;
    private final Runnable mRunnable; 
    ...
            public void run() {
                        if (mResponse.isSuccess()) {
        mRequest.deliverResponse(mResponse.result);
    } else {
        mRequest.deliverError(mResponse.error);
    }
    ...
                if (mRunnable != null) {
        mRunnable.run();
    }
    ...
</code></pre><p>*<br>* 这样我们就把Volley的机制大致过了一遍，我们发现Volley实现了并发的异步请求，数据缓存，优先级，同时有一个RequestQueue来同一存放请求，相对于我们单独地使用HttpURLConnection，它减少了大量线程开启和销毁带来的消耗，还是有比较多的优点的，另外使用它的时候要特别注意不要多次创建RequestQueue队列，否则会开启很多长期运行的线程</p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ViewPager+TabLayout+Fragment 实现懒加载]]></title>
      <url>/2017/07/17/ViewPagerTabFragments/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><strong>本篇乙烷</strong></p>
<h2 id="TabLayout"><a href="#TabLayout" class="headerlink" title="TabLayout"></a>TabLayout</h2><p><strong>水平展示标签的布局，在Google推出TabLayout之前，一般使用TabActivity或者ViewPageIndicator等第三方库实现这种功能</strong></p>
<ul>
<li>使用之前需要先添加支持库</li>
</ul>
<pre><code>compile &apos;com.android.support:design:24.2.1&apos;
</code></pre><ul>
<li>像普通控件一样，在需要的地方设置XML属性，注意app:tabMode属性一般设置为滚动，因为当标签数目较少时scrollable默认是静止的，而当标签数目较多时如果没有设置这个属性时，Tab不能滚动，文字会显示不全</li>
</ul>
<pre><code>&lt;android.support.design.widget.TabLayout
android:id=&quot;@+id/tab&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;wrap_content&quot;
app:tabMode=&quot;scrollable&quot;/&gt;
</code></pre><ul>
<li>动态添加Tab，使用addTag方法和newTab方法</li>
</ul>
<pre><code>for(int i = 0;i&lt;10;i++){
    tabLayout.addTab(tabLayout.newTab().setText(&quot;NO: &quot;+i));
}
</code></pre><ul>
<li>这时一个TabLayout已经可以正常显示了，但是它并没有什么作用，TabLayout一般与ViewPager相结合，实现翻页的功能</li>
</ul>
<h2 id="FragmentPagerAdapter"><a href="#FragmentPagerAdapter" class="headerlink" title="FragmentPagerAdapter"></a>FragmentPagerAdapter</h2><p>** 用于显示一组Fragment的ViewPager的Adapter**</p>
<ul>
<li>必须实现的方法有两个，和pagerAdapter的含义基本一致，在getItem中根据位置返回Fragment，getcount中返回item总数量</li>
</ul>
<pre><code>public FragmentAdapter(FragmentManager fm,List&lt;Fragment&gt; list) {
super(fm);
this.list = list;

}

@Override
public Fragment getItem(int position) {
return list.get(position);
}

@Override
public int getCount() {
return list.size();
}
</code></pre><ul>
<li>为Fragment设定Adapter之后调用tabLayout的setupWithViewPager方法即可将TabLayout和ViewPager关联起来</li>
</ul>
<pre><code>FragmentAdapter fragmentAdapter = new FragmentAdapter(getSupportFragmentManager(),fragments);
viewPager.setAdapter(fragmentAdapter);
tabLayout.setupWithViewPager(viewPager); 
</code></pre><ul>
<li>注意如果在之前设置了文字，这些文字会被<a href="http://blog.csdn.net/u013233097/article/details/54708202" target="_blank" rel="external">清除</a>，将这个步骤放在这之后即可</li>
</ul>
<pre><code>for(int i = 0;i\&lt;10;i++){
        tabLayout.getTabAt(i).setText(&quot;No：&quot;+i);
    }
</code></pre><ul>
<li>显示效果是这样的</li>
</ul>
<ul>
<li><img src="http://i1.buimg.com/1949/3df635474afa9281.png" alt=""></li>
</ul>
<h2 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h2><ul>
<li>ViewPager默认会缓存三页数据，这个属性是由DEFAULT_OFFSCREEN_PAGES决定的，可以使用setOffscreenPageLimit方法设定预加载的页数，但是没有办法设定为0</li>
<li>如果预加载的每个Fragment都去加载数据，Activity的创建时会造成卡顿，所以我们需要在页面切换到可见时再去加载数据</li>
<li>为了解决这个问题，必须从Fragment中入手，Fragment中含有setUserVisibleHint方法，它会在onCreateView之前被调用一次出入false参数，表示Fragment不可见，之后在每次Fragment变为可见时传入true，不可见时传入false</li>
<li>首先需要创建Fragment的子类作为我们使用Fragment的基类，设定三个标记，分别表示当前Fragment是否可见，布局是否已经加载，Fragment是否为第一次可见</li>
</ul>
<pre><code>    private boolean isVisible;
private boolean isPrepared;
private boolean isFirst; 
</code></pre><ul>
<li>在setUserVisibleHint方法中设置isVisible标记，注意必须调用父类的方法，否则在需要使用getUserVisibleHint时可能得到错误的返回值</li>
</ul>
<pre><code>@Override
public void setUserVisibleHint(boolean isVisibleToUser) {
    if(isVisibleToUser){
        isVisible = true;
        Log.d(TAG, &quot;setUserVisibleHint: fragment NO: &quot;+getArguments().getInt(&quot;name&quot;,0)+&quot; true&quot;);
        loadData();

    }else {
        isVisible = false;
        Log.d(TAG, &quot;setUserVisibleHint: fragment NO: &quot;+getArguments().getInt(&quot;name&quot;,0)+&quot; false&quot;);

    }
    super.setUserVisibleHint(isVisibleToUser);
}
</code></pre><ul>
<li>在onCreateView中返回RootView，注意判空，并设置isPrepared标记，当然，直接判断RootView是否为空也能起到isPrepared标记的作用</li>
</ul>
<pre><code>@Override
public View onCreateView(LayoutInflater inflater, ViewGroup container,
                     Bundle savedInstanceState) {

if(mRoot ==null){
    mRoot = initView(inflater,container);
    Log.d(TAG, &quot;onCreateView: &quot;);
}            
    isPrepared = true;
return mRoot;
}
</code></pre><ul>
<li>在setUserVisibleHint中调用了loadData方法，它大致上是这样的，在加载数据之前先检查一下三个标记</li>
</ul>
<pre><code>void loadData(){
if(isFirst&amp;&amp;isPrepared&amp;&amp;isVisible) {
    Log.d(TAG, &quot;loadData: --------------&quot;);
    Log.d(TAG, &quot;loadData: &quot;+ getArguments().getInt(&quot;name&quot;,0));
    isFirst = false;
   return;
}
    ...
}
</code></pre><ul>
<li>注意在onActivityCreated中也要调用一次loadData方法这是因为当ViewPager第一次加载两个Fragment时，setUserVisibleHint 在 onCreateView之前调用了，这时 isPrepared是false，当然无法加载数据。如果不在onActivityCreated中调用loadData方法，第一页的数据将无法在第一次显示时初始化</li>
</ul>
<pre><code>@Override
public void onActivityCreated(@Nullable Bundle savedInstanceState) {
super.onActivityCreated(savedInstanceState);

Log.d(TAG, &quot;onActivityCreated: &quot;+ getArguments().getInt(&quot;name&quot;,0));
loadData();

}
</code></pre><ul>
<li>下面滑动页面进行测试，可以看到进入Activity和翻页时虽然各个Fragment都有回应ViewPager的缓存机制，但是只有到它们被显示时才会去加载数据，懒加载的目的达成了，当需要使用这个Fragment时重写loadData方法和initView方法即可  </li>
</ul>
<pre><code>onActivityCreated: 0
loadData: --------------
loadData: 0
initView: 
onCreateView: 
onActivityCreated: 1

setUserVisibleHint: fragment NO: 2 false
setUserVisibleHint: fragment NO: 0 false
setUserVisibleHint: fragment NO: 1 true

loadData: 1
initView: 
onCreateView: 
onActivityCreated: 2
setUserVisibleHint: fragment NO: 3 false
setUserVisibleHint: fragment NO: 1 false
setUserVisibleHint: fragment NO: 2 true
loadData: --------------
loadData: 2
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Activity 知识补充]]></title>
      <url>/2017/07/10/AdditionOfActivity/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><strong>参考资料</strong></p>
<p><a href="http://blog.csdn.net/liuhe688/article/details/6733407" target="_blank" rel="external">liuhe688</a></p>
<p><a href="http://blog.csdn.net/weizongwei5/article/details/50515719" target="_blank" rel="external">weizongwei5</a></p>
<p><a href="http://download.csdn.net/detail/jsntghf/9602444" target="_blank" rel="external">Android开发艺术探索</a></p>
<p>**<br>第一行代码中Activity的内容比较简单，因此额外找了一些内容进一步学习<br>**</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul>
<li>首先看一下<a href="https://alberthumbert.github.io/2017/04/30/firstCodeLine/#%E6%B4%BB%E5%8A%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">Android生命周期的普通过程</a>，这一部分应该已经学习过几遍了，不再赘述，通过一个简单的demo进行回顾，稍后修改这个demo并切入主题</li>
</ul>
<pre><code>public class LifeActivity extends AppCompatActivity {

    private static final String TAG = &quot;LifeActivity&quot;;
    @Override
    protected void onCreate(Bundle savedInstanceState){
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_life);
        Log.i(TAG, &quot;onCreate called&quot;);
    }

    @Override
    protected void onStart() {
        super.onStart();
        Log.i(TAG, &quot;onStart called&quot;);
    }

 @Override
    protected void onRestart() {
        super.onRestart();
        Log.i(TAG, &quot;nRestart called&quot;);
    }

    @Override
    protected void onResume() {
        super.onResume();
        Log.i(TAG, &quot;onResume called&quot;);
    }

    @Override
    protected void onPause() {
        super.onPause();
        Log.i(TAG, &quot;onPause called&quot;);
    }

    @Override
    protected void onStop() {
        super.onStop();
        Log.i(TAG, &quot;onStop called&quot;);
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        Log.i(TAG, &quot;onDestroy called&quot;);
    }
}
</code></pre><ul>
<li>启动Activity</li>
</ul>
<pre><code>LifeActivity: onCreate called
LifeActivity: onStart called
LifeActivity: onResume called
</code></pre><ul>
<li>启动另一个Activity，可以看到前一个Activity的onPause执行之后下一个Activity的onCreated才会执行，这就是onPause耗时操作要少的原因，应当考虑能否将这部分操作在onStoped进行</li>
</ul>
<pre><code>LifeActivity: onPause called
AnotherActivity: onCreate called
AnotherActivity: onStart called
AnotherActivity: onResume called
LifeActivity: onStop called
</code></pre><ul>
<li>back键返回LifeActivity，同样前一个Activity的onPause执行后下一个Activity的onRestart才会执行</li>
</ul>
<pre><code>AnotherActivity: onPause called
LifeActivity: onRestart called
LifeActivity: onStart called
AnotherActivity: onStop called
AnotherActivity: onDestroy called
</code></pre><ul>
<li>点击home键</li>
</ul>
<pre><code>LifeActivity: onPause called
LifeActivity: onStop called     
</code></pre><ul>
<li>点击home键后回到应用</li>
</ul>
<pre><code>lifeActivity: oRestart called
ifeActivity: onStart called
LifeActivity: onResume called
</code></pre><p>**<br>接下来对这些调用方法进行一些奇怪的操作<br>**</p>
<ul>
<li>在onCreate执行之前让Activity结束</li>
</ul>
<pre><code>...
finish();
super.onCreate(savedInstanceState);
...
</code></pre><ul>
<li>输出</li>
</ul>
<pre><code>LifeActivity: onCreate called
LifeActivity: onDestroy called
</code></pre><ul>
<li>很正常，onCreate被完整执行后onDestory()被执行了</li>
</ul>
<ul>
<li>在onStart()中执行finish()，从结果可见没有进入前台期，与onStart对应的onStop被执行了</li>
</ul>
<pre><code>onStart called
onStop called
onDestroy called
</code></pre><ul>
<li>接下来尝试在onRestart()中执行finish()，然后在第二个Activity中按back键。有点奇怪，LifeActivity并不直接执行onStop，而是回到了前台，经历了一个非常完整的生命周期并且在第二个Activity之前被销毁</li>
</ul>
<pre><code>AnotherActivity: onPause called
LifeActivity: onRestart called
LifeActivity: onStart called
LifeActivity: onResume called
LifeActivity: onPause called
LifeActivity: onStop called
LifeActivity: onDestroy called
AnotherActivity: onStop called
AnotherActivity: onDestroy called
</code></pre><ul>
<li>到这里本来想测试一下Activity因内存不足而被销毁会经历什么过程，于是把虚拟机内存调为了128m，但是没能成功实现内存不足的情况…搜索到了使用adb模拟内存不足销毁应用的方法</li>
</ul>
<pre><code>adb shell am kill-all
adb shell am kill package-name 
# 我们关注的应用只有一个，所以这两个命令是一样的
</code></pre><ul>
<li>如无意外，应用会被kill，然而这里出现一个错误导致缓冲区被锁，log无法打印，暂时没有找到解决办法，实在不行以后下载个大点的游戏进行真机调试……</li>
</ul>
<pre><code>E/Surface: getSlotFromBufferLocked: unknown buffer: 0xb40152c0
</code></pre><ul>
<li>另外屏幕旋转会导致Activity被销毁重建，销毁过程为</li>
</ul>
<pre><code>AnotherActivity: onPause called
AnotherActivity: onStop called
AnotherActivity: onDestroy called
</code></pre><h2 id="onWindowFocusChanged"><a href="#onWindowFocusChanged" class="headerlink" title="onWindowFocusChanged"></a>onWindowFocusChanged</h2><p>**<br>这个方法会在Activity窗口获得或失去焦点被调用，和生命周期方法一样，程序员不应该自己去调用它<br>**</p>
<pre><code>onResume called
onWindowFocusChanged called
</code></pre><ul>
<li>当我们在想在onCreate方法中获取组件大小时，有可能会因为window对象未创建而失败，必须保证在onCreate方法完成之后再执行</li>
<li>重写onWindowFocusChanged方法可以解决这个问题</li>
</ul>
<h2 id="onSaveInstanceState"><a href="#onSaveInstanceState" class="headerlink" title="onSaveInstanceState"></a>onSaveInstanceState</h2><p>**<br>这是一个为了Activity被调离栈顶时保存数据而存在的方法<br>**</p>
<ul>
<li>被调用的位置，下一个活动进入前台，而之前的活动转为不可见时</li>
</ul>
<pre><code>AnotherActivity: onResume called
LifeActivity: onSaveInstanceState called
LifeActivity: onStop called
</code></pre><ul>
<li>注意一个会被销毁的Activity是不会调用这个方法的，只在可以被返回的Activity中重写它</li>
</ul>
<pre><code>    @Override
    protected void onSaveInstanceState(Bundle outState){
    outState.putInt(&quot;param&quot;,param);
    Log.i(TAG, &quot;onSaveInstanceState called&quot;);
}
</code></pre><h2 id="onRestoreInstanceState"><a href="#onRestoreInstanceState" class="headerlink" title="onRestoreInstanceState"></a>onRestoreInstanceState</h2><p>**<br>生命周期相关的方法总是两两配对，而onRestoreInstanceState的作用自然是获取保留下来的数据了，不过它的情况有点特殊，只会在Activity在后台被杀死或者屏幕旋转时被调用<br>**</p>
<ul>
<li>同样重写这个方法，以键值对的形式得到数据</li>
</ul>
<pre><code>@Override
    protected void onRestoreInstanceState(Bundle savedInstanceState){
        param = savedInstanceState.getInt(&quot;param&quot;);
        Log.i(TAG, &quot;onRestoreInstanceState called get&quot;+param);
        super.onRestoreInstanceState(savedInstanceState);
    } 
</code></pre><ul>
<li>旋转屏幕并恢复</li>
</ul>
<pre><code>LifeActivity: onCreate called
LifeActivity: onStart called
LifeActivity: onRestoreInstanceState called get 1
LifeActivity: onResume called
LifeActivity: onWindowFocusChanged called 
</code></pre><h2 id="启动模式与Flags"><a href="#启动模式与Flags" class="headerlink" title="启动模式与Flags"></a>启动模式与Flags</h2><p>**<br>除了<a href="https://alberthumbert.github.io/2017/04/30/firstCodeLine/#%E5%9B%9B%E4%B8%AA%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F">在XML中设置启动模式</a>，<br>下面还有一种设置启动模式的方法<br>**</p>
<ul>
<li>Flags标记位有许多作用，其中一种是设置启动模式</li>
<li><p>Flags标记位的优先级要大于XML属性，但它无法设置singleInstance模式，使用方式如下</p>
<pre><code>public static void actionStart(Context context){

        Intent intent = new Intent(context,FlagActivity.class);
        intent.addFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
        context.startActivity(intent);
    }
</code></pre></li>
</ul>
<ul>
<li>几种常用的Flags</li>
</ul>
<pre><code>FLAG_ACTIVITY_NEW_TASK
//指定singleTask模式

FLAG_ACTIVITY_SINGLE_TOP
//指定singleTop模式

FLAG_ACTIVITY_CLEAR_TOP
//启动时所用该Activity之上的Activity全部出栈，一般与singleTask一起使用
//如果采用standard模式，该Activity与其上的Activity会出栈并建立新的Activity

FLAG_ACTIVITY_FROM_RECENTS
//Activity不出现在历史列表中
</code></pre><ul>
<li><p>我们使用 FLAG_ACTIVITY_NEW_TASK 为例循环启动3个Activity，不在XML中标记，可以看出依然为standard模式</p>
<pre><code>Run #6: ActivityRecord{fd1d8c9 u0 com.linjiamin.myapplication/.NewTaskActivity t138}
 Run #5: ActivityRecord{47b8982 u0 com.linjiamin.myapplication/.NewTaskActivity t138}
 Run #4: ActivityRecord{60095cc u0 com.linjiamin.myapplication/.MainActivity t138}
 Run #3: ActivityRecord{786e788 u0 com.linjiamin.myapplication/.Main2Activity t138}
 Run #2: ActivityRecord{87a03a5 u0 com.linjiamin.myapplication/.Main2Activity t138}
 Run #1: ActivityRecord{9471e17 u0 com.linjiamin.myapplication/.NewTaskActivity t138}
 Run #0: ActivityRecord{49c4ac2 u0 com.linjiamin.myapplication/.MainActivity t138}
</code></pre></li>
<li><p>接着在XML中标记为SingleInstance模式，FLAG依然不起作用，singleTask亦同</p>
<pre><code>   TaskRecord{bfd2cdd #139 A=com.linjiamin.myapplication U=0 sz=5}
  Run #5: ActivityRecord{6fd6eee u0 com.linjiamin.myapplication/.Main2Activity t139}
TaskRecord{98a6f23 #140 A=com.linjiamin.myapplication U=0 sz=1}
  Run #4: ActivityRecord{1d577f4 u0 com.linjiamin.myapplication/.NewTaskActivity t140}
TaskRecord{bfd2cdd #139 A=com.linjiamin.myapplication U=0 sz=5}
  Run #3: ActivityRecord{3ba4af9 u0 com.linjiamin.myapplication/.MainActivity t139}
  Run #2: ActivityRecord{4a4b5bc u0 com.linjiamin.myapplication/.Main2Activity t139}
  Run #1: ActivityRecord{5e70342 u0 com.linjiamin.myapplication/.Main2Activity t139}
  Run #0: ActivityRecord{b3bab83 u0 com.linjiamin.myapplication/.MainActivity t139}
</code></pre></li>
<li><p>查看文档，这个Flag确实用来标记(或者曾经用来标记)singleTask模式，实践发现手动设置Flag已经不起作用，但文档却没有修改，存在一定的误导性</p>
<pre><code>* &lt;p&gt;When using this flag, if a task is already running for the activity
* you are now starting, then a new activity will not be started; instead,
* the current task will simply be brought to the front of the screen with
* the state it was last in.  See {@link #FLAG_ACTIVITY_MULTIPLE_TASK} for a flag
* to disable this behavior.
</code></pre></li>
</ul>
<h2 id="TaskAffinity"><a href="#TaskAffinity" class="headerlink" title="TaskAffinity"></a>TaskAffinity</h2><p><strong>TaskAffinity，指定了Activity将归属于哪一个任务栈，一般只配合singleTask和singleInstance模式使用</strong></p>
<h3 id="查看和修改任务栈"><a href="#查看和修改任务栈" class="headerlink" title="查看和修改任务栈"></a>查看和修改任务栈</h3><ul>
<li>首先，需要查看Activity任务栈信息的手段，使用adb shell dumpsys activity可以查看所有与Activity相关的信息，但是输出非常冗长，不妨这样</li>
</ul>
<pre><code>adb shell dumpsys activity activities | sed -En -e &apos;/Running activities/,/Run #0/p&apos;
</code></pre><ul>
<li>TaskRecord 信息就是我们需要的，例如 com.linjiamin.lifecycle 就是Task的名字</li>
</ul>
<pre><code>TaskRecord{776e103 #53 A=com.linjiamin.lifecycle U=0 sz=3}
</code></pre><ul>
<li>taskAffinity指定Activity应属于哪一个任务栈，默认情况下它等于包名，这意味着Activity倾向于属于同一个任务，通过XML可以设置这个属性，以singleTask模式为例</li>
</ul>
<pre><code>&lt;activity
    android:name=&quot;.FlagActivity&quot;
    android:launchMode=&quot;singleTask&quot;
    android:taskAffinity=&quot;com.linjiamin.lifecycle.task3&quot;&gt;
    &lt;/activity&gt;
</code></pre><ul>
<li>执行 adb shell dumpsys，可见任务栈的已被修改，task3出现了</li>
</ul>
<pre><code>TaskRecord{1605ccbd #52 A=com.linjiamin.lifecycle.task3 U=0 sz=1}
TaskRecord{2300c203 #51 A=com.linjiamin.lifecycle U=0 sz=2}
</code></pre><h3 id="TaskAffinity与任务栈"><a href="#TaskAffinity与任务栈" class="headerlink" title="TaskAffinity与任务栈"></a>TaskAffinity与任务栈</h3><ul>
<li>启动一个singleTask属性的Activity，系统首先会查找Activity想要的task，若不存在就会创建这个task。而Activity具体需的Task名，默认情况是使用包名，若标记了TaskAffinity就会使用TaskAffinity指定的值</li>
</ul>
<ul>
<li>使用Standard模式启动Activity，会将Activity加入启动它的Activity的任务栈中，除非是用TaskAffinity去标记MainActivity（一般不会这样），否则TaskAffinity和sandard配合时TaskAffinity是没有意义的</li>
</ul>
<pre><code>&lt;activity android:name=&quot;.LifeActivity&quot;
    android:taskAffinity=&quot;com.linjiamin.lifecycle.task1&quot;
    android:launchMode=&quot;standard&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;

        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;

//输出为
 TaskRecord{21a9d665 #57 A=com.linjiamin.lifecycle.task1 U=0 sz=4}
</code></pre><ul>
<li>当使用ApplicationContext去启动standard模式的Activity时，Application根本就没有任务栈，所以这时会报错，为解决这个问题，需要将Activity的FLAG标记为singleTask模式，即</li>
</ul>
<pre><code>FLAG_ACTIVITY_NEW_TASK
</code></pre><ul>
<li>当使用 singleInstance，若实例存在，它的任务栈不会改变，如果实例不存在且栈不存在，则会创建TaskAffinity指定的任务栈和实例</li>
</ul>
<h2 id="使用Bundle传递数据"><a href="#使用Bundle传递数据" class="headerlink" title="使用Bundle传递数据"></a>使用Bundle传递数据</h2><p>**<br>考虑一种情况，当一个组数据需要在Activity间多次添加、修改、传递，如果<a href="https://alberthumbert.github.io/2017/04/30/firstCodeLine/#%E4%BD%BF%E7%94%A8Intent%E5%9C%A8%E6%B4%BB%E5%8A%A8%E4%B9%8B%E9%97%B4%E7%A9%BF%E6%A2%AD">只使用Intent</a>是否会相当麻烦？<br>**</p>
<ul>
<li>使用Bundle可以使数据的传输变得简单许多，创建Bundle并调用intent的putExtras(Bundle extras)方法即可</li>
</ul>
<pre><code>        button.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        Bundle bundle = new Bundle();
        bundle.putBoolean(&quot;aBooleanParam&quot;,false);
        bundle.putInt(&quot;anIntParam&quot;,1);
        bundle.putString(&quot;aStringParam&quot;,&quot;2&quot;);
        Intent intent = new Intent(AnotherActivity.this,FlagActivity.class);
        intent.putExtras(bundle);
        startActivity(intent);
    }
}); 
</code></pre><ul>
<li>获取数据的方法和intent相同，也可以用putParcelable传递自定义的类型</li>
</ul>
<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_flag);
    Bundle bundle = getIntent().getExtras();
    Log.d(TAG, &quot;onCreate: &quot;+bundle.getBoolean(&quot;aBooleanParam&quot;));
    Log.d(TAG, &quot;onCreate: &quot;+bundle.getInt(&quot;anIntParam&quot;));
    Log.d(TAG, &quot;onCreate: &quot;+bundle.getString(&quot;aStringParam&quot;));
}       
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[pro git 1-6章 笔记]]></title>
      <url>/2017/05/22/ProGit/</url>
      <content type="html"><![CDATA[<p>onCreate</p>
<a id="more"></a>
<h2 id="第一章-起步"><a href="#第一章-起步" class="headerlink" title="第一章 起步"></a>第一章 起步</h2><hr>
<p>**  略 **</p>
<p><br></p>
<h2 id="第二章-Git-基础"><a href="#第二章-Git-基础" class="headerlink" title="第二章 Git 基础"></a>第二章 Git 基础</h2><hr>
<p><br></p>
<h3 id="获取git仓库"><a href="#获取git仓库" class="headerlink" title="获取git仓库"></a>获取git仓库</h3><hr>
<p><br></p>
<h4 id="git-init-初始化仓库"><a href="#git-init-初始化仓库" class="headerlink" title="git init - 初始化仓库"></a>git init - 初始化仓库</h4><p><strong>创建.git目录</strong></p>
<ul>
<li>.git，包含一个git仓库中所有必须的文件，这即是说当要清除版本控制时只需要执行：</li>
</ul>
<pre><code>$ rm -rf .git
</code></pre><ul>
<li>init 参数只会执行初始化操作，所以还需要对现有文件进行选择性的跟踪和提交：</li>
</ul>
<pre><code>$ git add *.c
$ git add LICENSE
$ git commit -m &apos;initial project version&apos;
</code></pre><ul>
<li>init执行后 .git 中至少包含：</li>
</ul>
<pre><code>refs/
# 指向commit的指针，即commit的SHA-1值


HEAD
# 指示目前被检出的分支
# 内容形如： ref: refs/heads/master

config
# 包含配置信息
# 内容形如：
# repositoryformatversion = 0
# filemode = true 
# ...

description
# 仅供 GitWeb 程序使用，无需关心

hooks/
# 目录包含客户端或服务端的钩子脚本

info/
# 包含一个名为exclude的全局性排除文件
# 可以追加不希望被记录在.gitignore的排除内容，如：
# *.[oa] 
# *~
# 在这里添加的排除信息不会提交到仓库，也就不会影响到别人

objects/
# 储存版本控制的所有数据
</code></pre><p><br>          </p>
<h4 id="git-clone-url-克隆现有仓库"><a href="#git-clone-url-克隆现有仓库" class="headerlink" title="git clone [url] - 克隆现有仓库"></a>git clone [url] - 克隆现有仓库</h4><p><strong>拉取仓库中每个文件的每个版本</strong></p>
<ul>
<li>clone会创建.git文件夹将所有数据放入在内并读取最新版本的文件</li>
<li>url支持多种协议格式，如https协议，git协议，ssh协议</li>
<li>clone会自动添加远程仓库并以origin为简写</li>
<li>clone会自动设置本地master分支跟踪克隆的远程仓库的master分支（默认分支）</li>
</ul>
<p><br></p>
<h3 id="记录每次更新到仓库"><a href="#记录每次更新到仓库" class="headerlink" title="记录每次更新到仓库"></a>记录每次更新到仓库</h3><hr>
<p><br></p>
<h4 id="git-status-检查当前文件状态"><a href="#git-status-检查当前文件状态" class="headerlink" title="git status - 检查当前文件状态"></a>git status - 检查当前文件状态</h4><ul>
<li>文件根据是否纳入版本控制存在两种状态，已跟踪和未跟踪</li>
<li>已跟踪文件分为三种状态，未修改，已修改，已暂存</li>
<li>Changes not staged for commit 下的文件属于已修改状态</li>
<li>Changes to be committed 下的文件处于已暂存状态</li>
<li>使用参数 -s 可得到简略输出</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">？？  # 未跟踪文件</div><div class="line">A    # 新添加到暂存区的文件</div><div class="line"> M   # 修改后未暂存</div><div class="line">M    # 修改后已暂存</div><div class="line">MM   # 修改暂存后又修改</div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="git-add-flie-跟踪与暂存文件"><a href="#git-add-flie-跟踪与暂存文件" class="headerlink" title="git add [flie] - 跟踪与暂存文件"></a>git add [flie] - 跟踪与暂存文件</h4><ul>
<li>git 不会自动跟踪之前提交中没有的文件</li>
<li>add 使用文件或目录为参数，如果参数是路径，将递归地跟踪或暂存该目录下的所有文件</li>
<li>add 只会暂存当前时刻的版本，再次修改需重新暂存</li>
</ul>
<p><br></p>
<h4 id="gitignore-忽略文件"><a href="#gitignore-忽略文件" class="headerlink" title=".gitignore - 忽略文件"></a>.gitignore - 忽略文件</h4><ul>
<li>日志文件，编译临时文件等不需要纳入版本控制，可在.gitignore中添加排除信息</li>
<li>数十种语言的 gitignore文件 <a href="https://github.com/github/gitignore" target="_blank" rel="external">https://github.com/github/gitignore</a></li>
<li>格式规范</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#   开头，被忽略，通常用于注释</div><div class="line">/   开头，防止递归，只忽略当前目录所匹配的文件</div><div class="line">/   结尾，指定目录</div><div class="line">!   开头，取反</div><div class="line">*   任意匹配0或多个字符</div><div class="line">?   任意匹配一个字符</div><div class="line">[ ] 任意匹配括号中的一个字符  </div><div class="line">**  任意匹配中间目录</div></pre></td></tr></table></figure>
<ul>
<li>下面是一个java项目可用的文件：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"># Compiled class file</div><div class="line">*.class</div><div class="line"></div><div class="line"># Log file</div><div class="line">*.log</div><div class="line"></div><div class="line"># BlueJ files</div><div class="line">*.ctxt</div><div class="line"></div><div class="line"># Mobile Tools for Java (J2ME)</div><div class="line">.mtj.tmp/</div><div class="line"></div><div class="line"># Package Files #</div><div class="line">*.jar</div><div class="line">*.war</div><div class="line">*.ear</div><div class="line">*.zip</div><div class="line">*.tar.gz</div><div class="line">*.rar</div><div class="line"></div><div class="line"># virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xml</div><div class="line">hs_err_pid*</div></pre></td></tr></table></figure>
<p><br>      </p>
<h4 id="git-diff-查看修改"><a href="#git-diff-查看修改" class="headerlink" title="git diff - 查看修改"></a>git diff - 查看修改</h4><p><strong>显示修改的具体信息</strong> </p>
<ul>
<li>git diff 只显示尚未暂存的改动，而不是上次提交以来的所有改动</li>
<li>git diff –staged 只显示已暂存的改动</li>
</ul>
<p><br></p>
<h4 id="git-commit-提交更新"><a href="#git-commit-提交更新" class="headerlink" title="git commit - 提交更新"></a>git commit - 提交更新</h4><ul>
<li>每次提交前应先用git status查看是否有文件未暂存</li>
<li>git commit 默认启动shell环境变量 $EDITOR所指定的编辑器</li>
<li>在编辑器中，所有注释将会在生成提交时被移除，而提交信息会保留</li>
<li>git commit -m “[description]” 允许在命令中添加提交信息</li>
<li>git commit -a 允许跳过暂存操作，所有跟踪过的文件会被一并提交</li>
</ul>
<p><br></p>
<h4 id="git-rm-file-移除文件"><a href="#git-rm-file-移除文件" class="headerlink" title="git rm [file] - 移除文件"></a>git rm [file] - 移除文件</h4><ul>
<li>rm 参数只对已跟踪的文件起作用</li>
<li>git rm 会将文件从将暂存区和工作目录中删除</li>
<li>git rm -f 删除修改过并且已放到暂存区的文件</li>
<li>git rm –cached 只将文件从暂存区中移除，文件会恢复为未跟踪状态，不会被删除，因此可能需要手动添加到.gitignore</li>
</ul>
<p><br></p>
<h3 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h3><hr>
<p><br></p>
<h4 id="git-log-查看提交历史"><a href="#git-log-查看提交历史" class="headerlink" title="git log - 查看提交历史"></a>git log - 查看提交历史</h4><ul>
<li>git log 会按时间由后到前列出所有更新信息</li>
<li>git log -p 附带每次提交内容的差异</li>
<li>git log –stat 附带被修改文件的名称、数量和修改类型</li>
<li>git log –pretty=format 使用占位符修改输出信息</li>
<li>git log –graph 附带描述分支合并历史的图表</li>
</ul>
<p><br></p>
<h3 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h3><hr>
<p><br></p>
<h4 id="git-commit-–amend-修改提交"><a href="#git-commit-–amend-修改提交" class="headerlink" title="git commit –amend -修改提交"></a>git commit –amend -修改提交</h4><ul>
<li>git commit –amend 会将暂存中的文件与上一次提交合并，可以用来补充遗漏</li>
<li>amend选项覆盖的提交是可恢复的，详见数据恢复章节</li>
</ul>
<p><br></p>
<h4 id="git-reset-取消暂存的文件"><a href="#git-reset-取消暂存的文件" class="headerlink" title="git reset - 取消暂存的文件"></a>git reset - 取消暂存的文件</h4><ul>
<li>git reset HEAD [file] 可以将文件修改为未暂存状态</li>
<li>reset 和 rm –cached 的区别：reset不会使文件变为未跟踪状态 </li>
<li><a href="https://stackoverflow.com/questions/17122480/difference-between-git-rm-cached-and-git-reset-head" target="_blank" rel="external">https://stackoverflow.com/questions/17122480/difference-between-git-rm-cached-and-git-reset-head</a></li>
</ul>
<p><br></p>
<h4 id="git-checkout-–-file-撤销修改"><a href="#git-checkout-–-file-撤销修改" class="headerlink" title="git checkout – [file] - 撤销修改"></a>git checkout – [file] - 撤销修改</h4><ul>
<li>git checkout – [file] 会将文件还原为上次提交时的内容</li>
<li>这是一个危险的命令，它造成的效果是不可逆的</li>
</ul>
<p><br></p>
<h3 id="远程仓库的使用"><a href="#远程仓库的使用" class="headerlink" title="远程仓库的使用"></a>远程仓库的使用</h3><hr>
<p><br></p>
<h4 id="git-remote-查看远程仓库"><a href="#git-remote-查看远程仓库" class="headerlink" title="git remote - 查看远程仓库"></a>git remote - 查看远程仓库</h4><ul>
<li>git remote 会显示远程仓库列表，如果已经克隆了仓库，那么至少可以看到 origin</li>
<li>git remote 会显示读写远程仓库使用的简写与其对应的URL</li>
<li>git remote show [remote-name] 会显示一个远程仓库的更多信息</li>
</ul>
<p><br></p>
<h4 id="git-remote-add-添加远程仓库"><a href="#git-remote-add-添加远程仓库" class="headerlink" title="git remote add - 添加远程仓库"></a>git remote add - 添加远程仓库</h4><ul>
<li>git remote add [shortname] [url] 添加一个新的远程Git仓库，同时指定一个可以引用的简写</li>
<li>git remote rename [oldname] [newname] 可以修改远程仓库的简写</li>
<li>git remote rm [remote-name] 将会移除一个远程仓库</li>
</ul>
<p><br></p>
<h4 id="git-fetch-从远程仓库中抓取与拉取"><a href="#git-fetch-从远程仓库中抓取与拉取" class="headerlink" title="git fetch - 从远程仓库中抓取与拉取"></a>git fetch - 从远程仓库中抓取与拉取</h4><ul>
<li>git fetch [remote-name] 会拉取远程仓库中的所有分支和数据</li>
<li>git fetch origin 会抓取克隆或上一次抓取后推送的所有工作</li>
<li>git fetch 不会自动合并和修改当前的工作，必须手动合并</li>
</ul>
<p><br></p>
<h4 id="git-push-推送到远程仓库"><a href="#git-push-推送到远程仓库" class="headerlink" title="git push - 推送到远程仓库"></a>git push - 推送到远程仓库</h4><ul>
<li>git push [remote-name][branch-name]，只有拥有所克隆服务器的写入权限并且之前没有人推送过时，命令才会生效</li>
<li>当他人先将数据推送到上游时命令会被拒绝，必须先将他人的工作拉取并合并后才能推送</li>
<li>git push origin [tagname]，push不会将标签推送到服务器上，在创建完标签后必须显式地推送</li>
<li>git push origin –tags ，推送所有标签</li>
</ul>
<p><br></p>
<h3 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h3><hr>
<p><br></p>
<h4 id="git-tag-列出标签"><a href="#git-tag-列出标签" class="headerlink" title="git tag - 列出标签"></a>git tag - 列出标签</h4><ul>
<li>git tag 会以字母顺序列出标签</li>
<li>可以用特定的模式查找标签，如</li>
</ul>
<pre><code>git tag -l &apos; v1.* &apos;
</code></pre><p><br></p>
<h4 id="git-tag-a-创建标签"><a href="#git-tag-a-创建标签" class="headerlink" title="git tag -a 创建标签"></a>git tag -a 创建标签</h4><ul>
<li>git tag -a (v1.0) -m ‘my version 1.0’ ，为最新的提交打上附注标签，若无 -m参数，编辑器会被打开</li>
<li>git tag -a v1.0 9fceb02，为指定提交打标签，需要在末尾指定提交的校验和</li>
<li>git tag (v1.0)  ,为最新的提交打上轻量标签</li>
<li>附注标签是Git数据库中的一个完整对象，可以被校验，包含多种信息</li>
<li>轻量标签是一个特定提交的引用，类似分支，只是将校验和存储到一个文件里而已</li>
</ul>
<p><br></p>
<h3 id="git别名"><a href="#git别名" class="headerlink" title="git别名"></a>git别名</h3><p>** 略 **</p>
<p><br></p>
<h2 id="第三章-Git-分支"><a href="#第三章-Git-分支" class="headerlink" title="第三章 Git 分支"></a>第三章 Git 分支</h2><hr>
<p><strong>分支，一个包含对象校验和（长度为40的SHA-1值字符串）的文件</strong></p>
<p><br></p>
<h3 id="commit-object-提交对象"><a href="#commit-object-提交对象" class="headerlink" title="commit object - 提交对象"></a>commit object - 提交对象</h3><ul>
<li>git保存的不是文件的变化和差异，而是不同时刻的文件快照</li>
<li>除首次提交外，每次提交产生的提交对象都有父对象，多分支合并产生的提交有多个父对象，构成提交对象的树（图）结构</li>
<li>git仓库至少有三种对象，包括 blob对象（保存文件快照），树对象（记录目录结构和blob对象索引）以及提交对象（包含指向树对象的指针和所有提交信息）</li>
<li>git init默认创建的分支名是master，master不是一个特殊的分支，它和其他分支相比没有任何本质区别</li>
<li><strong>git分支本质上只是指向提交对象的可变指针</strong></li>
</ul>
<p><br></p>
<h3 id="使用分支"><a href="#使用分支" class="headerlink" title="使用分支"></a>使用分支</h3><hr>
<p><br></p>
<h4 id="git-branch-分支创建"><a href="#git-branch-分支创建" class="headerlink" title="git branch - 分支创建"></a>git branch - 分支创建</h4><ul>
<li>git branch [branchname]，会创建一个新的分支</li>
<li>创建新分支实际上只是在当前提交对象上创建了一个可移动的新指针</li>
<li>HEAD指针，这是一个特殊指针，永远指向当前分支</li>
<li>git branch 只会创建分支并不会自动切换到新分支</li>
<li>git checkout -b [branchname]，会创建一个新分支并切换到这个新分支上</li>
<li>git branch -d [branchname]，会删除一个分支，当分支已被合并时理应进行删除操作</li>
<li>git branch -D [branchname]，会强制删除一个分支</li>
<li>git log –oneline –decorate 可以显示各个分支当前指向的提交对象</li>
<li>git log –oneline –decorate –graph –all 可以显示提交历史、各分支的指向以及项目的分支分叉情况</li>
</ul>
<p><br></p>
<h4 id="git-checkout-分支切换"><a href="#git-checkout-分支切换" class="headerlink" title="git checkout - 分支切换"></a>git checkout - 分支切换</h4><ul>
<li>git checkout [branchname] ，会将HEAD切换到新分支，即更换当前分支</li>
<li>提交更新时只有head指向的分支会向前移动，其他分支则依然停留在原先的版本</li>
<li>git checkout [branchname] 本质上做了两件事，将head指向另外的分支，将工作目录恢复为该分支所指向的快照内容</li>
</ul>
<p><br></p>
<h4 id="git-merge-合并分支"><a href="#git-merge-合并分支" class="headerlink" title="git merge - 合并分支"></a>git merge - 合并分支</h4><ul>
<li>git merge [branchname] 会将当前分支与指定分支合并</li>
<li>fast-forward 模式，两个分支是直接的上下游关系，合并分支只会简单地将指针向前推进</li>
<li>两个不同的分支对同一个文件的同一个部分进行了不同的修改时，git不会提交合并，需要手动解决冲突</li>
<li>git branch –merged，可以查看已合并的分支，通常这些分支可以删除</li>
<li>git branch –no-merged，可以查看未合并的分支</li>
<li>产生冲突时使用git status查看包含冲突而未合并的文件，解决后使用git add将文件标价为冲突已解决</li>
</ul>
<p><br></p>
<h3 id="分支开发工作流"><a href="#分支开发工作流" class="headerlink" title="分支开发工作流"></a>分支开发工作流</h3><hr>
<p>** 略 **</p>
<p><br></p>
<h3 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h3><hr>
<p><br></p>
<h4 id="远程引用"><a href="#远程引用" class="headerlink" title="远程引用"></a>远程引用</h4><ul>
<li>远程引用是对远程仓库的引用（指针），包括分支、标签等</li>
<li>git ls-remote [remotename]，会显示远程引用的完整列表</li>
</ul>
<p><br></p>
<h4 id="远程跟踪分支"><a href="#远程跟踪分支" class="headerlink" title="远程跟踪分支"></a>远程跟踪分支</h4><ul>
<li>远程跟踪分支，以[remote] / [branch] 形式命名，是不能手动移动的本地引用，当进行网络通信操作时会自动移动</li>
<li>远程跟踪分支类似上次连接到远程仓库时的书签</li>
<li>当使用git clone时，git会自动将远程仓库命名为origin并创建一个名为origin/master的远程分支，同时还会创建一个相同的本地master分支</li>
<li>origin无特殊含义，和其他所有远程仓库引用是一致的，如果喜欢可以使用 git clone -o [name] 来自己命名</li>
<li>git remote add [shortname] [url] ，会添加一个新的远程仓库引用到当前项目</li>
</ul>
<p><br></p>
<h4 id="git-fetch-更新远程仓库引用"><a href="#git-fetch-更新远程仓库引用" class="headerlink" title="git fetch - 更新远程仓库引用"></a>git fetch - 更新远程仓库引用</h4><p><strong>以origin为例</strong></p>
<ul>
<li>只要不与服务器连接，origin/master就不会移动</li>
<li>git fetch origin ， 将会查找origin指代的服务器，抓取本地没有的数据并更新本地数据库，移动origin/master指针</li>
</ul>
<p><br></p>
<h4 id="git-push-推送"><a href="#git-push-推送" class="headerlink" title="git push - 推送"></a>git push - 推送</h4><ul>
<li>想要公开分享一个分支时，需要将其推送到有写入权限的远程仓库上</li>
<li>git push [remote][branch]，可以更新远程分支</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># 例：</div><div class="line">$ git push origin serverfix</div><div class="line"># git 会自动将serverfix展开为refs/heads/serverfix:refs/heads/serverfix</div><div class="line"># 这意味着本地serverfix会更新远程仓库的serverfix分支</div><div class="line"># 它相当于 git push serverfix:serverfix</div><div class="line"># 详见 Git内部原理 章节</div></pre></td></tr></table></figure>
<ul>
<li>抓取远程分支时不会自动形成可编辑的副本拷贝，被抓取的[remote][branch] 只有不可修改的指针，需要使用 git merge [remote][branch] 将这个分支合并到当前分支</li>
<li>git push [remote] –delete [branchname] 可以在服务器上删除远程分支</li>
</ul>
<p><br></p>
<h4 id="本地跟踪分支"><a href="#本地跟踪分支" class="headerlink" title="本地跟踪分支"></a>本地跟踪分支</h4><p><strong>注：书中使用远程跟踪分支和跟踪分支这两个概念，为了避免混淆这里将跟踪分支叫做本地跟踪分支，举例来说两者间的区别就是 origin/master和master的区别</strong></p>
<ul>
<li>从远程跟踪分支检出一个本地分支会自动创建一个本地跟踪分支，在本地跟踪分支上使用git pull 还会自动识别需要抓取合并的分支</li>
<li>克隆一个仓库时，会自动创建一个跟踪origin/master分支的本地master分支</li>
<li>git checkout -b [branch] [remotename]/[branch]，将创建一个本地跟踪分支</li>
<li>git checkout –track [remotename]/[branch] 为简写</li>
<li>git branch -u [remotename]/[branchname]，可以初始化或修改当前分支跟踪的远程分支，-u全写为 –set-upstream-to</li>
<li>git branch -vv，查看所有的本地跟踪分支</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">例：</div><div class="line">$git branch -vv</div><div class="line">* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it</div><div class="line"># 当前分支为 serverfix</div><div class="line"># 跟踪的分支为 teamone/server-fix-good</div><div class="line"># 本地有三次提交未上传合并，服务器上有一次提交未拉取合并</div></pre></td></tr></table></figure>
<ul>
<li>可以使用@{upstream}或@{u}快捷方式来引用当前分支跟踪的远程分支</li>
</ul>
<p><strong>值得一提的是在远程分支上进行git pull时git会声称当前不在一条分支上面，大概upstream和branch是两个不同的概念</strong></p>
<p><br></p>
<h4 id="git-pull-拉取分支"><a href="#git-pull-拉取分支" class="headerlink" title="git pull -拉取分支"></a>git pull -拉取分支</h4><ul>
<li>git pull 大多数情况下的含义是git fetch 后紧跟一个git merge</li>
<li>git pull 容易让人困惑，通常单独显式地使用fetch 和 merge 会更好</li>
</ul>
<p><br></p>
<h3 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h3><hr>
<p><strong>gayhub的由来(才怪)</strong></p>
<p><strong>不常用，仅作了解</strong><br><br></p>
<h4 id="git-rebase-变基的基本操作"><a href="#git-rebase-变基的基本操作" class="headerlink" title="git rebase - 变基的基本操作"></a>git rebase - 变基的基本操作</h4><ul>
<li>merge 被称为三方合并，它选取两个分支的最新快照与两者最近的共同祖先合并形成一个新的快照</li>
<li>rebese 命令将提交到某一分支上的修改移到另一分支上，它造成的结果和merge是一样的，但提交历史会是更加简洁的一条直线</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">列：</div><div class="line">$ git checkout experiment</div><div class="line">$ git rebase master</div><div class="line"># 此时当前maser所在位置相当于experiment的直接上游</div><div class="line">$ git checkout experiment</div><div class="line">$ git rebase master</div><div class="line"># 将experiment的修改在master上重演，相当于fast-forward模式</div></pre></td></tr></table></figure>
<p><br>      </p>
<h4 id="非目标分支上的重演"><a href="#非目标分支上的重演" class="headerlink" title="非目标分支上的重演"></a>非目标分支上的重演</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git rebase --onto master server client</div><div class="line"># 意思是取出client分支，找出client分支和server分支的共同祖先后的修改，让他们在master分支上重演一遍</div></pre></td></tr></table></figure>
<p><br></p>
<font size="5">第四、五章中关于服务器上git仓库的内容全部跳过</font>

<p><br></p>
<h2 id="第四章-服务器上的git"><a href="#第四章-服务器上的git" class="headerlink" title="第四章 服务器上的git"></a>第四章 服务器上的git</h2><hr>
<p><strong>略</strong></p>
<p><br></p>
<h2 id="第五章-分布式git"><a href="#第五章-分布式git" class="headerlink" title="第五章 分布式git"></a>第五章 分布式git</h2><hr>
<p><strong>成为合格的贡献者和整合者</strong></p>
<p><br></p>
<h3 id="分布式工作流程"><a href="#分布式工作流程" class="headerlink" title="分布式工作流程"></a>分布式工作流程</h3><hr>
<p><br></p>
<h4 id="集中式工作流"><a href="#集中式工作流" class="headerlink" title="- 集中式工作流"></a>- 集中式工作流</h4><p><strong>开发团队常用模式</strong></p>
<ul>
<li>以接受代码的仓库为中心，若干开发者为节点将工作与仓库同步</li>
<li>若有两个开发者从中心仓库克隆代码并修改，只有第一个开发者可以顺利地把数据推送回共享服务器，第二个开发者必须先将第一个人的工作合并，这样才不会覆盖第一个人的修改</li>
</ul>
<p><br></p>
<h4 id="集成管理者工作流"><a href="#集成管理者工作流" class="headerlink" title="- 集成管理者工作流"></a>- 集成管理者工作流</h4><p><strong>Github常用模式</strong></p>
<ul>
<li>每个开发者拥有自己仓库的读写权限和其他所有人的读取权限，为代表官方项目的权威仓库贡献</li>
<li><p>维护者将开发者的仓库作为远程仓库添加，在本地测试变更，将其合并进入官方仓库</p>
<pre><code>例：

1. 项目维护者推送到主仓库
2. 贡献者克隆此仓库，做出修改
3. 贡献者将数据推送到自己的公开仓库
4. 贡献者给维护者发送邮件，请求拉取自己的更新
5. 维护者在自己的本地仓库中，将贡献者的仓库加为远程仓库合并修改
6. 维护者将合并后的修改推送到主仓库
</code></pre></li>
</ul>
<p><br></p>
<h4 id="提交准则"><a href="#提交准则" class="headerlink" title="- 提交准则"></a>- 提交准则</h4><p><strong>写好 Git Commit 信息的 7 个建议：<a href="http://blog.jobbole.com/92713/" target="_blank" rel="external">http://blog.jobbole.com/92713/</a></strong></p>
<ul>
<li>git diff –check，显示空白错误，空白错误指文件中的tab等字符，这些字符也会被视为修改内容，不应将这些修改提交</li>
<li>让每一个提交成为一个逻辑上的独立变更，即不要尝试一次解决多个问题然后上传一个巨大的提交</li>
<li>提交信息，应当少于50个字符（25个汉字）的单行开始且简要地描述变更，接着是一个空白行，再接着是一个更加详细的解释（每行小于72字符）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#################################################</div><div class="line"></div><div class="line">    修改的摘要（50个字符或更少）</div><div class="line">    # 首字母大写，若只需要这一行，可以直接使用-m参数</div><div class="line">     </div><div class="line">    关于修改的更多解释（每行小于72字符）</div><div class="line">    # 使用空行分隔段落，可以使用 - 符号开头，注意git不会自动换行</div><div class="line">     </div><div class="line">##################################################</div><div class="line">     </div><div class="line">列：</div><div class="line">     </div><div class="line">commit eb0b56b19017ab5c16c745e6da39c53126924ed6</div><div class="line">Author: Pieter Wuille &lt;pieter.wuille@gmail.com&gt;</div><div class="line">Date:   Fri Aug 1 22:57:55 2014 +0200</div><div class="line">     </div><div class="line"> Simplify serialize.h&apos;s exception handling</div><div class="line"> </div><div class="line"> Remove the &apos;state&apos; and &apos;exceptmask&apos; from serialize.h&apos;s stream</div><div class="line"> implementations, as well as related methods.</div><div class="line"> </div><div class="line"> As exceptmask always included &apos;failbit&apos;, and setstate was always</div><div class="line"> called with bits = failbit, all it did was immediately raise an</div><div class="line"> exception. Get rid of those variables, and replace the setstate</div><div class="line"> with direct exception throwing (which also removes some dead code).</div><div class="line"> </div><div class="line"> As a result, good() is never reached after a failure (there are</div><div class="line"> only 2 calls, one of which is in tests), and can just be replaced</div><div class="line"> by !eof().</div><div class="line"> </div><div class="line"> fail(), clear(n) and exceptions() are just never called. Delete them.</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="第六章-GitHub"><a href="#第六章-GitHub" class="headerlink" title="第六章 GitHub"></a>第六章 GitHub</h2><hr>
<p><strong>暂略</strong></p>
<p><br></p>
<h2 id="第七章-Git-工具"><a href="#第七章-Git-工具" class="headerlink" title="第七章 Git 工具"></a>第七章 Git 工具</h2><hr>
<p><br>   </p>
<h3 id="引用技巧"><a href="#引用技巧" class="headerlink" title="引用技巧"></a>引用技巧</h3><hr>
<p><br>   </p>
<h4 id="简短的SHA-1"><a href="#简短的SHA-1" class="headerlink" title="- 简短的SHA-1"></a>- 简短的SHA-1</h4><ul>
<li>可以使用开头的几个字符（不少于4个）代替完整SHA-1</li>
<li>git log –abbrev-commit，会显示简短且唯一的值，默认7个字符，如果有冲突会增加字符</li>
</ul>
<p><br>   </p>
<h4 id="分支引用"><a href="#分支引用" class="headerlink" title="- 分支引用"></a>- 分支引用</h4><ul>
<li>指明一个提交最直接的方法是有一个指向它的分支引用，可以用分支引用代替SHA-1</li>
<li>git rev-parse [branchname]，显示分支指代的SHA-1</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git rev-parse master</div><div class="line">          </div><div class="line">25303d395e6075d5d627a79ce914ad0fb47f352c</div></pre></td></tr></table></figure>
<p><br>  </p>
<h4 id="git-reflog-引用日志"><a href="#git-reflog-引用日志" class="headerlink" title="git reflog - 引用日志"></a>git reflog - 引用日志</h4><ul>
<li>git会在后台保存一个引用日志（reflog）记录进几个月HEAD和分支引用指向的历史</li>
<li>每当HEAD所指向的位置发生了变化，git就会将信息存储到引用日志里</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ git reflog</div><div class="line"></div><div class="line">25303d3 HEAD@&#123;0&#125;: commit: Fix image source database</div><div class="line">367fcf7 HEAD@&#123;1&#125;: checkout: moving from 367fcf7d44af7e90ad2e8505cf3e4aa5b69d401d to master</div><div class="line">367fcf7 HEAD@&#123;2&#125;: checkout: moving from master to origin/master</div><div class="line">367fcf7 HEAD@&#123;3&#125;: pull: Fast-forward</div><div class="line">b7c7faa HEAD@&#123;4&#125;: commit: Add README</div><div class="line">77e24b9 HEAD@&#123;5&#125;: commit (initial): First commit</div></pre></td></tr></table></figure>
<ul>
<li><p>可以使用@{n} 来引用reflog中输出的提交记录</p>
<pre><code>$ git show HEAD@{5}
</code></pre></li>
<li><p>也可以查看某个分支在特定时间前的位置</p>
<pre><code>$ git show master@{yesterday}
</code></pre></li>
</ul>
<p><br>      </p>
<h4 id="祖先引用"><a href="#祖先引用" class="headerlink" title="^~ - 祖先引用"></a>^~ - 祖先引用</h4><ul>
<li>祖先引用符号 ^ 会被解析为它前面的引用的上一个版本，HEAD^、d9219970^等写法都是合理的</li>
<li>祖先引用符号 ~ 一般和 ^ 是等价的，唯一的区别在于，~后的数字为倒退的次数，^后的数字为父提交的序号（只有存在多个父提交时才能这么使用），即 ~3 等价于 ^^^，而 ^2 相当于父提交中被合并的次级分支</li>
</ul>
<pre><code>例：
$ git show HEAD^^^
</code></pre><h4 id="…-提交区间"><a href="#…-提交区间" class="headerlink" title="^… - 提交区间"></a>^… - 提交区间</h4><ul>
<li>双点符号 .. ，用于列出在一个分支而不在另一个分支的提交</li>
</ul>
<pre><code>例：
$ git log master..experiment
D
C
</code></pre><ul>
<li>双点常被用来查看即将推送的内容</li>
</ul>
<pre><code>$ git log origin/master..HEAD

# 等价于

$ git log origin/master..

# HEAD可以省略
</code></pre><ul>
<li>多点符号^，用于列出不被包含在其中的提交</li>
</ul>
<pre><code>$ git log refA..refB

# 等价于

$ git log ^refA refB

# 等价于

$ git log refB --not refA
</code></pre><ul>
<li>多点符号存在的意义在于它可以查询两个以上的引用</li>
</ul>
<pre><code>$ git log refA refB --not refC
</code></pre><ul>
<li>三点符号 … ，用于列出被两个引用中的一个包含但又不被两者同时包含的提交</li>
</ul>
<pre><code>$ git log master...experiment
F
E
D
C

# EF只在master分支上，CD只在experiment分支上     # 等价于


$ git log --left-right master...experiment 
&lt;F
&lt;E
&gt;D
&gt;C
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ubuntu 16.04 开启daytime服务（端口13）]]></title>
      <url>/2017/02/20/Daytime/</url>
      <content type="html"><![CDATA[<hr>
<a id="more"></a>
<p>学习《unix网络编程》时，解决完编译问题，第一个程序又出现如下错误代码</p>
<pre><code>connect error: Connection refused
</code></pre><p>这个serve一般被系统默认关闭，用书中的daytimesrv程序可以暂时打开端口</p>
<p>不过最好通过xinetd（守护进程服务程序）开启</p>
<p>ubuntu不自带xinetd，因此</p>
<pre><code>sudo apt install xinetd
</code></pre><p>这个时候又报错 : (</p>
<pre><code>......
E: Unable to locate package xinetd
</code></pre><p>尝试用upgrade更新源依然失败<br>在系统设置->软件和更新->下载自：->其他站点中选择最佳服务区<br>再次安装xinetd成功</p>
<p>然后在/etc/xinetd.d中将daytime的两个disable改为no<br>（注意在vim中修改只读模式仍然可能无法保存，建议使用sudo chmod）</p>
<p>最后重新启动xinetd</p>
<pre><code>/etc/init.d/xinetd restart
</code></pre><p>运行，正常</p>
<pre><code>$ ./daytimetcpcli 127.0.0.1

20 FEB 2017 23:39:29 CST
counter = 1
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> unix </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[酷炫的终端配置入门指南]]></title>
      <url>/2016/11/13/ITerm2/</url>
      <content type="html"><![CDATA[<p><img src="http://p1.bqimg.com/4851/fa551cd95e4fdbc4.jpg" class="img-topic"><br>记录一些自己的配置，只是入门级别而已<br><a id="more"></a></p>
<h2 id="iTerm2-mac上最好用的终端"><a href="#iTerm2-mac上最好用的终端" class="headerlink" title="iTerm2 : mac上最好用的终端"></a>iTerm2 : mac上最好用的终端</h2><p>有多好用看看快捷键功能就知道了<br>插件都是通用的,linux可以使用tmux </p>
<pre><code>⌘ + —/+/0 : 调整字体大小
⌘ + r : 清屏
⌘ + 数字 : 切换标签页
⌘ + 方向键 : 按方向切换标签页
⌘ + enter : 切换全屏
⌘ + d: 垂直分屏
⌘ + shift + d : 水平分屏
⌘ + ] ⌘ + [ : 在最近使用的分屏直接切换 
⌘ + opt + 方向键 : 切换到指定位置的分屏
⌘ + t : 新的标签页
⌘ + w : 关闭当前标签页
⌘ + ；: 自动补全历史命令
space + opt : 呼出悬浮窗
ctrl + u : 清空当前行
ctrl + a : 到行首
ctrl + e : 行末
ctrl + f/b : 前进后退
ctrl + p : 上一条命令
ctrl + r : 搜索命令历史
ctrl + d : 删除当前字符
ctrl + h : 删除之前的字符
ctrl + w : 删除光标前的单词
ctrl + k : 删除到文本末尾
ctrl + t : 交换光标处文本 
</code></pre><h2 id="zsh-终极-Shell"><a href="#zsh-终极-Shell" class="headerlink" title="zsh : 终极 Shell"></a>zsh : 终极 Shell</h2><p>1.确保已安装git</p>
<p>2.然后安装oh my zsh :</p>
<pre><code>git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh
</code></pre><p>3.创建zsh的配置文件</p>
<pre><code>cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc
</code></pre><p>4.设置默认 </p>
<pre><code>chsh -s /bin/zsh
</code></pre><p>5.选择主题</p>
<pre><code>~/.oh-my-zsh/themes 
</code></pre><p> 这里有上百种主题可供选择</p>
<pre><code>vim ~/.zshrc
</code></pre><p> 修改ZSH_THEME=你的主题</p>
<p> 最后</p>
<pre><code>source ~/.zshrc
</code></pre><h2 id="autojump-智能跳转"><a href="#autojump-智能跳转" class="headerlink" title="autojump : 智能跳转"></a>autojump : 智能跳转</h2><p>1.确保已安装homebrew</p>
<p>2.安装autojump</p>
<pre><code>brew install autojump
</code></pre><p>3.修改zsh配置<br>    vim ~/.zshrc</p>
<p>加入</p>
<pre><code>[[ -s ~/.autojump/etc/profile.d/autojump.sh ]] &amp;&amp; . ~/.autojump/etc/profile.d/autojump.sh
</code></pre><h2 id="pathogen-vim插件管理"><a href="#pathogen-vim插件管理" class="headerlink" title="pathogen : vim插件管理"></a>pathogen : vim插件管理</h2><p>1.安装pathogen</p>
<pre><code>git clone git://github.com/tpope/vim-pathogen
</code></pre><p>2.进入.vim, 没有就建一个<br>    mkdir autoload bundle<br>  以后vim插件最好都在bundle中下载<br>  将下载到的pathogen.vim复制到autoload目录</p>
<p>3.打开.vimrc, 没有也建一个<br>（vim的配置可以实现很多功能，要是觉得麻烦，网上有现成）</p>
<p>加入</p>
<pre><code>call pathogen#infect()
</code></pre><h2 id="NERDTree：树形目录"><a href="#NERDTree：树形目录" class="headerlink" title="NERDTree：树形目录"></a>NERDTree：树形目录</h2><p>1.在.vim/bundle下安装NERDTree</p>
<pre><code>git clone git://github.com/scrooloose/nerdtree.git
</code></pre><p>2.进入目录内的doc，在vim内使用:Helptags</p>
<h2 id="powerline：状态栏插件"><a href="#powerline：状态栏插件" class="headerlink" title="powerline：状态栏插件"></a>powerline：状态栏插件</h2><p>1.安装powerline<br>    git clone git://github.com/Lokaltog/powerline.git<br>2.设置zsh </p>
<pre><code>vim ~/.zshrc
</code></pre><p>添加<br>    . /Users/～/PowerLine/powerline/bindings/zsh/powerline.zsh<br>  以上路径需要自行修改</p>
<p>3.设置vim</p>
<pre><code>vim ~/.vimrc
</code></pre><p>加入</p>
<pre><code>&quot;powerline 
set rtp+=/Users/～/PowerLine/  
powerline/bindings/vim
set guifont=PowerlineSymbols\ for\ Powerline
set laststatus=2
let g:Powerline_symbols = &apos;fancy&apos;
let g:Powerline_symbols = &apos;unicode&apos;
set encoding=utf-8
set t_Co=256
set number
set fillchars+=stl:\ ,stlnc:\
set term=xterm-256color
set termencoding=utf-8
</code></pre><p>路径同样需要自行修改<br>4.在iTerm2的profiles中把字体改为powerline字体</p>
<h2 id="Solarized-完善的配色方案"><a href="#Solarized-完善的配色方案" class="headerlink" title="Solarized : 完善的配色方案"></a>Solarized : 完善的配色方案</h2><p>1.安装Solarized</p>
<pre><code>git clone git://github.com/altercation/solarized.git
</code></pre><p>2.执行下列命令行</p>
<hr>
<pre><code>cd solarized
</code></pre><p>-—<br>    cd vim-colors-solarized/colors<br>-—<br>    mkdir -p ~/.vim/colors<br>-—<br>    cp solarized.vim ~/.vim/colors/<br>-—<br>    vim ~/.vimrc</p>
<hr>
<p>3.修改vim设置，加入<br>    syntax enable<br>    set background=dark<br>    colorscheme solarized</p>
<p>4.在profiles中选择Solarized主题</p>
<h2 id="ctags-生成索引"><a href="#ctags-生成索引" class="headerlink" title="ctags : 生成索引"></a>ctags : 生成索引</h2><p>os x自带了ctags，但是这并没有什么卵用</p>
<p>1.下载ctags</p>
<pre><code>http://ctags.sourceforge.net/
</code></pre><p>并解压<br>    tar zxvf ctags-5.8.tar.gz<br>安装</p>
<pre><code>sudo ./configure &amp;&amp; make all &amp;&amp; sudo make install 
</code></pre><p>2.打开 ~/.profile, 如果没有，还是那句，建一个</p>
<p>加入</p>
<pre><code>export PATH=&quot;/usr/local/bin:/usr/local/sbin:$PATH&quot; 
</code></pre><p>3.修改PATH<br>    vim ~/.zshrc  </p>
<p>添加<br>    PATH=”/usr/local/bin:$PATH”</p>
<h2 id="taglist：代码概览"><a href="#taglist：代码概览" class="headerlink" title="taglist：代码概览"></a>taglist：代码概览</h2><p>1.下载taglist</p>
<pre><code>git clone git://github.com/vim-scripts/taglist.vim
</code></pre><p>2.修改vimrc<br>加入</p>
<pre><code>&quot;taglist{
let Tlist_Show_One_File = 1         
let Tlist_Exit_OnlyWindow = 1          
let Tlist_Use_Right_Window = 1         
let Tlist_GainFocus_On_ToggleOpen = 1  
let Tlist_Ctags_Cmd=&apos;/usr/local/bin/ctags&apos;  
nnoremap &lt;leader&gt;tl : Tlist&lt;CR&gt;        
}  
</code></pre><p>注：taglist需要使用ctags生成的tags    </p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 终端配置 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hello world]]></title>
      <url>/2016/10/14/HowLowWorld/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p>缘起</p>
<p>欢迎来到我的小窝</p>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
