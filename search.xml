<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Volley 事件派发机制]]></title>
      <url>/2017/08/09/aboutVolleyDispatcher/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<ul>
<li>之前大致浏<a href="https://alberthumbert.github.io/2017/07/19/aboutVolley/">览过</a>一遍Volley的源码，对事件派发的部分有不少缺漏，下面进行补充</li>
</ul>
<h2 id="请求容器"><a href="#请求容器" class="headerlink" title="请求容器"></a>请求容器</h2><ul>
<li>我们知道，Volley将所有请求都存放在RequestQueue当中，虽然叫做Queue但实际上RequestQueue并不是collection类，Volley暂存请求的容器有四个，mCacheQueue 用于存放可以访问缓存的请求，mNetworkQueue用于存放需要访问网络的请求，mWaitingRequests用于存放等待的处理的请求，mCurrentRequests用于存放正在处理的请求，之前对mWaitingRequests的存在意义不是很理解，后来发现它的设计还是很巧妙的，下面会进行详细的分析</li>
</ul>
<pre><code>private final Map&lt;String, Queue&lt;Request&lt;?&gt;&gt;&gt; mWaitingRequests =
    new HashMap&lt;String, Queue&lt;Request&lt;?&gt;&gt;&gt;();

    private final Set&lt;Request&lt;?&gt;&gt; mCurrentRequests = new HashSet&lt;Request&lt;?&gt;&gt;();            

    private final PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mCacheQueue =
new PriorityBlockingQueue&lt;Request&lt;?&gt;&gt;();

    private final PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mNetworkQueue =
new PriorityBlockingQueue&lt;Request&lt;?&gt;&gt;();
</code></pre><ul>
<li>来看RequestQueue的add方法，首先是调用request的setRequestQueue将请求与RequestQueue绑定。然后将请求放入mCurrentRequests，正在处理的请求的容器当中，mCurrentRequests是一个HashSet，线程不安全，所以使用了锁</li>
</ul>
<pre><code>public &lt;T&gt; Request&lt;T&gt; add(Request&lt;T&gt; request) {
    // Tag the request as belonging to this queue and add it to the set of current requests.
    request.setRequestQueue(this);
    synchronized (mCurrentRequests) {
        mCurrentRequests.add(request);
    }

    // Process requests in the order they are added.
    request.setSequence(getSequenceNumber());
    request.addMarker(&quot;add-to-queue&quot;);
</code></pre><ul>
<li>如果请求不能缓存，直接放入mNetworkQueue网络队列</li>
</ul>
<pre><code>// If the request is uncacheable, skip the cache queue and go straight to the network.
if (!request.shouldCache()) {
    mNetworkQueue.add(request);
    return request;
}
</code></pre><ul>
<li>接着对mWaitingRequests的操作是关键，我们先看看文档中对mWaitingRequests的描述。mWaitingRequests是一个HashMap，这个HashMap的每个value值都是一个队列，每个队列当中都是相同的请求，这是因为mWaitingRequests是专门用于存放重复的请求的</li>
</ul>
<pre><code>/**
 * Staging area for requests that already have a duplicate request in flight.
 *
 * &lt;ul&gt;
 *     &lt;li&gt;containsKey(cacheKey) indicates that there is a request in flight for the given cache
 *          key.&lt;/li&gt;
 *     &lt;li&gt;get(cacheKey) returns waiting requests for the given cache key. The in flight request
 *          is &lt;em&gt;not&lt;/em&gt; contained in that list. Is null if no requests are staged.&lt;/li&gt;
 * &lt;/ul&gt;
 */
    private final Map&lt;String, Queue&lt;Request&lt;?&gt;&gt;&gt; mWaitingRequests =
    new HashMap&lt;String, Queue&lt;Request&lt;?&gt;&gt;&gt;();
</code></pre><ul>
<li>继续看add方法，HashMap线程不安全所以也开启了锁，我们发现这里检查mWaitingRequests中是否存在给定的key，如果存在则说明先前已有相同的请求被提交了，但是最初已被提交的请求并不会创建队列，而是放入一个null值，当下一个相同的请求到来，发现Map中有了这个Key值，才会创建队列并且将请求放进队列之后就暂时再不处理，Volley就是利用这种方法避免请求被重复执行的</li>
</ul>
<pre><code>    // Insert request into stage if there&apos;s already a request with the same cache key in flight.
    synchronized (mWaitingRequests) {
        String cacheKey = request.getCacheKey();
        if (mWaitingRequests.containsKey(cacheKey)) {
            // There is already a request in flight. Queue up.
            Queue&lt;Request&lt;?&gt;&gt; stagedRequests = mWaitingRequests.get(cacheKey);
            if (stagedRequests == null) {
                stagedRequests = new LinkedList&lt;Request&lt;?&gt;&gt;();
            }
            stagedRequests.add(request);
            mWaitingRequests.put(cacheKey, stagedRequests);
            if (VolleyLog.DEBUG) {
                VolleyLog.v(&quot;Request for cacheKey=%s is in flight, putting on hold.&quot;, cacheKey);
            }
        } else {
            // Insert &apos;null&apos; queue for this cacheKey, indicating there is now a request in
            // flight.
            mWaitingRequests.put(cacheKey, null);
            mCacheQueue.add(request);
        }
        return request;
    }
}
</code></pre><ul>
<li>进过一段时间，当一个Request被处理完毕时，它的finish方法会被执行，之前Volley将Request与RequestQueue进行了绑定，在这里回调RequestQueue的finish()方法并传入自身</li>
</ul>
<pre><code> void finish(final String tag) {
if (mRequestQueue != null) {
    mRequestQueue.finish(this);
    onFinish();
}
if (MarkerLog.ENABLED) {
    final long threadId = Thread.currentThread().getId();
    if (Looper.myLooper() != Looper.getMainLooper()) {
        // If we finish marking off of the main thread, we need to
        // actually do it on the main thread to ensure correct ordering.
        Handler mainThread = new Handler(Looper.getMainLooper());
        mainThread.post(new Runnable() {
            @Override
            public void run() {
                mEventLog.add(tag, threadId);
                mEventLog.finish(this.toString());
            }
        });
        return;
    }

    mEventLog.add(tag, threadId);
    mEventLog.finish(this.toString());
    }
}    
</code></pre><ul>
<li>下面来看RequestQueue的finish方法，一开始在mCurrentRequests移除了Request，这里比较好理解，接着在等待队列waitingRequests中取出了所有相同的请求，并把这些请求全部加入到mCacheQueue当中，这样做是因为刚刚只是把这些相同的Request放入waitingRequests而没有去处理，现在最初的Request对象被处理完毕了，所有与它相同的请求都可以保证能从缓存中拿到结果了，故将其加入到缓存队列当中。通过这个机制，相同的请求同时进入到RequestQueue中时，只会从网络获取一次（假设Response不需要更新），很好地节约了时间</li>
</ul>
<pre><code>    /**
     * Called from {@link Request#finish(String)}, indicating that processing of the given request
     * has finished.
     *
     * &lt;p&gt;Releases waiting requests for &lt;code&gt;request.getCacheKey()&lt;/code&gt; if
     *      &lt;code&gt;request.shouldCache()&lt;/code&gt;.&lt;/p&gt;
     */
    &lt;T&gt; void finish(Request&lt;T&gt; request) {
// Remove from the set of requests currently being processed.
synchronized (mCurrentRequests) {
    mCurrentRequests.remove(request);
}
synchronized (mFinishedListeners) {
  for (RequestFinishedListener&lt;T&gt; listener : mFinishedListeners) {
    listener.onRequestFinished(request);
      }
    }

if (request.shouldCache()) {
    synchronized (mWaitingRequests) {
        String cacheKey = request.getCacheKey();
        Queue&lt;Request&lt;?&gt;&gt; waitingRequests = mWaitingRequests.remove(cacheKey);
        if (waitingRequests != null) {
            if (VolleyLog.DEBUG) {
                VolleyLog.v(&quot;Releasing %d waiting requests for cacheKey=%s.&quot;,
                        waitingRequests.size(), cacheKey);
            }
            // Process all queued up requests. They won&apos;t be considered as in flight, but
            // that&apos;s not a problem as the cache has been primed by &apos;request&apos;.
            mCacheQueue.addAll(waitingRequests);
        }
    }
}
} 
</code></pre><h2 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h2><ul>
<li>再来看start方法，这里开启了处理和分发请求的线程，网上普遍说这里处理网络请求的线程<strong>默认</strong>是四个，但实际上由于外部调用RequestQueue的构造方法没有意义，所以定死了就是四个</li>
</ul>
<pre><code>    public void start() {
    stop();  // Make sure any currently running dispatchers are stopped.
    // Create the cache dispatcher and start it.
    mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);
    mCacheDispatcher.start();

    // Create network dispatchers (and corresponding threads) up to the pool size.
    for (int i = 0; i &lt; mDispatchers.length; i++) {
        NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork,
                mCache, mDelivery);
        mDispatchers[i] = networkDispatcher;
        networkDispatcher.start();
    }
}


    ...

    RequestQueue queue;
    if (maxDiskCacheBytes &lt;= -1)
            {
        // No maximum size specified
        queue = new RequestQueue(new DiskBasedCache(cacheDir), network);
    }
    else
          {
              // Disk cache size specified
              queue = new RequestQueue(new DiskBasedCache(cacheDir, maxDiskCacheBytes), network);
          }

    ...

    public RequestQueue(Cache cache, Network network) {
            this(cache, network, DEFAULT_NETWORK_THREAD_POOL_SIZE);
        }

    ...

    public RequestQueue(Cache cache, Network network, int threadPoolSize,
        ResponseDelivery delivery) {
    mCache = cache;
    mNetwork = network;
    mDispatchers = new NetworkDispatcher[threadPoolSize];
    mDelivery = delivery;
    }

    ...
</code></pre><ul>
<li>我们来看处理缓存请求的CacheDispatcher线程的run方法，具体的分析写在注释里</li>
</ul>
<pre><code>    @Override
    public void run() {
if (DEBUG) VolleyLog.v(&quot;start new dispatcher&quot;);
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);

// Make a blocking call to initialize the cache.
mCache.initialize();
//初始化缓存

Request&lt;?&gt; request;
while (true) {
//开启一个死循环处理请求
    // release previous request object to avoid leaking request object when mQueue is drained.
    request = null;
    try {
        // Take a request from the queue.
        request = mCacheQueue.take();
        //重置请求，BlockingQueue的take()方法会阻塞线程直到有一个元素被拿出为止

    } catch (InterruptedException e) {
        // We may have been interrupted because it was time to quit.
        if (mQuit) {
            return;
            //当关闭线程时会在这里抛出异常，检查是否需要停止
        }
        continue;
    }
    try {
        request.addMarker(&quot;cache-queue-take&quot;);

        // If the request has been canceled, don&apos;t bother dispatching it.
        if (request.isCanceled()) {
            request.finish(&quot;cache-discard-canceled&quot;);
            continue;
            //如果请求被取消，直接放过
        }

        // Attempt to retrieve this item from cache.
        Cache.Entry entry = mCache.get(request.getCacheKey());
        if (entry == null) {
            request.addMarker(&quot;cache-miss&quot;);
            // Cache miss; send off to the network dispatcher.
            mNetworkQueue.put(request);
            //拿不到缓存，放入网络队列
            continue;
        }

        // If it is completely expired, just send it to the network.
        if (entry.isExpired()) {
            request.addMarker(&quot;cache-hit-expired&quot;);
            request.setCacheEntry(entry);
            mNetworkQueue.put(request);
            //请求过期，也放入网络队列
            continue;
        }

        // We have a cache hit; parse its data for delivery back to the request.
        request.addMarker(&quot;cache-hit&quot;);
        Response&lt;?&gt; response = request.parseNetworkResponse(
                new NetworkResponse(entry.data, entry.responseHeaders));
        request.addMarker(&quot;cache-hit-parsed&quot;);

        if (!entry.refreshNeeded()) {
            // Completely unexpired cache hit. Just deliver the response.
            mDelivery.postResponse(request, response);
            //从缓存中拿到了结果，如果不需要更新内容，则直接投递结果
        } else {
            // Soft-expired cache hit. We can deliver the cached response,
            // but we need to also send the request to the network for
            // refreshing.
            request.addMarker(&quot;cache-hit-refresh-needed&quot;);
            request.setCacheEntry(entry);

            // Mark the response as intermediate.
            response.intermediate = true;

            // Post the intermediate response back to the user and have
            // the delivery then forward the request along to the network.
            final Request&lt;?&gt; finalRequest = request;

           //如果内容需要更新，也同样会投递结果，不同的是之后这里的run方法会执行，进行更新
            mDelivery.postResponse(request, response, new Runnable() {
                @Override
                public void run() {
                    try {
                        mNetworkQueue.put(finalRequest);
                    } catch (InterruptedException e) {
                        // Not much we can do about this.
                    }
                }
            });
        }
    } catch (Exception e) {
        VolleyLog.e(e, &quot;Unhandled exception %s&quot;, e.toString());
            }
        }
    }
}
</code></pre><ul>
<li>接着再看NetworkDispatcher的run方法，逻辑是差不多的</li>
</ul>
<pre><code>@Override
    public void run() {
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
Request&lt;?&gt; request;
while (true) {
//开启死循环处理请求
    long startTimeMs = SystemClock.elapsedRealtime();
    // release previous request object to avoid leaking request object when mQueue is drained.
    request = null;
    try {
        // Take a request from the queue.
        request = mQueue.take();
        //阻塞直到获得对象
    } catch (InterruptedException e) {
        // We may have been interrupted because it was time to quit.
        if (mQuit) {
            return;
        }
        continue;
    }

    try {
        request.addMarker(&quot;network-queue-take&quot;);

        // If the request was cancelled already, do not perform the
        // network request.
        if (request.isCanceled()) {
            request.finish(&quot;network-discard-cancelled&quot;);
            continue;
        }

        addTrafficStatsTag(request);

        // Perform the network request.
        NetworkResponse networkResponse = mNetwork.performRequest(request);
        //从网络获取Response
        request.addMarker(&quot;network-http-complete&quot;);

        // If the server returned 304 AND we delivered a response already,
        // we&apos;re done -- don&apos;t deliver a second identical response.
        if (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) {
            request.finish(&quot;not-modified&quot;);
            continue;
        }

        // Parse the response here on the worker thread.
        Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse);
        request.addMarker(&quot;network-parse-complete&quot;);

        // Write to cache if applicable.
        // TODO: Only update cache metadata instead of entire record for 304s.
        if (request.shouldCache() &amp;&amp; response.cacheEntry != null) {
            mCache.put(request.getCacheKey(), response.cacheEntry);
            //将结果放入缓存
            request.addMarker(&quot;network-cache-written&quot;);
        }

        // Post the response back.
        request.markDelivered();
        mDelivery.postResponse(request, response);
        //投递结果
    } catch (VolleyError volleyError) {
        volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);
        parseAndDeliverNetworkError(request, volleyError);
    } catch (Exception e) {
        VolleyLog.e(e, &quot;Unhandled exception %s&quot;, e.toString());
        VolleyError volleyError = new VolleyError(e);
        volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);
        mDelivery.postError(request, volleyError);
    }
}
} 
</code></pre><h2 id="ExecutorDelivery"><a href="#ExecutorDelivery" class="headerlink" title="ExecutorDelivery"></a>ExecutorDelivery</h2><ul>
<li>mDelivery是真正用于投递结果的对象，是ExecutorDelivery的实例，持有一个主线程的handler</li>
</ul>
<pre><code>    public RequestQueue(Cache cache, Network network, int threadPoolSize) {
this(cache, network, threadPoolSize,
        new ExecutorDelivery(new Handler(Looper.getMainLooper())));
    }

    public ExecutorDelivery(final Handler handler) {                // Make an Executor that just wraps the handler.
       mResponsePoster = new Executor() {
           @Override
           public void execute(Runnable command) {
               handler.post(command);
           }
       };
}
</code></pre><ul>
<li>ExecutorDelivery内部有一个实现了Runnable接口的类，它用于将请求结构返回给我们实现的监听器，这样我们就能接收到数据了，注意这里还调用到了Request的finish方法，这之后就回到刚刚讲到的RequestQueue的finish方法了</li>
</ul>
<pre><code>        /**
         * A Runnable used for delivering network responses to a listener on the
         * main thread.
         */
        @SuppressWarnings(&quot;rawtypes&quot;)
        private class ResponseDeliveryRunnable implements Runnable {
            private final Request mRequest;
            private final Response mResponse;
            private final Runnable mRunnable;

    public ResponseDeliveryRunnable(Request request, Response response, Runnable runnable) {
        mRequest = request;
        mResponse = response;
        mRunnable = runnable;
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public void run() {
        // If this request has canceled, finish it and don&apos;t deliver.
        if (mRequest.isCanceled()) {
            mRequest.finish(&quot;canceled-at-delivery&quot;);
            return;
        }

        // Deliver a normal response or error, depending.
        if (mResponse.isSuccess()) {
            mRequest.deliverResponse(mResponse.result);
        } else {
            mRequest.deliverError(mResponse.error);
        }

        // If this is an intermediate response, add a marker, otherwise we&apos;re done
        // and the request can be finished.
        if (mResponse.intermediate) {
            mRequest.addMarker(&quot;intermediate-response&quot;);
        } else {
            mRequest.finish(&quot;done&quot;);
        }

        // If we have been provided a post-delivery runnable, run it.
        if (mRunnable != null) {
            mRunnable.run();
        }
   }
}
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Picasso 源码分析]]></title>
      <url>/2017/08/08/aboutPicasso/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<ul>
<li>使用<a href="https://github.com/square/picasso" target="_blank" rel="external">Picasso</a>主要包括四步，创建单例（with / Builder），传入链接（load），配置属性（centerCrop，resize … ），加载图片（into），下面就大致按照这个顺序来解析Picasso的源码</li>
</ul>
<pre><code>Picasso.with(context)
        .load(uri)
        .centerCrop()
        .into(imageView);
</code></pre><h2 id="with"><a href="#with" class="headerlink" title="with"></a>with</h2><ul>
<li>with方法是一种全部使用内部默认组件进行初始化的方法，所以并不会很复杂，这里主要用到了单例模式，通过Builder对象创建Picasso的单例，注意这里的Builder对象在创建出来之后直接调用了build()方法，其实相当于没有使用到建造者模式</li>
</ul>
<pre><code>public static Picasso with(Context context) {
  if (singleton == null) {
    synchronized (Picasso.class) {
      if (singleton == null) {
        singleton = new Builder(context).build();
      }
    }
  }
  return singleton;
}
</code></pre><ul>
<li>再来看build()方法，这里包含了Picasso中几个至关重要的成员的初始化，Downloader、Cache、ExecutorService、RequestTransformer、Stats和Dispatcher</li>
</ul>
<pre><code>  public Picasso build() {
    Context context = this.context;

    if (downloader == null) {
      downloader = Utils.createDefaultDownloader(context);
    }
    if (cache == null) {
      cache = new LruCache(context);
    }
    if (service == null) {
      service = new PicassoExecutorService();
    }
    if (transformer == null) {
      transformer = RequestTransformer.IDENTITY;
    }

    Stats stats = new Stats(cache);

    Dispatcher dispatcher = new Dispatcher(context, service, HANDLER, downloader, cache, stats);

    return new Picasso(context, dispatcher, cache, listener, transformer, requestHandlers, stats,
        defaultBitmapConfig, indicatorsEnabled, loggingEnabled);
  }
} 
</code></pre><ul>
<li>默认的downloader使用的是OkHttpClient或者UrlConnection，一般情况下会是OkHttpClient，它们是用于处理图片的网络请求工具类，如有需要我们可以进行自定义，只需实现Downloader接口即可，但一般没有这个必要</li>
</ul>
<pre><code>static Downloader createDefaultDownloader(Context context) {
    try {
      Class.forName(&quot;com.squareup.okhttp.OkHttpClient&quot;);
      //如果加载类时抛出异常，将使用UrlConnectionDownloader
      return OkHttpLoaderCreator.create(context);
    } catch (ClassNotFoundException ignored) {
    }
    return new UrlConnectionDownloader(context);
  }

...
public class OkHttpDownloader implements Downloader {
  private static OkHttpClient defaultOkHttpClient() {
    OkHttpClient client = new OkHttpClient();
    client.setConnectTimeout(Utils.DEFAULT_CONNECT_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
    client.setReadTimeout(Utils.DEFAULT_READ_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
    client.setWriteTimeout(Utils.DEFAULT_WRITE_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
    return client;
  } 

...
public class UrlConnectionDownloader implements Downloader {
  static final String RESPONSE_SOURCE = &quot;X-Android-Response-Source&quot;;
  static volatile Object cache;

  private static final Object lock = new Object();
  private static final String FORCE_CACHE = &quot;only-if-cached,max-age=2147483647&quot;;
  private static final ThreadLocal&lt;StringBuilder&gt; CACHE_HEADER_BUILDER =
  new ThreadLocal&lt;StringBuilder&gt;() {
        @Override protected StringBuilder initialValue() {
          return new StringBuilder();
        }
      };

  private final Context context;

  public UrlConnectionDownloader(Context context) {
    this.context = context.getApplicationContext();
  }          
</code></pre><ul>
<li>cache，默认LruCache，没什么好讲的，一般自定义也是封装LruCache</li>
</ul>
<ul>
<li>service，Picasso使用ThreadPoolExecutor配置的线程池，内部根据手机使用的通信标准进行了优化，核心线程数与最大线程数一致，根据网络条件优劣(wifi,4g,3g,2g)进行配置</li>
</ul>
<pre><code>private void setThreadCount(int threadCount) {
  setCorePoolSize(threadCount);
  setMaximumPoolSize(threadCount);
}
</code></pre><ul>
<li>PicassoExecutorService维护一个优先级队列，质量高的图片优先加载，质量相同的图片先进先出</li>
</ul>
<pre><code>public enum Priority {
    LOW,
    NORMAL,
    HIGH
  }

 @Override
public int compareTo(PicassoFutureTask other) {
  Picasso.Priority p1 = hunter.getPriority();
  Picasso.Priority p2 = other.hunter.getPriority();

  // High-priority requests are &quot;lesser&quot; so they are sorted to the front.
  // Equal priorities are sorted by sequence number to provide FIFO ordering.
  return (p1 == p2 ? hunter.sequence - other.hunter.sequence : p2.ordinal() - p1.ordinal());
}
</code></pre><ul>
<li>RequestTransformer，对Request进行转换的接口，内部提供一个空实现，一般也不做处理</li>
</ul>
<pre><code>public interface RequestTransformer {

  Request transformRequest(Request request);

  RequestTransformer IDENTITY = new RequestTransformer() {
    @Override public Request transformRequest(Request request) {
      return request;
    }
  };
}
</code></pre><ul>
<li>stats，记录图片状态，dispatcher，用于分发任务，之后会详细分析</li>
</ul>
<ul>
<li>使用Builder可以进行一些自定义配置，注意不要漏了设置单例</li>
</ul>
<pre><code>Picasso picasso = new Picasso.Builder(this)  
        .downloader(...) 
        .addRequestHandler(...)
        .build();  
        Picasso.setSingletonInstance(picasso);  
</code></pre><h2 id="load"><a href="#load" class="headerlink" title="load"></a>load</h2><ul>
<li>load用于传入的链接并创建RequestCreator对象，提供四个重载，但最终都将参数转换为uri处理，RequestCreator实际上也是一个builder模式</li>
</ul>
<pre><code>public RequestCreator load(Uri uri) {
  return new RequestCreator(this, uri, 0);
}

  public RequestCreator load(String path) {
  if (path == null) {
    return new RequestCreator(this, null, 0);
  }
  if (path.trim().length() == 0) {
    throw new IllegalArgumentException(&quot;Path must not be empty.&quot;);
  }
  return load(Uri.parse(path));
}

  public RequestCreator load(File file) {
  if (file == null) {
    return new RequestCreator(this, null, 0);
  }
  return load(Uri.fromFile(file));
}

  public RequestCreator load(int resourceId) {
  if (resourceId == 0) {
    throw new IllegalArgumentException(&quot;Resource ID must not be zero.&quot;);
  }
  return new RequestCreator(this, null, resourceId);
}
</code></pre><ul>
<li>通过RequestCreator，我们可以对加载的图片进行一些设定，传入的参数一般保留在RequestCreator的成员变量data当中</li>
</ul>
<pre><code>public RequestCreator resize(int targetWidth, int targetHeight) {
  data.resize(targetWidth, targetHeight);
  return this;
}

public RequestCreator centerCrop() {
  data.centerCrop();
  return this;
}

  public RequestCreator rotate(float degrees) {
  data.rotate(degrees);
  return this;
}
</code></pre><h2 id="into"><a href="#into" class="headerlink" title="into"></a>into</h2><ul>
<li>into是真正加载图片的方法，这个方法中首先对刚刚传入的参数进行检查和应用，这部分不是重点</li>
</ul>
<pre><code>if (!data.hasImage()) { 
...
}

if (data.hasSize()) {
...
}

if (setPlaceholder) {
...
}
</code></pre><ul>
<li>在这之后会判断是否从内存缓存读取图片，拿到图片则关闭请求设置图片，拿不到再去加载图片</li>
</ul>
<pre><code>if (shouldReadFromMemoryCache(memoryPolicy)) {
      Bitmap bitmap = picasso.quickMemoryCacheCheck(requestKey);
      //从缓存中读取
      if (bitmap != null) {
        picasso.cancelRequest(target);
        //关闭请求
        setBitmap(target, picasso.context, bitmap, MEMORY, noFade, picasso.indicatorsEnabled);
        //设置图片
        if (picasso.loggingEnabled) {
              log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), &quot;from &quot; + MEMORY);
          //如果需要，将图片信息用log打出    
        }
        if (callback != null) {
          callback.onSuccess();
          //加载图片的监听器
        }
        return;
      }
    }

    //如果拿不到图片，则从本地或网络加载
    if (setPlaceholder) {
      setPlaceholder(target, getPlaceholderDrawable());
      //如果需要，设置占位图
    }

    Action action =
new ImageViewAction(picasso, target, request, memoryPolicy, networkPolicy, errorResId,
    errorDrawable, requestKey, tag, callback, noFade);
    //创建action对象
    picasso.enqueueAndSubmit(action);
    //投递action对象
  }
</code></pre><ul>
<li>可以看到action对象几乎包含了图片的所有信息，这之后action会交由Dispatcher的dispatchSubmit方法处理，这个handler来自于HandlerThread</li>
</ul>
<pre><code>this.dispatcherThread = new DispatcherThread();  
   this.handler = new DispatcherHandler(dispatcherThread.getLooper(), this);

static class DispatcherThread extends HandlerThread {
    DispatcherThread() {
      super(Utils.THREAD_PREFIX + DISPATCHER_THREAD_NAME, THREAD_PRIORITY_BACKGROUND);
    }
  }

  void dispatchSubmit(Action action) {
            handler.sendMessage(handler.obtainMessage(REQUEST_S        UBMIT, action));
          }
</code></pre><ul>
<li><p>如无意外现在action对象会在Dispatcher对象的performSubmit方法中被处理，</p>
<pre><code>@Override public void handleMessage(final Message msg) {
  switch (msg.what) {
    case REQUEST_SUBMIT: {
      Action action = (Action) msg.obj;
      dispatcher.performSubmit(action);
      break;
    } 

...    
</code></pre></li>
</ul>
<h2 id="BitmapHunter"><a href="#BitmapHunter" class="headerlink" title="BitmapHunter"></a>BitmapHunter</h2><ul>
<li>BitmaHunter是一个Runnable对象，内部最多可持有三个Action对象</li>
</ul>
<ul>
<li>performSubmit的主要步骤是，判断请求是否被停止，判断Action是否已分配BitmapHunter，判断线程池是否被关闭，以上三个条件只要一个成立都会直接返回，如果都不成立则创建BitmapHunter，投递BimapHunter给线程池</li>
</ul>
<pre><code>    void performSubmit(Action action, boolean dismissFailed) {
      if (pausedTags.contains(action.getTag())) {
        pausedActions.put(action.getTarget(), action);
        if (action.getPicasso().loggingEnabled) {
          log(OWNER_DISPATCHER, VERB_PAUSED, action.request.logId(),
      &quot;because tag &apos;&quot; + action.getTag() + &quot;&apos; is paused&quot;);
        }
        return;
      }

      BitmapHunter hunter = hunterMap.get(action.getKey());
      if (hunter != null) {
        hunter.attach(action);
        return;
      }

      if (service.isShutdown()) {
        if (action.getPicasso().loggingEnabled) {
          log(OWNER_DISPATCHER, VERB_IGNORED, action.request.logId(), &quot;because shut down&quot;);
        }
        return;
      }

      hunter = forRequest(action.getPicasso(), this, cache, stats, action);
      hunter.future = service.submit(hunter);
      hunterMap.put(action.getKey(), hunter);
      if (dismissFailed) {
        failedActions.remove(action.getTarget());
      }

      if (action.getPicasso().loggingEnabled) {
        log(OWNER_DISPATCHER, VERB_ENQUEUED, action.request.logId());
      }
}
</code></pre><ul>
<li>创建BitmapHunter中使用到了责任链模式，在Picasso的构造函数中，初始化了一条责任链，这是一条不可变的RequestHandler的ArrayList，RequestHandler对象在BitmapHunter中用于获取Bitmap对象，RequestHandler是一个抽象类其中包含判断是否可以处理某个请求的canHandleRequest方法，图片对象的构造器，压缩图片的calculateInSampleSize方法</li>
</ul>
<pre><code>allRequestHandlers.add(new ContactsPhotoRequestHandler(context));
allRequestHandlers.add(new MediaStoreRequestHandler(context));
allRequestHandlers.add(new ContentStreamRequestHandler(context));
allRequestHandlers.add(new AssetRequestHandler(context));
allRequestHandlers.add(new FileRequestHandler(context));
allRequestHandlers.add(new NetworkRequestHandler(dispatcher.downloader, stats));
requestHandlers = Collections.unmodifiableList(allRequestHandlers);
</code></pre><ul>
<li>创建BitmapHunter时，遍历RequestHandler链表，查找可以处理Request的对象</li>
</ul>
<pre><code>    static BitmapHunter forRequest(Picasso picasso, Dispatcher dispatcher, Cache cache, Stats stats,
Action action) {
      Request request = action.getRequest();
      List&lt;RequestHandler&gt; requestHandlers = picasso.getRequestHandlers();

      // Index-based loop to avoid allocating an iterator.
      //noinspection ForLoopReplaceableByForEach
      for (int i = 0, count = requestHandlers.size(); i &lt; count; i++) {
        RequestHandler requestHandler = requestHandlers.get(i);
        if (requestHandler.canHandleRequest(request)) {
          return new BitmapHunter(picasso, dispatcher, cache, stats, action, requestHandler);
        }
      }

      return new BitmapHunter(picasso, dispatcher, cache,         stats, action, ERRORING_HANDLER);
    } 
</code></pre><ul>
<li>在BitmapHunter的run方法中执行了hunt方法，hunt方法使用requestHandler的load方法得到需要的bitmap，之后使用dispatcher来传递bitmap</li>
</ul>
<pre><code>Bitmap hunt() throws IOException {
    ...
    data.networkPolicy = retryCount == 0 ? NetworkPolicy.OFFLINE.index : networkPolicy;
    RequestHandler.Result result = requestHandler.load(data, networkPolicy);
    if (result != null) {
      loadedFrom = result.getLoadedFrom();
      exifRotation = result.getExifOrientation();

      bitmap = result.getBitmap();
     ...

     }


Run(){
    ...
      result = hunt();

      if (result == null) {
        dispatcher.dispatchFailed(this);
      } else {
        dispatcher.dispatchComplete(this);
    ...
      }
}             
</code></pre><ul>
<li>最终bitmap被传递到performBatchComplete当中，使用主线程的handler来发送信息，在handlerMessage方法中调用到了picasso对象的complete方法，这个方法最终调用到了action的complete方法</li>
</ul>
<pre><code>void performBatchComplete() {
  List&lt;BitmapHunter&gt; copy = new ArrayList&lt;BitmapHunter&gt;(batch);
  batch.clear();
  mainThreadHandler.sendMessage(mainThreadHandler.obtainMessage(HUNTER_BATCH_COMPLETE, copy));
  logBatch(copy);
} 
</code></pre><ul>
<li>在ImageViewAction的complete方法中我们可以看到bitmap已经被设置了，这样就完成了一个完整的图片加载过程</li>
</ul>
<pre><code>@Override public void complete(Bitmap result,         Picasso.LoadedFrom from) {
  if (result == null) {
    throw new AssertionError(
        String.format(&quot;Attempted to complete action with no result!\n%s&quot;, this));
  }

  ImageView target = this.target.get();
  if (target == null) {
    return;
  }

  Context context = picasso.context;
  boolean indicatorsEnabled = picasso.indicatorsEnabled;
  PicassoDrawable.setBitmap(target, context, result, from, noFade, indicatorsEnabled);

  if (callback != null) {
    callback.onSuccess();
  }
} 
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Matisse 源码分析]]></title>
      <url>/2017/08/07/aboutMatisse/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<ul>
<li>首先还是从最初使用的地方开始一步步分析，很明显这里用到了builder模式，我们在启动Activity之前进行一些基本的配置，这里主要关心的方法有三个from，choose和forResult</li>
</ul>
<pre><code>Matisse.from(SampleActivity.this)
        .choose(MimeType.ofAll(), false)
        .countable(true)
        // 是否在图片右上角显示选中的数目
        .capture(true)
        //是否开启照相功能
        .captureStrategy(new CaptureStrategy(true, &quot;com.zhihu.matisse.sample.fileprovider&quot;)) 
        .maxSelectable(9)
        //设置最大可选数量
        .addFilter(new GifSizeFilter(320, 320, 5 * Filter.K * Filter.K))
        //添加过滤器,可自定义
        .gridExpectedSize(getResources().getDimensionPixelSize(R.dimen.grid_expected_size))
        //设置期待的尺寸
        .restrictOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT)
        //设置布局的水平或垂直属性
        .thumbnailScale(0.85f)
        //缩略图的缩放尺寸，默认为0.5
        .imageEngine(new GlideEngine())
        //设置图片加载库，Matisse对Glide和Picasso做了一层封装，也可以自定义，后面会提到
        .forResult(REQUEST_CODE_CHOOSE);
        //启动选择图片的Activity
</code></pre><ul>
<li>查看from方法，这里利用重载一个静态构造方法，既可以利用Activity也可以通过Fragment来创建Matisse对象</li>
</ul>
<pre><code>public static Matisse from(Activity activity) {
    return new Matisse(activity);
}

public static Matisse from(Fragment fragment) {
    return new Matisse(fragment);
}
</code></pre><ul>
<li>查看choose方法，这里我们定义了可以获取的媒体类型，构造并返回SelectionCreator对象，SelectionCreator类是Matisse中一个类似Builder的类型，从这里开始所有的配置方法都返回这个SelectionCreator</li>
</ul>
<pre><code>    public SelectionCreator choose(Set&lt;MimeType&gt; mimeTypes) {
        return this.choose(mimeTypes, true);
    }

    public SelectionCreator choose(Set&lt;MimeType&gt; mimeTypes, boolean mediaTypeExclusive) {
return new SelectionCreator(this, mimeTypes, mediaTypeExclusive);
}
</code></pre><ul>
<li>查看SelectionCreator对象的构造器和类结构，它只持有刚刚创建的Matisse对象和SelectionSpec对象，SelectionSpec对象保存调用countable，capture等方法时传入的参数，也就是保存了我们对matisse的配置属性</li>
</ul>
<pre><code>SelectionCreator(Matisse matisse, @NonNull Set&lt;MimeType&gt; mimeTypes, boolean mediaTypeExclusive) {
mMatisse = matisse;
mSelectionSpec = SelectionSpec.getCleanInstance();
mSelectionSpec.mimeTypeSet = mimeTypes;
mSelectionSpec.mediaTypeExclusive = mediaTypeExclusive;
mSelectionSpec.orientation = SCREEN_ORIENTATION_UNSPECIFIED;
}
</code></pre><ul>
<li>mSelectionSpec是一个懒汉式单例，当被初次调用<br>时InstanceHolder才会被加载进来，同时完成INSTANCE的初始化</li>
</ul>
<pre><code>private static final class InstanceHolder {
private static final SelectionSpec INSTANCE = new SelectionSpec();
} 
</code></pre><ul>
<li>mSelectionSpec 持有了这些配置属性，作为一个第三方库，我们使用的时候只需要进行这些配置，而不需要关系Matisse的内部实现</li>
</ul>
<pre><code>public Set&lt;MimeType&gt; mimeTypeSet;
    public boolean mediaTypeExclusive;
    public boolean showSingleMediaType;
    public int themeId;
    public int orientation;
    public boolean countable;
    public int maxSelectable;
    public List&lt;Filter&gt; filters;
    public boolean capture;
    public CaptureStrategy captureStrategy;
    public int spanCount;
    public int gridExpectedSize;
    public float thumbnailScale;
    public ImageEngine imageEngine; 
</code></pre><ul>
<li>再来看看forResult方法，如果我们之前传入的是activity就会调用activity的startActivityForResult，如果传入的是fragment那就调用fragment的startActivityForResult方法，所以重写onActivityResult方法获取返回的数据即可</li>
</ul>
<pre><code>    public void forResult(int requestCode) {
Activity activity = mMatisse.getActivity();
if (activity == null) {
    return;
}

Intent intent = new Intent(activity, MatisseActivity.class);

Fragment fragment = mMatisse.getFragment();
if (fragment != null) {
    fragment.startActivityForResult(intent, requestCode);
} else {
    activity.startActivityForResult(intent, requestCode);
}
} 

...

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
super.onActivityResult(requestCode, resultCode, data);
if (requestCode == REQUEST_CODE_CHOOSE &amp;&amp; resultCode == RESULT_OK) {
    mAdapter.setData(Matisse.obtainResult(data), Matisse.obtainPathResult(data));
}
}
</code></pre><ul>
<li>刚才使用startActivityForResult启动了MatisseActivity，那么首先查看MatisseActivity的onCreate方法，这里获取到了刚刚的SelectionSpec静态常量进行初始化</li>
</ul>
<pre><code>mSpec = SelectionSpec.getInstance();
setTheme(mSpec.themeId);

...

mButtonPreview = (TextView) findViewById(R.id.button_preview);
mButtonApply = (TextView) findViewById(R.id.button_apply);

...

mAlbumsSpinner = new AlbumsSpinner(this);
mAlbumCollection.onCreate(this, this);
</code></pre><ul>
<li>比较值得学习的一点是这里的AlbumsSpinner类，它其实是将Activity左上角的一组控件进行了封装，主要包括显示文件夹名称的TextView，ListPopupWindow，Adapter等等，相当于把一个相对完整的功能抽取出来，把逻辑操作写在里面，在Activity中当做一种控件来使用，有点类似自定义View。观察整个MatisseActivity，发现内部基本只有回调方法，逻辑还是挺清晰的。</li>
</ul>
<pre><code>public class AlbumsSpinner {

private static final int MAX_SHOWN_COUNT = 6;
private CursorAdapter mAdapter;
private TextView mSelected;
private ListPopupWindow mListPopupWindow;
private AdapterView.OnItemSelectedListener mOnItemSelectedListener;
...
</code></pre><ul>
<li>Matisse的数据加载使用 <a href="http://www.jianshu.com/p/385327e35711" target="_blank" rel="external">Loader机制</a>，AlbumCollection是一个LoaderCallbacks的实现，同时提供一个接口给Activity在数据加载时更新UI</li>
</ul>
<pre><code>public interface AlbumCallbacks {
void onAlbumLoad(Cursor cursor);

void onAlbumReset();
}
</code></pre><ul>
<li>当选中文件夹时，调用Activity中的回调方法，如果没有图片就加载一个简单的布局提示用户，有图片就加载一个Fragment，并传入一个Album文件夹对象</li>
</ul>
<pre><code>    @Override
    public void onItemSelected(AdapterView&lt;?&gt; parent, View view, int position, long id) {
mAlbumCollection.setStateCurrentSelection(position);
mAlbumsAdapter.getCursor().moveToPosition(position);
Album album = Album.valueOf(mAlbumsAdapter.getCursor());
if (album.isAll() &amp;&amp; SelectionSpec.getInstance().capture) {
    album.addCaptureCount();
}
onAlbumSelected(album);
    }

    private void onAlbumSelected(Album album) {
if (album.isAll() &amp;&amp; album.isEmpty()) {
    mContainer.setVisibility(View.GONE);
    mEmptyView.setVisibility(View.VISIBLE);
} else {
    mContainer.setVisibility(View.VISIBLE);
    mEmptyView.setVisibility(View.GONE);
    Fragment fragment = MediaSelectionFragment.newInstance(album);
    getSupportFragmentManager()
            .beginTransaction()
            .replace(R.id.container, fragment, MediaSelectionFragment.class.getSimpleName())
            .commitAllowingStateLoss();
    }
} 
</code></pre><ul>
<li>进入到MediaSelectionFragment，在onAttach方法中将Activity作为监听器传来进来</li>
</ul>
<pre><code>    @Override
    public void onAttach(Context context) {
super.onAttach(context);
if (context instanceof SelectionProvider) {
    mSelectionProvider = (SelectionProvider) context;
} else {
    throw new IllegalStateException(&quot;Context must implement SelectionProvider.&quot;);
}
if (context instanceof AlbumMediaAdapter.CheckStateListener) {
    mCheckStateListener = (AlbumMediaAdapter.CheckStateListener) context;
}
if (context instanceof AlbumMediaAdapter.OnMediaClickListener) {
    mOnMediaClickListener = (AlbumMediaAdapter.OnMediaClickListener) context;
}
    }
</code></pre><ul>
<li>各种初始化的操作主要在onActivityCreated当中，比较重要的步骤是通过在Activity中传入的Album对象初始化Loader</li>
</ul>
<pre><code>mAlbumMediaCollection.onCreate(getActivity(), this);
mAlbumMediaCollection.load(album, selectionSpec.capture);

    public void load(@Nullable Album target, boolean enableCapture) {
Bundle args = new Bundle();
args.putParcelable(ARGS_ALBUM, target);
args.putBoolean(ARGS_ENABLE_CAPTURE, enableCapture);
mLoaderManager.initLoader(LOADER_ID, args, this);
}


@Override
    public void onMediaClick(Album album, Item item, int adapterPosition) {
Intent intent = new Intent(this, AlbumPreviewActivity.class);
intent.putExtra(AlbumPreviewActivity.EXTRA_ALBUM, album);
intent.putExtra(AlbumPreviewActivity.EXTRA_ITEM, item);
intent.putExtra(BasePreviewActivity.EXTRA_DEFAULT_BUNDLE, mSelectedCollection.getDataWithBundle());
startActivityForResult(intent, REQUEST_CODE_PREVIEW);
    }
</code></pre><ul>
<li>Fragment图片Item的监听器最终调用到，Activity中的方法，启动预览Activity，这后面就没什么好说的了</li>
</ul>
<pre><code>    @Override
    public void onMediaClick(Album album, Item item, int adapterPosition) {
Intent intent = new Intent(this, AlbumPreviewActivity.class);
intent.putExtra(AlbumPreviewActivity.EXTRA_ALBUM, album);
intent.putExtra(AlbumPreviewActivity.EXTRA_ITEM, item);
intent.putExtra(BasePreviewActivity.EXTRA_DEFAULT_BUNDLE, mSelectedCollection.getDataWithBundle());
startActivityForResult(intent, REQUEST_CODE_PREVIEW);
    }
</code></pre><ul>
<li>另外在RecycleView的AlbumMediaAdapter的onBindViewHolder中，可以发现Matisse将ViewHolder抽取出来，通过preBindMedia和bindMedia来设定Item信息</li>
</ul>
<pre><code>mediaViewHolder.mMediaGrid.preBindMedia(new MediaGrid.PreBindInfo(
        getImageResize(mediaViewHolder.mMediaGrid.getContext()),
        mPlaceholder,
        mSelectionSpec.countable,
        holder
));
mediaViewHolder.mMediaGrid.bindMedia(item);
</code></pre><ul>
<li>ViewHolder中只有一个MediaGrid对象，它是一个正方形的FrameLayout</li>
</ul>
<pre><code>public class MediaGrid extends SquareFrameLayout implements View.OnClickListener {

private ImageView mThumbnail;
private CheckView mCheckView;
private ImageView mGifTag;
private TextView mVideoDuration;

private Item mMedia;
private PreBindInfo mPreBindInfo;
private OnMediaGridClickListener mListener; 
</code></pre><ul>
<li>在MediaGrid中我们可以找到设定图片的方法，engine包下是真正的图片加载工具，包括了默认的GlideEngine和PicassoEngine</li>
</ul>
<pre><code>    private void setImage() {
if (mMedia.isGif()) {
    SelectionSpec.getInstance().imageEngine.loadGifThumbnail(getContext(), mPreBindInfo.mResize,
            mPreBindInfo.mPlaceholder, mThumbnail, mMedia.getContentUri());
} else {
    SelectionSpec.getInstance().imageEngine.loadThumbnail(getContext(), mPreBindInfo.mResize,
            mPreBindInfo.mPlaceholder, mThumbnail, mMedia.getContentUri());
    }
}
</code></pre><ul>
<li>GlideEngine，PicassoEngine是对两个第三方库的封装，实现了ImageEngine接口，ImageEngine中只有几个加载图片的方法，如果要使用自定义的图片加载工具，只需实现这个接口即可，可见使用接口大大地提高了可扩展性</li>
</ul>
<pre><code>    public interface ImageEngine {

    void loadThumbnail(Context context, int resize, Drawable placeholder, ImageView imageView, Uri uri);

    void loadGifThumbnail(Context context, int resize, Drawable placeholder, ImageView imageView, Uri uri);


    void loadImage(Context context, int resizeX, int resizeY, ImageView imageView, Uri uri);

    void loadGifImage(Context context, int resizeX, int resizeY, ImageView imageView, Uri uri);

    boolean supportAnimatedGif();
} 
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[线程池基本用法]]></title>
      <url>/2017/07/28/aboutThreadPool/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<h2 id="关于线程池"><a href="#关于线程池" class="headerlink" title="关于线程池"></a>关于线程池</h2><ul>
<li>当我们异步处理请求时，如果每一个请求都去创建一个线程，那么请求和销毁线程所消耗的时间和空间上的资源可能比时间处理请求的销毁的资源更多，为了解决线程开销的问题，需要使用线程池统一管理和复用线程</li>
</ul>
<ul>
<li>任何的多线程操作都有死锁的风险。如果线程池太大，系统资源会被长期占用影响程序的性能。</li>
</ul>
<ul>
<li>线程池最严重的风险是线程泄漏，当线程抛出运行时异常或Error时如果没有被捕捉，线程意外死亡，那么池的大小就永远减小一个，最终很有可能导致线程池为空的情况，另外如果某个线程被一个任务永久消耗，那么实际上它相当于被从线程池中移除了</li>
</ul>
<h2 id="Java自带线程池"><a href="#Java自带线程池" class="headerlink" title="Java自带线程池"></a>Java自带线程池</h2><h3 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h3><ul>
<li>java.util.concurrent包中提供了进行后台操作的接口ExecutorService，这个接口继承了Executor接口，Executor中只有一个Execute方法，ExecutorService主要有两个实现ThreadPoolExecutor和ScheduledThreadPoolExecutor，这两个类为我们提供了各种各样的线程池</li>
</ul>
<pre><code>public interface Executor {

/**
 * Executes the given command at some time in the future.  The command
 * may execute in a new thread, in a pooled thread, or in the calling
 * thread, at the discretion of the {@code Executor} implementation.
 *
 * @param command the runnable task
 * @throws RejectedExecutionException if this task can    not be
 * accepted for execution
 * @throws NullPointerException if command is null
 */
void execute(Runnable command);
}
</code></pre><ul>
<li><p>ExecutorService有一个工厂类Executors，Executors可以创建下面四类线程池</p>
<pre><code>newCachedThreadPool
newFixedThreadPool
newScheduledThreadPoo
newSingleThreadExecutor
</code></pre></li>
</ul>
<ul>
<li><p>ExecutorService有五个执行方法</p>
<pre><code>execute(Runnable)
submit(Runnable)
submit(Callable)
invokeAny()
invokeAll()
</code></pre></li>
<li><p>execute方法不能得到返回值而submit方法可以得到返回值的Future对象，使用submit(Runnable)得到的Future对象调用get()方法会阻塞当前线程，并最终得到一个null值，但是submit(Callable)得到Future对象的get()方法可以获取结果</p>
</li>
<li><p>invokeAny方法接受一个Callable，但是执行这个方法不会返回Future，而是可以得到其中一个Callable的结果，但无法保证是哪一个Callable的结果，使用invokeAll可以返回一个Future对象的list使用future.get()可以得到对应结果</p>
</li>
</ul>
<h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><ul>
<li><p>这种线程池对线程创建的数量几乎没有要求，查看内部的构造器发现它传递的是Integer.MAX_VALUE，它会根据需要回收线程，如果没有线程可回收就新开线程，当某线程空闲时间超过60秒时，该线程会被回收</p>
<pre><code>    public static ExecutorService newCachedThreadPool() {
return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                              60L, TimeUnit.SECONDS,
                              new SynchronousQueue&lt;Runnable&gt;());
    }
</code></pre></li>
<li><p>开启线程池使用Executors的静态方法</p>
</li>
</ul>
<pre><code>ExecutorService cachedThreadPool = Executors.newCachedThreadPool(); 
</code></pre><ul>
<li>发送请求，投递Runnable或Thread</li>
</ul>
<pre><code>cachedThreadPool.execute(new Runnable() {
        @Override
        public void run() {
        //do something
        }
    });    
</code></pre><ul>
<li>使用shutdown和shutdownNow方法可以终止线程池，shutdown会等待队列中的任务执行完毕才去终止线程池，shutdownNow或尝试打断正在执行的任务    </li>
</ul>
<ul>
<li>这种线程一般用在请求的速度小于处理请求的速度的情况下，也就是说任务的耗时比较短，注意一点要控制任务的数量不然相当于没有使用线程池管理线程，并清空任务队列</li>
</ul>
<h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><ul>
<li>这种线程池可以规定池的大小，每提交一个任务就开启一个线程，直到线程数量达到最大值为止</li>
</ul>
<pre><code>ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3);
</code></pre><ul>
<li>可以看到当任务数量超过池的大小，多出来的任务需要等待空闲的线程</li>
</ul>
<pre><code>fixedThreadPool.execute(new Runnable() {
            @Override
            public void run() {

                try {

                    Thread.sleep(3000);
                    Log.d(TAG, &quot;run: &quot;+index+&quot; &quot;+ Thread.currentThread());

                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

            }
        });


    07-28 15:10:50.137 24819-24849/com.linjiamin.threadtest D/MainActivity: run: 1 Thread[pool-1-thread-2,5,main]
    07-28 15:10:50.137 24819-24850/com.linjiamin.threadtest D/MainActivity: run: 2 Thread[pool-1-thread-3,5,main]
    07-28 15:10:50.157 24819-24848/com.linjiamin.threadtest D/MainActivity: run: 0 Thread[pool-1-thread-1,5,main]
    07-28 15:10:53.138 24819-24849/com.linjiamin.threadtest D/MainActivity: run: 3 Thread[pool-1-thread-2,5,main]
    07-28 15:10:53.138 24819-24850/com.linjiamin.threadtest D/MainActivity: run: 4 Thread[pool-1-thread-3,5,main]
    07-28 15:10:53.158 24819-24848/com.linjiamin.threadtest D/MainActivity: run: 5 Thread[pool-1-thread-1,5,main]
</code></pre><ul>
<li>FixedThreadPool一般用在耗时较长的任务上，对于一些需要马上执行的任务可能要考虑另外执行</li>
</ul>
<h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><ul>
<li>创建一个单线程的Executor，所有任务都在一个线程中执行，并且保证了任务的优先级，当线程发生异常时，会有新的线程被创造，以保证任务的正常进行</li>
</ul>
<pre><code>ExecutorService fixedThreadPool = Executors.newSingleThreadExecutor();    
</code></pre><ul>
<li>适用于需要串行的任务，如数据库，文件的读写等</li>
</ul>
<h3 id="newScheduleThreadPool"><a href="#newScheduleThreadPool" class="headerlink" title="newScheduleThreadPool"></a>newScheduleThreadPool</h3><ul>
<li>一种定长的线程池，支持定时和周期性的执行任务</li>
</ul>
<pre><code>ExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(3);
</code></pre><ul>
<li>使用schedule方法可以重复执行任务</li>
</ul>
<pre><code>public ScheduledFuture&lt;?&gt; schedule(Runnable command,
                               long delay, TimeUnit unit);
</code></pre><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><ul>
<li>上述的四种线程池都调用了ThreadPoolExecutor这个构造方法，ThreadPoolExecutor一般用来定义新的线程池</li>
<li>ThreadPoolExecutor的构造器如下，corePoolSize表示核心池的大小，当线程池中的线程数目大于该值时会把任务放到缓存队列当中</li>
</ul>
<ul>
<li>maximumPoolSize，最大线程数，表示一个线程池最多能创建多少线程</li>
</ul>
<ul>
<li>keepAliveTime，当线程池的大小超过corePoolSize且线程的空闲时间超过该值，该线程就会终止</li>
</ul>
<ul>
<li>unit时间单位，包括DAYS，HOURS，MINUTES，SECONDS，MILLISECONDS，MICROSECONDS，NANOSECONDS</li>
</ul>
<ul>
<li>workQueue，阻塞队列，用来储存待执行的任务，一般有三个可能的类型，ArrayBlockingQueue，先进先出队列，必须指定大小，LinkedBlockingQueue，先进先出队列，可不指定大小，SynchronousQueue，直接新建一个线程来执行新来的任务，不缓存任务，ThreadFactory用于创建线程，RejectedExecutionHandler用于处理当线程池拒绝任务时的策略</li>
</ul>
<pre><code>public ThreadPoolExecutor(int corePoolSize,
                      int maximumPoolSize,
                      long keepAliveTime,
                      TimeUnit unit,
                      BlockingQueue&lt;Runnable&gt; workQueue,
                      ThreadFactory threadFactory,
                      RejectedExecutionHandler handler) {    
</code></pre><ul>
<li>下面来实现一个后进先出的线程池，首先需要实现它的构造函数，一般外界只需要决定池的大小即可，这里创建了一个PriorityBlockingQueue并传入了自定义的comparator，PriorityBlockingQueue需要comparator来决定优先顺序，那么我们可以利用comparator来实现后进先出</li>
</ul>
<pre><code>    public static LIFOThreadExecutor newLIFOExecutor(int size){

return new LIFOThreadExecutor(size,MAX_SIZE,ALIVE_TIME,TimeUnit.SECONDS,new PriorityBlockingQueue&lt;&gt;(MAX_SIZE,comparator));
    }


    private LIFOThreadExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) {
super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);
    }
</code></pre><ul>
<li>这里我们获取execute方法传入的Runnable对象，并为其加上一个标记</li>
</ul>
<pre><code>class RunnabalbeWithTag implements Runnable{

private final Runnable runnable;
private final long tag;

RunnabalbeWithTag(Runnable runnable) {
    this.runnable = runnable;
    this.tag = LIFOThreadExecutor.this.tag.getAndIncrement();
}

@Override
public void run() {
    runnable.run();
    }
}

@Override
public void execute(Runnable command) {

super.execute(new RunnabalbeWithTag(command));

}
</code></pre><ul>
<li>在compare方法中利用标记决定优先顺序</li>
</ul>
<pre><code>private static final Comparator&lt;Runnable&gt; comparator = new Comparator&lt;Runnable&gt;() {
@Override
public int compare(Runnable o1, Runnable o2) {

    return ((RunnabalbeWithTag)o1).tag&lt;((RunnabalbeWithTag)o2).tag ?
            1: ((RunnabalbeWithTag)o1).tag&gt;((RunnabalbeWithTag)o2).tag? -1:0;
    }
};    
</code></pre><ul>
<li>接着使用这个线程池，可以看到已经实现了后进先出的效果</li>
</ul>
<pre><code>LIFOThreadExecutor executor =  LIFOThreadExecutor.newLIFOExecutor(1);
for(int i = 0 ;i&lt;10;i++){

        final int index = i;
        executor.execute(new Runnable() {
            @Override
            public void run() {
                try {
                    Thread.sleep(3000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                Log.d(TAG, &quot;run: &quot;+ index +&quot; &quot;+Thread.currentThread());
            }
        });
    }
}    

    ...
MainActivity: run: 6 Thread[pool-1-thread-1,5,main]
MainActivity: run: 5 Thread[pool-1-thread-1,5,main]
MainActivity: run: 4 Thread[pool-1-thread-1,5,main]
MainActivity: run: 3 Thread[pool-1-thread-1,5,main]
MainActivity: run: 2 Thread[pool-1-thread-1,5,main]
MainActivity: run: 1 Thread[pool-1-thread-1,5,main]
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Bitmap 基本用法]]></title>
      <url>/2017/07/26/aboutBitmap/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<h2 id="Bitmap属性"><a href="#Bitmap属性" class="headerlink" title="Bitmap属性"></a>Bitmap属性</h2><ul>
<li>Bitmap主要的属性有三个，width，height，config，可以直接通过get方法获得</li>
<li>config 是bitmap的像素类型，有四种可能的值，config后面的数字表明了每个像素占用的位数，如    ALPHA_8 为8位，RGB_565为16位，ARGB_8888为32位，ARGB_8888模式的Bitmap是最清晰的，这也是默认的模式</li>
</ul>
<pre><code>ALPHA_8 
RGB_565 
ARGB_4444 
ARGB_8888 
</code></pre><h2 id="获取Bitmap"><a href="#获取Bitmap" class="headerlink" title="获取Bitmap"></a>获取Bitmap</h2><h3 id="获取Bitmap对象"><a href="#获取Bitmap对象" class="headerlink" title="获取Bitmap对象"></a>获取Bitmap对象</h3><ul>
<li>Drawable -&gt; Bitmap </li>
</ul>
<pre><code>//BitmapDrawable
Bitmap bitmap = drawable.getBitmap();

//Drawable
int w = drawable.getIntrinsicWidth();
int h = drawable.getIntrinsicHeight();
Bitmap bitmap = Bitmap.createBitmap(w,h, drawable.getOpacity()!= PixelFormat.OPAQUE?Bitmap.Config.ARGB_8888:Bitmap.Config.RGB_565);
Canvas canvas = new Canvas(bitmap);
drawable.setBounds(0, 0, w, h);
drawable.draw(canvas);
</code></pre><ul>
<li>BitmapFactory.decodeResource，从资源获取</li>
</ul>
<pre><code>Bitmap bitmap = BitmapFactory.decodeResource(getResources(),R.mipmap.ic_launcher);
</code></pre><ul>
<li>BitmapFactory.decodeFile ，从文件获取      </li>
</ul>
<pre><code>//需要加入权限
//WRITE_EXTERNAL_STORAGE
//MOUNT_UNMOUNT_FILESYSTEMS

String path = Environment.getExternalStorageDirectory().getPath()+&quot;/bitmap/bitmaptest.jpg&quot;;
Bitmap bitmap = BitmapFactory.decodeFile(path);
imageView.setImageBitmap(bitmap);
</code></pre><ul>
<li><p>BitmapFactory.decodeByteArray</p>
<pre><code>Bitmap bitmap = BitmapFactory.decodeByteArray(bitmap,0,bitmap);
</code></pre></li>
</ul>
<ul>
<li>BitmapFactory.decodeStream，从流获取, decodeFile和decodeResource内部都调用这个方法       </li>
</ul>
<pre><code>Bitmap bitmap = BitmapFactory.decodeStream(inputStream);
</code></pre><h3 id="获取所有本地图片"><a href="#获取所有本地图片" class="headerlink" title="获取所有本地图片"></a>获取所有本地图片</h3><ul>
<li><p>android的媒体文件数据信息主要存储在 /data/data/com.android.providers.media/databases目录中，其中有两个db文件，external.db和internal.db 前者是储存卡数据库，后者是内部存储的数据库，两者中包含的表和表结构是一致的</p>
</li>
<li><p>数据库中和图片相关的主要有两张表iamges 和 thumbnails，表结构如下，后者是缩略图的信息</p>
</li>
</ul>
<pre><code>CREATE TABLE images (
_id INTEGER PRIMARY KEY,
_data TEXT,
_size INTEGER,
_display_name TEXT,
mime_type TEXT,
title TEXT,
date_added INTEGER,
date_modified INTEGER,
description TEXT,
picasa_id TEXT,
isprivate INTEGER,
latitude DOUBLE,
longitude DOUBLE,
datetaken INTEGER,
orientation INTEGER,
mini_thumb_magic INTEGER,
bucket_id TEXT,
bucket_display_name TEXT);            

CREATE TABLE thumbnails (
_id INTEGER PRIMARY KEY,
_data TEXT,
image_id INTEGER,
kind INTEGER,
width INTEGER,height INTEGER);
</code></pre><ul>
<li>获取所有包含图片的文件夹名称和文件夹id</li>
</ul>
<pre><code>select DISTINCT bucket_display_name from images;
select DISTINCT bucket_id from images;
</code></pre><ul>
<li>获取所有缩略图bitmap</li>
</ul>
<pre><code>public List&lt;ImageInfo&gt; getImage(Context context){

List&lt;ImageInfo&gt; list = new ArrayList&lt;&gt;();

ContentResolver resolver = context.getContentResolver();
Cursor cursor = null;
try{
    cursor = resolver.query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,null,null,null,null);
    int i = 0;
    if(cursor!=null){
        while (cursor.moveToFirst()) {
            Log.d(TAG, &quot;getImage: got &quot;+i++);
            final ImageInfo imageInfo = new ImageInfo();
            imageInfo.id = cursor.getInt(cursor.getColumnIndex(MediaStore.Images.Media._ID));
            imageInfo.path = cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media.DATA));
            Log.d(TAG, &quot;getImage: &quot;+imageInfo.path);
            imageInfo.name = cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media.DISPLAY_NAME));
            imageInfo.bitmap = MediaStore.Images.Thumbnails.getThumbnail(resolver, imageInfo.id, MediaStore.Images.Thumbnails.MICRO_KIND, null);
            list.add(imageInfo);

        }
    }

}catch (Exception e){
    e.printStackTrace();
}

return list;
}

class ImageInfo{

int id ;
String path;
String name;
Bitmap bitmap;
}
</code></pre><h2 id="处理Bitmap"><a href="#处理Bitmap" class="headerlink" title="处理Bitmap"></a>处理Bitmap</h2><h3 id="compress"><a href="#compress" class="headerlink" title="compress"></a>compress</h3><ul>
<li>compress为质量压缩，不会丢失像素，只会降低图片的存储大小，而不会改变Bitmap的内存大小</li>
</ul>
<pre><code>OutputStream outputStream = new FileOutputStream(picFile);
bitmap.compress(Bitmap.CompressFormat.JPEG,50,outputStream);
outputStream.close();
</code></pre><ul>
<li>compress方法接受三个参数,图片类型，压缩比例，流对象，注意压缩比例是从最小质量到最大质量算起的，如果使用PNG格式，这个参数貌似是没有意义的</li>
</ul>
<pre><code> * @param format   The format of the compressed image
 * @param quality  Hint to the compressor, 0-100. 0 meaning compress for
 *                 small size, 100 meaning compress for max quality. Some
 *                 formats, like PNG which is lossless, will ignore the
 *                 quality setting
 * @param stream   The outputstream to write the compressed data.
 * @return true if successfully compressed to the specified stream.
 */
public boolean compress(CompressFormat format, int quality, OutputStream stream)
</code></pre><h3 id="inSampleSize"><a href="#inSampleSize" class="headerlink" title="inSampleSize"></a>inSampleSize</h3><ul>
<li><p>inSampleSize表示加载的图片的宽高相对于原始图片的比例，例如当这个值为2时，图片宽和高就为原始图片的1/2，因此内存占用降到里1/4，还是比较高效的一种方式</p>
</li>
<li><p>最简单的用法，创建一个option对象，设定它的inSampleSize值并传入BitmapFactory.decodeFile方法即可，inSampleSize最小值为1，且当其大于1时且不为偶数时会自动向下取偶然</p>
</li>
</ul>
<pre><code>BitmapFactory.Options options = new BitmapFactory.Options();
options.inSampleSize = 2;
Bitmap bitmap = BitmapFactory.decodeFile(path, options);
</code></pre><ul>
<li><p>但是我们在加载图片时常常不知道图片的尺寸大小，也就不知道是否需要压缩与压缩比例应该为多少，而将Bitmap加载进来再压缩又将毫无意义，好在Option提供了一个只加载宽和高的方法，获得宽高之后可以和我们需要的尺寸进行比较调整缩放比例</p>
<pre><code>BitmapFactory.Options options = new BitmapFactory.Options();
options.inSampleSize = 2;
options.inJustDecodeBounds =true;
Bitmap bitmap = BitmapFactory.decodeFile(path, options);
Log.d(TAG, &quot;onCreate: &quot;+options.outHeight+options.outWidth);
</code></pre></li>
<li><p>下面是一个Android提供的计算缩放比例的方法</p>
</li>
</ul>
<pre><code>int calculateInSampleSize(BitmapFactory.Options options,  int reqWidth, int reqHeight){

final int height = options.outHeight;

final int width  = options.outWidth;

int inSampleSize = 1 ;

if(reqWidth &lt; width || reqHeight &lt;height){

final int halfWidth = width / 2;

final int halfHeight = height / 2;

   // Calculate the largest inSampleSize value that is a power of 2 and keeps both        // height and width larger than the requested height and width.   

while( (halfWidth / inSampleSize &gt; reqWidth &amp;&amp; halfHeight / inSampleSize &gt; reqHeight){

    inSampleSize *= 2;

    }

    }

}
</code></pre><ul>
<li>除了通过压缩Bitmap减少内存占用以外，bitmap使用完之后最好进行回收，注意不要频繁进行gc，这样可能造成卡顿</li>
</ul>
<pre><code>if(bitmap != null &amp;&amp; !bitmap.isRecycled()){   
        bitmap.recycle();   
        bitmap = null;   
}   
System.gc();  
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HandlerThread 基本用法]]></title>
      <url>/2017/07/25/aboutHandlerThread/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><ul>
<li><p>子线程不能直接创建Handler，所以当我们需要使用handler时必须先创建Looper</p>
<pre><code>Can&apos;t create handler inside thread that has not called Looper.prepare()
</code></pre></li>
</ul>
<ul>
<li>使用Looper.prepare之后创建Handler，这个handler可以处理其他线程中发送的消息，但是Looper.loop()之后的操作不会执行，因为looper开启了一个无限循环，它是一个阻塞操作</li>
</ul>
<pre><code>public void run(){
    super.run();
    Looper.prepare();
    mHandler = new Handler(){
        @Override
        public void handleMessage(Message msg) {
            super.handleMessage(msg);

            Log.d(TAG, &quot;handleMessage: &quot;+Thread.currentThread().getName()+&quot; &quot;+msg.what);
        }
    };
    Looper.loop();
    Log.d(TAG, &quot;behind loop&quot;);
}    
</code></pre><ul>
<li><p>要在子线程使用Handler，还有更方便的方法，使用HandlerThread，获取它的Looper</p>
<pre><code> HandlerThread  handlerThread = new HandlerThread(&quot;test thread&quot;);
        handlerThread.start();
        Handler handler = new Handler(handlerThread.getLooper()){

    @Override
    public void handleMessage(Message msg) {
        super.handleMessage(msg);
        Log.d(TAG, &quot;handleMessage: &quot;+Thread.currentThread());
        Log.d(TAG, &quot;handleMessage: &quot;+msg.what);
    }
};

handler.sendEmptyMessage(0);    

...
</code></pre></li>
</ul>
<pre><code>handlerThread.quit();
...

D/MainActivity: handleMessage: Thread[test thread,5,main]
D/MainActivity: handleMessage: 0
</code></pre><ul>
<li>我们可以把耗时操作放在handleMessage方法中执行，以分担主线程的工作</li>
</ul>
<pre><code>handler.post(new Runnable() {
    @Override
    public void run() {
        Log.d(TAG, &quot;run: -------------&quot;+Thread.currentThread());
    }
});
</code></pre><ul>
<li>在handlerMessage中发送延迟消息，可以实现定时操作的功能</li>
</ul>
<pre><code>public void handleMessage(Message msg)
 {
     doSomething();
     if (!stop)
     {
         handler.sendEmptyMessageDelayed(DO_SOMETHING, 1000);
     }
</code></pre><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><ul>
<li>HandlerThread的源码比较简短，HandlerThread有两个 构造方法，在不传入优先级的情况下会使用默认的优先级5</li>
</ul>
<pre><code>public class HandlerThread extends Thread {
    int mPriority;
    int mTid = -1;
    Looper mLooper;

    public HandlerThread(String name) {
        super(name);
        mPriority = Process.THREAD_PRIORITY_DEFAULT;
    }

    /**
     * Constructs a HandlerThread.
     * @param name
     * @param priority The priority to run the thread at. The value supplied must be from 
     * {@link android.os.Process} and not from java.lang.Thread.
     */
    public HandlerThread(String name, int priority) {
        super(name);
        mPriority = priority;
    }
</code></pre><ul>
<li>查看run方法，发现这里调用了Looper.prepare()和Looper.loop()方法创建了looper，这就是使用HandlerThread只需要调用start方法就可以获得Looper的原因</li>
</ul>
<pre><code>@Override
public void run() {
    mTid = Process.myTid();
    Looper.prepare();
    synchronized (this) {
        mLooper = Looper.myLooper();
        notifyAll();
    }
    Process.setThreadPriority(mPriority);
    onLooperPrepared();
    Looper.loop();
    mTid = -1;
}
</code></pre><ul>
<li>在创建Looper时会创建一个消息队列，Looper.loop则会开启循环处理消息，这部分之前了解过不再重复了</li>
</ul>
<pre><code>    private Looper(boolean quitAllowed) {
mQueue = new MessageQueue(quitAllowed);
mThread = Thread.currentThread();
    }
</code></pre><ul>
<li>在我们用来获得looper的方法getLooper中，为了保证Looper已经创建完毕，会调用wait()进行等待</li>
</ul>
<pre><code>    public Looper getLooper() {
        if (!isAlive()) {
            return null;
        }

// If the thread has been started, wait until the looper has been created.
synchronized (this) {
    while (isAlive() &amp;&amp; mLooper == null) {
        try {
            wait();
        } catch (InterruptedException e) {
        }
    }
}
return mLooper;
}
</code></pre><ul>
<li><p>停止消息循环，有两个方法quit和quitSafely，它们分别调用了looper的同名方法，而这两个方法都调用到了MessageQueue中的quit方法，只是传入的参数不同而已</p>
<pre><code>//in HandlerThread
    public boolean quit() {
        Looper looper = getLooper();
        if (looper != null) {
            looper.quit();
            return true;
        }
        return false;
    }
</code></pre></li>
</ul>
<pre><code>        public boolean quitSafely() {
            Looper looper = getLooper();
            if (looper != null) {
                looper.quitSafely();
                return true;
            }
            return false;
        } 

        //in MessageQueue
            void quit(boolean safe) {
    if (!mQuitAllowed) {
        throw new IllegalStateException(&quot;Main thread not allowed to quit.&quot;);
    }

    synchronized (this) {
        if (mQuitting) {
            return;
        }
        mQuitting = true;

        if (safe) {
            removeAllFutureMessagesLocked();
        } else {
            removeAllMessagesLocked();
        }

        // We can assume mPtr != 0 because mQuitting was previously false.
        nativeWake(mPtr);
    }
}
</code></pre><ul>
<li>可以看到quit和quitSafely最终的区别在于MessageQueue调用removeAllFutureMessagesLocked方法还是removeAllMessagesLocked方法，在removeAllMessagesLocked中只是简单地遍历单链表并回收消息结点而已，而removeAllFutureMessagesLocked中使用判断条件n.when &gt; now 跳过了所有非延迟的消息，也就是说不管是使用quit还是quitSafely，队列中都不会再添加消息，但是quitSafely处理完队列中的非延迟消息，到这里就过完HandlerThread的源码了</li>
</ul>
<pre><code> private void removeAllMessagesLocked() {
Message p = mMessages;
while (p != null) {
    Message n = p.next;
    p.recycleUnchecked();
    p = n;
}
mMessages = null;
}

    private void removeAllFutureMessagesLocked() {
final long now = SystemClock.uptimeMillis();
Message p = mMessages;
if (p != null) {
    if (p.when &gt; now) {
        removeAllMessagesLocked();
    } else {
        Message n;
        for (;;) {
            n = p.next;
            if (n == null) {
                return;
            }
            if (n.when &gt; now) {
                break;
            }
            p = n;
        }
        p.next = null;
        do {
            p = n;
            n = p.next;
            p.recycleUnchecked();
        } while (n != null);
    }
}
    }
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Animation基本用法]]></title>
      <url>/2017/07/25/aboutAnimation/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<h2 id="属性动画"><a href="#属性动画" class="headerlink" title="属性动画"></a>属性动画</h2><ul>
<li>补间动画只能改变View的显示效果，并不会改变View的属性，View的形状位置发生改变，点击事件的响应区域并不会跟着变化</li>
</ul>
<ul>
<li>ValueAnimator是属性动画中最核心的类，它提供了两个比较重要的监听器，其中AnimatorListener中的四个方法分别会在动画开始，结束，循环，取消时被调用，而AnimatorUpdateListener的onAnimationUpdate方法会在动画的每一帧被调用，想要实现动画效果，必须实现onAnimationUpdate方法</li>
</ul>
<pre><code>new Animator.AnimatorListener() {
    @Override
    public void onAnimationStart(Animator animation) {

    }

    @Override
    public void onAnimationEnd(Animator animation) {

    }

    @Override
    public void onAnimationCancel(Animator animation) {

    }

    @Override
    public void onAnimationRepeat(Animator animation) {

    }
};

new ValueAnimator.AnimatorUpdateListener() {
    @Override
    public void onAnimationUpdate(ValueAnimator animation) {

    }
};
</code></pre><ul>
<li>ValueAnimator能够在一段时间中为我们提供渐变的值，这些值本身不会对控件造成任何影响，不过我们能够使用这些值和监听器去改变控件的属性从而实现动画效果，下面实现一个位移动画。要点在于使用ofInt方法获得animator对象，在onAnimationUpdate使用它的getAnimatedValue得到不断改变的值去设定layout属性。</li>
</ul>
<pre><code>final ValueAnimator animator = ValueAnimator.ofInt(0,200);
animator.setDuration(3000);
animator.setRepeatCount(3);
animator.setRepeatMode(ValueAnimator.REVERSE);

animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
    @Override
    public void onAnimationUpdate(ValueAnimator animation) {
        int value = (int)animator.getAnimatedValue();
        ViewGroup.MarginLayoutParams marginLayoutParams = (ViewGroup.MarginLayoutParams) imageView.getLayoutParams();
        marginLayoutParams.leftMargin = value;
        imageView.setLayoutParams(marginLayoutParams);
    }
});
animator.setTarget(imageView);
animator.start();
</code></pre><ul>
<li>接着实现一个响应按钮点击事件弹出或关闭ListView的方法</li>
</ul>
<pre><code>    button.setOnClickListener(new View.OnClickListener(){
        @Override
        public void onClick(View v) {
            hideOrShowListView();
        }
    });
}
</code></pre><ul>
<li>逻辑和前者基本一致，不过在方法里进行了关于ListView高度状态的判断，注意如果使用LinearLayout，由于布局的特性，ListView弹出之后其他控件的位置会跟着改动，使用FrameLayout和RelativeLayout可以实现”覆盖”的效果，并且指定了layout_alignParentBottom属性的情况下可以让ListView从下往上弹出，另外ListView的背景最好不要透明</li>
</ul>
<pre><code>public static final int LIST_HEIGHT = 300;
public void hideOrShowListView(){

final ValueAnimator mAnimator;

if(listView.getHeight()==LIST_HEIGHT) {
    mAnimator = ValueAnimator.ofInt(LIST_HEIGHT, 0);
}else {
    mAnimator = ValueAnimator.ofInt(0, LIST_HEIGHT);
}

mAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
    @Override
    public void onAnimationUpdate(ValueAnimator animation) {

        listView.getLayoutParams().height = (int)animation.getAnimatedValue();
        listView.setLayoutParams(listView.getLayoutParams());
        Log.d(TAG, &quot;onAnimationUpdate: &quot; +listView.getHeight());

    }
});
mAnimator.start();
}
</code></pre><h2 id="ObjectAnimator"><a href="#ObjectAnimator" class="headerlink" title="ObjectAnimator"></a>ObjectAnimator</h2><ul>
<li>ObjectAnimator对ValueAnimator进行了封装，使用更加方便</li>
</ul>
<ul>
<li>这里使用到了PropertyName，它指定了控件需要改变的属性，包括alpha，scaleX等</li>
</ul>
<ul>
<li>使用插值器Interpolator可以改变数值变化的效果，官方提供了多种插值器，实现插值器涉及较多数学方面的内容，需要时再<a href="http://blog.csdn.net/xiaochuanding/article/details/73200149" target="_blank" rel="external">查找</a>即可</li>
</ul>
<pre><code>ObjectAnimator animator = ObjectAnimator.ofInt(button,
           &quot;backgroundColor&quot;, Color.RED, Color.GREEN, Color.BLUE,
           Color.GREEN);
   animator.setDuration(300);
   animator.setRepeatCount(3);
   animator.setInterpolator(new DecelerateInterpolator());
   animator.setRepeatMode(ValueAnimator.REVERSE);
   animator.start();
</code></pre><h2 id="补间动画"><a href="#补间动画" class="headerlink" title="补间动画"></a>补间动画</h2><ul>
<li>AlphaAnimation，渐变动画，四种补间动画的设置方法基本一致</li>
</ul>
<pre><code>Animation alphaAnimation = new AlphaAnimation(0, 1); //传入开始和结束时的透明度，0~1
alphaAnimation.setDuration(3000);//持续时间
alphaAnimation.setFillAfter(true);//是否停留在执行完的状态
alphaAnimation.setRepeatCount(2);//重复次数
alphaAnimation.setStartOffset(1000);//执行前的等待时间
imageView.startAnimation(alphaAnimation);
</code></pre><ul>
<li>RotateAnimation，旋转动画</li>
</ul>
<pre><code>Animation rotateAnimation = new RotateAnimation(0,45);//传入开始和结束时的角度
rotateAnimation.setDuration(3000);
imageView.startAnimation(rotateAnimation);   
</code></pre><ul>
<li>ScaleAnimation，伸缩动画</li>
</ul>
<pre><code>ScaleAnimation scaleAnimation = new ScaleAnimation(0.5f,1.0f,1.0f,1.0f);//传入开始和结束时的伸缩比例
 scaleAnimation.setDuration(3000);
 imageView.startAnimation(scaleAnimation);
</code></pre><ul>
<li>TranslateAnimation，位移动画</li>
</ul>
<pre><code>TranslateAnimation translateAnimation = new TranslateAnimation(0,100,0,0);//传入开始和结束时的位置
translateAnimation.setDuration(3000);
imageView.startAnimation(translateAnimation);
</code></pre><ul>
<li>AnimationSet，混合动画，同时执行一系列的动画</li>
</ul>
<pre><code>AnimationSet animationSet = new AnimationSet(true);
animationSet.addAnimation(scaleAnimation);
  animationSet.addAnimation(rotateAnimation);
  animationSet.addAnimation(scaleAnimation);
  imageView.startAnimation(animationSet);
</code></pre><ul>
<li>也可以在XML中设置动画属性， 创建anim文件夹添加XML文件，使用AnimationUtils.loadAnimation获取实例即可</li>
</ul>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;alpha xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:duration=&quot;500&quot;
    android:fillAfter=&quot;false&quot;
    android:fromAlpha=&quot;1.0&quot;
    android:toAlpha=&quot;0.0&quot; /&gt;
     Animation alphaAnimation = AnimationUtils.loadAnimation(this,R.anim.animation);
</code></pre><h2 id="帧动画"><a href="#帧动画" class="headerlink" title="帧动画"></a>帧动画</h2><ul>
<li>逐帧动画用于一张张地播放图片，一般用于实现较简单的动画效果，不建议设置帧数过多的逐帧动画</li>
</ul>
<ul>
<li>在drawable文件夹中</li>
</ul>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
android:oneshot=&quot;false&quot;&gt;

&lt;item
android:drawable=&quot;@drawable/img_1&quot;
android:duration=&quot;200&quot; /&gt;
&lt;item
android:drawable=&quot;@drawable/img_2&quot;
android:duration=&quot;200&quot; /&gt;
&lt;item
android:drawable=&quot;@drawable/img_3&quot;
android:duration=&quot;200&quot; /&gt;

&lt;/animation-list&gt;
</code></pre><ul>
<li>在java代码中，注意不要直接在onCreate中开启动画，Window初始化完毕时动画才可能播放，因此可以在onWindowFocusChanged中开启</li>
</ul>
<pre><code>imageView.setImageResource(R.drawable.animation);
AnimationDrawable animationDrawable = (AnimationDrawable) imageView.getDrawable();
animationDrawable.start();
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[控件架构与自定义View]]></title>
      <url>/2017/07/24/aboutView/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<h2 id="android-控件架构"><a href="#android-控件架构" class="headerlink" title="android 控件架构"></a>android 控件架构</h2><ul>
<li>每一个Activity包含一个PhoneWindow对象，它是Window抽象类的唯一实现，PhoneWindow将DectorView作为整个窗口的根View，DectoView只含有一个LinearLayout，其中包含了两个子View，分别是TitleView和ContentView，ContentView为一个FrameLayout，onCreate方法中的setContentView就是把我们的布局添加到ContentView上</li>
</ul>
<p><img src="http://img.mukewang.com/568b5f2d0001c42a11300576.png" alt=""></p>
<h3 id="MeasureSpec"><a href="#MeasureSpec" class="headerlink" title="MeasureSpec"></a>MeasureSpec</h3><ul>
<li>MeasureSpec是一个32位int值，高二位用来表示SpecMode，低30位用来表示SpecSize，SpecMode有三个可能的值UNSPECIFIED，EXACTLY，AT_MOST，view的大小由父布局的属性和MeasureSpec共同决定</li>
</ul>
<pre><code>/**
 * Measure specification mode: The parent has not imposed any constraint
 * on the child. It can be whatever size it wants.
 */
public static final int UNSPECIFIED = 0 &lt;&lt; MODE_SHIFT;

/**
 * Measure specification mode: The parent has determined an exact size
 * for the child. The child is going to be given those bounds regardless
 * of how big it wants to be.
 */
public static final int EXACTLY     = 1 &lt;&lt; MODE_SHIFT;

/**
 * Measure specification mode: The child can be as large as it wants up
 * to the specified size.
 */
public static final int AT_MOST     = 2 &lt;&lt; MODE_SHIFT;
</code></pre><ul>
<li><p>UNSPECIFIED，view的大小不受父布局的限制，view想要多大就多大</p>
</li>
<li><p>EXACTLY，对应match_parent和精确数字的布局大小，是父布局测量出来的SpecSize值</p>
</li>
<li><p>AT_MOST，父布局指定SpecSize，view不能超过SpecSize规定的大小</p>
</li>
</ul>
<h3 id="View的工作流程"><a href="#View的工作流程" class="headerlink" title="View的工作流程"></a>View的工作流程</h3><ul>
<li>measure，测量View的尺寸,一个ViewGroup会遍历调用子View的测量方法，子View再递归地去执行测量，最终的到所有元素的大小</li>
</ul>
<pre><code>protected void measureChild(View child, int parentWidthMeasureSpec,

   ...

child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
}
</code></pre><ul>
<li>layout，确定子View的位置，layout()会确定View本身的位置而onLayout会确定所有子View的位置，和measure的逻辑类似。onLayout，方法由具体的布局去实现，所有ViewGroup的子类都必须去重写这个方法。在layout中可以发现view的位置由四种属性构成，它们分别表示view相对于父布局的位置，left是左上角的横坐标，top是左上角的纵坐标，right是右下角的横坐标，bottom是右下角的纵坐标，x和y轴的的正方向为右和下</li>
</ul>
<pre><code> * @param l Left position, relative to parent
 * @param t Top position, relative to parent
 * @param r Right position, relative to parent
 * @param b Bottom position, relative to parent

int oldL = mLeft;
int oldT = mTop;
int oldB = mBottom;
int oldR = mRight;
boolean changed = setFrame(l, t, r, b);  
</code></pre><ul>
<li>draw，view的绘制 ，主要包括绘制背景，View本身，子View，装饰四个步骤，其中dispatchDraw用于遍历所有子View并绘制</li>
</ul>
<pre><code>   /*
     * Draw traversal performs several drawing steps which must be executed
     * in the appropriate order:
     *
     *      1. Draw the background
     *      2. If necessary, save the canvas&apos; layers to prepare for fading
     *      3. Draw view&apos;s content
     *      4. Draw children
     *      5. If necessary, draw the fading edges and restore layers
     *      6. Draw decorations (scrollbars for instance)
     *    /

// Step 1, draw the background, if needed
int saveCount;
if (!dirtyOpaque) {
    drawBackground(canvas);
}

// skip step 2 &amp; 5 if possible (common case)
final int viewFlags = mViewFlags;
boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0;
boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0;
if (!verticalEdges &amp;&amp; !horizontalEdges) {

    // Step 3, draw the content
    if (!dirtyOpaque) onDraw(canvas);

    // Step 4, draw the children
    dispatchDraw(canvas);

    // Overlay is part of the content and draws beneath Foreground
    if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) {
        mOverlay.getOverlayView().dispatchDraw(canvas);
    }

    // Step 6, draw decorations (foreground, scrollbars)
    onDrawForeground(canvas);
</code></pre><ul>
<li>自定义布局，需要实现onMeasure方法和onLayout方法，在onMeasure方法中需要测量出子View的大小，在onLayout中可以通过子View的getMeasuredWidth方法和getMeasuredHeighet方法得到在onMeasure中测量出来的大小。调用子View的layout方法我们可以设定它在这个父布局中的位置，注意如果四个点之间的相对位置和原来子View不同，它就会被拉伸</li>
</ul>
<pre><code>public class MyLayout extends ViewGroup {

public MyLayout(Context context, AttributeSet attrs) {
    super(context, attrs);
}

@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
        if(getChildCount()&gt;0){
        View child = getChildAt(0);
        measureChild(child,widthMeasureSpec,heightMeasureSpec);
    }
}

@Override
protected void onLayout(boolean changed, int l, int t, int r, int b) {

    if(getChildCount()&gt;0){
        View child = getChildAt(0);
        child.layout(0,0,child.getMeasuredWidth(),child.getMeasuredHeight());
    }
}
}
</code></pre><ul>
<li>重写onDraw，通过Paint和Canvas对象绘制图像，在onLayout方法执行之后可以通过getWidth方法和getHeigh方法得到View的实际显示的宽和高</li>
</ul>
<pre><code>@Override
protected void onDraw(Canvas canvas){

mPaint.setColor(Color.GREEN);
canvas.drawRect(0,0,getWidth(),getHeight(),mPaint);

mPaint.setColor(Color.YELLOW);
canvas.drawOval(20,20,getWidth()/2,getHeight()/2,mPaint);

}
</code></pre><h2 id="自定义View"><a href="#自定义View" class="headerlink" title="自定义View"></a>自定义View</h2><h3 id="attrs-属性"><a href="#attrs-属性" class="headerlink" title="attrs 属性"></a>attrs 属性</h3><ul>
<li>当使用控件时我们可以设定系统提供的layout_width等属性值，为了能够使用自定义的属性，需要在values文件中加入attrs.xml文件</li>
</ul>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;resources&gt;
    &lt;declare-styleable name=&quot;test_attrs&quot;&gt;
        &lt;attr name=&quot;myColor&quot; format=&quot;color&quot;/&gt;
        &lt;attr name=&quot;mySize&quot; format=&quot;dimension&quot;/&gt;
        &lt;attr name=&quot;myFlag&quot; format=&quot;boolean&quot;/&gt;
    &lt;/declare-styleable&gt;
&lt;/resources&gt;    
</code></pre><ul>
<li>在布局文件中声明名称空间</li>
</ul>
<pre><code>xmlns:test_view = &quot;http://schemas.android.com/apk/res-auto&quot;
</code></pre><ul>
<li>在控件属性中设置变量值，注意名称空间不需要与attrs中的name属性相同，但是变量的名称一定要能够与attrs中的匹配</li>
</ul>
<pre><code>&lt;com.linjiamin.viewtest.MyView
    android:layout_width=&quot;200dp&quot;
    android:layout_height=&quot;200dp&quot;
    test_view:myColor=&quot;#000000&quot;&gt;
</code></pre><ul>
<li><p>在java文件中，使用context的obtainStyledAttributes方法获取TypedArray对象，再将属性值在typedArray当中取出，注意typedArray对象使用完之后必须回收</p>
<pre><code>    public MyView(Context context, @Nullable AttributeSet attrs) {
        super(context, attrs);
        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
        mContext = context;
        TypedArray typedArray = mContext.obtainStyledAttributes(attrs,R.styleable.test_attrs2);
    mColor = typedArray.getColor(R.styleable.test_attrs2_myColor2,Color.BLUE);
    typedArray.recycle();
}
</code></pre></li>
</ul>
<h3 id="继承View"><a href="#继承View" class="headerlink" title="继承View"></a>继承View</h3><ul>
<li>重写构造方法，获取XML中的属性值</li>
</ul>
<pre><code>public MyTextView(Context context, @Nullable AttributeSet attrs) {
super(context, attrs);
TypedArray typedArray = context.obtainStyledAttributes(attrs,R.styleable.my_text_view);
mColor = typedArray.getColor(R.styleable.my_text_view_text_color, Color.BLUE);
mbackColor = typedArray.getInteger(R.styleable.my_text_view_background_color,Color.BLUE);
mSize = typedArray.getInteger(R.styleable.my_text_view_text_size,10);
mContent = typedArray.getString(R.styleable.my_text_view_text_content);
mPaint = new Paint();
mPaint.setTextSize(mSize);
typedArray.recycle();

}
</code></pre><ul>
<li>重写onMeasure，当长宽属性为wrap_content及AT_MOST时，我们需要自己实现测量的逻辑</li>
</ul>
<pre><code>     @Override
        protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
           int widthMode = MeasureSpec.getMode(widthMeasureSpec);
            int heightMode = MeasureSpec.getMode(heightMeasureSpec);
            int width = MeasureSpec.getSize(widthMeasureSpec);
        int heigeht = MeasureSpec.getSize(heightMeasureSpec);

    if(widthMode == MeasureSpec.AT_MOST){

        mPaint.setTextSize(mSize);
        mPaint.getTextBounds(mContent,0,mContent.length(),mBound);
        width = getPaddingLeft()+ getPaddingEnd() +mBound.width();

    }

    if(heightMode == MeasureSpec.AT_MOST){

        mPaint.setTextSize(mSize);
        mPaint.getTextBounds(mContent,0,mContent.length(),mBound);
        heigeht = getPaddingTop()+ getPaddingBottom() +mBound.height();
    }

    setMeasuredDimension(width,heigeht);
}
</code></pre><ul>
<li><p>重写onDraw，使canvas和paint对象绘制</p>
<p>  @Override<br>  protected void onDraw(Canvas canvas) {</p>
<pre><code>mPaint.setColor(mbackColor);
canvas.drawRect(0,0,getWidth(),getHeight(),mPaint);
mPaint.setColor(mColor);
canvas.drawText(mContent,getWidth()/2-mBound.width()/2,getHeight()/2,mPaint);
}
</code></pre><p>  }</p>
</li>
</ul>
<h2 id="继承特定的View"><a href="#继承特定的View" class="headerlink" title="继承特定的View"></a>继承特定的View</h2><ul>
<li><p>我们想为已有的View类添加新特性的时候，可以继承这个view类，下面实现一个右上角带有选择框的ImageView</p>
<pre><code>private boolean checked = false;
private Bitmap mCheckedImage;
private Bitmap mUncheckImage;
private Paint mPaint;
private Rect mRect;
private static final String TAG = &quot;CheckableImageView&quot;;

public CheckableImageView(Context context, AttributeSet attrs) {
super(context, attrs);

mCheckedImage = BitmapFactory.decodeResource(getResources(),R.drawable.checked);
mUncheckImage = BitmapFactory.decodeResource(getResources(),R.drawable.uncheck);

mPaint = new Paint();
mRect = new Rect();
}
</code></pre></li>
<li><p>在onDraw方法中添加需要绘制的内容，其余操作交回给父类去处理</p>
<pre><code>public void onDraw(Canvas canvas){

super.onDraw(canvas);
mRect.left = getWidth()-mUncheckImage.getWidth();
mRect.right = getWidth();
mRect.top = 0;
mRect.bottom = mUncheckImage.getHeight();

if(checked)
    canvas.drawBitmap(mCheckedImage,null, mRect, mPaint);

else canvas.drawBitmap(mUncheckImage,null, mRect, mPaint);
}
</code></pre></li>
<li><p>处理点击事件，注意最好不要直接使用setOnClickListener方法，而是在onTouchEvent中处理点击事件，需要调用父类的方法并返回true，返回false时onTouchEvent中的操作不会执行</p>
<pre><code>@Override
public boolean onTouchEvent(MotionEvent event) {

int action = event.getAction();

super.onTouchEvent(event);
switch (action) {

    case MotionEvent.ACTION_DOWN:
        break;
    case MotionEvent.ACTION_MOVE:
        break;
    case MotionEvent.ACTION_UP:

        checked = !checked;
        invalidate();
        Log.d(TAG, &quot;onTouchEvent: &quot;);

        break;
    }
return true;
}
</code></pre></li>
<li><p>另外还可以创建一个listener,并提供一个set方法，在onTouchEvent中调用listener的方法</p>
<pre><code>private OnCheckListener listener;

    public CheckableImageView(Context context, AttributeSet attrs) {
super(context, attrs);

...

setOnCheckedListener(new OnCheckListener() {
    @Override
    public void onCheck() {
        Log.d(TAG, &quot;onCheck: &quot;);
    }
}); 
}

public interface OnCheckListener{
void onCheck();
}
</code></pre></li>
</ul>
<ul>
<li><p>最后像原本的view一样去使用它即可</p>
<pre><code>&lt;com.linjiamin.CheckableImageView
 android:id=&quot;@+id/item_image&quot;
 android:layout_alignParentEnd=&quot;true&quot;
 android:layout_width=&quot;100dp&quot;
 android:layout_height=&quot;100dp&quot;
 android:padding=&quot;8dp&quot;
 android:contentDescription=&quot;@string/desc&quot;/&gt;
</code></pre></li>
<li><p><img src="http://i2.kiimg.com/1949/599504b74c0fd397.png" alt=""></p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[工厂模式与单例模式]]></title>
      <url>/2017/07/20/aboutPattern/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><br></p>
<h2 id="静态工厂方法"><a href="#静态工厂方法" class="headerlink" title="静态工厂方法"></a>静态工厂方法</h2><p><br></p>
<h3 id="使用静态工厂方法代替构造器"><a href="#使用静态工厂方法代替构造器" class="headerlink" title="使用静态工厂方法代替构造器"></a>使用静态工厂方法代替构造器</h3><p><strong>对于类而言，获取实例的手段无非两个，构造器和静态工厂方法</strong></p>
<ul>
<li>静态工厂方法的优点在于它是有名字的，一个签名只能对应一个构造器，对于相同参数的构造器我们只能通过修改参数列表的位置进行扩展，而且构造器较多时往往会造成混乱</li>
<li>静态工厂方法不必每次都创造对象，可以使用预先构建好的实例</li>
<li>静态工厂方法可以返回任何子类型的对象</li>
</ul>
<p><br></p>
<h3 id="静态工厂模式"><a href="#静态工厂模式" class="headerlink" title="静态工厂模式"></a>静态工厂模式</h3><ul>
<li>静态工厂模式包含一个具体的工厂类，一个抽象的产品类，不限数量的具体产品类</li>
<li>当我们有较多的产品类时，通常的这些产品会是一个树形结构，但是这时相同的逻辑很难复用，所有静态工厂方法模式有时并不理想</li>
</ul>
<p><br></p>
<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><ul>
<li>工厂方法模式是对静态工厂模式的扩展，它包含一个抽象工厂类，一个抽象象产品类，不限数量的具体产品类和具体工厂类</li>
<li>抽象的工厂类定义了规范，每一个具体的产品对应一个具体的工厂类，这样使得需求增加时只要再实现工厂类即可</li>
<li>这种方法通常只针对的单一产品结构，当我们需要多种差别较大的实例时会导致具体工厂的数量非常多，这时回使用抽象工厂方法</li>
</ul>
<p><br></p>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><ul>
<li>抽象工厂模式与工厂方法模式的不同在于它有多个抽象产品类而且每个具体的工厂类可以产生多个具体产品类的实例</li>
<li>这种模式是高度解耦的，但是当抽象产品类的数量较少时它实际上回退化为工厂方法模式，所以实际上并不是越抽象就越好，而要看实际的情况来使用</li>
</ul>
<p><br></p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p><strong>单例模式指的时同一时刻一个类最多只存在一个实例，并且这个唯一实例由类自己创建并提供给其他对象</strong></p>
<p><br></p>
<h3 id="懒汉式单例"><a href="#懒汉式单例" class="headerlink" title="懒汉式单例"></a>懒汉式单例</h3><ul>
<li>懒汉式单例指的是一个类只有到有需要时才去创建单例，在这之前让它一直为null，这里使用了私有的构造器，并让这个类持有自己的实例，只有这个引用为null且外界调用了静态工厂方法时才去创建实例</li>
</ul>
<pre><code>public class Singleton {  

    private static Singleton singleton=null;

    private Singleton() {
        }  

    public static Singleton getInstance() {  
         if (singleton == null) {    
         singleton = new Singleton();  
         }    
        return singleton;  
    }  
}  
</code></pre><ul>
<li>考虑到线程安全的问题，为这个方法加上锁，这样每次获取对象时都会受到同步锁的影响</li>
</ul>
<pre><code>public static synchronized Singleton getInstance() {  
     if (singleton == null) {    
     single = new Singleton();  
     }    
    return singleton;  
}  
</code></pre><ul>
<li>synchronized(ClassName.class)这种写法可以时同一时刻只有一个线程可以访问这个类的实例，但是这样又产生了问题如果两个线程同时进行了判空，这时就会产生两个实例</li>
</ul>
<pre><code>Public static Singleton getInstance(){
       If(singleton == null){
          Synchronized(singleton.class){
                    Singleton = new Singleton();
              }
          return singleton;  
       }
}    
</code></pre><ul>
<li>因此这里再检查一遍防止有多余的实例产生</li>
</ul>
<pre><code>public static Singleton getInstance() {  
        if (singleton == null) {    
            synchronized (Singleton.class) {    
               if (singleton == null) {    
                  singleton = new Singleton();   
               }    
            }    
    }    
    return singleton;   
}  
</code></pre><ul>
<li>还有另一种懒汉式的单例，它使用了利用了类加载机制的特点，对应JVM来说外部类和内部类是同等的类，类加载时方法不会被调用，当我们调用getInstance时内部类才会加载进来，这时才会去初始化，而类加载只进行一次，所以它是懒汉式单例</li>
</ul>
<pre><code>public class Singleton {  
    private static class SingletonHolder {  
    private static final Singleton INSTANCE = new     Singleton();  
    }  
    private Singleton (){}  
    public static final Singleton getInstance() {  
    return SingletonHolder.INSTANCE;  
    }  
}  
</code></pre><p><br></p>
<h3 id="饿汉式单例"><a href="#饿汉式单例" class="headerlink" title="饿汉式单例"></a>饿汉式单例</h3><ul>
<li>饿汉式单例指的是类的实例在获取之前就初始化，根据类加载的机制在类创建时创建实例，由于类只会加载一次，所以只会有一个实例</li>
</ul>
<pre><code>public class Singleton {  
    private static Singleton singleton = new Singleton();  
    private Singleton (){}  
    public static Singleton getInstance() {  
    return singleton;  
    }  
}  
</code></pre><ul>
<li>下面这种方式使用了静态域，本质上和上一种没有区别</li>
</ul>
<pre><code>public class Singleton {  
    private Singleton instance = null;  
    static {  
    instance = new Singleton();  
    }  
    private Singleton (){}  
    public static Singleton getInstance() {  
    return this.instance;  
    }  
}      
</code></pre><ul>
<li>通过枚举来实现单例是最简洁的，枚举可以含有私有的构造器，同时枚举有保证了内部只会有一个实例</li>
</ul>
<pre><code>private static enum Singleton{
    INSTANCE;

    private EnumSingleton singleton;

    private Singleton(){
        singleton = new EnumSingleton();
    }
    public EnumSingleton getInstance(){
    return singleton;
    }
}            
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[注解 基本用法]]></title>
      <url>/2017/07/20/aboutAnnotation/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<h2 id="元数据与注解"><a href="#元数据与注解" class="headerlink" title="元数据与注解"></a>元数据与注解</h2><ul>
<li>元数据用来描述代码之间以及代码与所使用的资源之间的关系</li>
<li>从JDK 5.0之后java 有了四种类型，class，enum，interface，@interface，@interface就是注解，java通过注解来表示元数据</li>
<li>元数据只是一种描述数据的数据，所以注解本身除了定义信息外其实什么都没做，它和业务逻辑没有关系，当我们使用@Override却没有重写父类的方法，编译器会报错，当我们使用<a href="http://blog.csdn.net/zcxwww/article/details/52205832" target="_blank" rel="external">ButterKnife</a>这种工具时会有类文件被自动生成…这些都不是注解负责的，它们主要交由<a href="http://blog.csdn.net/u013045971/article/details/53509237" target="_blank" rel="external">解析工具</a>或者是编译工具等消费器来处理</li>
</ul>
<h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><ul>
<li>元注解是描述其他注解的注解，元注解本身也由元注解描述</li>
</ul>
<pre><code>@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.ANNOTATION_TYPE})
public @interface Inherited {
}

@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.ANNOTATION_TYPE})
public @interface Retention {
    RetentionPolicy value();
}
...
</code></pre><ul>
<li>@Retention，描述了注解的生命周期长度，可能的值有：</li>
</ul>
<pre><code>SOURCE：只会保留在源代码中
CLASS: 驻留在CLASS文件中，但会被JVM在运行时忽略，运行时不可见
RUNTIME：可以在运行时通过反射获取
</code></pre><ul>
<li>@Target，注解可以用在代码的任何地方，使用@Target可以进行限制，约束使用的范围</li>
</ul>
<pre><code>ElementType.TYPE:只能描述类、接口或enum
ElementType.FIELD:只能描述实例变量
ElementType.METHOD:只能描述方法
ElementType.PARAMETER:只能描述方法的参数
ElementType.CONSTRUCTOR:只能描述构造器
ElementType.LOCAL_VARIABLE:只能描述局部变量
ElementType.ANNOTATION_TYPE:只能描述另一个注释
ElementType.PACKAGE: 只能描述包名    
</code></pre><ul>
<li>@Documented，表示在生成JavaDoc文档时，注解也会出现在文档当中</li>
<li>@Inherited ，使注解的信息会被标注了这个注解的类的子类继承</li>
</ul>
<h2 id="內建注解"><a href="#內建注解" class="headerlink" title="內建注解"></a>內建注解</h2><ul>
<li>java提供了三种内建注解</li>
<li>@Override，告诉编译器该方法重写了父类方法</li>
</ul>
<pre><code>@Target({ElementType.METHOD})
@Retention(RetentionPolicy.SOURCE)
public @interface Override {
}
</code></pre><ul>
<li><p>Deprecated，告诉编译器该方法不推荐使用，使用它时应该提供充分的说明和替代方案</p>
</li>
<li><p>SuppressWarnings，用于忽略警告信息，需要提供一个字符串值进行说明</p>
</li>
</ul>
<pre><code>@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.CONSTRUCTOR, ElementType.FIELD, ElementType.LOCAL_VARIABLE, ElementType.METHOD, ElementType.PACKAGE, ElementType.PARAMETER, ElementType.TYPE})
public @interface Deprecated {
}
</code></pre><h2 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h2><ul>
<li>注解需要用@interface指示，内部属性只支持基本类型，String类型、枚举类型、Class类型，Annotation和这些类型的数组，所有这些属性都使用方法来定义，并且可以提供一个默认值 </li>
</ul>
<pre><code>@Inherited
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Hello {
    String author() default &quot;Albert&quot;;
    public enum Priority {ONE, TOW, THREE}
    Hello.Priority priority() default Hello.Priority.ONE;
    String[] strs() default {&quot;1&quot;,&quot;2&quot;,&quot;3&quot;};
    int i() default 1;
    float f() default (float)2.0;
    double d() default 3.0;
    boolean b() default false;
    Class  c() default Void.class;
    AnnotationTest a();
}
</code></pre><ul>
<li>使用注解，注解只能标注于Target指定的类型之前，在括号中为属性赋值，如果某个属性没有默认值，则它必须被赋值，如果注解只有一个属性，那么使用时赋值可以不用指定属名称，但内部必须将它的名称指定为value</li>
</ul>
<pre><code>@Hello(d = 2.0)
    public static String helloWorld(){

     }
...

public @interface Hello2 {

    double value() default 3.0;

}

@Hello2(2.0)
public static String helloWorld2(){

 }
</code></pre><h2 id="获取注解属性"><a href="#获取注解属性" class="headerlink" title="获取注解属性"></a>获取注解属性</h2><ul>
<li>使用反射我们可以得到一个类中所有注解的属性值，这里随便找了一个类进行测试</li>
</ul>
<pre><code>public static void getInfo() {

Class&lt;GetDate&gt; annotationDemoClass = GetDate.class;
for (Method method : annotationDemoClass.getMethods()) {
    Hello hello = (Hello) method.getAnnotation(Hello.class);
    if (hello != null) {
        Log.d(TAG, &quot;getInfo: &quot;+method.getName());
        Log.d(TAG, &quot;getInfo: &quot;+hello.b());
        Log.d(TAG, &quot;getInfo: &quot;+hello.c());
        }
    }
} 
</code></pre><ul>
<li>输出为</li>
</ul>
<pre><code>getInfo: formatDate
getInfo: false
getInfo: class java.lang.Void 
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ButterKnife 基本用法]]></title>
      <url>/2017/07/20/aboutButterKnife/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><ul>
<li>鉴于ButterKnife更新较快，添加依赖的方法以GitHub上的为准</li>
</ul>
<pre><code>https://github.com/JakeWharton/butterknife
</code></pre><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><ul>
<li>ButterKnife最初和最常见的用途就是绑定View类，使我们不用去打findViewById</li>
</ul>
<ul>
<li>首先必须在setContentView之后调用ButterKnife.bind()方法，这样BindView方法才有效    </li>
</ul>
<pre><code>setContentView(R.layout.activity_home);
ButterKnife.bind(this);    
</code></pre><ul>
<li>声明一个View引用时使用BindView方法，这样我们在使用这些变量的时候就不用去初始化了</li>
</ul>
<pre><code>   @BindView(R.id.home_srl_update)SwipeRefreshLayout mSrUpdate;
@BindView(R.id.home_tb_title)Toolbar toolbar;
@BindView(R.id.drawer_layout)DrawerLayout mHomeLayout;
@BindView(R.id.home_rv_news)RecyclerView rvNews;
@BindView(R.id.home_lv_types)ListView lvTypes;
@BindView(R.id.download) Button download;
</code></pre><ul>
<li>ButterKnife生成的代码长这个样子</li>
</ul>
<pre><code>target.rvNews = finder.findRequiredViewAsType(source, R.id.home_rv_news, &quot;field &apos;rvNews&apos;&quot;, RecyclerView.class);
target.lvTypes = finder.findRequiredViewAsType(source, R.id.home_lv_types, &quot;field &apos;lvTypes&apos;&quot;, ListView.class); 
</code></pre><ul>
<li>绑定Fragment的方式基本相同，但是要注意解绑   </li>
</ul>
<pre><code>ButterKnife.bind(this,mRootView)    

...

public void onDestroyView() {  
super.onDestroyView();  
ButterKnife.unbind(this);//解绑  
}          
</code></pre><ul>
<li>ButterKnife还可以绑定其他资源</li>
</ul>
<pre><code>@BindDrawable(R.drawable.ic_comment)Drawable drawable;
@BindColor(R.color.dark)  
</code></pre><ul>
<li><p>还可以绑定监听事件</p>
<pre><code>@OnClick(R.id.download)
public void download() {
    ...
}

@OnItemClick({R.id.item_lv_news,R.id.item_lv_types})
itemClick(){

}
</code></pre></li>
</ul>
<ul>
<li>也可以在ViewHolder中使用</li>
</ul>
<pre><code>static class ViewHolder extends RecyclerView.ViewHolder {

@BindView(R.id.item_image) ImageView imageView;
public ViewHolder(View itemView) {

    super(itemView);
    ButterKnife.bind(this, itemView);       
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Volley 基本用法和源码分析]]></title>
      <url>/2017/07/19/aboutVolley/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><strong>Volley是一套比较完善的网络框架，它可以自动调度网络请求，实现并发的网络连接，并且可以很方便的更新UI</strong></p>
<ul>
<li>添加依赖</li>
</ul>
<pre><code>compile &apos;com.mcxiaoke.volley:library:1.0.19&apos;
</code></pre><h2 id="StringRequest，JsonRequest"><a href="#StringRequest，JsonRequest" class="headerlink" title="StringRequest，JsonRequest"></a>StringRequest，JsonRequest</h2><ul>
<li>一般使用Volley会包括三个部分，创建requestQueue对象，创建request对象，将request对象添加到requestQueue对象当中</li>
<li>requestQueue对象不需要每次都创建，它是一个请求队列</li>
</ul>
<pre><code>mQueue = Volley.newRequestQueue(NewsApplication.getNewsContext());
</code></pre><ul>
<li>创建request对象，我们需要服务器地址和两个监听器，然后将其添加到队列即可</li>
</ul>
<pre><code>    public static void  getString(String url,     Response.Listener&lt;String&gt; listener,Response.ErrorListener errorListener){

    StringRequest stringRequest = new StringRequest(url,listener,errorListener);
    mQueue.add(stringRequest);

} 
</code></pre><ul>
<li>Response.Listener 和 Response.ErrorListener 中我们需要分别实现成功加载时和加载失败时的回调方法</li>
</ul>
<pre><code>    @Override
public void onErrorResponse(VolleyError error) {
Log.d(TAG, &quot;onErrorResponse: &quot;);

}

...
public void onResponse(String response) {
Log.d(TAG, &quot;onResponse:&quot;);

}
</code></pre><ul>
<li>Volley 没有提供默认的post方法，但是我们可以重写getParams方法，将POST参数放入一个map容器中返回即可</li>
</ul>
<pre><code>        protected Map&lt;String, String&gt; getParams() throws AuthFailureError {
    Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
    map.put(&quot;params1&quot;, &quot;value1&quot;);
    map.put(&quot;params2&quot;, &quot;value2&quot;);
    return map;
}
</code></pre><h2 id="ImageRequest"><a href="#ImageRequest" class="headerlink" title="ImageRequest"></a>ImageRequest</h2><ul>
<li><p>ImageRequest专门用于加载网络图片，使用方法和StringRequest和JsonRequest有小小的差别</p>
</li>
<li><p>ImageRequest的构造方法有七个参数，分别为链接，含有加载成功时的回调方法的监听器，最大的长和宽，缩放模式，颜色属性，加载失败的监听器，当不需要限制长宽时可以将参数设置为0，图片参数一般设置为 Config.RGB_565 即可</p>
</li>
</ul>
<pre><code>public ImageRequest(String url, Response.Listener&lt;Bitmap&gt; listener, int maxWidth, int maxHeight,
    ScaleType scaleType, Config decodeConfig, Response.ErrorListener errorListener)
 ...

ImageRequest imageRequest = new ImageRequest(url,

        new Response.Listener&lt;Bitmap&gt;() {
    @Override
    public void onResponse(Bitmap response) {
        imageView.setImageBitmap(response);
    }

}, 0,0, ImageView.ScaleType.CENTER_INSIDE, Bitmap.Config.RGB_565,

        new Response.ErrorListener() {
    @Override
    public void onErrorResponse(VolleyError error) {

    }

});
</code></pre><h2 id="ImageLoader"><a href="#ImageLoader" class="headerlink" title="ImageLoader"></a>ImageLoader</h2><ul>
<li>ImageRequest 使用起来还是比较麻烦的，使用ImageLoader会比较简洁而且它支持了缓存功能</li>
<li>创建ImageLoader对象需要请求队列和缓存对象，Imageloader为回调方法做了封装，我们只需要提供ImageView和成功及失败时使用的资源图片即可</li>
</ul>
<pre><code>public static void getImage(String url, ImageLoader.ImageCache cache, ImageView imageView){

setQueue();
ImageLoader imageLoad = new ImageLoader(mQueue,cache);
ImageLoader.ImageListener listener = ImageLoader.getImageListener(imageView, R.drawable.downing,R.drawable.failed);
imageLoad.get(url,listener);

}
</code></pre><ul>
<li>一般使用LruCache来缓存，让它实现ImageCache接口即可，这个接口只需实现将Bitmap加入缓存和取出缓存的方法</li>
</ul>
<pre><code>@Override
public Bitmap getBitmap(String url) {
return mCache.get(url);
}

@Override
public void putBitmap(String url, Bitmap bitmap) {

mCache.put(url,bitmap);
}
</code></pre><h2 id="NetworkImageView"><a href="#NetworkImageView" class="headerlink" title="NetworkImageView"></a>NetworkImageView</h2><ul>
<li>NetworkImageView是一个封装了请求操作的图片控件，我们只需要提供一个imageLoad对象和url即可</li>
</ul>
<pre><code>&lt;com.android.volley.toolbox.NetworkImageView
android:id=&quot;@+id/theme_iv_header&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;360dp&quot; /&gt;

  ...  

ivHeader.setImageUrl(imageUrl,new ImageLoader(DataFromVolley.getQueue(),new BitmapCache(BitmapCache.MAX_MEMORY /8)));
</code></pre><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><ul>
<li>我们使用Volley的第一步，是调用newRequestQueue方法创建请求队列，那么先来查看这个方法，它的内部经过了几次直接的return，之后我们来到这里</li>
</ul>
<pre><code>     public static RequestQueue newRequestQueue(Context context, HttpStack stack, int maxDiskCacheBytes) {


    ...    

    if (stack == null) {
        if (Build.VERSION.SDK_INT &gt;= 9) {
            stack = new HurlStack();
        } else {
            // Prior to Gingerbread, HttpUrlConnection was unreliable.
            // See: http://android-developers.blogspot.com/2011/09/androids-http-clients.html
            stack = new HttpClientStack(AndroidHttpClient.newInstance(userAgent));
        }
    }

    Network network = new BasicNetwork(stack);

    RequestQueue queue;
    if (maxDiskCacheBytes &lt;= -1)
    {
        // No maximum size specified
        queue = new RequestQueue(new DiskBasedCache(cacheDir), network);
    }
    else
    {
        // Disk cache size specified
        queue = new RequestQueue(new DiskBasedCache(cacheDir, maxDiskCacheBytes), network);
    }

    queue.start();

    return queue;
}    
</code></pre><ul>
<li>我们看到这里判断了 Build.VERSION.SDK_INT ，以此根据不同的安卓版本创建了两个Stack类的实例，查看注释这两个类分别是基于HttpURLConnection和HttpClient来实现的，在较新的版本上使用的是 HttpURLConnection。所以我们可以知道Volley真正的网络操作实际交由这两者来执行的。</li>
</ul>
<pre><code>/**
 * An {@link HttpStack} based on {@link         HttpURLConnection}.
 */ 

 /**
 * An HttpStack that performs request over an {@link         HttpClient}.
 */
</code></pre><ul>
<li>创建完stack对象，networ对象和请求队列queue之后，queue的start方法执行了，查看这个方法的内部</li>
</ul>
<pre><code>public void start() {
stop();  // Make sure any currently running dispatchers are stopped.
// Create the cache dispatcher and start it.
mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);
mCacheDispatcher.start();

// Create network dispatchers (and corresponding threads) up to the pool size.
for (int i = 0; i &lt; mDispatchers.length; i++) {
    NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork,
            mCache, mDelivery);
    mDispatchers[i] = networkDispatcher;
    networkDispatcher.start();
}
}
</code></pre><ul>
<li>start 方法中主要有两个对象 mCacheDispatcher和networkDispatcher，查看继承关系，得知他们是 Thread 子类的实例，同一时刻会有一个CacheDispatcher线程和多个NetworkDispatcher线程在执行，从名字就可以看出CacheDispatcher用来执行缓存操作而NetworkDispatcher用来执行网络操作，找到前者的run方法</li>
</ul>
<pre><code>public void run() {
if (DEBUG) VolleyLog.v(&quot;start new dispatcher&quot;);
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);

// Make a blocking call to initialize the cache.
mCache.initialize();

Request&lt;?&gt; request;
while (true) {
    // release previous request object to avoid leaking request object when mQueue is drained.
    request = null;
    try {
        //这里从请求队列拿出了请求
        // Take a request from the queue.
        request = mCacheQueue.take();
    }

    ....

        // Attempt to retrieve this item from cache.
        Cache.Entry entry = mCache.get(request.getCacheKey());

        //查看是否有缓存，没有则交给网络队列
        if (entry == null) {
            request.addMarker(&quot;cache-miss&quot;);
            // Cache miss; send off to the network dispatcher.
            mNetworkQueue.put(request);
            continue;
        }

        // If it is completely expired, just send it to the network.
        if (entry.isExpired()) {
            request.addMarker(&quot;cache-hit-expired&quot;);
            request.setCacheEntry(entry);
            mNetworkQueue.put(request);
            continue;
        }

        // We have a cache hit; parse its data for delivery back to the request.

            // Post the intermediate response back to the user and have
            // the delivery then forward the request along to the network.
            final Request&lt;?&gt; finalRequest = request;
            mDelivery.postResponse(request, response, new Runnable() {
                @Override
                public void run() {
                    try {
                        mNetworkQueue.put(finalRequest);
                    } catch (InterruptedException e) {
                        // Not much we can do about this.
                    }
                }
            });
        }
    }
</code></pre><ul>
<li><p>可以看到CacheDispatcher缓存线程会先检查它的请求队列mCacheQueue中各个请求的数据是否在缓存中，如果缓存中没有就加入到NetworkDispatcher网络线程处理的队列mNetworkQueue，让NetworkDispatcher去处理。注意这里的循环是while (true)，所以我们调用newRequestQueue最后就是为了开启了这几个无限循环处理请求的线程，注意这里的队列都是PriorityBlockingQueue，也就是优先级队列</p>
</li>
<li><p>线程已经打开了但是这时还没有请求，那么再来看看我们调用的add方法，终于看到比较短的代码了…</p>
</li>
</ul>
<pre><code>public &lt;T&gt; Request&lt;T&gt; add(Request&lt;T&gt; request) {
// Tag the request as belonging to this queue and add it to the set of current requests.
request.setRequestQueue(this);
synchronized (mCurrentRequests) {
    mCurrentRequests.add(request);
}

// Process requests in the order they are added.
request.setSequence(getSequenceNumber());
request.addMarker(&quot;add-to-queue&quot;);

// If the request is uncacheable, skip the cache queue and go straight to the network.
if (!request.shouldCache()) {
    mNetworkQueue.add(request);
    return request;
}

// Insert request into stage if there&apos;s already a request with the same cache key in flight.
synchronized (mWaitingRequests) {
    String cacheKey = request.getCacheKey();
    if (mWaitingRequests.containsKey(cacheKey)) {
        // There is already a request in flight. Queue up.
        Queue&lt;Request&lt;?&gt;&gt; stagedRequests = mWaitingRequests.get(cacheKey);
        if (stagedRequests == null) {
            stagedRequests = new LinkedList&lt;Request&lt;?&gt;&gt;();
        }
        stagedRequests.add(request);
        mWaitingRequests.put(cacheKey, stagedRequests);
        if (VolleyLog.DEBUG) {
            VolleyLog.v(&quot;Request for cacheKey=%s is in flight, putting on hold.&quot;, cacheKey);
        }
    } else {
        // Insert &apos;null&apos; queue for this cacheKey, indicating there is now a request in
        // flight.
        mWaitingRequests.put(cacheKey, null);
        mCacheQueue.add(request);
    }
    return request;
}
} 
</code></pre><ul>
<li>add方法几乎每一步都加了注释，还是很好解读的，去掉一些判断逻辑，发现add方法其实是先检查我们传进来的请求是否需要缓存，如果不需要就直接加入上NetworkDispatcher处理的队列否则就加入CacheDispatcher的队列，一般请求都是默认可以缓存的，到了这里队列就有请求了</li>
</ul>
<ul>
<li>现在再来看看请求得到的response是怎么回到主线程处理的，reponse是由之前提到的NetWork对象操作stack对象（HttpURLConnection或者HttpClient）得到的，置于怎么操作不是很重要，不去研究。我们看到NetworkDispatcher的run方法最后使用ResponseDelivery mDelivery的一个post方法，顾名思义，response被传递了，点进去发现ResponseDelivery是一个接口，所以还得去找找他是在哪创建的</li>
</ul>
<pre><code>mDelivery.postResponse(request, response);
</code></pre><ul>
<li>找了半天发现它是在RequestQueue被创建时调用的，也就是在newRequestQueue方法的过程中，它的实现类是ExecutorDelivery，这里我们看到它持有了一个MainLooper，已经大概可以猜到内部实现了</li>
</ul>
<pre><code>public RequestQueue(Cache cache, Network network, int threadPoolSize) {
this(cache, network, threadPoolSize,
        new ExecutorDelivery(new Handler(Looper.getMainLooper())));
}
</code></pre><ul>
<li>找到之前 postResponse 方法的具体实现， 它调用了mResponsePoster 的 execute方法             </li>
</ul>
<pre><code>              @Override
public void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable) {
request.markDelivered();
request.addMarker(&quot;post-response&quot;);
mResponsePoster.execute(new ResponseDeliveryRunnable(request, response, runnable));
}
</code></pre><ul>
<li>execute其实就是handler的post方法，由于已经知道handler持有的是mainLooper，因此response可以在主线程处理了</li>
</ul>
<pre><code>mResponsePoster = new Executor() {
    @Override
    public void execute(Runnable command) {
        handler.post(command);
    }
};
</code></pre><ul>
<li>那么这里post的Runnable又是什么呢，查看ExecutorDelivery，也就是之前接受了MainLooper的那个类，看来这个Runnable是它的内部类，当请求成功时调用deliverResponse，不成功时调用deliverError，在进去阅读文档得知这两个方法最终会调用Listener的回调方法，也就是我们熟悉的onResponse方法了，值得注意的是这个Runnable的run方法里面又执行了另一个Runnable的run方法，在NetworkDispatcher中这个传入的Runnable是null，这个Runnable是用于CacheDispatcher得到缓存后可以直接回到主线程而存在的</li>
</ul>
<pre><code>    @Override
    public void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response) {
    postResponse(request, response, null);
    }

    @Override
    public void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable) {
    request.markDelivered();
    request.addMarker(&quot;post-response&quot;);
    mResponsePoster.execute(new ResponseDeliveryRunnable(request, response, runnable));
    }


    /**
     * A Runnable used for delivering network responses to a listener on the
     * main thread.
     */
@SuppressWarnings(&quot;rawtypes&quot;)
private class ResponseDeliveryRunnable implements Runnable {
    private final Request mRequest;
    private final Response mResponse;
    private final Runnable mRunnable; 
    ...
            public void run() {
                        if (mResponse.isSuccess()) {
        mRequest.deliverResponse(mResponse.result);
    } else {
        mRequest.deliverError(mResponse.error);
    }
    ...
                if (mRunnable != null) {
        mRunnable.run();
    }
     ...
</code></pre><ul>
<li></li>
<li><p>这样我们就把Volley的机制大致过了一遍，我们发现Volley实现了并发的异步请求，数据缓存，优先级，同时有一个RequestQueue来同一存放请求，相对于我们单独地使用HttpURLConnection，它减少了大量线程开启和销毁带来的消耗，还是有比较多的优点的，另外使用它的时候要特别注意不要多次创建RequestQueue队列，否则会开启很多长期运行的线程        </p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RecycleView基本用法]]></title>
      <url>/2017/07/18/aboutRecycleView/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><strong>RecycleView不但能提供比ListView更多的显示效果，还提供了较高的解耦性，可定制性，另外，它封装了我们常用的ViewHolder机制，使得代码更加清晰</strong></p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><ul>
<li>recycleView 相比于ListView除了设置适配器以外还必须设置布局管理器，LayoutManager是一个抽象类，它有三个子类LinearLayoutManager、GridLayoutManager和StaggeredGridLayoutManager分别支持线性布局、表格布局和瀑布流布局的属性设置，线性布局通常用来实现与ListView相似的效果</li>
<li>通过addItemDecoration方法和setItemAnimator方法我们可以设分割线和添加和删除的动画,但是分割线的参数类型ItemDecoration需要重写</li>
</ul>
<pre><code>List&lt;NewsBase&gt; commentDataList = new ArrayList&lt;&gt;();
RecyclerView rvComment = (RecyclerView) findViewById(R.id.comment_lv_content);
rvComment.setLayoutManager(new LinearLayoutManager(this,LinearLayoutManager.VERTICAL,false));
UserAdapter commentAdapter = new UserAdapter(commentDataList,apiType);
rvComment.setAdapter(commentAdapter);
CommentHandler handler = new CommentHandler(commentAdapter);
</code></pre><ul>
<li>在XML中设置属性，和ListView大同小异，但注意设置divider属性是不起作用的</li>
</ul>
<pre><code>&lt;android.support.v7.widget.RecyclerView
    android:id=&quot;@+id/home_lv_news&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:scrollbars=&quot;vertical&quot;
    android:scrollbarStyle=&quot;insideOverlay&quot;/&gt;
</code></pre><ul>
<li>接着我们需要重写Adapter，注意要在其中实现ViewHolder的子类</li>
</ul>
<pre><code>static class ViewHolder extends RecyclerView.ViewHolder{

ImageView itemIvAvatar;
TextView itemTvAuthor;
TextView itemTvContent;
TextView itemTvLikes;
TextView itemTvTime;

public ViewHolder(View itemView) {

    super(itemView);
    itemIvAvatar = (ImageView)itemView.findViewById(R.id.item_iv_avatar);
    itemTvAuthor =  (TextView)itemView.findViewById(R.id.item_tv_author);
    itemTvContent = (TextView)itemView.findViewById(R.id.item_tv_content);
    itemTvLikes = (TextView)itemView.findViewById(R.id.item_tv_likes);
    itemTvTime = (TextView)itemView.findViewById(R.id.item_tv_time);
    }

}
</code></pre><ul>
<li>在onCreateViewHolder中返回我们的item布局</li>
</ul>
<pre><code>public UserAdapter.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_rc_news,parent,false);
ViewHolder viewHolder = new ViewHolder(v);
return viewHolder;
} 
</code></pre><ul>
<li>在onBindViewHolder中设置控件的相关信息，这个步骤和listView的getView是相似的只不过Recycle将ViewHolder机制包装起来了</li>
</ul>
<pre><code>@Override
public void onBindViewHolder(ViewHolder viewHolder, int position) {

NewsUser user = (NewsUser)mDataList.get(position);
viewHolder.itemTvContent.setText(user.getContent());
viewHolder.itemTvAuthor.setText(user.getAuthor());
}
</code></pre><ul>
<li>在getItemCount中返回Item的数目</li>
</ul>
<pre><code>@Override
public int getItemCount() {
return mDataList.size();
}
</code></pre><ul>
<li>对于Recycle我们需要自己创建和实现接口，已响应点击时间</li>
</ul>
<pre><code>public interface OnItemClickListener{
void onClick(int positon);
}
</code></pre><ul>
<li><p>对于表格布局和瀑布流布局，使用其他管理器</p>
<pre><code>new StaggeredGridLayoutManager(3,StaggeredGridLayoutManager.VERTICAL);
</code></pre></li>
</ul>
<h2 id="添加HeaderView"><a href="#添加HeaderView" class="headerlink" title="添加HeaderView"></a>添加HeaderView</h2><ul>
<li>在ListView中有 getItemViewType方法，但并不怎么常用，而在扩展性较强的Recycle中就十分常用了</li>
<li>ListView中可以通过调用addHeader方法添加一个顶部布局，但RecycleView中不提供这种方法，需要自己动手写的代码比较多</li>
</ul>
<ul>
<li>首先我们需要让Adapter持有Header同时需要调用notifyItemInserted方法来告诉Adapter我们在顶部插入了一个子View</li>
</ul>
<pre><code>public void setHeaderView(View mHeaderView) {
this.mHeaderView = mHeaderView;
notifyItemInserted(0);
}
</code></pre><ul>
<li>对于header与普通的子View应划分成两种类型，通过getItemViewType得到具体位置的类型，注意我们需要检查是否有加入header，以便进行不同的处理以提高复用性</li>
</ul>
<pre><code>@Override
public int getItemViewType(int position) {

if(mHeaderView == null)return TYPE_NORMAL;
if(position == 0)return TYPE_HEADER;
return TYPE_NORMAL;
}
</code></pre><ul>
<li>在ListView中添加了header之后，通常要将在onClick方法中的position参数减一来使用，对于RecycleView，插入header同样使得显示列表的position和我们数据中的position不一致，需要处理这部分逻辑，创建一个方法返回一个ViewHolder的数据在集合中的正确位置</li>
</ul>
<pre><code>public int getItemPosition(NewsAdapter.ViewHolder viewHolder){
   int position =  viewHolder.getLayoutPosition();
    return mHeaderView == null ? position : position-1;
}

@Override
public int getItemCount() {
return mHeaderView == null ? mDataList.size() : mDataList.size()+1;
}
</code></pre><ul>
<li>对于header和普通子View的ViewHolder需要分别处理</li>
</ul>
<pre><code>public NewsAdapter.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {

if(mHeaderView != null &amp;&amp; viewType == TYPE_HEADER) return  new ViewHolder(mHeaderView);
View v = LayoutInflater.from(parent.getContext()).inflate(mResourceId,parent,false);
return new ViewHolder(v);
}

@Override
public void onBindViewHolder(NewsAdapter.ViewHolder viewHolder, int forePosition) {


    if(getItemViewType(forePosition)==TYPE_HEADER)return;

    final int position = getItemPosition(viewHolder);
    ....
</code></pre><ul>
<li>这样一个支持Header的Recycle就完成了，理论上套用这个方式可以添加各种不同的布局到Recycle的各个位置</li>
</ul>
<h2 id="上拉加载"><a href="#上拉加载" class="headerlink" title="上拉加载"></a>上拉加载</h2><ul>
<li><p>使用上面的方式添加footer功能，可以提供点击加载的效果，但现在的应用还是以上拉自动加载居多</p>
</li>
<li><p>Recycle提供了addOnScrollListener方法，但是它只能响应滚动状态，具体什么时候去加载需要我们自己去实现</p>
</li>
<li><p>对于一个滚动列表，当我们滑动到底部时，可见的item数量加上上方所有的item数量就是item的总数量，LayoutManager的ChildCount，FirstVisibleItemPosition，ItemCount，分别就当别这三个数量，还是比较好实现的</p>
</li>
</ul>
<pre><code>rvNews.addOnScrollListener(new RecyclerView.OnScrollListener() {
     int pastCount, visibleCount, totalCount;
     @Override
     public void onScrolled(RecyclerView recyclerView, int dx, int dy) {

         visibleCount = mLayoutManager.getChildCount();
         totalCount = mLayoutManager.getItemCount();
         pastCount = mLayoutManager.findFirstVisibleItemPosition();

             if ( (visibleCount + pastCount) &gt;= totalCount) {
                 String date = mNewsDataList.get(mNewsDataList.size() - 1).getDate();
                 Log.d(TAG, &quot;onClick: &quot;+mNewsDataList.get(mNewsDataList.size() - 1).getDate()+mNewsDataList.get(mNewsDataList.size() - 1).getTitle());
                 dataTask.execute(mNewsDataList,new Api(Api.BEFORE,date,0,0));

             }
         }
 });
</code></pre><h2 id="绘制分割线"><a href="#绘制分割线" class="headerlink" title="绘制分割线"></a>绘制分割线</h2><ul>
<li><p>ItemDecoration主要有三个绘制方法可以重写，都可以实现绘制分割线的功能，选一种即可</p>
</li>
<li><p>首先创建布局文件</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:shape=&quot;rectangle&quot;&gt;
    &lt;size
    android:width=&quot;1dp&quot;
    android:height=&quot;1dp&quot; /&gt;
    &lt;solid android:color=&quot;@color/colorPrimary&quot; /&gt;

&lt;/shape&gt;
</code></pre></li>
</ul>
<ul>
<li><p>在Style的AppTheme中添加属性</p>
<pre><code>&lt;item name=&quot;android:listDivider&quot;&gt;@drawable/divider&lt;/item&gt;
</code></pre></li>
<li><p>使用 getResources().getDrawable即可获取到我们定义的divider，对于一个垂直的Recycle，我们可以通过父布局的padding属性得到，但上下的偏移量需要通过每个子View得到，这部分涉及较多View绘制的内容，暂时不去深究   </p>
</li>
</ul>
<pre><code>public class Decoration extends RecyclerView.ItemDecoration {



public Drawable mDivider;

public Decoration(Context context){
mDivider =context.getResources().getDrawable(R.drawable.divider,null);

}

@Override
public void onDrawOver(Canvas c, RecyclerView parent, RecyclerView.State state) {
int left = parent.getPaddingLeft();
int right = parent.getWidth()-parent.getPaddingRight();

int count = parent.getChildCount();
for (int i=0;i&lt;count;i++){
    View child = parent.getChildAt(i);

    RecyclerView.LayoutParams params = (RecyclerView.LayoutParams)child.getLayoutParams();

    int top = child.getBottom()+params.bottomMargin;
    int bottom = top + mDivider.getIntrinsicWidth();

    mDivider.setBounds(left,top,right,bottom);
    mDivider.draw(c);

}
}
}
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[viewPager+TabLayout+Fragment 用法]]></title>
      <url>/2017/07/17/viewPagerTabFragments/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><strong>本篇乙烷</strong></p>
<h2 id="TabLayout"><a href="#TabLayout" class="headerlink" title="TabLayout"></a>TabLayout</h2><p><strong>水平展示标签的布局，在Google推出TabLayout之前，一般使用TabActivity或者ViewPageIndicator等第三方库实现这种功能</strong></p>
<ul>
<li>使用之前需要先添加支持库</li>
</ul>
<pre><code>compile &apos;com.android.support:design:24.2.1&apos;
</code></pre><ul>
<li>像普通控件一样，在需要的地方设置XML属性，注意app:tabMode属性一般设置为滚动，因为当标签数目较少时scrollable默认是静止的，而当标签数目较多时如果没有设置这个属性时，Tab不能滚动，文字会显示不全</li>
</ul>
<pre><code>&lt;android.support.design.widget.TabLayout
android:id=&quot;@+id/tab&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;wrap_content&quot;
app:tabMode=&quot;scrollable&quot;/&gt;
</code></pre><ul>
<li>动态添加Tab，使用addTag方法和newTab方法</li>
</ul>
<pre><code>for(int i = 0;i&lt;10;i++){
    tabLayout.addTab(tabLayout.newTab().setText(&quot;NO: &quot;+i));
}
</code></pre><ul>
<li>这时一个TabLayout已经可以正常显示了，但是它并没有什么作用，TabLayout一般与ViewPager相结合，实现翻页的功能</li>
</ul>
<h2 id="FragmentPagerAdapter"><a href="#FragmentPagerAdapter" class="headerlink" title="FragmentPagerAdapter"></a>FragmentPagerAdapter</h2><p><strong> 用于显示一组Fragment的ViewPager的Adapter</strong></p>
<ul>
<li>必须实现的方法有两个，和pagerAdapter的含义基本一致，在getItem中根据位置返回Fragment，getcount中返回item总数量</li>
</ul>
<pre><code>public FragmentAdapter(FragmentManager fm,List&lt;Fragment&gt; list) {
super(fm);
this.list = list;

}

@Override
public Fragment getItem(int position) {
return list.get(position);
}

@Override
public int getCount() {
return list.size();
}
</code></pre><ul>
<li>为Fragment设定Adapter之后调用tabLayout的setupWithViewPager方法即可将TabLayout和ViewPager关联起来</li>
</ul>
<pre><code>FragmentAdapter fragmentAdapter = new FragmentAdapter(getSupportFragmentManager(),fragments);
viewPager.setAdapter(fragmentAdapter);
tabLayout.setupWithViewPager(viewPager); 
</code></pre><ul>
<li>注意如果在之前设置了文字，这些文字会被<a href="http://blog.csdn.net/u013233097/article/details/54708202" target="_blank" rel="external">清除</a>，将这个步骤放在这之后即可</li>
</ul>
<pre><code>for(int i = 0;i&lt;10;i++){
        tabLayout.getTabAt(i).setText(&quot;No：&quot;+i);
    }
</code></pre><ul>
<li>显示效果是这样的</li>
</ul>
<ul>
<li><img src="http://i1.buimg.com/1949/3df635474afa9281.png" alt=""></li>
</ul>
<h2 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h2><ul>
<li>ViewPager默认会缓存三页数据，这个属性是由DEFAULT_OFFSCREEN_PAGES决定的，可以使用setOffscreenPageLimit方法设定预加载的页数，但是没有办法设定为0</li>
<li>如果预加载的每个Fragment都去加载数据，Activity的创建时会造成卡顿，所以我们需要在页面切换到可见时再去加载数据</li>
<li>为了解决这个问题，必须从Fragment中入手，Fragment中含有setUserVisibleHint方法，它会在onCreateView之前被调用一次出入false参数，表示Fragment不可见，之后在每次Fragment变为可见时传入true，不可见时传入false</li>
<li>首先需要创建Fragment的子类作为我们使用Fragment的基类，设定三个标记，分别表示当前Fragment是否可见，布局是否已经加载，Fragment是否为第一次可见</li>
</ul>
<pre><code>    private boolean isVisible;
private boolean isPrepared;
private boolean isFirst; 
</code></pre><ul>
<li>在setUserVisibleHint方法中设置isVisible标记，注意必须调用父类的方法，否则在需要使用getUserVisibleHint时可能得到错误的返回值</li>
</ul>
<pre><code>@Override
public void setUserVisibleHint(boolean isVisibleToUser) {

    if(isVisibleToUser){
        isVisible = true;
        Log.d(TAG, &quot;setUserVisibleHint: fragment NO: &quot;+getArguments().getInt(&quot;name&quot;,0)+&quot; true&quot;);
        loadData();

    }else {
        isVisible = false;
        Log.d(TAG, &quot;setUserVisibleHint: fragment NO: &quot;+getArguments().getInt(&quot;name&quot;,0)+&quot; false&quot;);

    }
    super.setUserVisibleHint(isVisibleToUser);
}
</code></pre><ul>
<li>在onCreateView中返回RootView，注意判空，并设置isPrepared标记，当然，直接判断RootView是否为空也能起到isPrepared标记的作用</li>
</ul>
<pre><code>@Override
public View onCreateView(LayoutInflater inflater, ViewGroup container,
                     Bundle savedInstanceState) {

if(mRoot ==null){
    mRoot = initView(inflater,container);
    Log.d(TAG, &quot;onCreateView: &quot;);
}            
    isPrepared = true;
   return mRoot;
}
</code></pre><ul>
<li>在setUserVisibleHint中调用了loadData方法，它大致上是这样的，在加载数据之前先检查一下三个标记</li>
</ul>
<pre><code>void loadData(){
if(isFirst&amp;&amp;isPrepared&amp;&amp;isVisible) {
    Log.d(TAG, &quot;loadData: --------------&quot;);
    Log.d(TAG, &quot;loadData: &quot;+ getArguments().getInt(&quot;name&quot;,0));
    isFirst = false;
   return;
}
    ...
}
</code></pre><ul>
<li>注意在onActivityCreated中也要调用一次loadData方法这是因为当ViewPager第一次加载两个Fragment时，setUserVisibleHint 在 onCreateView之前调用了，这时 isPrepared是false，当然无法加载数据。如果不在onActivityCreated中调用loadData方法，第一页的数据将无法在第一次显示时初始化</li>
</ul>
<pre><code>@Override
public void onActivityCreated(@Nullable Bundle savedInstanceState) {
super.onActivityCreated(savedInstanceState);

Log.d(TAG, &quot;onActivityCreated: &quot;+ getArguments().getInt(&quot;name&quot;,0));
loadData();

}
</code></pre><ul>
<li>下面滑动页面进行测试，可以看到进入Activity和翻页时虽然各个Fragment都有回应ViewPager的缓存机制，但是只有到它们被显示时才会去加载数据，懒加载的目的达成了，当需要使用这个Fragment时重写loadData方法和initView方法即可     </li>
</ul>
<pre><code>onActivityCreated: 0
loadData: --------------
loadData: 0
initView: 
onCreateView: 
onActivityCreated: 1

setUserVisibleHint: fragment NO: 2 false
setUserVisibleHint: fragment NO: 0 false
setUserVisibleHint: fragment NO: 1 true

loadData: 1
initView: 
onCreateView: 
onActivityCreated: 2
setUserVisibleHint: fragment NO: 3 false
setUserVisibleHint: fragment NO: 1 false
setUserVisibleHint: fragment NO: 2 true
loadData: --------------
loadData: 2
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Fragment基本用法]]></title>
      <url>/2017/07/17/aboutFragment/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<h2 id="Fragment-生命周期"><a href="#Fragment-生命周期" class="headerlink" title="Fragment 生命周期"></a>Fragment 生命周期</h2><ul>
<li>Fragment的生命周期简单来说是这样的</li>
</ul>
<ul>
<li><img src="http://img.blog.csdn.net/20140719225005356?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbG1qNjIzNTY1Nzkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></li>
</ul>
<ul>
<li>但实际上是这样的</li>
</ul>
<p><img src="http://www.jcodecraeer.com/uploads/20150605/1433435656859602.png" alt=""></p>
<ul>
<li>Fragment 依赖于Activity而存在，相对于Activity它还多了几个回调方法</li>
<li>onAttach（Activity） 当Fragment和Activity发生关联的时候调用</li>
<li>onCreateView（Bundle）创建Fragment视图时调用，需要返回Fragment的布局视图，注意查找控件时要先判断是否为null避免重复加载</li>
<li>onActivityCreate（Bundle）当Activity的onCreate方法返回时调用，到了调用这个方法的时候才可以和Activity中的控件进行交互的UI操作，因为这个此时Activity的onCreate方法才调用完毕</li>
<li>onDestroyView（）当Fragment的视图被移除时调用</li>
<li>onDetach（）当Fragment与Activity关联被取消时调用</li>
<li>如果Activity处于暂停状态时其中所有的Fragment都是暂停状态，如果Activity处于stopped状态，其中所有Fragment都不能启动，如果Activity被销毁，所有Fragment都会被销毁</li>
<li>在onCreate中应该初始化除了view类之外的东西，在onCreateView中应该创建Fragment自己的视图并且返回</li>
</ul>
<h2 id="静态使用Fragment"><a href="#静态使用Fragment" class="headerlink" title="静态使用Fragment"></a>静态使用Fragment</h2><ul>
<li>创建Fragment子类和它的布局文件，在onCreateView中初始化控件并返回Fragment的布局</li>
</ul>
<pre><code>@Nullable
@Override
public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {


View view = inflater.inflate(R.layout.fragment_content,container,false);

Button button = (Button)view.findViewById(R.id.button);
...

return view;

}
</code></pre><ul>
<li>在Activity的XML文件中使用Fragment的布局</li>
</ul>
<pre><code>&lt;fragment
android:id=&quot;@+id/title&quot;
android:name = &quot;com.linjiamin.aboutfragment.TitleFragment&quot;
android:layout_width=&quot;wrap_content&quot;
android:layout_height=&quot;wrap_content&quot;/&gt;

&lt;fragment
android:id=&quot;@+id/content&quot;
android:name=&quot;com.linjiamin.aboutfragment.ContentFragment&quot;
android:layout_width=&quot;wrap_content&quot;
android:layout_height=&quot;wrap_content&quot;/&gt;
</code></pre><h2 id="动态使用Fragment-及常见问题"><a href="#动态使用Fragment-及常见问题" class="headerlink" title="动态使用Fragment 及常见问题"></a>动态使用Fragment 及常见问题</h2><ul>
<li>管理Fragment Transaction 需要获取FragmentManage，注意调用getSupportFragmentManager而不是getFragmentManager，我们需要获取support-v4包中的FragmentManager</li>
</ul>
<ul>
<li>动态使用Fragment时，可以使用findFragmentByTag方法，Tag为使用add和replace方法时添加的第三个参数</li>
</ul>
<ul>
<li>动态使用Fragment时调用FragmentManage的findFragmentById方法会返回null值，因为这个方法通过在Activity的布局文件中查找Fragment的id，因为通常只有静态使用Fragment时我们才会在Activity的布局中添加Fragment标签</li>
</ul>
<pre><code>FragmentManager fragmentManager = getSupportFragmentManager();
FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();
fragmentOne = new FragmentOne();
fragmentTransaction.replace(R.id.content,fragmentOne);
fragmentTransaction.commit(); 
</code></pre><ul>
<li>FragmentTransaction用于对Fragment进行添加，替换，移除等操作，一个完整的事务可以设定一系列的变化， 但只有提交之后这些变化才会执行</li>
</ul>
<ul>
<li>add、hide、show方法避免了重复加载数据的问题，但是可能会导致视图的重叠，需要合理地配合replace</li>
</ul>
<ul>
<li>当使用add方法在同一显示位置反复添加一个Fragment时会抛出异常，通常进行检查已避免这个问题：if(fragmentTwo.isAdded())</li>
</ul>
<pre><code>java.lang.IllegalStateException: Fragment already added: FragmentTwo
</code></pre><ul>
<li>若不调用 addToBackStack(String)方法，被移除的Fragment会被销毁，addToBackStack通过模拟返回栈可以实现回退的功能，该方法接受一个参数，它仅作为标记，可以为null</li>
</ul>
<pre><code>fragmentTransaction.addToBackStack(null);
    fragmentTransaction.replace(R.id.content,fragmentTwo);
</code></pre><ul>
<li>使用addToBackStack和replace时，Fragment的实例虽然不会被销毁，但是视图层依然会被销毁，为了避免这种状况，可以使用hide()方法将Fragment隐藏</li>
</ul>
<ul>
<li>Activity重启时可能会造成Fragment重叠的问题，解决方案可以参考<a href="http://www.jianshu.com/p/c12a98a36b2b" target="_blank" rel="external">这里</a></li>
</ul>
<h2 id="Fragment-与-Activity-进行通信"><a href="#Fragment-与-Activity-进行通信" class="headerlink" title="Fragment 与 Activity 进行通信"></a>Fragment 与 Activity 进行通信</h2><ul>
<li>通过Fragment通过getActivity可以活动Activity的实例，Activity通过findFragment*方法可以获得Fragment的实例</li>
<li>通常情况下Fragment不应该和具体的Activity耦合，这样会降低Fragment的重用性，通常使用接口回调的方法实现Activity和Fragment之间的通信</li>
</ul>
<pre><code>    private FragmentButtonListener mListener;

public void setListener(FragmentButtonListener mListener) {
this.mListener = mListener;
}

public interface FragmentButtonListener{
void onFragmentButtonClick();
}

@Override
public void onClick(View v) {

if(mListener!= null){
    mListener.onFragmentButtonClick();
}
}
</code></pre><ul>
<li>下面这种方法也是可行的</li>
</ul>
<pre><code>@Override
public void onClick(View v) {

    if(getActivity() instanceof FragmentButtonListener){
       (FragmentButtonListener) getActivity()).onFragmentButtonClick();
    }
}
</code></pre><ul>
<li>注意通常不要让Fragment直接与其他Fragment进行消息传递，这样会使不同的Fragment耦合，应当让Activity充当总线去接受和发送消息给各个Fragment</li>
</ul>
<h2 id="DialogFragment"><a href="#DialogFragment" class="headerlink" title="DialogFragment"></a>DialogFragment</h2><p><strong> DialogFragment 首先是一种Fragment，Google官方不推荐直接使用Dialog，Dialog在屏幕旋转和按下后退键时有更好管理的生命周期，它与Fragment基本一致，并且可以在不同尺寸的屏幕上显示不同的效果</strong></p>
<h3 id="onCreatDialog"><a href="#onCreatDialog" class="headerlink" title="onCreatDialog"></a>onCreatDialog</h3><p><strong>使用DialogFragment有两种途径，重写onCreateView和onCreateDialog，不能同时使用两者</strong></p>
<ul>
<li>重写该方法，返回一个AlertDialog对象，注意需要实现监听器，在需要的地方调用dismiss()方法即可</li>
</ul>
<pre><code>@Override
public Dialog onCreateDialog(Bundle savedInstanceState) {

AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
builder.setTitle(&quot;title&quot;)
        .setPositiveButton(&quot;yes&quot;,this)
        .setNegativeButton(&quot;no&quot;,this)
        .setCancelable(true);

return builder.create();
}
</code></pre><ul>
<li>实例化DialogFragment传入FragmentManger和tag即可</li>
</ul>
<pre><code>new TestDialog().show(getFragmentManager(),null);
</code></pre><h3 id="onCreateView"><a href="#onCreateView" class="headerlink" title="onCreateView"></a>onCreateView</h3><ul>
<li>首先自定义布局</li>
</ul>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout
xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
android:orientation=&quot;horizontal&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot;
android:id=&quot;@+id/dialog&quot;&gt;

&lt;Button
android:id=&quot;@+id/positive&quot;
android:text=&quot;yes&quot;
android:layout_width=&quot;wrap_content&quot;
android:layout_height=&quot;wrap_content&quot; /&gt;

&lt;Button
android:id=&quot;@+id/negative&quot;
android:text=&quot;no&quot;
android:layout_width=&quot;wrap_content&quot;
android:layout_height=&quot;wrap_content&quot; /&gt;

&lt;Button
android:text=&quot;help&quot;
android:id=&quot;@+id/help&quot;
android:layout_width=&quot;wrap_content&quot;
android:layout_height=&quot;wrap_content&quot; /&gt;

&lt;/LinearLayout&gt;
</code></pre><ul>
<li>继承DialogFragment，重写onCreateView，设定控件的监听器，返回自定义的view</li>
</ul>
<pre><code>    @Nullable
    @Override
public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, Bundle savedInstanceState) {

View view = inflater.inflate(R.layout.test_dialog, container, false);
Button posivitive = (Button)view.findViewById(R.id.positive);
Button negative = (Button)view.findViewById(R.id.negative);
Button help = (Button)view.findViewById(R.id.help);

posivitive.setOnClickListener(this);
help.setOnClickListener(this);
negative.setOnClickListener(this);

return view;
}
</code></pre><ul>
<li>二次弹窗需要开启事务，操作和普通Fragment是相似的，之后开启新的弹窗即可</li>
</ul>
<pre><code>FragmentTransaction fragmentTransaction = getActivity().getSupportFragmentManager().beginTransaction();
fragmentTransaction.remove(this);
fragmentTransaction.addToBackStack(null);
fragmentTransaction.commit();
new AnotherDialog().show(getFragmentManager(),null); 
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Handler基本用法]]></title>
      <url>/2017/07/13/aboutHandler/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<h2 id="ANR"><a href="#ANR" class="headerlink" title="ANR"></a>ANR</h2><ul>
<li>application not responding，当线程阻塞超过5秒时会弹出无响应的Dialog</li>
</ul>
<pre><code>       button.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {

        Thread thread = Thread.currentThread();
        try {
            thread.sleep(6000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
});
</code></pre><ul>
<li><img src="http://i2.kiimg.com/1949/7d8478d22d279b6a.png" alt=""></li>
<li>所以我们需要在子线程中进行耗时操作，但是子线程是不可以更新UI的，这就意味着我们需要一种机制，使子线程中加载完数据可以马上切换到主线程</li>
</ul>
<h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><h3 id="post"><a href="#post" class="headerlink" title="post"></a>post</h3><p><strong>发送线程</strong></p>
<ul>
<li>post用于投递Runnable，通常被投递的Runnable的run方法会在UI线程中执行，可以更新UI，尝试运行下面这段代码</li>
</ul>
<pre><code>button.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {

        new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    Thread.sleep(3000);

                    new Handler.post(new Runnable() {
                        @Override
                        public void run() {
                            textView.setText(&quot;clicked&quot;);
                            Log.d(&quot;MainActivity&quot;, &quot;run: &quot;);
                        }
                    });
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }).start();
    }
});
</code></pre><ul>
<li>抛出了exception， Can’t create handler inside thread that has not called Looper.prepare()，那么这次尝试先执行Looper.prepare()，UI没有更新，原因和looper的机制有关暂时不去研究，只要把handler改为在主线程中创建即可</li>
</ul>
<pre><code>handler = new Handler();
    button.setOnClickListener(new View.OnClickListener() 
    ...
</code></pre><h3 id="postDelay"><a href="#postDelay" class="headerlink" title="postDelay"></a>postDelay</h3><ul>
<li>postDelay方法提供了一个参数，它用来设定run方法执行的时间，通常可以用来延迟执行UI更新</li>
</ul>
<ul>
<li>这一段代码可以用来实现应用的启动logo，延迟设定一个宽高属性为match_parent的view的Visibility属性，在它遮盖整个界面的情况下onCreate中界面的初始化还可以进行,一定程度上提高了用户体验</li>
</ul>
<pre><code>new Handler().postDelayed(new Runnable() {
    @Override
    public void run() {
        HomeActivity.this.findViewById(R.id.home_fl_logo)
                .setVisibility(View.GONE);
    }
},3000);        
</code></pre><h3 id="sendMessage"><a href="#sendMessage" class="headerlink" title="sendMessage"></a>sendMessage</h3><ul>
<li>查看源码发现它是一个空方法，接受message必须重写它才行</li>
</ul>
<pre><code>/**
 * Subclasses must implement this to receive messages.
 */
public void handleMessage(Message msg) {
} 
</code></pre><ul>
<li>这次使用sendMessage更新UI</li>
</ul>
<pre><code>handler = new Handler(){

    @Override
    public void handleMessage(Message msg) {
        super.handleMessage(msg);
        switch (msg.what){
            case 1:
                textView.setText(&quot;clicked&quot;);
                Log.d(&quot;MainActivity&quot;, &quot;run: &quot;);
                break;
            default:
                break;
        }
    }
}; 

...

new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    Thread.sleep(3000);
                    Message msg = new Message();
                    msg.what = 1;
                    handler.sendMessage(msg);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }).start();
</code></pre><ul>
<li>这种方式分为两个步骤，重写 handleMessage 在switch语句中以Message.what为标识更新UI，调用sendMessage传入message对象</li>
<li>注意，msg.setData()方法可以接受一个Bundle对象为参数，利用Bundle的putParcelable()就可以传递自定义的数据了</li>
<li>使用Message.obtain()方法获取Message对象，避免反复创建实例        </li>
</ul>
<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><h3 id="原因"><a href="#原因" class="headerlink" title="- 原因"></a>- 原因</h3><ul>
<li>handler的生命周期与activity不一致，handler关联了looper管理message队列，这个队列在整个Application的生命周期中存在，handler不会因为Activity的finish()被销毁</li>
<li>非静态（匿名）内部类会持有外部对象，当我们这样重写handler时它就成了一个匿名内部类，这样结合前面如果finish时handler有message未处理，Activity就不能被销毁</li>
</ul>
<pre><code> handler = new Handler(){

    @Override
    public void handleMessage(Message msg) {
        super.handleMessage(msg);
        switch (msg.what){
            case 1:
                textView.setText(&quot;clicked&quot;);
                Log.d(&quot;MainActivity&quot;, &quot;run: &quot;);
                break;
            default:
                break;
        }
    }
}; 
</code></pre><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="- 解决方案"></a>- 解决方案</h3><ul>
<li>在外部新建一个类完全可以解决这个问题，但有时内部类确实比较方便</li>
<li>这时我们可以使用静态内部类和弱引用，当一个对象只被弱引用依赖时它会被gc回收</li>
<li>首先不使用弱引用，我们在onResume中延迟发送消息并马上finish()，handler是一个静态内部类，它显式引用Activity</li>
</ul>
<pre><code>    @Override
protected void onResume() {
super.onResume();
Message message = Message.obtain();
message.what =1;
handler.sendMessageDelayed(message,5000);
finish();
}

...

    private static class MyHandler extends Handler {

//private WeakReference&lt;Activity&gt; reference;
private Activity reference;

public MyHandler(Activity activity){
    //reference = new WeakReference&lt;&gt;(activity);
    reference = activity;
}

@Override
public void handleMessage(Message msg) {
    super.handleMessage(msg);
    switch (msg.what){
        case 1:
            if(reference!= null){
            Log.d(&quot;Main2Activity&quot;, &quot;Leak!! &quot;);
            }else {
                Log.d(&quot;Main2Activity&quot;, &quot;not leak: &quot;);
            }
            break;
        default:
            break;
        }
    }
}
</code></pre><ul>
<li>启动这个Activity之后，马上手动gc，收到log，Activity没有被回收</li>
</ul>
<pre><code>07-14 10:38:43.958 24909-24909/com.linjiamin.handler D/Main2Activity: Leak!! 
</code></pre><ul>
<li><p>这次使用弱引用，注意判空条件为 reference.get()!= null</p>
<pre><code>private static class MyHandler extends Handler {

private WeakReference&lt;Activity&gt; reference;
//private Activity reference;

public MyHandler(Activity activity){
    reference = new WeakReference&lt;&gt;(activity);
    //reference = activity;
}

@Override
public void handleMessage(Message msg) {
    super.handleMessage(msg);
    switch (msg.what){
        case 1:
            if(reference.get()!= null){
            Log.d(&quot;Main2Activity&quot;, &quot;Leak!! &quot;);
            }else {
                Log.d(&quot;Main2Activity&quot;, &quot;not leak: &quot;);
            }
            break;
        default:
            break;
    }
}
</code></pre><p>  }</p>
</li>
</ul>
<ul>
<li>手动gc，收到log，Activity已销毁，Activity内存泄漏的问题已经解决了</li>
</ul>
<pre><code>07-14 10:40:12.400 26112-26112/com.linjiamin.handler D/Main2Activity: not leak: 
</code></pre><ul>
<li>那么如果不使用静态类，只使用弱引用</li>
</ul>
<pre><code>private class MyHandler extends Handler {
</code></pre><ul>
<li>Activity没有被销毁，原因应该是非静态内部类隐式持有了外部类Activity的引用导致无法释放</li>
</ul>
<pre><code>07-14 10:43:41.252 29232-29232/com.linjiamin.handler D/Main2Activity: Leak!!     
</code></pre><ul>
<li>因此我们需要同时使用static和弱引用避免内存泄漏</li>
</ul>
<h2 id="Handler机制"><a href="#Handler机制" class="headerlink" title="Handler机制"></a>Handler机制</h2><ul>
<li>多线程访问UI会导致控件处于不可预期状态，使用线程锁会导致UI访问效率降低，线程阻塞等问题，所以Android使用了单线程来管理UI控件</li>
<li>Handler机制由MessageQueue，Looper和Handler本身组成</li>
<li>Looper用于循环查找MessageQueue中的消息，最终消息会交由Runnable或handler的handlerMessage()处理</li>
</ul>
<h3 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h3><ul>
<li>MessageQueue的中的enqueueMessage可以将消息插入管理消息的单链表，接受参数Message message和Long when就是需要被插入的消息，when是一个位置标记，写过单链表的增删查改的话，下面的操作应该很眼熟了，知道有这回事就够了   </li>
</ul>
<pre><code>Message prev;
        for (;;) {
            prev = p;
            p = p.next;
            if (p == null || when &lt; p.when) {
                break;
            }
        ...
        }
        msg.next = p; // invariant: p == prev.next
        prev.next = msg;
    }
</code></pre><ul>
<li>MessageQueue还有一个next()方法，返回一个Message，并将其从链表中删除</li>
</ul>
<h3 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h3><ul>
<li>有了MessageQueue保存和管理Message的方法，那么当然还需要有这些方法的使用者，它就是looper</li>
<li>looper会不停地查看 MessageQueue中是否有新的Message</li>
<li>只有在主线程中才可以认为有默认的looper在工作，在其他线程中直接创建Handler就会报错</li>
</ul>
<pre><code>Can’t create handler inside thread that has not called Looper.prepare()
</code></pre><ul>
<li>因此在一个子线程中要使用 looper，需要调用Looper的两个静态方法，Looper.prepare可以为当前线程创建一个Looper，Looper.loop会开启Looper的无限循坏，这样就有一个正在工作的Looper了</li>
</ul>
<pre><code>Looper.prepare();
Looper.loop(); 
</code></pre><h3 id="Handler-1"><a href="#Handler-1" class="headerlink" title="Handler"></a>Handler</h3><ul>
<li>从上面了解到Looper只是在不停的查看MessageQueue，那么还需要有 Message的发送者和处理者，它就是Handler</li>
<li>Handler有sendMessage方法和post方法，后者就是基于前者来实现的，最终只是向MessageQueue添加一个Message而已</li>
</ul>
<pre><code>queue.enqueueMessage(msg, uptimeMillis);
</code></pre><ul>
<li>Looper会将Message交由handler处理，而handler会执行dispatchMessage方法查看有没有 callback，这个callback就是我们post的Runnable对象了，如果没有就会调用我们重写的handleMessage方法</li>
</ul>
<pre><code>public void dispatchMessage(Message msg) {
if (msg.callback != null) {
    handleCallback(msg);
} else {
    if (mCallback != null) {
        if (mCallback.handleMessage(msg)) {
            return;
        }
    }
    handleMessage(msg);
        }
    }    
</code></pre><ul>
<li><p>从整体上看，Looper在一个线程中创建，它的操作都在这个线程中，我们在其他线程使用Handler其实最终都是给Looper发送Message，然后Looper再调用handler的方法，所以我们的操作能够在Looper的线程中执行</p>
</li>
<li><p>另外之所以子线程中不能修改UI，其实是由于ViewRoot的实现类有一个检查当前线程是否是主线程的方法，子线程修改UI时的Exception就是它抛出的</p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OkHttp基本用法]]></title>
      <url>/2017/07/13/aboutNet/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<h2 id="HttpClient"><a href="#HttpClient" class="headerlink" title="HttpClient"></a>HttpClient</h2><p><strong>过时的HttpClient</strong></p>
<ul>
<li>Android 5.1后的版本已经废弃HttpClinet，继续使用需要添加依赖</li>
<li>HttpClinet虽然比较灵活，但是api数量过多使得在Android上使用不稳定，Google已经放弃了对它的扩展，转而推荐使用HttpURLConnection</li>
</ul>
<h2 id="OkHttp"><a href="#OkHttp" class="headerlink" title="OkHttp"></a>OkHttp</h2><ul>
<li>首先需要添加依赖，okhttp目前已更新到3.8.1版本，okio会一并获得</li>
</ul>
<pre><code>compile &apos;com.squareup.okhttp3:okhttp:3.8.1&apos;
</code></pre><ul>
<li>jar包可以上okhttp官网下载，需要okhttp和okio两个包</li>
</ul>
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><h4 id="同步"><a href="#同步" class="headerlink" title="- 同步"></a>- 同步</h4><ul>
<li>只要是网络请求，我们就需要在AndroidManifest文件中添加权限，并且开启子线程</li>
<li>同步的意思是一直等待http请求，直到返回了响应</li>
<li>一个类库要完成一次请求需要请求方法, 请求地址, 请求协议, 请求头, 请求体，查看okhttp中Request的类属性，除了协议在Response中以外，其他都能找到</li>
</ul>
<pre><code>public final class Request {
  private final HttpUrl url;
  private final String method;
  private final Headers headers;
  private final RequestBody body;
  private final Object tag;
</code></pre><ul>
<li>get方法比较简单，我们需要一个OkHttpClient的实例和Request对象的实例，使用这两者来构造RealCall对象</li>
<li>RealCall用来发送请求和读取响应，执行execute请求能够得到一个response对象，response.body()返回的ResponseBody对象就是获取的结果</li>
<li>调用ResponseBody我们可以得到想要的数据或数据流，数据流为大文件下载提供了支持，超过1mb的文档不应该使用string方法，它会把文档加入到内存当中，应当使用流来操作</li>
</ul>
<pre><code>new Thread(new Runnable() {
                @Override
                public void run() {
                    try {
                    OkHttpClient okHttpClient = new OkHttpClient();
                    Request request = new Request.Builder().url(&quot;Https://baidu.com&quot;).build();

                        Response response = okHttpClient.newCall(request).execute();
                        Log.d(&quot;MainActivity&quot;,response.body().string());
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }).start();
</code></pre><h4 id="异步"><a href="#异步" class="headerlink" title="- 异步"></a>- 异步</h4><ul>
<li>okhttp支持异步线程，只需要重写传入参数的Callback的两个方法即可，它们分别在请求成功和失败时被调用，回调方法在子线程中调用</li>
</ul>
<pre><code>OkHttpClient okHttpClient = new OkHttpClient();
Request request = new Request.Builder().url(&quot;Https://baidu.com&quot;).build();
okHttpClient.newCall(request).enqueue(new Callback() {
    @Override
    public void onFailure(Call call, IOException e) {

        Log.d(&quot;MainActivity&quot;, &quot;onFailure: &quot;);

    }

    @Override
    public void onResponse(Call call, Response response) throws IOException {

        Log.d(&quot;MainActivity&quot;, response.body().string());
    }

});
</code></pre><h3 id="post"><a href="#post" class="headerlink" title="post"></a>post</h3><ul>
<li>post方法和get类似，只需要调用post方法并传入body参数即可</li>
<li>构建一个body，使用FormBody.Builder，MultipartBody.Builder和使用RequestBody.create()，FormEncodingBuilder已过时，RequestBody.create()可以设定文件的类型，具体的参数在需要时<a href="http://tool.oschina.net/commons/" target="_blank" rel="external">查找</a>即可</li>
</ul>
<pre><code>RequestBody RequestBody = new FormBody.Builder().add(&quot;str&quot;,&quot;1&quot;).build();
RequestBody.create(MediaType.parse(&quot;image/jpeg; charset=utf-8&quot;),new File(path));
</code></pre><h3 id="取消Call"><a href="#取消Call" class="headerlink" title="取消Call"></a>取消Call</h3><ul>
<li>调用Call.cancle()可以取消一个call，不论它是同步还是异步的，也可以使用OkHttpClient.cancel(tag)来取消，tag在RequestBuilder的tag()方法中设置</li>
<li>设置超时响应也可以结束call</li>
</ul>
<pre><code>        OkHttpClient okHttpClient = new OkHttpClient();
new OkHttpClient.Builder()
        .connectTimeout(10, TimeUnit.SECONDS)
        .writeTimeout(10,TimeUnit.SECONDS).build();
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ListView基本用法]]></title>
      <url>/2017/07/12/aboutListView/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><strong>本篇未完</strong></p>
<h2 id="BaseAdapter"><a href="#BaseAdapter" class="headerlink" title="BaseAdapter"></a>BaseAdapter</h2><p><strong>主要学习BaseAdapter的几个方法，ArrayAdapter是BaseAdapter的子类，用法相似</strong></p>
<h3 id="重写方法"><a href="#重写方法" class="headerlink" title="重写方法"></a>重写方法</h3><ul>
<li>BaseAdapter实现了ListAdapter接口，ListAdapter接口继承自Adapter接口，在Adapter中找到getView方法，它需要三个参数，position，view是需要的数据在数据集合中的位置，convertView是旧的View，Adapter会缓存一个刚离开屏幕的View，使用它可以避免反复的查找子View，parent就是使用Adapter的ListView，当然也可能不是ListView，这要看哪个控件使用这个Adapter</li>
</ul>
<pre><code>int position, View convertView, ViewGroup parent
</code></pre><ul>
<li>getItemId，getItem，item指的是数据集合中的每一个元素，ItemId是Item的标记，前者返回position指定的item的id，后者返回position指定Item</li>
</ul>
<ul>
<li>getCount，返回Item的数量，通常为容器的大小</li>
<li>总的来说实现一个adapter的步骤为</li>
</ul>
<pre><code>public class NewsListAdapter extends BaseAdapter {

private int mResourceId;
private BitmapCache mCache;
private Context mContext;
private List mDataList;

public NewsListAdapter(Context context, int resourceId, List&lt;NewsBase&gt; dataList){
mResourceId = resourceId;
mContext = context;
mDataList = dataList;
mCache = new 
    }

@Override
public int getCount() {
return mDataList.size();
}

@Override
public Object getItem(int position) {
return mDataList.get(position);
}

@Override
public long getItemId(int position) {
return position;
}

@Override
public @NonNull View getView(int position,View convertView,@NonNull ViewGroup parent){

View view = null;
ViewHolder viewHolder;
if(convertView == null) {
    view = LayoutInflater.from(getContext()).inflate(mResourceId, parent, false);
    viewHolder = new ViewHolder();
    viewHolder.***View = (***View)view.findViewById(R.id.item_***);
    //通过view.findViewById查找view
    ...         
    view.setTag(viewHolder);

}else {
    view = convertView;
    viewHolder = (ViewHolder)view.getTag();
}

Item item = (Item) getItem(position);
if(item == null)
    return view;

viewHolder.***View.set(item.get***());
//设置界面信息
...


return view;
}

public Context getContext() {
return mContext;
}

private class ViewHolder{

***View  ***View;
//需要缓存的子view引用
...

      }
}
</code></pre><ul>
<li>一般情况下position和itemId可以共用，getItemId返回position即可，getItem返回data.get(position)即可</li>
<li>使用ViewHolder，这样虽然不能保证convertView每次都缓存成功，但能够保证convertView缓存成功时，我们不用通过convertView的findViewById去查找它的子View</li>
</ul>
<h2 id="进一步优化"><a href="#进一步优化" class="headerlink" title="进一步优化"></a>进一步优化</h2><h3 id="LruCache"><a href="#LruCache" class="headerlink" title="- LruCache"></a>- LruCache</h3><ul>
<li>当convertView被用来修改成新view时，旧的数据也就没有了，这时如果用户往回拖动ListView，又得重新加载，可以使用LruCache保留这些数据</li>
<li>LruCache使用泛型，但对于ListView来说通常需要缓存的是Bitmap，下面实现一个LruCache的工具类</li>
</ul>
<pre><code>public class BitmapCache {

public static int MAX_MEMORY = (int)(Runtime.getRuntime().maxMemory()/1024);
private LruCache&lt;String,Bitmap&gt; mCache;

public BitmapCache(int cacheSize){
mCache = new LruCache&lt;String,Bitmap&gt;(cacheSize){
    @Override
    protected int sizeOf(String url,Bitmap bitmap) {
        return bitmap.getByteCount() / 1024;
    }
};
}

/**
 *
 * 该方法用于将图片放入缓存
 * @param url 链接，或其他标识
 * @param bitmap 图片
 *
 */
public void put(String url,Bitmap bitmap){
    mCache.put(url,bitmap);
}

/**
 *
 * 该方法用于将图片从缓存中取出
 * @param url 链接，或其他标识
 * @return 图片，当缓存中没有指定图片时返回null
 *
 */
public Bitmap get(String url){
    return mCache.get(url);
    }
}
</code></pre><ul>
<li>LrCache通常只需要设定类型和缓存大小，这个大小最好不要写入一个常值，而是根据运行时的内存大小来设定</li>
</ul>
<pre><code>public static int MAX_MEMORY = (int)(Runtime.getRuntime().maxMemory()/1024);
</code></pre><h3 id="隐藏滚动条"><a href="#隐藏滚动条" class="headerlink" title="- 隐藏滚动条"></a>- 隐藏滚动条</h3><ul>
<li>ListView默认会有一个比较鸡肋的滚动条，可以在XML中隐藏</li>
</ul>
<pre><code>android:scrollbars=&quot;none&quot;    
</code></pre><h3 id="无数据提示"><a href="#无数据提示" class="headerlink" title="- 无数据提示"></a>- 无数据提示</h3><ul>
<li>ListView提供了一个方法用来在没有数据时提示用户</li>
</ul>
<pre><code>lv.setEmptyView(R.id.empty);
</code></pre><h3 id="滑动监听"><a href="#滑动监听" class="headerlink" title="- 滑动监听"></a>- 滑动监听</h3><h4 id="OnScrollListener"><a href="#OnScrollListener" class="headerlink" title="OnScrollListener"></a>OnScrollListener</h4><ul>
<li>实现 OnScrollListener，在不同的状态下自定义ListView        </li>
</ul>
<pre><code>lv.setOnScrollListener(new AbsListView.OnScrollListener() {
    @Override
    public void onScrollStateChanged(AbsListView view, int scrollState) {
        switch (scrollState){
            case AbsListView.OnScrollListener.SCROLL_STATE_IDLE:
                break;
            case AbsListView.OnScrollListener.SCROLL_STATE_TOUCH_SCROLL:
                break;
            case AbsListView.OnScrollListener.SCROLL_STATE_FLING:
                break;

        }
    }

    @Override
    public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) {

    }
});
</code></pre><h4 id="OnTouchListener"><a href="#OnTouchListener" class="headerlink" title="OnTouchListener"></a>OnTouchListener</h4><ul>
<li>实现 OnTouchListener，在不同的状态下自定义ListView</li>
</ul>
<pre><code>lv.setOnTouchListener(new View.OnTouchListener() {
    @Override
    public boolean onTouch(View v, MotionEvent event) {
        switch (event.getAction()){
            case MotionEvent.ACTION_DOWN:
                break;
            case MotionEvent.ACTION_MOVE:
                break;
            case MotionEvent.ACTION_UP:
                break;
        }
        return false;
    }
});
</code></pre><h3 id="解决乱序"><a href="#解决乱序" class="headerlink" title="- 解决乱序"></a>- 解决乱序</h3><ul>
<li>由于网络请求加载的速度远小于 <a href="#RecycleBin">RecycleBin</a> 返回view的速度，当一个图片没有加载完成就被划出屏幕，这时又开启了新的网络请求，也就是说会有两张图片需要被加载到同一个ImageView中</li>
<li>通常前一个请求会先完成，接着后一个请求得到的bitmap会进行覆盖，加载效果会变得很混乱</li>
<li>如果前一个请求没有及时完成可能导致图片乱序的问题</li>
<li><p>解决方案是在开启网络请求时使用ImageView的setTag方法</p>
<pre><code>image.setTag(url)
</code></pre></li>
<li><p>当我们下载完图片时，先使用url去查找ImageVIew而不是直接将bitmap设置到ImageView上</p>
<pre><code>ImageView imageView = (ImageView) listView.findViewWithTag(imageUrl); 
if(imageView!=null){
    ...
}    
</code></pre></li>
<li><p>当开启第二次请求前原先的url会被覆盖，第一次请求就会得到空值，这样就不会造成混乱了</p>
</li>
</ul>
<h2 id="适配器模式与ListView"><a href="#适配器模式与ListView" class="headerlink" title="适配器模式与ListView"></a>适配器模式与ListView</h2><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="- 适配器模式"></a>- 适配器模式</h3><ul>
<li>适配器模式是指将一个类的接口转换为用户类需要的接口，使得不同结构的对象可以通过适配器为用户提供服务</li>
<li>ListView是一个用户，它调用adapter的目标接口（Target），而这些接口本身是抽象的，实现这些统一的接口使得数据集合与ListView可以通过adapter这个桥梁连接起来，这时我们的数据可以是数组，集合，还可以是游标等，具体是什么数据结构ListView是不会去关心的，因为它获取的是Adapter提供的View</li>
</ul>
<h3 id="RecycleBin机制"><a href="#RecycleBin机制" class="headerlink" title="RecycleBin机制"></a><span id="RecycleBin">RecycleBin机制</span></h3><ul>
<li>ListView还有一个比较特殊的机制，它为Adapter在获取数据的同时还为adapter返回一个数据，convertView</li>
<li>AbsListView中有一个内部类RecycleBin，它使用数组来保存当前使用的所有View，当一个View被滑出屏幕时，它调用addScrapView将这个view从数组中移除并且缓存起来，ListView在调用我们实现的getView方法之前会调用RecycleBin的getScrapView，将获取到的对象（可能为null，可能是重用的View）提供给adapter作为convertView参数</li>
<li>RecycleBin这种循环复用的机制一定程度上避免了OOM</li>
</ul>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ContentProvider基本用法]]></title>
      <url>/2017/07/12/aboutContentProvider/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<h2 id="运行时权限"><a href="#运行时权限" class="headerlink" title="运行时权限"></a>运行时权限</h2><p><strong>每当跨应用传递数据和信息时都要考虑是否需要申请权限，申请权限的授予分两种情况，系统自动授权和运行时授权</strong></p>
<ul>
<li>compileSdk小于23的程序在6.0以上的系统运行，所有的权限只要在XML中注册即可，大于23的版本若需要获取dangerous类型的权限必须动态申请否则程序会崩溃</li>
<li>动态申请的权限也必须在AndroidManifest中注明</li>
<li>获取运行时权限的步骤还是比较简单的，首先使用ContextCompat.checkSelfPermission方法检查是否已被授权，若未授权着调用ActivityCompat.requestPermissions方法申请权限，系统会自动调用onRequestPermissionsResult，在里面写入想要进行的操作即可</li>
</ul>
<pre><code>button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                if(ContextCompat.checkSelfPermission
                (MainActivity.this, Manifest.permission.CALL_PHONE)
                != PackageManager.PERMISSION_GRANTED){

                    ActivityCompat.requestPermissions(MainActivity.this,
                    new String[]{Manifest.permission.CALL_PHONE},1);
                }

                else{
                    call();
                }
            }
        });

    }

    public void call(){
        try{
            Intent intent = new Intent(Intent.ACTION_CALL);
            intent.setData(Uri.parse(&quot;tel:10086&quot;));
            MainActivity.this.startActivity(intent);

        }catch (SecurityException e){
            e.printStackTrace();
        }
    }

@Override
    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults);

        switch (requestCode){
            case 1:
                if (grantResults.length&gt;0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED){
                    call();
                }
        }
    }
}
</code></pre><ul>
<li>经过测试在API 23以下的虚拟机自动获取到了这个权限，ContextCompat.checkSelfPermission 返回 PERMISSION_GRANTED</li>
</ul>
<h2 id="Uri"><a href="#Uri" class="headerlink" title="Uri"></a>Uri</h2><p><strong>HTTP中规定的资源标识符</strong></p>
<ul>
<li>一个Uri由三部分组成，scheme (android中为content://)，主机名或Authority (如com.example.contenttest )，路径 (如/test/20)</li>
</ul>
<pre><code>content://com.example.contenttest/test/20
//test为表名，20位id
//使用*和#通配符匹配任意长度的字符和数字，可得到一个表中的所有数据
</code></pre><ul>
<li>用一个字符串获取Uri，只需调用Uri.parse(“”)方法</li>
</ul>
<h2 id="UriMatcher"><a href="#UriMatcher" class="headerlink" title="UriMatcher"></a>UriMatcher</h2><p><strong>Uri匹配工具</strong></p>
<ul>
<li>向外界共享数据时，首先要考虑什么数据可以共享，什么数据不可以共享，所以第一步需要将可以匹配的Uri进行注册,这里使用了<a href="#初始化块">初始化块</a></li>
</ul>
<pre><code>public class NewsProvider extends ContentProvider {
    public static final int NEWS_ALL = 0;
    public static final int NEWS_ITEM = 1;

    public static final String AUTHORITY = &quot;com.linjiamin.provider&quot;;
    private static UriMatcher uriMatcher;

    static{
        uriMatcher = new UriMatcher(UriMatcher.NO_MATCH);
        uriMatcher.addURI(AUTHORITY,&quot;News&quot;,NEWS_ALL);
        uriMatcher.addURI(AUTHORITY,&quot;News/#&quot;,NEWS_ITEM);
    }
</code></pre><ul>
<li><p>uriMatcher.addURI中的第三个参数是uri匹配时会返回的值，可以用它来标记查询的内容</p>
</li>
<li><p>接着重写几个数据库方法，返回对应的cursor，在switch中我们使用uriMatcher.match(uri)来得到刚刚的NEWS_ALL等标记</p>
</li>
</ul>
<pre><code>@Override
public Cursor query(Uri uri, String[] projection, String selection,
                    String[] selectionArgs, String sortOrder) {
    SQLiteDatabase db = newsDatabaseHelper.getReadableDatabase();
    Cursor cursor =  null;
    switch (uriMatcher.match(uri)){
        case NEWS_ALL:
            cursor = db.query(&quot;news&quot;,new String[]{&quot;id&quot;,&quot;title&quot;,&quot;image_url&quot;,&quot;has_read&quot;,&quot;multipic&quot;},&quot;date=? and from_Home=?&quot;,new String[]{&quot;20170710&quot;,&quot;true&quot;},null,null,null);
            break;
        case NEWS_ITEM:
            String id = uri.getPathSegments().get(1);
            cursor = db.query(&quot;news&quot;,new String[]{&quot;id&quot;,&quot;title&quot;,&quot;image_url&quot;,&quot;has_read&quot;,&quot;multipic&quot;},&quot;id=?&quot;,new String[]{id,&quot;true&quot;},null,null,null);
            break;

        default:
            break;
    }

    return cursor;
}
</code></pre><ul>
<li>CRUD的方法只要使用数据库就可以实现了，除此之外只有一个方法比较特殊，它需要返回MIME类型，MIME Type由媒体类型(type)与子类型(subtype)组成，在intent-filter中添加MIME Type属性可以定义一个Activity可以打开什么类型的文件，provider中自定义MIME Type的规范为  vnd.android.cursor.dir(或item)/vnd.com.linjiamin.provider.news(表名)”</li>
</ul>
<pre><code>@Override
    public String getType(Uri uri) {
        switch(uriMatcher.match(uri)){
            case NEWS_ALL:
                return &quot;vnd.android.cursor.dir/vnd.com.linjiamin.provider.news&quot;;

            case NEWS_ITEM:
                return &quot;vnd.android.cursor.item/vnd.com.linjiamin.provider.news&quot;;

            default:
                break;
        }
</code></pre><ul>
<li><p>接着在另一个应用中获取数据，调用getContentResolver得到cursor</p>
<pre><code>button.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        Uri uri = Uri.parse(&quot;content://com.linjiamin.provider/news&quot;);
        Cursor cursor = getContentResolver().query(uri,null,null,null,null);
        if(cursor!=null){
            cursor.moveToFirst();
            Log.d(&quot;MainActivity&quot;, &quot;onClick: &quot;+cursor.getString(cursor.getColumnIndex(&quot;title&quot;)));
        }
</code></pre></li>
</ul>
<ul>
<li>得到一条新闻标题，可见数据跨应用传输了 </li>
</ul>
<pre><code>MainActivity: onClick: 为什么民航航班会在途中绕圈？
</code></pre><h2 id="初始化块"><a href="#初始化块" class="headerlink" title="初始化块"></a><span id="初始化块">初始化块</span></h2><ul>
<li>在一个类声明中可以包含多个代码块并在其中进行简单的逻辑操作，这些代码块会在构造器运行之前调用，在JDK6之前一个程序甚至可以没有main入口</li>
</ul>
<pre><code>public class Hello{
    static{
        System.out.println(&quot;hello world&quot;);
    }
}
</code></pre><ul>
<li>当一个类的静态域比较复杂，可以使用静态初始化块进行初始化</li>
</ul>
<pre><code>static{

    ...
    ...

}
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[常用布局的使用方法和场景]]></title>
      <url>/2017/07/11/aboutLayout/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<h2 id="使用RelativeLayout减少层级"><a href="#使用RelativeLayout减少层级" class="headerlink" title="使用RelativeLayout减少层级"></a>使用RelativeLayout减少层级</h2><h3 id="层级的影响"><a href="#层级的影响" class="headerlink" title="层级的影响"></a>层级的影响</h3><ul>
<li>要完整地显示一个界面就需要对所有的View进行一次绘制工作，Android通过递归查找View树，而多叉树的层级越深，耗时就越长</li>
<li>布局层次深会增加内存的消耗，甚至会引起栈溢出等问题</li>
<li>RelativeLayout也有性能的问题，它会对子View进行竖直和水平的两次测量，但如果LinearLayout中含有weight属性那么LinearLayout也同样需要进行两次测量</li>
<li>可以在XML界面中的Component Tree或是AS自带的Hierachy View 工具中查看一个界面的层级</li>
</ul>
<h3 id="RelativeLayout替换LinearLayout"><a href="#RelativeLayout替换LinearLayout" class="headerlink" title="- RelativeLayout替换LinearLayout"></a>- RelativeLayout替换LinearLayout</h3><ul>
<li><p>以这个界面为例</p>
<p>  <img src="http://i2.kiimg.com/1949/a4919b1895abe7ea.png" alt=""></p>
</li>
</ul>
<ul>
<li>这是一个评论ListView的Item视图，在一个LinearLayout中嵌套了两个LinearLayout来实现，可能还不算太深</li>
</ul>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout
xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
android:orientation=&quot;vertical&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;wrap_content&quot;
android:background=&quot;#FFFAFA&quot;&gt;

&lt;LinearLayout
    android:orientation=&quot;horizontal&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;&gt;

    &lt;ImageView
        android:id=&quot;@+id/item_iv_avatar&quot;
        android:layout_width=&quot;36dp&quot;
        android:layout_height=&quot;36dp&quot;
        android:layout_marginStart=&quot;4dp&quot;
        android:layout_marginTop=&quot;4dp&quot;
        android:scaleType=&quot;fitXY&quot; /&gt;

    &lt;TextView
        android:id=&quot;@+id/item_tv_author&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:paddingStart=&quot;8dp&quot;
        android:paddingEnd=&quot;8dp&quot;
        android:paddingTop=&quot;8dp&quot;
        android:textSize=&quot;17sp&quot;
        android:textColor=&quot;#303030&quot;/&gt;
    &lt;/LinearLayout&gt;

    &lt;TextView
        android:id=&quot;@+id/item_tv_content&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:paddingStart=&quot;50dp&quot;
        android:paddingEnd=&quot;8dp&quot;
        android:lineSpacingMultiplier=&quot;1.2&quot;
        android:layout_marginBottom=&quot;8dp&quot;
        android:textSize=&quot;16sp&quot;
        android:textColor=&quot;#3B3B3B&quot;/&gt;

    &lt;LinearLayout
        android:orientation=&quot;horizontal&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_marginBottom=&quot;8dp&quot;&gt;

        &lt;TextView
            android:id=&quot;@+id/item_tv_time&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:paddingStart=&quot;50dp&quot;
            android:paddingEnd=&quot;8dp&quot;
            android:layout_marginBottom=&quot;8dp&quot;
            android:textSize=&quot;12sp&quot;
            android:textColor=&quot;#66000000&quot;/&gt;

        &lt;TextView
            android:id=&quot;@+id/item_tv_likes&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;match_parent&quot;
            android:paddingStart=&quot;2dp&quot;
            android:paddingEnd=&quot;2dp&quot;
            android:paddingTop=&quot;8dp&quot;
            android:textSize=&quot;12sp&quot;
            android:textColor=&quot;#AAFF4040&quot;/&gt;
    &lt;/LinearLayout&gt;
</code></pre><p></p>
<ul>
<li>现在尝试使用一层RelativeLayout来实现，只要确定好子View之间的位置关系，使用 android:layout_toRightOf等<a href="http://blog.csdn.net/notenlife/article/details/7256363" target="_blank" rel="external">相对属性</a>很快就能替换</li>
</ul>
<pre><code>    &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
    &lt;RelativeLayout
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:orientation=&quot;vertical&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:background=&quot;#FFFAFA&quot;&gt;


    &lt;ImageView
        android:id=&quot;@+id/item_iv_avatar&quot;
        android:layout_width=&quot;36dp&quot;
        android:layout_height=&quot;36dp&quot;
        android:layout_marginStart=&quot;4dp&quot;
        android:layout_marginTop=&quot;4dp&quot;
        android:scaleType=&quot;fitXY&quot; /&gt;

    &lt;TextView
        android:id=&quot;@+id/item_tv_author&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_toRightOf=&quot;@id/item_iv_avatar&quot;
        android:paddingStart=&quot;8dp&quot;
        android:paddingEnd=&quot;8dp&quot;
        android:paddingTop=&quot;8dp&quot;
        android:textSize=&quot;15sp&quot;
        android:textColor=&quot;#303030&quot;/&gt;


    &lt;TextView
        android:id=&quot;@+id/item_tv_content&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_below=&quot;@id/item_tv_author&quot;
        android:paddingStart=&quot;50dp&quot;
        android:paddingTop=&quot;18dp&quot;
        android:paddingEnd=&quot;8dp&quot;
        android:lineSpacingMultiplier=&quot;1.1&quot;
        android:layout_marginBottom=&quot;8dp&quot;
        android:textSize=&quot;16sp&quot;
        android:textColor=&quot;#3B3B3B&quot;/&gt;

        &lt;TextView
            android:id=&quot;@+id/item_tv_time&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:layout_below=&quot;@id/item_tv_content&quot;
            android:paddingStart=&quot;50dp&quot;
            android:paddingEnd=&quot;8dp&quot;
            android:paddingTop=&quot;8dp&quot;
            android:paddingBottom=&quot;8dp&quot;
            android:textSize=&quot;12sp&quot;
            android:textColor=&quot;#66000000&quot;/&gt;

        &lt;TextView
            android:id=&quot;@+id/item_tv_likes&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;match_parent&quot;
            android:layout_below=&quot;@id/item_tv_content&quot;
            android:layout_toEndOf=&quot;@id/item_tv_time&quot;
            android:paddingStart=&quot;2dp&quot;
            android:paddingEnd=&quot;2dp&quot;
            android:paddingTop=&quot;8dp&quot;
            android:paddingBottom=&quot;8dp&quot;
            android:textSize=&quot;12sp&quot;
            android:textColor=&quot;#AAFF4040&quot;/&gt;

&lt;/RelativeLayout&gt;
</code></pre><ul>
<li>就这两种布局而言，当层级较深时我们可以使用RelativeLayout来优化，层级较浅时则优先使用便捷的LinearLayout</li>
</ul>
<h2 id="其他布局"><a href="#其他布局" class="headerlink" title="其他布局"></a>其他布局</h2><p><strong>RelativeLayout，LinearLayout比较常用，这里主要了解一下其他布局的属性</strong></p>
<h3 id="TableLayout"><a href="#TableLayout" class="headerlink" title="- TableLayout"></a>- TableLayout</h3><p><strong>表格布局，所有子元素以表格的形式摆放</strong></p>
<ul>
<li>android:shrinkColumns，若内容过多，指定的列会收缩，为其他列提供空间</li>
<li>android:stretchColumns，当内容过少，指定的列会伸展，填满多余空间</li>
<li>android:collapseColumns，隐藏指定的列</li>
<li>android:layout_column，设置view的行位置</li>
<li>android:layout_span，设置view的占据的列数(宽度)</li>
</ul>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;TableLayout
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
xmlns:tools=&quot;http://schemas.android.com/tools&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot;
tools:context=&quot;com.linjiamin.layout.MainActivity&quot;
android:stretchColumns=&quot;0&quot;
android:collapseColumns=&quot;1&quot;
android:shrinkColumns =&quot;2&quot;&gt;
&lt;!--使用stretchColumns，第一行被伸展--&gt;
&lt;!--使用collapseColumns，第二行被隐藏--&gt;
&lt;TableRow
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot;&gt;
&lt;TextView
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:textSize=&quot;80sp&quot;
    android:text=&quot;0&quot;/&gt;
&lt;TextView
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:textSize=&quot;80sp&quot;
    android:text=&quot;1&quot; /&gt;
&lt;TextView
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:textSize=&quot;80sp&quot;
    android:text=&quot;2&quot;/&gt;
&lt;TextView
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:textSize=&quot;80sp&quot;
    android:text=&quot;3&quot;/&gt;
&lt;/TableRow&gt;
&lt;TableRow
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot;&gt;
&lt;TextView
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:text=&quot;4&quot;
    android:textSize=&quot;80sp&quot; /&gt;
&lt;/TableRow&gt;
&lt;TableRow
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot;&gt;
&lt;!-- 使用layout_column ，显示在第三格--&gt;
&lt;!-- 使用layout_span ，占据两列--&gt;
&lt;TextView
    android:layout_column =&quot;2&quot;
    android:layout_span=&quot;2&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:text=&quot;5&quot;
    android:textSize=&quot;80sp&quot;
    /&gt;
    &lt;/TableRow&gt;
&lt;/TableLayout&gt;
</code></pre><ul>
<li>显示效果如下</li>
</ul>
<p><img src="http://i1.buimg.com/1949/2fffb0e58fd813b1.png" alt=""></p>
<h3 id="AbsoluteLayout"><a href="#AbsoluteLayout" class="headerlink" title="- AbsoluteLayout"></a>- AbsoluteLayout</h3><p><strong>绝对布局，已淘汰，知道即可</strong></p>
<ul>
<li>写swing的时候曾经使用过这种布局，当时在不同的系统上测试时发现界面会出现一定的差异，不过还挺好用的……</li>
<li>由于手机屏幕的尺寸种类较多，这个布局会对适配造成很大的影响，因此已经被废置了</li>
<li>android:layout_x  指定X坐标</li>
<li>android:layout_y 指定Y坐标</li>
</ul>
<h3 id="GridLayout"><a href="#GridLayout" class="headerlink" title="- GridLayout"></a>- GridLayout</h3><p><strong>网格布局，使用矩阵排列</strong></p>
<ul>
<li>每一个子View都有唯一的坐标，从0开始计数，但大小可以不同</li>
<li>android:columnCount，最大列数</li>
<li>android:rowCount，最大行数</li>
<li>android:useDefaultMargins，使行边距和列边距的大小相同</li>
<li>android:layout_row，子view的行位置</li>
<li>android:layout_column，子view的列位置</li>
<li>android:layout_rowSpan，子view占据的行数</li>
<li>android:layout_columnSpan，子view占据的列数</li>
</ul>
<pre><code>    &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
    &lt;GridLayout
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    tools:context=&quot;com.linjiamin.layout.MainActivity&quot;
    android:columnCount = &quot;4&quot;
    android:useDefaultMargins = &quot;true&quot;&gt;
&lt;!--使用columnCount，最大为4列--&gt;
&lt;!--使用useDefaultMargins，行距和列距相等--&gt;
    &lt;TextView
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:textSize=&quot;80sp&quot;
    android:text=&quot;0&quot;/&gt;

    &lt;!--使用layout_column，显示在第一行地四列--&gt;
    &lt;TextView
    android:layout_column =&quot;3&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:textSize=&quot;80sp&quot;
    android:text=&quot;1&quot;/&gt;
     &lt;!--使用layout_columnSpan，占据两列--&gt;
    &lt;TextView
    android:layout_columnSpan=&quot;2&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:textSize=&quot;80sp&quot;
    android:text=&quot;2&quot;/&gt;
    &lt;!--使用layout_rowSpan，占据两行，所有下方没有数字--&gt;
    &lt;TextView
    android:layout_rowSpan=&quot;2&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:textSize=&quot;80sp&quot;
    android:text=&quot;3&quot;/&gt;

    &lt;TextView
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:textSize=&quot;80sp&quot;
    android:text=&quot;4&quot;/&gt;

    &lt;TextView
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:textSize=&quot;80sp&quot;
    android:text=&quot;5&quot;/&gt;

    &lt;TextView
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:textSize=&quot;80sp&quot;
    android:text=&quot;6&quot;/&gt;

    &lt;TextView
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:textSize=&quot;80sp&quot;
    android:text=&quot;7&quot;/&gt;
    &lt;/GridLayout&gt;
</code></pre><ul>
<li>显示效果如下</li>
</ul>
<p><img src="http://i2.kiimg.com/1949/964a6d449f23347a.png" alt=""></p>
<ul>
<li>Table不能设置Span属性，它的行数和列数不确定，控件不能跨行跨列，实现复杂的界面会比较困难，这种情况下应当使用GridLayout</li>
</ul>
<h3 id="frameLayout"><a href="#frameLayout" class="headerlink" title="- frameLayout"></a>- frameLayout</h3><p><strong>帧布局</strong></p>
<ul>
<li>帧布局是功能最少的布局</li>
<li>帧布局的大小由最大的控件决定，底层的控件会被覆盖</li>
<li>android:foreground，设置前景图像，前景图像永远不会被覆盖</li>
<li>android:foregroundGravity，设置背景图像</li>
<li>当我们需要通过覆盖来实现界面时，就会使用到frameLayout</li>
</ul>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[BroadcastReceiver的使用]]></title>
      <url>/2017/07/11/aboutBroadcast/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p><strong>Intent的四个基本属性包括Action、Data、Category、Extras</strong></p>
<ul>
<li>ACTION是一个字符串，它代表一个动作，可以是创建一个Activity，启动应用，或者用来发送广播等</li>
<li>ACTION值可以自定义，只要Intent-filter中ACTION的值与自定义的相同，Intent就可以被接收</li>
<li>自定义ACTION的规范为 package name + activity name + ACTION，ACTION需要大写并使用下划线隔开</li>
</ul>
<h3 id="发送广播"><a href="#发送广播" class="headerlink" title="发送广播"></a>发送广播</h3><ul>
<li>有序广播与标准广播发送的过程都是类似的，只是最后发送时调用的方法可能不同而已</li>
</ul>
<pre><code>Intent intent = new Intent();
intent.setAction(&quot;com.linjiamin.broadcast.NORMAL&quot;);
intent.putExtra(&quot;key&quot;,&quot;value&quot;);
sendBroadcast(intent);
//sendOrderedBroadcast(intent,null);
//有序广播
//接收至少接收两个参数，一个为intent，另一个为权限，只有持有权限的应用才可以接收
</code></pre><ul>
<li>本地广播的发送方式则有些不同，需要获取localBroadcastManager的实例并调用其方法来发送</li>
</ul>
<pre><code>Intent intent = new Intent(&quot;com.linjiamin.broadcast.NORMAL&quot;);
LocalBroadcastManager localBroadcastManager = LocalBroadcastManager.getInstance(MainActivity.this);
localBroadcastManager.sendBroadcast(intent);
</code></pre><h3 id="注册广播"><a href="#注册广播" class="headerlink" title="注册广播"></a>注册广播</h3><p><strong>注册广播分为两种方式，静态和动态</strong>   </p>
<ul>
<li>静态注册，在新建BroadcastReceiver子类时，AS会自动生成</li>
</ul>
<pre><code>&lt;receiver
    android:name=&quot;.MyReceiver&quot;
    android:enabled=&quot;true&quot;
    android:exported=&quot;true&quot;&gt;
&lt;/receiver&gt; 
</code></pre><ul>
<li>我们只需要添加Intent-filter 属性，通过priority还可以设置优先级，优先级范围在 -1000~1000</li>
</ul>
<pre><code>&lt;receiver
    android:name=&quot;.MyReceiver&quot;
    android:enabled=&quot;true&quot;
    android:exported=&quot;true&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;com.linjiamin.broadcast.NORMAL&quot;/&gt;
    &lt;/intent-filter&gt;

&lt;/receiver&gt;
</code></pre><ul>
<li>动态注册，需要BroadcastReceiver和IntentFilter的实例，并调用注册方法</li>
</ul>
<pre><code> ....

    MyReceiver receiver = new MyReceiver();
    IntentFilter intentFilter = new IntentFilter();

 ....     
   intentFilter.addAction(&quot;com.linjiamin.broadcast.NORMAL&quot;);
    registerReceiver(receiver,intentFilter);

//LocalBroadcastManager localBroadcastManager = LocalBroadcastManager.getInstance(MainActivity.this);
//localBroadcastManager.registerReceiver(receiver,intentFilter);            
//本地广播注册同样要获取LocalBroadcastManager实例
</code></pre><ul>
<li>不要忘记解除注册</li>
</ul>
<pre><code>unregisterReceiver(receiver);
</code></pre><ul>
<li>如果接收的是有序广播，可以选择终止传递</li>
</ul>
<pre><code>    @Override
public void onReceive(Context context, Intent intent) {

    Log.d(&quot;MyReceiver&quot;, &quot;onReceive: receive&quot;);
    abortBroadcast();
}
</code></pre><ul>
<li>注册系统广播的方法是相同的，但有时需要在androidManifest中添加权限</li>
</ul>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;
</code></pre><h2 id="本地广播"><a href="#本地广播" class="headerlink" title="本地广播"></a>本地广播</h2><ul>
<li>本地广播的用法和一般广播类似</li>
<li>本地广播只会在同一个app中传递，不用担心信息泄露而且可以提高效率</li>
</ul>
<h2 id="自定义权限"><a href="#自定义权限" class="headerlink" title="自定义权限"></a>自定义权限</h2><p><strong>在androidManifest中还可以自定义权限，此时除了权限的名称（规范和action基本一致）外，还有一个protectionLevel需要指定</strong></p>
<pre><code>&lt;permission
android:name=&quot;com.linjiamin.permission.TEST&quot;
android:protectionLevel=&quot;normal&quot; /&gt;
</code></pre><ul>
<li>protectionLevel有四个可选值</li>
</ul>
<pre><code>normal：无需用户确认，申请了就可使用
dangerous：用户确认后申请才有效
signature：当使用权限的应用与声明权限的应用打包时签名相同申请才有效
signatureOrSystem：符合上述signature条件或者请求应用为系统应用时申请有效
</code></pre><ul>
<li>申请方法是相同的</li>
</ul>
<pre><code>&lt;uses-permission android:name=&quot;com.linjiamin.permission.TEST&quot;/&gt;
</code></pre><ul>
<li>注册时需要添加权限属性</li>
</ul>
<pre><code>&lt;receiver
    android:name=&quot;.MyReceiver&quot;
    android:enabled=&quot;true&quot;
    android:exported=&quot;true&quot;
    android:permission=&quot;com.linjiamin.permission.TEST&quot;&gt;
    &lt;action android:name=&quot;com.linjiamin.broadcast.TEST&quot;/&gt;
&lt;/receiver&gt;
</code></pre><ul>
<li><p>使用带权限参数的方法发送广播</p>
<pre><code>sendBroadcast(intent,&quot;com.linjiamin.permission.TEST&quot;);
</code></pre></li>
</ul>
<h3 id="onReceive-耗时操作"><a href="#onReceive-耗时操作" class="headerlink" title="onReceive 耗时操作"></a>onReceive 耗时操作</h3><ul>
<li>查看文档我们发现除非使用registerReceiver，onReceive是执行在主线程中的，这意味着一般不能进行耗时操作</li>
</ul>
<pre><code>* This method is always called within the main thread of its process, unless you
* explicitly asked for it to be scheduled on a different thread using
* {@link android.content.Context#registerReceiver(BroadcastReceiver,
* IntentFilter, String, android.os.Handler)}. When it runs on the main
* thread you should
* never perform long-running operations in it (there is a timeout of
* 10 seconds that the system allows before considering the receiver to
* be blocked and a candidate to be killed). You cannot launch a popup dialog
* in your implementation of onReceive().
</code></pre><ul>
<li>那么不妨尝试在onReceive开启一个子线程，同时使用另一个应用发送广播</li>
</ul>
<pre><code>    @Override
    public void onReceive(Context context, Intent intent) {

new Thread(new Runnable() {
    @Override
    public void run() {

        try {
            Thread.sleep(10000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        Log.d(&quot;MyReceiver&quot;, &quot;onReceive: receive&quot;);
    }
}).start();
</code></pre><ul>
<li>当我们设定sleep方法参数为10秒时，我们可以收到日志，设定为1分钟，依然收到了数据，从日志信息可见确实过了1分钟</li>
</ul>
<pre><code>07-13 12:53:35.212 30154-30154/? I/art: Not late-enabling -Xcheck:jni (already on)
07-13 12:53:35.600 30154-30154/com.linjiamin.broadcast W/System: ClassLoader referenced unknown path: /data/app/com.linjiamin.broadcast-1/lib/x86
07-13 12:54:35.618 30154-30169/com.linjiamin.broadcast D/MyReceiver: onReceive: receive
</code></pre><ul>
<li>但是根据网络上的说法，BroadcastReceiver的生命周期很短，onReceive执行完就结束了，这时我们建立的BroadcastReceiver的进程就成了空进程，很容易被杀死，这里可能跟内存占用有关，不管怎样，在onReceive中开启子线程不太可靠，一般来说会使用service进行耗时操作</li>
</ul>
<h3 id="单进程与广播"><a href="#单进程与广播" class="headerlink" title="单进程与广播"></a>单进程与广播</h3><p><a href="http://blog.csdn.net/crazy_yyyyy/article/details/51318092" target="_blank" rel="external">参考</a></p>
<ul>
<li>实践上单进程很少使用本地广播，广播是一种相对耗时，占用空间较多的方式，onReceive方法中可以得到context参数，如果不需要用到相关的方法，就不需要使用广播，可以选择EventBus</li>
</ul>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[实践使用服务]]></title>
      <url>/2017/07/10/aboutService/</url>
      <content type="html"><![CDATA[<p>onCreate</p>
<a id="more"></a>
<p><strong><a href="https://alberthumbert.github.io/2017/07/10/aboutService/">或者看这里</a></strong></p>
<p><strong>主要通过实践对<a href="https://alberthumbert.github.io/2017/04/30/firstCodeLine/#服务的基本用法">Service的内容</a>进行复习</strong></p>
<p><br></p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p><br></p>
<h3 id="startService形式"><a href="#startService形式" class="headerlink" title="startService形式"></a>startService形式</h3><ul>
<li>在Activity中使用 startService来启动服务，必要数据可以通过Intent来传递</li>
</ul>
<pre><code>...

Intent(HomeActivity.this,NewsService.class);

...

vpDownload.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                Intent intent = new 
                intent.putExtra(&quot;date&quot;,GetDate.today());
                startService(intent);
            }
});
</code></pre><ul>
<li>在Service的 onStartCommand中开启线程，注意需要返回父类方法的结果</li>
</ul>
<pre><code>public int onStartCommand(final Intent intent, int flags, int startId) {


new Thread(new Runnable() {
    @Override
    public void run() {
        String date = intent.getStringExtra(&quot;date&quot;);
        if(date == null)return;
        JsonFromUrl jsonFromUrl= new JsonFromUrl();
        jsonFromUrl.setApi(NewsApi.COMMON+NewsApi.BEFORE+date);
        Log.d(TAG, &quot;run: &quot;+NewsApi.COMMON+NewsApi.BEFORE+date);
        JSONObject jsonObject = null;
        try {
            jsonObject = jsonFromUrl.getJson();
            Log.d(TAG, &quot;run: &quot;+jsonObject.toString());
        } catch (IOException | JSONException e) {
            e.printStackTrace();
        }

        List newsList = new ArrayList();
        JsonAnalysis.analyze(newsList,jsonObject,NewsApi.BEFORE,null);
    }
}).start();

return super.onStartCommand(intent, flags, startId);
}
</code></pre><ul>
<li>为避免内存泄漏，必须在内部或外部将service停止</li>
</ul>
<pre><code>//in activity
protected void onStop(){
        super.onStop();
        stopService(intent);
    } 

    //in service
    ...
    stopSelf()
   ...
</code></pre><ul>
<li>注意当一个service被多次执行时请使用 stopSelf(Int startId)方法保证请求被正确终止，    startId由service的onStartCommand参数提供，它标记了请求的编号用以一一对应</li>
</ul>
<p> <br></p>
<h3 id="bindService形式"><a href="#bindService形式" class="headerlink" title="bindService形式"></a>bindService形式</h3><p><strong><br>引入binder机制，实现Activity与service的通信
</strong></p>
<ul>
<li>这次我们使用bindService形式启动</li>
</ul>
<pre><code>vpDownload.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                intent.putExtra(&quot;date&quot;,GetDate.today());
                bindService(intent, HomeActivity.this,Service.BIND_AUTO_CREATE);                
            }
        });
</code></pre><ul>
<li>在service中应当实现一个binder，用以传递service的句柄，如此Activity便可以持有service从而调用service的方法了，这个binder在onBind中被传递</li>
</ul>
<pre><code>@Override
public IBinder onBind(Intent intent) {
    return new Binder();
}

public class Binder extends android.os.Binder{
     public NewsService getService(){
        return NewsService.this;
    }
}
</code></pre><ul>
<li>注意此时，线程应该写在onCreate中，如果不混合使用两种启动方式，此时的onStartCommand是不会被调用的</li>
</ul>
<pre><code>@Override
public void onCreate(){
    super.onCreate();
    //write your THREAD here !!
    Log.d(TAG, &quot;onCreate: &quot;);
}
</code></pre><ul>
<li>返回到Activity中，再实现一个ServiceConnection接口，这个接口只有两个方法必须实现，可以看到service成功进入到了我们的Activity内</li>
</ul>
<pre><code>@Override
public void onServiceConnected(ComponentName name, IBinder service) {
    binder = (NewsService.Binder)service;
    NewsService newsService = binder.getService();
    newsService.showConnection();
}

@Override
public void onServiceDisconnected(ComponentName name) {

} 
</code></pre><ul>
<li><a href="http://blog.csdn.net/u013553529/article/details/54754491?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="external">多次调用bindService()，onBind()只会执行一次</a></li>
</ul>
<p><br></p>
<h2 id="service-生命周期"><a href="#service-生命周期" class="headerlink" title="service 生命周期"></a>service 生命周期</h2><p><br></p>
<h3 id="startService形式-1"><a href="#startService形式-1" class="headerlink" title="startService形式"></a>startService形式</h3><ul>
<li>startService()-&gt;onCreate()-&gt;onStartCommand()-&gt;onDestroy</li>
<li>必须显式关闭service</li>
</ul>
<p><br></p>
<h3 id="bindService形式-1"><a href="#bindService形式-1" class="headerlink" title="bindService形式"></a>bindService形式</h3><ul>
<li>bindService()-&gt;onCreate()-&gt;onBind()-&gt;onUnbind()-&gt;onDestriy</li>
<li>service和所有客户端接触绑定之后才会被系统销毁，因此它的生命周期不用过多关心</li>
</ul>
<p><br></p>
<h2 id="Service的存在意义"><a href="#Service的存在意义" class="headerlink" title="Service的存在意义"></a>Service的存在意义</h2><p><strong>service本身是在主线程运行的，这是就是使用service还需要另外开启子线程的原因，那么为什么还要用到service？</strong></p>
<ul>
<li>service的运行是不依赖UI的，即使活动被销毁，service也可以一直运行</li>
<li>Activity很难对内部创建的子线程进行控制，而service可以和所有Activity进行通信</li>
<li>通过前台service提高优先级，在状态栏可以一直为用户提供功能，这是简单地在Activity中创建一个子线程所办不到的</li>
</ul>
<p><br></p>
<h2 id="前台service使用实例"><a href="#前台service使用实例" class="headerlink" title="前台service使用实例"></a>前台service使用实例</h2><p><strong>前台service和后台Service的使用方法基本与前述的Service基本无异，需要了解的只有Notification和startForeground方法</strong><br><strong>这次通过bindService和startForeground来发送通知</strong></p>
<ul>
<li><p>前面在onServiceConnected中使用binder获取了service的实例，这个时候只要发送通知并调用service的startForeground即可，这一部分写在onCreate也是一样的</p>
<pre><code>//in onServiceConnected
binder = (NewsService.Binder)service;
    final NewsService newsService = binder.getService();
    new Handler().postDelayed(new Runnable() {
        @Override
        public void run() {
            List list= newsService.getNewsList();
            if(list==null)return;
            Notification.Builder builder = new Notification.Builder(HomeActivity.this);
            Intent intent = new Intent(HomeActivity.this,HomeActivity.class);
            builder.setContentIntent(PendingIntent.getActivity(HomeActivity.this,0,intent,0))
                    .setContentTitle(((NewsBase)list.get(1)).getTitle())
                    .setSmallIcon(R.mipmap.news_ic_launcher);
            Notification notification = builder.build();
            newsService.startForeground(1,notification);

        }
    },1000);
</code></pre></li>
</ul>
<ul>
<li>为了使通知能够多次更新，可以考虑使用onStartCommand</li>
<li>Notification<a href="http://blog.csdn.net/zhou452840622/article/details/52028896" target="_blank" rel="external">可设置的属性</a>非常多，它采取了非常典型的构造者模式，内部通过return this实现链式调用</li>
</ul>
<p><br></p>
<h2 id="IntentService使用实例"><a href="#IntentService使用实例" class="headerlink" title="IntentService使用实例"></a>IntentService使用实例</h2><p><strong>当要执行多套后台操作时我们首先使用的是onStartCommand，但是在开启线程和关闭请求时会比较繁琐，而IntentService提供简洁的使用方式</strong></p>
<ul>
<li>IntentService必须要有的方法之有两个，构造器和onHandleIntent</li>
<li>构造器必须调用父类方法</li>
</ul>
<pre><code>public NewsIntentService() {
    super(&quot;NewsIntentService&quot;);
    }

    //查看源码发现super(name)使用它的参数来标记线程的名称，而这个名称只在调试时有用
    //Used to name the worker thread, important only for debugging.
</code></pre><ul>
<li>onHandleIntent()该方法运行于子线程中，所以不用自己开启线程</li>
</ul>
<pre><code>protected void onHandleIntent(@Nullable Intent intent) {

JsonFromUrl jsonFromUrl= new JsonFromUrl();
jsonFromUrl.setApi(NewsApi.COMMON+NewsApi.LATEST);
JSONObject jsonObject = null;
try {
    jsonObject = jsonFromUrl.getJson();
} catch (IOException | JSONException e) {
    e.printStackTrace();
}
setNewsList(JsonAnalysis.analyze(newsList,jsonObject,NewsApi.LATEST,null));
Notification.Builder builder = new Notification.Builder(this);
builder.setContentIntent(PendingIntent.getActivity(this,0,intent,0))
        .setContentTitle(((NewsBase)newsList.get(1)).getTitle())
        .setSmallIcon(R.mipmap.news_ic_launcher);
Notification notification = builder.build();
startForeground(1,notification);
}
</code></pre><ul>
<li>有时我们需要获取数据更新UI，那么只需要将Messenger传递给IntentService即可。现在我们发现，利用binder、handler和broadcastReceiver，信息可以很方便地在Activity和service间传输了</li>
</ul>
<pre><code>Handler handler = new Handler(){

@Override
public void handleMessage(Message msg){

    Bundle bundle = msg.getData();
    String message = bundle.getString(&quot;message&quot;);
    switch(message){
        case &quot;update something&quot;:
        ... 
    }
    return;
}
};

        intent = new Intent(HomeActivity.this,NewsService.class);
intent.putExtra(&quot;messager&quot;,new Messenger(handler));
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Activity 知识补充]]></title>
      <url>/2017/07/10/additionOfActivity/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><strong>参考资料</strong></p>
<p><a href="http://blog.csdn.net/liuhe688/article/details/6733407" target="_blank" rel="external">liuhe688</a></p>
<p><a href="http://blog.csdn.net/weizongwei5/article/details/50515719" target="_blank" rel="external">weizongwei5</a></p>
<p><a href="http://download.csdn.net/detail/jsntghf/9602444" target="_blank" rel="external">Android开发艺术探索</a></p>
<p><strong><br>第一行代码中Activity的内容比较简单，因此额外找了一些内容进一步学习
</strong></p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul>
<li>首先看一下<a href="https://alberthumbert.github.io/2017/04/30/firstCodeLine/#活动生命周期">Android生命周期的普通过程</a>，这一部分应该已经学习过几遍了，不再赘述，通过一个简单的demo进行回顾，稍后修改这个demo并切入主题</li>
</ul>
<pre><code>public class LifeActivity extends AppCompatActivity {

    private static final String TAG = &quot;LifeActivity&quot;;
    @Override
    protected void onCreate(Bundle savedInstanceState){
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_life);
        Log.i(TAG, &quot;onCreate called&quot;);
    }

    @Override
    protected void onStart() {
        super.onStart();
        Log.i(TAG, &quot;onStart called&quot;);
    }

    @Override
    protected void onRestart() {
        super.onRestart();
        Log.i(TAG, &quot;nRestart called&quot;);
    }

    @Override
    protected void onResume() {
        super.onResume();
        Log.i(TAG, &quot;onResume called&quot;);
    }

    @Override
    protected void onPause() {
        super.onPause();
        Log.i(TAG, &quot;onPause called&quot;);
    }

    @Override
    protected void onStop() {
        super.onStop();
        Log.i(TAG, &quot;onStop called&quot;);
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        Log.i(TAG, &quot;onDestroy called&quot;);
    }
}
</code></pre><ul>
<li>启动Activity</li>
</ul>
<pre><code>LifeActivity: onCreate called
LifeActivity: onStart called
LifeActivity: onResume called
</code></pre><ul>
<li>启动另一个Activity，可以看到前一个Activity的onPause执行之后下一个Activity的onCreated才会执行，这就是onPause耗时操作要少的原因，应当考虑能否将这部分操作在onStoped进行</li>
</ul>
<pre><code>LifeActivity: onPause called
AnotherActivity: onCreate called
AnotherActivity: onStart called
AnotherActivity: onResume called
LifeActivity: onStop called
</code></pre><ul>
<li>back键返回LifeActivity，同样前一个Activity的onPause执行后下一个Activity的onRestart才会执行</li>
</ul>
<pre><code>AnotherActivity: onPause called
LifeActivity: onRestart called
LifeActivity: onStart called
AnotherActivity: onStop called
AnotherActivity: onDestroy called
</code></pre><ul>
<li>点击home键</li>
</ul>
<pre><code>LifeActivity: onPause called
LifeActivity: onStop called        
</code></pre><ul>
<li>点击home键后回到应用</li>
</ul>
<pre><code>lifeActivity: oRestart called
ifeActivity: onStart called
LifeActivity: onResume called
</code></pre><p><strong><br>接下来对这些调用方法进行一些奇怪的操作
</strong></p>
<ul>
<li>在onCreate执行之前让Activity结束</li>
</ul>
<pre><code>...
finish();
super.onCreate(savedInstanceState);
...
</code></pre><ul>
<li>输出</li>
</ul>
<pre><code>LifeActivity: onCreate called
LifeActivity: onDestroy called
</code></pre><ul>
<li>很正常，onCreate被完整执行后onDestory()被执行了</li>
</ul>
<ul>
<li>在onStart()中执行finish()，从结果可见没有进入前台期，与onStart对应的onStop被执行了</li>
</ul>
<pre><code>onStart called
onStop called
onDestroy called
</code></pre><ul>
<li>接下来尝试在onRestart()中执行finish()，然后在第二个Activity中按back键。有点奇怪，LifeActivity并不直接执行onStop，而是回到了前台，经历了一个非常完整的生命周期并且在第二个Activity之前被销毁</li>
</ul>
<pre><code>AnotherActivity: onPause called
LifeActivity: onRestart called
LifeActivity: onStart called
LifeActivity: onResume called
LifeActivity: onPause called
LifeActivity: onStop called
LifeActivity: onDestroy called
AnotherActivity: onStop called
AnotherActivity: onDestroy called
</code></pre><ul>
<li>到这里本来想测试一下Activity因内存不足而被销毁会经历什么过程，于是把虚拟机内存调为了128m，但是没能成功实现内存不足的情况…搜索到了使用adb模拟内存不足销毁应用的方法</li>
</ul>
<pre><code>adb shell am kill-all
adb shell am kill package-name 
# 我们关注的应用只有一个，所以这两个命令是一样的
</code></pre><ul>
<li>如无意外，应用会被kill，然而这里出现一个错误导致缓冲区被锁，log无法打印，暂时没有找到解决办法，实在不行以后下载个大点的游戏进行真机调试……</li>
</ul>
<pre><code>E/Surface: getSlotFromBufferLocked: unknown buffer: 0xb40152c0
</code></pre><ul>
<li>另外屏幕旋转会导致Activity被销毁重建，销毁过程为</li>
</ul>
<pre><code>AnotherActivity: onPause called
AnotherActivity: onStop called
AnotherActivity: onDestroy called
</code></pre><h2 id="onWindowFocusChanged"><a href="#onWindowFocusChanged" class="headerlink" title="onWindowFocusChanged"></a>onWindowFocusChanged</h2><p><strong><br>这个方法会在Activity窗口获得或失去焦点被调用，和生命周期方法一样，程序员不应该自己去调用它
</strong></p>
<pre><code>onResume called
onWindowFocusChanged called
</code></pre><ul>
<li>当我们在想在onCreate方法中获取组件大小时，有可能会因为window对象未创建而失败，必须保证在onCreate方法完成之后再执行</li>
<li>重写onWindowFocusChanged方法可以解决这个问题</li>
</ul>
<h2 id="onSaveInstanceState"><a href="#onSaveInstanceState" class="headerlink" title="onSaveInstanceState"></a>onSaveInstanceState</h2><p><strong><br>这是一个为了Activity被调离栈顶时保存数据而存在的方法
</strong></p>
<ul>
<li>被调用的位置，下一个活动进入前台，而之前的活动转为不可见时</li>
</ul>
<pre><code>AnotherActivity: onResume called
LifeActivity: onSaveInstanceState called
LifeActivity: onStop called
</code></pre><ul>
<li>注意一个会被销毁的Activity是不会调用这个方法的，只在可以被返回的Activity中重写它</li>
</ul>
<pre><code>     @Override
    protected void onSaveInstanceState(Bundle outState){
    outState.putInt(&quot;param&quot;,param);
    Log.i(TAG, &quot;onSaveInstanceState called&quot;);
}
</code></pre><h2 id="onRestoreInstanceState"><a href="#onRestoreInstanceState" class="headerlink" title="onRestoreInstanceState"></a>onRestoreInstanceState</h2><p><strong><br>生命周期相关的方法总是两两配对，而onRestoreInstanceState的作用自然是获取保留下来的数据了，不过它的情况有点特殊，只会在Activity在后台被杀死或者屏幕旋转时被调用
</strong></p>
<ul>
<li>同样重写这个方法，以键值对的形式得到数据</li>
</ul>
<pre><code>@Override
    protected void onRestoreInstanceState(Bundle savedInstanceState){
        param = savedInstanceState.getInt(&quot;param&quot;);
        Log.i(TAG, &quot;onRestoreInstanceState called get&quot;+param);
        super.onRestoreInstanceState(savedInstanceState);
    } 
</code></pre><ul>
<li>旋转屏幕并恢复</li>
</ul>
<pre><code>LifeActivity: onCreate called
LifeActivity: onStart called
LifeActivity: onRestoreInstanceState called get 1
LifeActivity: onResume called
LifeActivity: onWindowFocusChanged called 
</code></pre><h2 id="启动模式与Flags"><a href="#启动模式与Flags" class="headerlink" title="启动模式与Flags"></a>启动模式与Flags</h2><p><strong><br>除了<a href="https://alberthumbert.github.io/2017/04/30/firstCodeLine/#四个启动模式">在XML中设置启动模式</a>，<br>下面还有一种设置启动模式的方法
</strong></p>
<ul>
<li>Flags标记位有许多作用，其中一种是设置启动模式</li>
<li>Flags标记位的优先级要大于XML属性，但它无法设置singleInstance模式，使用方式如下</li>
</ul>
<pre><code>public static void actionStart(Context context){

        Intent intent = new Intent(context,FlagActivity.class);
        intent.addFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
        context.startActivity(intent);
    }
</code></pre><ul>
<li>几种常用的Flags</li>
</ul>
<pre><code>FLAG_ACTIVITY_NEW_TASK
//指定singleTask模式

FLAG_ACTIVITY_SINGLE_TOP
//指定singleTop模式

FLAG_ACTIVITY_CLEAR_TOP
//启动时所用该Activity之上的Activity全部出栈，一般与singleTask一起使用
//如果采用standard模式，该Activity与其上的Activity会出栈并建立新的Activity

FLAG_ACTIVITY_FROM_RECENTS
//Activity不出现在历史列表中
</code></pre><ul>
<li><p>我们使用 FLAG_ACTIVITY_NEW_TASK 为例循环启动3个Activity，不在XML中标记，可以看出依然为standard模式</p>
<pre><code>Run #6: ActivityRecord{fd1d8c9 u0 com.linjiamin.myapplication/.NewTaskActivity t138}
 Run #5: ActivityRecord{47b8982 u0 com.linjiamin.myapplication/.NewTaskActivity t138}
 Run #4: ActivityRecord{60095cc u0 com.linjiamin.myapplication/.MainActivity t138}
 Run #3: ActivityRecord{786e788 u0 com.linjiamin.myapplication/.Main2Activity t138}
 Run #2: ActivityRecord{87a03a5 u0 com.linjiamin.myapplication/.Main2Activity t138}
 Run #1: ActivityRecord{9471e17 u0 com.linjiamin.myapplication/.NewTaskActivity t138}
 Run #0: ActivityRecord{49c4ac2 u0 com.linjiamin.myapplication/.MainActivity t138}
</code></pre></li>
<li><p>接着在XML中标记为SingleInstance模式，FLAG依然不起作用，singleTask亦同</p>
<pre><code>   TaskRecord{bfd2cdd #139 A=com.linjiamin.myapplication U=0 sz=5}
  Run #5: ActivityRecord{6fd6eee u0 com.linjiamin.myapplication/.Main2Activity t139}
TaskRecord{98a6f23 #140 A=com.linjiamin.myapplication U=0 sz=1}
  Run #4: ActivityRecord{1d577f4 u0 com.linjiamin.myapplication/.NewTaskActivity t140}
TaskRecord{bfd2cdd #139 A=com.linjiamin.myapplication U=0 sz=5}
  Run #3: ActivityRecord{3ba4af9 u0 com.linjiamin.myapplication/.MainActivity t139}
  Run #2: ActivityRecord{4a4b5bc u0 com.linjiamin.myapplication/.Main2Activity t139}
  Run #1: ActivityRecord{5e70342 u0 com.linjiamin.myapplication/.Main2Activity t139}
  Run #0: ActivityRecord{b3bab83 u0 com.linjiamin.myapplication/.MainActivity t139}
</code></pre></li>
<li><p>查看文档，这个Flag确实用来标记(或者曾经用来标记)singleTask模式，实践发现手动设置Flag已经不起作用，但文档却没有修改，存在一定的误导性</p>
<pre><code>* &lt;p&gt;When using this flag, if a task is already running for the activity
 * you are now starting, then a new activity will not be started; instead,
 * the current task will simply be brought to the front of the screen with
 * the state it was last in.  See {@link #FLAG_ACTIVITY_MULTIPLE_TASK} for a flag
 * to disable this behavior.
</code></pre></li>
</ul>
<h2 id="TaskAffinity"><a href="#TaskAffinity" class="headerlink" title="TaskAffinity"></a>TaskAffinity</h2><p><strong>TaskAffinity，指定了Activity将归属于哪一个任务栈，一般只配合singleTask和singleInstance模式使用</strong></p>
<h3 id="查看和修改任务栈"><a href="#查看和修改任务栈" class="headerlink" title="查看和修改任务栈"></a>查看和修改任务栈</h3><ul>
<li>首先，需要查看Activity任务栈信息的手段，使用adb shell dumpsys activity可以查看所有与Activity相关的信息，但是输出非常冗长，不妨这样</li>
</ul>
<pre><code>adb shell dumpsys activity activities | sed -En -e &apos;/Running activities/,/Run #0/p&apos;
</code></pre><ul>
<li>TaskRecord 信息就是我们需要的，例如 com.linjiamin.lifecycle 就是Task的名字</li>
</ul>
<pre><code>TaskRecord{776e103 #53 A=com.linjiamin.lifecycle U=0 sz=3}
</code></pre><ul>
<li>taskAffinity指定Activity应属于哪一个任务栈，默认情况下它等于包名，这意味着Activity倾向于属于同一个任务，通过XML可以设置这个属性，以singleTask模式为例</li>
</ul>
<pre><code>&lt;activity
    android:name=&quot;.FlagActivity&quot;
    android:launchMode=&quot;singleTask&quot;
    android:taskAffinity=&quot;com.linjiamin.lifecycle.task3&quot;&gt;
    &lt;/activity&gt;
</code></pre><ul>
<li>执行 adb shell dumpsys，可见任务栈的已被修改，task3出现了</li>
</ul>
<pre><code>TaskRecord{1605ccbd #52 A=com.linjiamin.lifecycle.task3 U=0 sz=1}
TaskRecord{2300c203 #51 A=com.linjiamin.lifecycle U=0 sz=2}
</code></pre><h3 id="TaskAffinity与任务栈"><a href="#TaskAffinity与任务栈" class="headerlink" title="TaskAffinity与任务栈"></a>TaskAffinity与任务栈</h3><ul>
<li>启动一个singleTask属性的Activity，系统首先会查找Activity想要的task，若不存在就会创建这个task。而Activity具体需的Task名，默认情况是使用包名，若标记了TaskAffinity就会使用TaskAffinity指定的值</li>
</ul>
<ul>
<li>使用Standard模式启动Activity，会将Activity加入启动它的Activity的任务栈中，除非是用TaskAffinity去标记MainActivity（一般不会这样），否则TaskAffinity和sandard配合时TaskAffinity是没有意义的</li>
</ul>
<pre><code>&lt;activity android:name=&quot;.LifeActivity&quot;
    android:taskAffinity=&quot;com.linjiamin.lifecycle.task1&quot;
    android:launchMode=&quot;standard&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;

        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;

//输出为
 TaskRecord{21a9d665 #57 A=com.linjiamin.lifecycle.task1 U=0 sz=4}
</code></pre><ul>
<li>当使用ApplicationContext去启动standard模式的Activity时，Application根本就没有任务栈，所以这时会报错，为解决这个问题，需要将Activity的FLAG标记为singleTask模式，即</li>
</ul>
<pre><code>FLAG_ACTIVITY_NEW_TASK
</code></pre><ul>
<li>当使用 singleInstance，若实例存在，它的任务栈不会改变，如果实例不存在且栈不存在，则会创建TaskAffinity指定的任务栈和实例</li>
</ul>
<h2 id="使用Bundle传递数据"><a href="#使用Bundle传递数据" class="headerlink" title="使用Bundle传递数据"></a>使用Bundle传递数据</h2><p><strong><br>考虑一种情况，当一个组数据需要在Activity间多次添加、修改、传递，如果<a href="https://alberthumbert.github.io/2017/04/30/firstCodeLine/#使用Intent在活动之间穿梭">只使用Intent</a>是否会相当麻烦？
</strong></p>
<ul>
<li>使用Bundle可以使数据的传输变得简单许多，创建Bundle并调用intent的putExtras(Bundle extras)方法即可</li>
</ul>
<pre><code>        button.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        Bundle bundle = new Bundle();
        bundle.putBoolean(&quot;aBooleanParam&quot;,false);
        bundle.putInt(&quot;anIntParam&quot;,1);
        bundle.putString(&quot;aStringParam&quot;,&quot;2&quot;);
        Intent intent = new Intent(AnotherActivity.this,FlagActivity.class);
        intent.putExtras(bundle);
        startActivity(intent);
    }
});    
</code></pre><ul>
<li>获取数据的方法和intent相同，也可以用putParcelable传递自定义的类型</li>
</ul>
<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_flag);
    Bundle bundle = getIntent().getExtras();
    Log.d(TAG, &quot;onCreate: &quot;+bundle.getBoolean(&quot;aBooleanParam&quot;));
    Log.d(TAG, &quot;onCreate: &quot;+bundle.getInt(&quot;anIntParam&quot;));
    Log.d(TAG, &quot;onCreate: &quot;+bundle.getString(&quot;aStringParam&quot;));
}           
</code></pre>]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Gradle 从入门到......]]></title>
      <url>/2017/07/08/aboutGradle/</url>
      <content type="html"><![CDATA[<p>-</p>
<a id="more"></a>
<p><strong>Gradle是一种依赖管理工具，它使用一种基于jvm的动态语言Groovy</strong></p>
<p><br></p>
<h3 id="Project-和-Task"><a href="#Project-和-Task" class="headerlink" title="Project 和 Task"></a>Project 和 Task</h3><p><strong><br>这是gradle中最基本的概念，其中Project并非Android Studio所指的Project
</strong></p>
<ul>
<li>每一个build.gradle对应一个project，每一个project对应一个相对完整的构建部分，如module</li>
<li>执行build.gradle会为每个Project创建和配置所有task，每一个task对应一个逻辑上的执行单元，task又由一系列的action组成</li>
</ul>
<pre><code>//在最外层的build.gradle中可以看见这样一个task
//它用于删除bulid目录
task clean(type: Delete) {
    delete rootProject.buildDir
}
</code></pre><ul>
<li>为更好地理解task，可以自定义一个task，在任意层级的build.gradle中加入如下代码</li>
</ul>
<pre><code>task hello &lt;&lt; {
    println &apos;hello&apos;
}
</code></pre><p>在终端界面中输入 ./gradlew hello （*nix），gradlew hello（windows，maybe…），会出现</p>
<pre><code>:hello
hello
</code></pre><p>这说明这个任务被成功执行了，由于我没有安装ndk所以还输出了一大堆诸如 NDK is missing a “platforms” directory的提示，另外输出的提示还有</p>
<pre><code>The Task.leftShift(Closure) method has been deprecated and is scheduled to be removed in Gradle 5.0. Please use Task.doLast(Action) instead.
</code></pre><p>leftShift(Closure)？？为什么出现它？？其实 &lt;&lt; 就相当于 leftShift() 方法，它是一个重载，表示添加一个action，并且已经过时了，可以修改为</p>
<pre><code>task hello {  
    doLast {      
        println &apos;hello&apos;      
    }      
}      
</code></pre><p><br>        </p>
<h3 id="gradle-脚本"><a href="#gradle-脚本" class="headerlink" title="gradle 脚本"></a>gradle 脚本</h3><p><strong><br>暂时需要了解的只有build.gradle和setting.gradle
</strong></p>
<p><br></p>
<h4 id="settings-gradle"><a href="#settings-gradle" class="headerlink" title="- settings.gradle"></a>- settings.gradle</h4><ul>
<li>这个文件在初始化时期执行，定义了需要被构建的module</li>
</ul>
<pre><code>include &apos;:app&apos;, &apos;:newsmodule&apos;, &apos;:newslibrary&apos;
</code></pre><ul>
<li>如果只有一个模块，它将会长成下面这样子，而且这个文件可以被删除</li>
</ul>
<pre><code>include &apos;:app&apos;
</code></pre><p><br>        </p>
<h4 id="根目录的build-gradle"><a href="#根目录的build-gradle" class="headerlink" title="- 根目录的build.gradle"></a>- 根目录的build.gradle</h4><pre><code>// Top-level build file where you can add configuration options common to all sub-projects/modules.

buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath &apos;com.android.tools.build:gradle:2.3.1&apos;

        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
}

allprojects {
    repositories {
        jcenter()
    }
}

task clean(type: Delete) {
    delete rootProject.buildDir
}
</code></pre><h5 id="repositorie"><a href="#repositorie" class="headerlink" title="repositorie"></a>repositorie</h5><ul>
<li><a href="#repositories">详见</a></li>
</ul>
<h5 id="buildscript"><a href="#buildscript" class="headerlink" title="buildscript"></a>buildscript</h5><ul>
<li>buildscript，该闭包中是关于gradle的构建工具的配置，dependecbies就是所依赖的构建工具的信息，由于在AS中，所以用到的是Android Gradle plugin</li>
</ul>
<h5 id="allprojects"><a href="#allprojects" class="headerlink" title="allprojects"></a>allprojects</h5><ul>
<li>allprojects，该闭包中是关于所有子项目的配置，这意味着可以直接在里面添加任务</li>
<li>buildscript和allprojects的本质不同在于，buildscript用于配置gradle本身，而allprojects用于配置需要被构建的子项目    <a href="https://stackoverflow.com/questions/30158971/whats-the-difference-between-buildscript-and-allprojects-in-build-gradle" target="_blank" rel="external">difference between buildscript and allprojects</a></li>
</ul>
<p><br></p>
<h4 id="模块内的build-gradle"><a href="#模块内的build-gradle" class="headerlink" title="- 模块内的build.gradle"></a>- 模块内的build.gradle</h4><pre><code>apply plugin: &apos;com.android.application&apos;

android {
    compileSdkVersion 24
    buildToolsVersion &quot;25.0.3&quot;
    defaultConfig {
        applicationId &quot;com.linjiamin.daily_linjiamin&quot;
        minSdkVersion 19
        targetSdkVersion 24
        versionCode 1
        versionName &quot;1.0&quot;
        testInstrumentationRunner         &quot;android.support.test.runner.AndroidJUnitRunner&quot;
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;
        }
    }
}

dependencies {
    compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])
    androidTestCompile(&apos;com.android.support.test.espresso:espresso-core:2.2.2&apos;, {
        exclude group: &apos;com.android.support&apos;, module: &apos;support-annotations&apos;
    })
    compile &apos;com.android.support:appcompat-v7:24.2.1&apos;
    compile &apos;com.android.support.constraint:constraint-layout:1.0.2&apos;

    testCompile &apos;junit:junit:4.12&apos;
}
</code></pre><p><br>        </p>
<h5 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h5><ul>
<li>apply plugin，表示为脚本添加插件，插件包括了已经定义好的属性和task，可以提供扩展功能，如下面的android标签就是Android application所插件提供，只有添加了它才能使用</li>
</ul>
<p><br></p>
<h5 id="compileSdkVersion"><a href="#compileSdkVersion" class="headerlink" title="compileSdkVersion"></a>compileSdkVersion</h5><ul>
<li>编译时使用的API版本</li>
</ul>
<p><br></p>
<h5 id="buildToolsVersion"><a href="#buildToolsVersion" class="headerlink" title="buildToolsVersion"></a>buildToolsVersion</h5><ul>
<li>构建工具的版本号，构建工具包括了一系列的命令</li>
</ul>
<p><br></p>
<h5 id="defaultConfig"><a href="#defaultConfig" class="headerlink" title="defaultConfig"></a>defaultConfig</h5><ul>
<li>关于app的属性配置，它将重写AndroidManifest.xml</li>
</ul>
<p><br></p>
<h5 id="applicationId"><a href="#applicationId" class="headerlink" title="applicationId"></a>applicationId</h5><ul>
<li>用于标识不同的app版本，不直接使用包名划分是因为包名会用于命名R文件，如果创建新版本时还需要修改R文件那将十分麻烦 </li>
</ul>
<p><br></p>
<h5 id="versionCode"><a href="#versionCode" class="headerlink" title="versionCode"></a>versionCode</h5><ul>
<li>versionCode 和 versionName 用于标识app版本，程序本身不会在任何地方调用到这个值，在开发过程中versionCode往往会变化非常快，会成为一个很大的值，这对用户来说不便，于是就产生了versionName这一字符串标识</li>
</ul>
<p><br></p>
<h5 id="buildTypes"><a href="#buildTypes" class="headerlink" title="buildTypes"></a>buildTypes</h5><ul>
<li>设置构建版本和混淆文件</li>
</ul>
<p><br></p>
<h5 id="dependencies"><a href="#dependencies" class="headerlink" title="dependencies"></a>dependencies</h5><ul>
<li><a href="#dependencies">详见</a></li>
</ul>
<p><br></p>
<h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p><strong><br>当项目需要用到其他开发者的依赖库时，我们不需要手动下载jar包so包到指定位置，更不需要未版本的迭代而操心，gradle已经解决了这些问题
</strong></p>
<p><br></p>
<h4 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a><span id="repositories">仓库</span></h4><ul>
<li>repositories，远程仓库，它是依赖包的来源，Android Studio默认为jcenter，也可以为maven，Ivy等</li>
<li>当执行build构建时依赖包会从这些远程仓库里下载并在本地留下缓存</li>
<li>Gradle默认使用三个maven仓库，mavenCrentral，jcenter，mavenLocal，有些依赖包并不在其中，这时只需</li>
</ul>
<pre><code>repositories {
       maven {
           url &quot;.....&quot;//填写maven仓库地址
       }
}
</code></pre><p><br></p>
<h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a><span id="dependencies">依赖</span></h4><ul>
<li>完整的依赖包含三个元素，group，通常为包名，name，library的唯一标识，version，版本号，通常写法为</li>
</ul>
<pre><code>dependencies {
       compile &apos;com.google.code.gson:gson:2.7&apos;
}
</code></pre><ul>
<li>也可以这样展开</li>
</ul>
<pre><code>dependencies {
  compile group: &apos;com.google.code.gson&apos;, name: &apos;gson&apos;, version:&apos;2.7&apos;
 }
</code></pre><ul>
<li>为避免键入错误，还可以在File-&gt;Project Structure-Dependencies 中联网查找并导入</li>
</ul>
<p><br></p>
<h4 id="本地依赖"><a href="#本地依赖" class="headerlink" title="本地依赖"></a>本地依赖</h4><p><br></p>
<h4 id="导入jar包"><a href="#导入jar包" class="headerlink" title="- 导入jar包"></a>- 导入jar包</h4><ul>
<li>在一个app的build.gradle中我们可以找到如下配置</li>
</ul>
<pre><code>compile fileTree(include: [&apos;*.jar&apos;], dir: &apos;libs&apos;)
</code></pre><ul>
<li>这意味着需要使用本地jar包时只要将其放入模块的libs文件即可</li>
</ul>
<p><br></p>
<h4 id="导入aar包"><a href="#导入aar包" class="headerlink" title="- 导入aar包"></a>- 导入aar包</h4><ul>
<li>添加文件夹 </li>
</ul>
<pre><code>repositories {
    flatDir {
    dirs &apos;aarlibs&apos;
}
</code></pre><ul>
<li>添加依赖</li>
</ul>
<pre><code>compile(name:&apos;aarlibrary&apos;, ext:&apos;aar&apos;)  
</code></pre><p><br></p>
<h4 id="导入so包"><a href="#导入so包" class="headerlink" title="- 导入so包"></a>- 导入so包</h4><ul>
<li>指定文件夹位置，将so包放入文件夹中即可</li>
</ul>
<pre><code>sourceSets {
    main {
        jniLibs.srcDirs = [&apos;src/main/LibsName&apos;]
    }
}
</code></pre><ul>
<li>Android Studio 默认 src/main/jniLibs 放置so包，这意味着可以直接新建一个jniLibs文件夹而不需要进行任何配置</li>
</ul>
<p><br></p>
<h4 id="使用模块"><a href="#使用模块" class="headerlink" title="- 使用模块"></a>- 使用模块</h4><ul>
<li>创建一个模块作为依赖包(library)时，Android Studio会自动在它的build.gradle配置对应的插件</li>
</ul>
<pre><code>apply plugin: &apos;com.android.library&apos;
</code></pre><ul>
<li>并且会在setting.gradle添加模块</li>
</ul>
<pre><code>include &apos;:app&apos;, &apos;:mylibrary&apos;
</code></pre><ul>
<li>所有只需要在调用到该模块的app的build.module中添加依赖即可，同样可以在File-&gt;Project Structure-Dependencies中导入</li>
</ul>
<pre><code> dependencies {
     compile project(&apos;:mylibrary&apos;)
}        
</code></pre><h4 id="其他配置"><a href="#其他配置" class="headerlink" title="- 其他配置"></a>- 其他配置</h4><ul>
<li>build.gradle中还能看到</li>
</ul>
<pre><code>testCompile &apos;junit:junit:4.12&apos;
androidTestCompile(&apos;com.android.support.test.espresso:espresso-core:2.2.2&apos;, {
        exclude group: &apos;com.android.support&apos;, module: &apos;support-annotations&apos;
    })            
</code></pre><ul>
<li>依赖本身有五种配置，compile只是默认的一个，其他可能用到的一般只有提供单元测试的testCompile和androidTestCompile，有空再来学习</li>
</ul>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Studio 基本操作]]></title>
      <url>/2017/07/05/ASShortcut/</url>
      <content type="html"><![CDATA[<p>还有这种操作？</p>
<a id="more"></a>
<p><br></p>
<h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><p><strong><br>Android Studio提供了大量的默认快捷键，当然用户也可以自定义快捷键。<br>Preference-&gt;keymap中可查看所有快键键，右键选择Add Keyboard shortcut 或 Add Mouse Shortcut 可自定义快捷键，<br>注意有些快捷键在特定的情况下才会触发。<br>浏览 Tip of the day 弹窗的每日介绍，是熟悉上手这些快捷键的好方法。
</strong></p>
<ul>
<li><strong>Cmd + “-“/“+”</strong> (mac)，<strong>Ctrl + Shift + “+”/”-“</strong> (win) ，展开或者以更简洁的方式显示代码</li>
<li><strong>Cmd + F</strong>(mac)，<strong>Ctrl + F</strong>(win)，快速查找，在对应的窗口中进行模糊查找</li>
<li><strong>Cmd + B</strong>(mac)，<strong>Ctrl + B</strong>(win)，查看类文件或方法的内容或变量被使用的地方</li>
<li><strong>Cmd + P</strong>(mac)，<strong>Ctrl + P</strong>(win)，查看方法所需变量类型</li>
<li><strong>Cmd + D</strong>(mac)，<strong>Ctrl + D</strong>(win)，复制并粘贴选中内容或当前光标所在行</li>
<li><strong>Cmd + N</strong>(mac)，<strong>Alt＋Insert</strong>(win)，添加构造器，getter，setter等</li>
<li><strong>Cmd + O</strong>(mac)，<strong>Ctrl + N</strong>(win)，快速打开类</li>
<li><strong>Cmd + /</strong>(mac)，<strong>Ctrl + /</strong>(win)，将当前行改为注释</li>
<li><strong>Cmd + F12</strong>(mac)，<strong>Ctrl + F12</strong>(win)，显示当前类结构</li>
<li><strong>Cmd + Shift + /</strong>(mac)，<strong>Ctrl + Shift + /</strong>(win)，添加注释，mac可能会同时触发Help-&gt;search的快捷键，建议在Keymap中修改</li>
<li><strong>Cmd + W</strong>(mac)，关闭当前窗口</li>
<li><strong>Cmd + Q</strong>(mac)，退出Android studio</li>
<li><strong>Alt +↑↓← →</strong>，快速 选择块/移动光标</li>
<li><strong>Ctrl + O / I</strong>，显示所有可 重写/实现 的方法，选中后输入模板</li>
<li><strong>Shift + F1</strong>，打开光标所在元素的网页文档，<strong>然而你可能被墙了</strong></li>
<li><strong>Ctrl + ~</strong>，更改显示选项</li>
</ul>
<p><br></p>
<h2 id="实用功能"><a href="#实用功能" class="headerlink" title="实用功能"></a>实用功能</h2><p><br></p>
<h3 id="书签"><a href="#书签" class="headerlink" title="- 书签"></a>- 书签</h3><p><strong><br>书签为代码位置提供一个标记。<br>在 Navigate-&gt;bookmark 中可对书签进行相应管理。
</strong></p>
<ul>
<li><strong>F3</strong> (mac)，<strong>F11</strong> (win)，添加/删除 书签</li>
<li><strong>Alt + F3</strong> (mac)，<strong>Ctrl + F11</strong> (win)，添加/删除 带有名称的书签</li>
<li><strong>Cmd + F3</strong> (mac) ，<strong>Shift + F11</strong> (win)，查看和管理所有标签</li>
<li><strong>Ctrl + NAME</strong>，当书签带有名称，可使用该操作进行快速跳转</li>
</ul>
<p><br></p>
<h3 id="版本控制"><a href="#版本控制" class="headerlink" title="- 版本控制"></a>- 版本控制</h3><p><strong><br>VCS-&gt;git 中可以实现常用git命令的功能，Android Stuido 还提供了图形化的比较工具
</strong></p>
<ul>
<li><strong>Ctrl + V</strong>(mac)，<strong>Alt + `</strong>(win)，弹出版本控制菜单</li>
<li>git-&gt;Compare With Branch，比较当前文件与分支中的修改</li>
<li>Version Control-&gt;Log，显示git log –graph日志</li>
</ul>
<p><br></p>
<h3 id="正则表达式检查工具"><a href="#正则表达式检查工具" class="headerlink" title="- 正则表达式检查工具"></a>- 正则表达式检查工具</h3><p><strong><br>将普通正则转化为Java中的正则表达式，并提供用实例检查的功能
</strong></p>
<ul>
<li><strong>Alt + Enter</strong>，需要在matches(“”)的双引号中才会触发</li>
<li>Sample 中输入例子进行检查</li>
</ul>
<p><br></p>
<h3 id="模板"><a href="#模板" class="headerlink" title="- 模板"></a>- 模板</h3><p><strong><br>模板，Live Template，是一种输入特定字符并利用编译器自动补全的方法
</strong></p>
<ul>
<li><strong>Cmd + J</strong>(mac)，<strong>Ctrl + J</strong>(win)，列出所有模板，这意味着并不需要记住所有匹配字符</li>
<li>Preference &gt; Editor &gt; Live Templates 可自定义模板，注意使用$符号将变量名包围</li>
<li>File and Code Template 中还可以自定义文件创建时自动添加的模板，Android Studio 中类开头的文档注释就是这么生成的</li>
</ul>
<p><br></p>
<h2 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h2><ul>
<li>preference-&gt;plugins中可以在线下载插件，下载完后点击重启AS即可，十分方便</li>
<li><a href="http://www.open-open.com/lib/view/open1480329318348.html" target="_blank" rel="external">插件能够提供的功能非常丰富</a></li>
<li><a href="http://blog.csdn.net/lmj623565791/article/details/51548272" target="_blank" rel="external">通过编写jar程序也可以实现简单的插件</a></li>
</ul>
<p><br></p>
<h2 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h2><p><strong><br>Android Studio中的Project-Module关系相当于，Eclipse中的Workplace-Project，VS中的解决方法-工程。
</strong><br><br></p>
<h3 id="创建Module"><a href="#创建Module" class="headerlink" title="创建Module"></a>创建Module</h3><ul>
<li>File-&gt;new-&gt;new module中可选择新建或导入不同类型的module</li>
<li>Phone &amp; Table Module，Android Module，Android TV module，Google Cloud Module，分别对应不同平台上的程序</li>
<li>Android Library，Java Library，分别生成aar和jar文件作为依赖库</li>
<li>每个module作为一个独立的程序可以单独运行和调试</li>
<li>原则上Android Library可以当做Java Library来使用，区别在于aar可以携带文件，调用android API<br><a href="https://stackoverflow.com/questions/28154681/android-studio-java-library-module-vs-android-library-module" target="_blank" rel="external">Difference between Android library and Java library</a></li>
</ul>
<p><br></p>
<h3 id="调用Module"><a href="#调用Module" class="headerlink" title="- 调用Module"></a>- 调用Module</h3><ul>
<li><a href="https://alberthumbert.github.io/2017/07/08/aboutGradle/">详见</a></li>
</ul>
<p><br></p>
<h2 id="性能分析工具"><a href="#性能分析工具" class="headerlink" title="性能分析工具"></a>性能分析工具</h2><p><br></p>
<h3 id="Profile-GPU-Rendering"><a href="#Profile-GPU-Rendering" class="headerlink" title="Profile GPU Rendering"></a>Profile GPU Rendering</h3><p><strong><br>当一个view被绘制，主要经过三个过程，GPU准备数据，GPU从缓存列表获取数据，Display设备绘制，这三个过程的耗时可通过 Profile GPU Rendering 查看
</strong></p>
<ul>
<li>在开发者选项中找到 Profile GPU Rendering 开关（或者叫GPU呈现模式分析），打开后可以看见一系列彩色柱状图</li>
<li>红，黄，蓝，紫分别对应每一帧在不同阶段的耗时情况</li>
<li>蓝 ,表示创建Display List所花费的时间，具体来说就是执行onDraw方法的时间，当蓝色的线很高时可能需要考虑优化onDraw方法</li>
<li>红，表示2D渲染Display List所消耗的时间，过高时可能是重新提交视图所致</li>
<li>黄，CPU告诉GPU进行绘制每一帧会后会等待GPU的回复，如果柱状图过高，表示GUP繁忙</li>
<li>紫，资源转移到渲染线程的时间</li>
</ul>
<p><br></p>
<h3 id="Trace-View"><a href="#Trace-View" class="headerlink" title="Trace View"></a>Trace View</h3><p><strong><br>Profile GPU Rendering提供的信息非常模糊，无法满足优化代码的需求，Trace View 可以分析到具体每一个方法的耗时
</strong></p>
<p><br></p>
<h4 id="获取-Trace-文件"><a href="#获取-Trace-文件" class="headerlink" title="- 获取 Trace 文件"></a>- 获取 Trace 文件</h4><ul>
<li>调试应用</li>
<li>打开DDMS</li>
<li>点击Strarted Method Profiling</li>
<li>操作应用后点击Stop Method Profiling会跳出一个非常丑的界面，它就是Trace View分析视图</li>
</ul>
<p><br></p>
<h4 id="TraceView-视图"><a href="#TraceView-视图" class="headerlink" title="- TraceView 视图"></a>- TraceView 视图</h4><ul>
<li>Timeline Panel 面板，X轴表示时间，Y轴表示不同的线程</li>
<li>Profile Panel 面板，主要关注Calls+Recur Calls / Total 和CPU time / call，表示调用次数和耗时</li>
</ul>
<p><br></p>
<h3 id="SYStrace-UI"><a href="#SYStrace-UI" class="headerlink" title="SYStrace UI"></a>SYStrace UI</h3><ul>
<li>打开DDMS，点击 SYStrace按钮（capture system wide…）</li>
<li>配置信息后生成Trace文件，用Chrome打开（只能用chrome），这个更丑的界面就是SYStrace UI类</li>
<li>Alert界面，标记了有问题的地方并提供了描述</li>
<li>点击 F字母标记的圆，当显示为红色或黄色时表示渲染耗时过长，达不到60fps，查看提示以及系统正在进行的任务以分析问题</li>
</ul>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[pro git 1-6章 笔记]]></title>
      <url>/2017/05/22/proGit/</url>
      <content type="html"><![CDATA[<p>onCreate</p>
<a id="more"></a>
<h2 id="第一章-起步"><a href="#第一章-起步" class="headerlink" title="第一章 起步"></a>第一章 起步</h2><hr>
<p><strong>    略    </strong></p>
<p><br></p>
<h2 id="第二章-Git-基础"><a href="#第二章-Git-基础" class="headerlink" title="第二章 Git 基础"></a>第二章 Git 基础</h2><hr>
<p><br></p>
<h3 id="获取git仓库"><a href="#获取git仓库" class="headerlink" title="获取git仓库"></a>获取git仓库</h3><hr>
<p><br></p>
<h4 id="git-init-初始化仓库"><a href="#git-init-初始化仓库" class="headerlink" title="git init - 初始化仓库"></a>git init - 初始化仓库</h4><p><strong>创建.git目录</strong></p>
<ul>
<li>.git，包含一个git仓库中所有必须的文件，这即是说当要清除版本控制时只需要执行：</li>
</ul>
<pre><code>$ rm -rf .git
</code></pre><ul>
<li>init 参数只会执行初始化操作，所以还需要对现有文件进行选择性的跟踪和提交：</li>
</ul>
<pre><code>$ git add *.c
$ git add LICENSE
$ git commit -m &apos;initial project version&apos;
</code></pre><ul>
<li>init执行后 .git 中至少包含：</li>
</ul>
<pre><code>refs/
# 指向commit的指针，即commit的SHA-1值

HEAD
# 指示目前被检出的分支
# 内容形如： ref: refs/heads/master

config
# 包含配置信息
# 内容形如：
# repositoryformatversion = 0
# filemode = true 
# ...

description
# 仅供 GitWeb 程序使用，无需关心

hooks/
# 目录包含客户端或服务端的钩子脚本

info/
# 包含一个名为exclude的全局性排除文件
# 可以追加不希望被记录在.gitignore的排除内容，如：
# *.[oa] 
# *~
# 在这里添加的排除信息不会提交到仓库，也就不会影响到别人

objects/
# 储存版本控制的所有数据
</code></pre><p><br>             </p>
<h4 id="git-clone-url-克隆现有仓库"><a href="#git-clone-url-克隆现有仓库" class="headerlink" title="git clone [url] - 克隆现有仓库"></a>git clone [url] - 克隆现有仓库</h4><p><strong>拉取仓库中每个文件的每个版本</strong></p>
<ul>
<li>clone会创建.git文件夹将所有数据放入在内并读取最新版本的文件</li>
<li>url支持多种协议格式，如https协议，git协议，ssh协议</li>
<li>clone会自动添加远程仓库并以origin为简写</li>
<li>clone会自动设置本地master分支跟踪克隆的远程仓库的master分支（默认分支）</li>
</ul>
<p><br></p>
<h3 id="记录每次更新到仓库"><a href="#记录每次更新到仓库" class="headerlink" title="记录每次更新到仓库"></a>记录每次更新到仓库</h3><hr>
<p><br></p>
<h4 id="git-status-检查当前文件状态"><a href="#git-status-检查当前文件状态" class="headerlink" title="git status - 检查当前文件状态"></a>git status - 检查当前文件状态</h4><ul>
<li>文件根据是否纳入版本控制存在两种状态，已跟踪和未跟踪</li>
<li>已跟踪文件分为三种状态，未修改，已修改，已暂存</li>
<li>Changes not staged for commit 下的文件属于已修改状态</li>
<li>Changes to be committed 下的文件处于已暂存状态</li>
<li>使用参数 -s 可得到简略输出</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">？？  # 未跟踪文件</div><div class="line">A    # 新添加到暂存区的文件</div><div class="line"> M   # 修改后未暂存</div><div class="line">M    # 修改后已暂存</div><div class="line">MM   # 修改暂存后又修改</div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="git-add-flie-跟踪与暂存文件"><a href="#git-add-flie-跟踪与暂存文件" class="headerlink" title="git add [flie] - 跟踪与暂存文件"></a>git add [flie] - 跟踪与暂存文件</h4><ul>
<li>git 不会自动跟踪之前提交中没有的文件</li>
<li>add 使用文件或目录为参数，如果参数是路径，将递归地跟踪或暂存该目录下的所有文件</li>
<li>add 只会暂存当前时刻的版本，再次修改需重新暂存</li>
</ul>
<p><br></p>
<h4 id="gitignore-忽略文件"><a href="#gitignore-忽略文件" class="headerlink" title=".gitignore - 忽略文件"></a>.gitignore - 忽略文件</h4><ul>
<li>日志文件，编译临时文件等不需要纳入版本控制，可在.gitignore中添加排除信息</li>
<li>数十种语言的 gitignore文件 <a href="https://github.com/github/gitignore" target="_blank" rel="external">https://github.com/github/gitignore</a></li>
<li>格式规范</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#   开头，被忽略，通常用于注释</div><div class="line">/   开头，防止递归，只忽略当前目录所匹配的文件</div><div class="line">/   结尾，指定目录</div><div class="line">!   开头，取反</div><div class="line">*   任意匹配0或多个字符</div><div class="line">?   任意匹配一个字符</div><div class="line">[ ] 任意匹配括号中的一个字符  </div><div class="line">**  任意匹配中间目录</div></pre></td></tr></table></figure>
<ul>
<li>下面是一个java项目可用的文件：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"># Compiled class file</div><div class="line">*.class</div><div class="line"></div><div class="line"># Log file</div><div class="line">*.log</div><div class="line"></div><div class="line"># BlueJ files</div><div class="line">*.ctxt</div><div class="line"></div><div class="line"># Mobile Tools for Java (J2ME)</div><div class="line">.mtj.tmp/</div><div class="line"></div><div class="line"># Package Files #</div><div class="line">*.jar</div><div class="line">*.war</div><div class="line">*.ear</div><div class="line">*.zip</div><div class="line">*.tar.gz</div><div class="line">*.rar</div><div class="line"></div><div class="line"># virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xml</div><div class="line">hs_err_pid*</div></pre></td></tr></table></figure>
<p><br>        </p>
<h4 id="git-diff-查看修改"><a href="#git-diff-查看修改" class="headerlink" title="git diff - 查看修改"></a>git diff - 查看修改</h4><p><strong>显示修改的具体信息</strong> </p>
<ul>
<li>git diff 只显示尚未暂存的改动，而不是上次提交以来的所有改动</li>
<li>git diff –staged 只显示已暂存的改动</li>
</ul>
<p><br></p>
<h4 id="git-commit-提交更新"><a href="#git-commit-提交更新" class="headerlink" title="git commit - 提交更新"></a>git commit - 提交更新</h4><ul>
<li>每次提交前应先用git status查看是否有文件未暂存</li>
<li>git commit 默认启动shell环境变量 $EDITOR所指定的编辑器</li>
<li>在编辑器中，所有注释将会在生成提交时被移除，而提交信息会保留</li>
<li>git commit -m “[description]” 允许在命令中添加提交信息</li>
<li>git commit -a 允许跳过暂存操作，所有跟踪过的文件会被一并提交</li>
</ul>
<p><br></p>
<h4 id="git-rm-file-移除文件"><a href="#git-rm-file-移除文件" class="headerlink" title="git rm [file] - 移除文件"></a>git rm [file] - 移除文件</h4><ul>
<li>rm 参数只对已跟踪的文件起作用</li>
<li>git rm 会将文件从将暂存区和工作目录中删除</li>
<li>git rm -f 删除修改过并且已放到暂存区的文件</li>
<li>git rm –cached 只将文件从暂存区中移除，文件会恢复为未跟踪状态，不会被删除，因此可能需要手动添加到.gitignore</li>
</ul>
<p><br></p>
<h3 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h3><hr>
<p><br></p>
<h4 id="git-log-查看提交历史"><a href="#git-log-查看提交历史" class="headerlink" title="git log - 查看提交历史"></a>git log - 查看提交历史</h4><ul>
<li>git log 会按时间由后到前列出所有更新信息</li>
<li>git log -p 附带每次提交内容的差异</li>
<li>git log –stat 附带被修改文件的名称、数量和修改类型</li>
<li>git log –pretty=format 使用占位符修改输出信息</li>
<li>git log –graph 附带描述分支合并历史的图表</li>
</ul>
<p><br></p>
<h3 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h3><hr>
<p><br></p>
<h4 id="git-commit-–amend-修改提交"><a href="#git-commit-–amend-修改提交" class="headerlink" title="git commit –amend -修改提交"></a>git commit –amend -修改提交</h4><ul>
<li>git commit –amend 会将暂存中的文件与上一次提交合并，可以用来补充遗漏</li>
<li>amend选项覆盖的提交是可恢复的，详见数据恢复章节</li>
</ul>
<p><br></p>
<h4 id="git-reset-取消暂存的文件"><a href="#git-reset-取消暂存的文件" class="headerlink" title="git reset - 取消暂存的文件"></a>git reset - 取消暂存的文件</h4><ul>
<li>git reset HEAD [file] 可以将文件修改为未暂存状态</li>
<li>reset 和 rm –cached 的区别：reset不会使文件变为未跟踪状态 </li>
<li><a href="https://stackoverflow.com/questions/17122480/difference-between-git-rm-cached-and-git-reset-head" target="_blank" rel="external">https://stackoverflow.com/questions/17122480/difference-between-git-rm-cached-and-git-reset-head</a></li>
</ul>
<p><br></p>
<h4 id="git-checkout-–-file-撤销修改"><a href="#git-checkout-–-file-撤销修改" class="headerlink" title="git checkout – [file] - 撤销修改"></a>git checkout – [file] - 撤销修改</h4><ul>
<li>git checkout – [file] 会将文件还原为上次提交时的内容</li>
<li>这是一个危险的命令，它造成的效果是不可逆的</li>
</ul>
<p><br></p>
<h3 id="远程仓库的使用"><a href="#远程仓库的使用" class="headerlink" title="远程仓库的使用"></a>远程仓库的使用</h3><hr>
<p><br></p>
<h4 id="git-remote-查看远程仓库"><a href="#git-remote-查看远程仓库" class="headerlink" title="git remote - 查看远程仓库"></a>git remote - 查看远程仓库</h4><ul>
<li>git remote 会显示远程仓库列表，如果已经克隆了仓库，那么至少可以看到 origin</li>
<li>git remote 会显示读写远程仓库使用的简写与其对应的URL</li>
<li>git remote show [remote-name] 会显示一个远程仓库的更多信息</li>
</ul>
<p><br></p>
<h4 id="git-remote-add-添加远程仓库"><a href="#git-remote-add-添加远程仓库" class="headerlink" title="git remote add - 添加远程仓库"></a>git remote add - 添加远程仓库</h4><ul>
<li>git remote add [shortname] [url] 添加一个新的远程Git仓库，同时指定一个可以引用的简写</li>
<li>git remote rename [oldname] [newname] 可以修改远程仓库的简写</li>
<li>git remote rm [remote-name] 将会移除一个远程仓库</li>
</ul>
<p><br></p>
<h4 id="git-fetch-从远程仓库中抓取与拉取"><a href="#git-fetch-从远程仓库中抓取与拉取" class="headerlink" title="git fetch - 从远程仓库中抓取与拉取"></a>git fetch - 从远程仓库中抓取与拉取</h4><ul>
<li>git fetch [remote-name] 会拉取远程仓库中的所有分支和数据</li>
<li>git fetch origin 会抓取克隆或上一次抓取后推送的所有工作</li>
<li>git fetch 不会自动合并和修改当前的工作，必须手动合并</li>
</ul>
<p><br></p>
<h4 id="git-push-推送到远程仓库"><a href="#git-push-推送到远程仓库" class="headerlink" title="git push - 推送到远程仓库"></a>git push - 推送到远程仓库</h4><ul>
<li>git push [remote-name][branch-name]，只有拥有所克隆服务器的写入权限并且之前没有人推送过时，命令才会生效</li>
<li>当他人先将数据推送到上游时命令会被拒绝，必须先将他人的工作拉取并合并后才能推送</li>
<li>git push origin [tagname]，push不会将标签推送到服务器上，在创建完标签后必须显式地推送</li>
<li>git push origin –tags ，推送所有标签</li>
</ul>
<p><br></p>
<h3 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h3><hr>
<p><br></p>
<h4 id="git-tag-列出标签"><a href="#git-tag-列出标签" class="headerlink" title="git tag - 列出标签"></a>git tag - 列出标签</h4><ul>
<li>git tag 会以字母顺序列出标签</li>
<li>可以用特定的模式查找标签，如</li>
</ul>
<pre><code>git tag -l &apos; v1.* &apos;
</code></pre><p><br></p>
<h4 id="git-tag-a-创建标签"><a href="#git-tag-a-创建标签" class="headerlink" title="git tag -a 创建标签"></a>git tag -a 创建标签</h4><ul>
<li>git tag -a (v1.0) -m ‘my version 1.0’ ，为最新的提交打上附注标签，若无 -m参数，编辑器会被打开</li>
<li>git tag -a v1.0 9fceb02，为指定提交打标签，需要在末尾指定提交的校验和</li>
<li>git tag (v1.0)  ,为最新的提交打上轻量标签</li>
<li>附注标签是Git数据库中的一个完整对象，可以被校验，包含多种信息</li>
<li>轻量标签是一个特定提交的引用，类似分支，只是将校验和存储到一个文件里而已</li>
</ul>
<p><br></p>
<h3 id="git别名"><a href="#git别名" class="headerlink" title="git别名"></a>git别名</h3><p><strong> 略 </strong></p>
<p><br></p>
<h2 id="第三章-Git-分支"><a href="#第三章-Git-分支" class="headerlink" title="第三章 Git 分支"></a>第三章 Git 分支</h2><hr>
<p><strong>分支，一个包含对象校验和（长度为40的SHA-1值字符串）的文件</strong></p>
<p><br></p>
<h3 id="commit-object-提交对象"><a href="#commit-object-提交对象" class="headerlink" title="commit object - 提交对象"></a>commit object - 提交对象</h3><ul>
<li>git保存的不是文件的变化和差异，而是不同时刻的文件快照</li>
<li>除首次提交外，每次提交产生的提交对象都有父对象，多分支合并产生的提交有多个父对象，构成提交对象的树（图）结构</li>
<li>git仓库至少有三种对象，包括 blob对象（保存文件快照），树对象（记录目录结构和blob对象索引）以及提交对象（包含指向树对象的指针和所有提交信息）</li>
<li>git init默认创建的分支名是master，master不是一个特殊的分支，它和其他分支相比没有任何本质区别</li>
<li><strong>git分支本质上只是指向提交对象的可变指针</strong></li>
</ul>
<p><br></p>
<h3 id="使用分支"><a href="#使用分支" class="headerlink" title="使用分支"></a>使用分支</h3><hr>
<p><br></p>
<h4 id="git-branch-分支创建"><a href="#git-branch-分支创建" class="headerlink" title="git branch - 分支创建"></a>git branch - 分支创建</h4><ul>
<li>git branch [branchname]，会创建一个新的分支</li>
<li>创建新分支实际上只是在当前提交对象上创建了一个可移动的新指针</li>
<li>HEAD指针，这是一个特殊指针，永远指向当前分支</li>
<li>git branch 只会创建分支并不会自动切换到新分支</li>
<li>git checkout -b [branchname]，会创建一个新分支并切换到这个新分支上</li>
<li>git branch -d [branchname]，会删除一个分支，当分支已被合并时理应进行删除操作</li>
<li>git branch -D [branchname]，会强制删除一个分支</li>
<li>git log –oneline –decorate 可以显示各个分支当前指向的提交对象</li>
<li>git log –oneline –decorate –graph –all 可以显示提交历史、各分支的指向以及项目的分支分叉情况</li>
</ul>
<p><br></p>
<h4 id="git-checkout-分支切换"><a href="#git-checkout-分支切换" class="headerlink" title="git checkout - 分支切换"></a>git checkout - 分支切换</h4><ul>
<li>git checkout [branchname] ，会将HEAD切换到新分支，即更换当前分支</li>
<li>提交更新时只有head指向的分支会向前移动，其他分支则依然停留在原先的版本</li>
<li>git checkout [branchname] 本质上做了两件事，将head指向另外的分支，将工作目录恢复为该分支所指向的快照内容</li>
</ul>
<p><br></p>
<h4 id="git-merge-合并分支"><a href="#git-merge-合并分支" class="headerlink" title="git merge - 合并分支"></a>git merge - 合并分支</h4><ul>
<li>git merge [branchname] 会将当前分支与指定分支合并</li>
<li>fast-forward 模式，两个分支是直接的上下游关系，合并分支只会简单地将指针向前推进</li>
<li>两个不同的分支对同一个文件的同一个部分进行了不同的修改时，git不会提交合并，需要手动解决冲突</li>
<li>git branch –merged，可以查看已合并的分支，通常这些分支可以删除</li>
<li>git branch –no-merged，可以查看未合并的分支</li>
<li>产生冲突时使用git status查看包含冲突而未合并的文件，解决后使用git add将文件标价为冲突已解决</li>
</ul>
<p><br></p>
<h3 id="分支开发工作流"><a href="#分支开发工作流" class="headerlink" title="分支开发工作流"></a>分支开发工作流</h3><hr>
<p><strong> 略 </strong></p>
<p><br></p>
<h3 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h3><hr>
<p><br></p>
<h4 id="远程引用"><a href="#远程引用" class="headerlink" title="远程引用"></a>远程引用</h4><ul>
<li>远程引用是对远程仓库的引用（指针），包括分支、标签等</li>
<li>git ls-remote [remotename]，会显示远程引用的完整列表</li>
</ul>
<p><br></p>
<h4 id="远程跟踪分支"><a href="#远程跟踪分支" class="headerlink" title="远程跟踪分支"></a>远程跟踪分支</h4><ul>
<li>远程跟踪分支，以[remote] / [branch] 形式命名，是不能手动移动的本地引用，当进行网络通信操作时会自动移动</li>
<li>远程跟踪分支类似上次连接到远程仓库时的书签</li>
<li>当使用git clone时，git会自动将远程仓库命名为origin并创建一个名为origin/master的远程分支，同时还会创建一个相同的本地master分支</li>
<li>origin无特殊含义，和其他所有远程仓库引用是一致的，如果喜欢可以使用 git clone -o [name] 来自己命名</li>
<li>git remote add [shortname] [url] ，会添加一个新的远程仓库引用到当前项目</li>
</ul>
<p><br></p>
<h4 id="git-fetch-更新远程仓库引用"><a href="#git-fetch-更新远程仓库引用" class="headerlink" title="git fetch - 更新远程仓库引用"></a>git fetch - 更新远程仓库引用</h4><p><strong>以origin为例</strong></p>
<ul>
<li>只要不与服务器连接，origin/master就不会移动</li>
<li>git fetch origin ， 将会查找origin指代的服务器，抓取本地没有的数据并更新本地数据库，移动origin/master指针</li>
</ul>
<p><br></p>
<h4 id="git-push-推送"><a href="#git-push-推送" class="headerlink" title="git push - 推送"></a>git push - 推送</h4><ul>
<li>想要公开分享一个分支时，需要将其推送到有写入权限的远程仓库上</li>
<li>git push [remote][branch]，可以更新远程分支</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># 例：</div><div class="line">$ git push origin serverfix</div><div class="line"># git 会自动将serverfix展开为refs/heads/serverfix:refs/heads/serverfix</div><div class="line"># 这意味着本地serverfix会更新远程仓库的serverfix分支</div><div class="line"># 它相当于 git push serverfix:serverfix</div><div class="line"># 详见 Git内部原理 章节</div></pre></td></tr></table></figure>
<ul>
<li>抓取远程分支时不会自动形成可编辑的副本拷贝，被抓取的[remote][branch] 只有不可修改的指针，需要使用 git merge [remote][branch] 将这个分支合并到当前分支</li>
<li>git push [remote] –delete [branchname] 可以在服务器上删除远程分支</li>
</ul>
<p><br></p>
<h4 id="本地跟踪分支"><a href="#本地跟踪分支" class="headerlink" title="本地跟踪分支"></a>本地跟踪分支</h4><p><strong>注：书中使用远程跟踪分支和跟踪分支这两个概念，为了避免混淆这里将跟踪分支叫做本地跟踪分支，举例来说两者间的区别就是 origin/master和master的区别</strong></p>
<ul>
<li>从远程跟踪分支检出一个本地分支会自动创建一个本地跟踪分支，在本地跟踪分支上使用git pull 还会自动识别需要抓取合并的分支</li>
<li>克隆一个仓库时，会自动创建一个跟踪origin/master分支的本地master分支</li>
<li>git checkout -b [branch] [remotename]/[branch]，将创建一个本地跟踪分支</li>
<li>git checkout –track [remotename]/[branch] 为简写</li>
<li>git branch -u [remotename]/[branchname]，可以初始化或修改当前分支跟踪的远程分支，-u全写为 –set-upstream-to</li>
<li>git branch -vv，查看所有的本地跟踪分支</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">例：</div><div class="line">$git branch -vv</div><div class="line">* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it</div><div class="line"># 当前分支为 serverfix</div><div class="line"># 跟踪的分支为 teamone/server-fix-good</div><div class="line"># 本地有三次提交未上传合并，服务器上有一次提交未拉取合并</div></pre></td></tr></table></figure>
<ul>
<li>可以使用@{upstream}或@{u}快捷方式来引用当前分支跟踪的远程分支</li>
</ul>
<p><strong>值得一提的是在远程分支上进行git pull时git会声称当前不在一条分支上面，大概upstream和branch是两个不同的概念</strong></p>
<p><br></p>
<h4 id="git-pull-拉取分支"><a href="#git-pull-拉取分支" class="headerlink" title="git pull -拉取分支"></a>git pull -拉取分支</h4><ul>
<li>git pull 大多数情况下的含义是git fetch 后紧跟一个git merge</li>
<li>git pull 容易让人困惑，通常单独显式地使用fetch 和 merge 会更好</li>
</ul>
<p><br></p>
<h3 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h3><hr>
<p><strong>gayhub的由来(才怪)</strong></p>
<p><strong>不常用，仅作了解</strong><br><br></p>
<h4 id="git-rebase-变基的基本操作"><a href="#git-rebase-变基的基本操作" class="headerlink" title="git rebase - 变基的基本操作"></a>git rebase - 变基的基本操作</h4><ul>
<li>merge 被称为三方合并，它选取两个分支的最新快照与两者最近的共同祖先合并形成一个新的快照</li>
<li>rebese 命令将提交到某一分支上的修改移到另一分支上，它造成的结果和merge是一样的，但提交历史会是更加简洁的一条直线</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">列：</div><div class="line">$ git checkout experiment</div><div class="line">$ git rebase master</div><div class="line"># 此时当前maser所在位置相当于experiment的直接上游</div><div class="line">$ git checkout experiment</div><div class="line">$ git rebase master</div><div class="line"># 将experiment的修改在master上重演，相当于fast-forward模式</div></pre></td></tr></table></figure>
<p><br>        </p>
<h4 id="非目标分支上的重演"><a href="#非目标分支上的重演" class="headerlink" title="非目标分支上的重演"></a>非目标分支上的重演</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git rebase --onto master server client</div><div class="line"># 意思是取出client分支，找出client分支和server分支的共同祖先后的修改，让他们在master分支上重演一遍</div></pre></td></tr></table></figure>
<p><br></p>
<font size="5">第四、五章中关于服务器上git仓库的内容全部跳过</font>

<p><br></p>
<h2 id="第四章-服务器上的git"><a href="#第四章-服务器上的git" class="headerlink" title="第四章 服务器上的git"></a>第四章 服务器上的git</h2><hr>
<p><strong>略</strong></p>
<p><br></p>
<h2 id="第五章-分布式git"><a href="#第五章-分布式git" class="headerlink" title="第五章 分布式git"></a>第五章 分布式git</h2><hr>
<p><strong>成为合格的贡献者和整合者</strong></p>
<p><br></p>
<h3 id="分布式工作流程"><a href="#分布式工作流程" class="headerlink" title="分布式工作流程"></a>分布式工作流程</h3><hr>
<p><br></p>
<h4 id="集中式工作流"><a href="#集中式工作流" class="headerlink" title="- 集中式工作流"></a>- 集中式工作流</h4><p><strong>开发团队常用模式</strong></p>
<ul>
<li>以接受代码的仓库为中心，若干开发者为节点将工作与仓库同步</li>
<li>若有两个开发者从中心仓库克隆代码并修改，只有第一个开发者可以顺利地把数据推送回共享服务器，第二个开发者必须先将第一个人的工作合并，这样才不会覆盖第一个人的修改</li>
</ul>
<p><br></p>
<h4 id="集成管理者工作流"><a href="#集成管理者工作流" class="headerlink" title="- 集成管理者工作流"></a>- 集成管理者工作流</h4><p><strong>Github常用模式</strong></p>
<ul>
<li>每个开发者拥有自己仓库的读写权限和其他所有人的读取权限，为代表官方项目的权威仓库贡献</li>
<li><p>维护者将开发者的仓库作为远程仓库添加，在本地测试变更，将其合并进入官方仓库</p>
<pre><code>例：

1. 项目维护者推送到主仓库
2. 贡献者克隆此仓库，做出修改
3. 贡献者将数据推送到自己的公开仓库
4. 贡献者给维护者发送邮件，请求拉取自己的更新
5. 维护者在自己的本地仓库中，将贡献者的仓库加为远程仓库合并修改
6. 维护者将合并后的修改推送到主仓库
</code></pre></li>
</ul>
<p><br></p>
<h4 id="提交准则"><a href="#提交准则" class="headerlink" title="- 提交准则"></a>- 提交准则</h4><p><strong>写好 Git Commit 信息的 7 个建议：<a href="http://blog.jobbole.com/92713/" target="_blank" rel="external">http://blog.jobbole.com/92713/</a></strong></p>
<ul>
<li>git diff –check，显示空白错误，空白错误指文件中的tab等字符，这些字符也会被视为修改内容，不应将这些修改提交</li>
<li>让每一个提交成为一个逻辑上的独立变更，即不要尝试一次解决多个问题然后上传一个巨大的提交</li>
<li>提交信息，应当少于50个字符（25个汉字）的单行开始且简要地描述变更，接着是一个空白行，再接着是一个更加详细的解释（每行小于72字符）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#################################################</div><div class="line"></div><div class="line">	修改的摘要（50个字符或更少）</div><div class="line">	# 首字母大写，若只需要这一行，可以直接使用-m参数</div><div class="line">		</div><div class="line">	关于修改的更多解释（每行小于72字符）</div><div class="line">	# 使用空行分隔段落，可以使用 - 符号开头，注意git不会自动换行</div><div class="line">		</div><div class="line">##################################################</div><div class="line">		</div><div class="line">列：</div><div class="line">		</div><div class="line">commit eb0b56b19017ab5c16c745e6da39c53126924ed6</div><div class="line">Author: Pieter Wuille &lt;pieter.wuille@gmail.com&gt;</div><div class="line">Date:   Fri Aug 1 22:57:55 2014 +0200</div><div class="line">		</div><div class="line"> Simplify serialize.h&apos;s exception handling</div><div class="line"> </div><div class="line"> Remove the &apos;state&apos; and &apos;exceptmask&apos; from serialize.h&apos;s stream</div><div class="line"> implementations, as well as related methods.</div><div class="line"> </div><div class="line"> As exceptmask always included &apos;failbit&apos;, and setstate was always</div><div class="line"> called with bits = failbit, all it did was immediately raise an</div><div class="line"> exception. Get rid of those variables, and replace the setstate</div><div class="line"> with direct exception throwing (which also removes some dead code).</div><div class="line"> </div><div class="line"> As a result, good() is never reached after a failure (there are</div><div class="line"> only 2 calls, one of which is in tests), and can just be replaced</div><div class="line"> by !eof().</div><div class="line"> </div><div class="line"> fail(), clear(n) and exceptions() are just never called. Delete them.</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="第六章-GitHub"><a href="#第六章-GitHub" class="headerlink" title="第六章 GitHub"></a>第六章 GitHub</h2><hr>
<p><strong>暂略</strong></p>
<p><br></p>
<h2 id="第七章-Git-工具"><a href="#第七章-Git-工具" class="headerlink" title="第七章 Git 工具"></a>第七章 Git 工具</h2><hr>
<p><br>     </p>
<h3 id="引用技巧"><a href="#引用技巧" class="headerlink" title="引用技巧"></a>引用技巧</h3><hr>
<p><br>     </p>
<h4 id="简短的SHA-1"><a href="#简短的SHA-1" class="headerlink" title="- 简短的SHA-1"></a>- 简短的SHA-1</h4><ul>
<li>可以使用开头的几个字符（不少于4个）代替完整SHA-1</li>
<li>git log –abbrev-commit，会显示简短且唯一的值，默认7个字符，如果有冲突会增加字符</li>
</ul>
<p><br>     </p>
<h4 id="分支引用"><a href="#分支引用" class="headerlink" title="- 分支引用"></a>- 分支引用</h4><ul>
<li>指明一个提交最直接的方法是有一个指向它的分支引用，可以用分支引用代替SHA-1</li>
<li>git rev-parse [branchname]，显示分支指代的SHA-1</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git rev-parse master</div><div class="line">		  </div><div class="line">25303d395e6075d5d627a79ce914ad0fb47f352c</div></pre></td></tr></table></figure>
<p><br>    </p>
<h4 id="git-reflog-引用日志"><a href="#git-reflog-引用日志" class="headerlink" title="git reflog - 引用日志"></a>git reflog - 引用日志</h4><ul>
<li>git会在后台保存一个引用日志（reflog）记录进几个月HEAD和分支引用指向的历史</li>
<li>每当HEAD所指向的位置发生了变化，git就会将信息存储到引用日志里</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ git reflog</div><div class="line"></div><div class="line">25303d3 HEAD@&#123;0&#125;: commit: Fix image source database</div><div class="line">367fcf7 HEAD@&#123;1&#125;: checkout: moving from 367fcf7d44af7e90ad2e8505cf3e4aa5b69d401d to master</div><div class="line">367fcf7 HEAD@&#123;2&#125;: checkout: moving from master to origin/master</div><div class="line">367fcf7 HEAD@&#123;3&#125;: pull: Fast-forward</div><div class="line">b7c7faa HEAD@&#123;4&#125;: commit: Add README</div><div class="line">77e24b9 HEAD@&#123;5&#125;: commit (initial): First commit</div></pre></td></tr></table></figure>
<ul>
<li><p>可以使用@{n} 来引用reflog中输出的提交记录</p>
<pre><code>$ git show HEAD@{5}
</code></pre></li>
<li><p>也可以查看某个分支在特定时间前的位置</p>
<pre><code>$ git show master@{yesterday}
</code></pre></li>
</ul>
<p><br>        </p>
<h4 id="祖先引用"><a href="#祖先引用" class="headerlink" title="^~ - 祖先引用"></a>^~ - 祖先引用</h4><ul>
<li>祖先引用符号 ^ 会被解析为它前面的引用的上一个版本，HEAD^、d9219970^等写法都是合理的</li>
<li>祖先引用符号 ~ 一般和 ^ 是等价的，唯一的区别在于，~后的数字为倒退的次数，^后的数字为父提交的序号（只有存在多个父提交时才能这么使用），即 ~3 等价于 ^^^，而 ^2 相当于父提交中被合并的次级分支</li>
</ul>
<pre><code>例：
   $ git show HEAD^^^
</code></pre><h4 id="…-提交区间"><a href="#…-提交区间" class="headerlink" title="^… - 提交区间"></a>^… - 提交区间</h4><ul>
<li>双点符号 .. ，用于列出在一个分支而不在另一个分支的提交</li>
</ul>
<pre><code>例：
$ git log master..experiment
  D
  C
</code></pre><ul>
<li>双点常被用来查看即将推送的内容</li>
</ul>
<pre><code>$ git log origin/master..HEAD

# 等价于

$ git log origin/master..

# HEAD可以省略
</code></pre><ul>
<li>多点符号^，用于列出不被包含在其中的提交</li>
</ul>
<pre><code>$ git log refA..refB

# 等价于

$ git log ^refA refB

# 等价于

$ git log refB --not refA
</code></pre><ul>
<li>多点符号存在的意义在于它可以查询两个以上的引用</li>
</ul>
<pre><code>$ git log refA refB --not refC
</code></pre><ul>
<li>三点符号 … ，用于列出被两个引用中的一个包含但又不被两者同时包含的提交</li>
</ul>
<pre><code>$ git log master...experiment
  F
  E
  D
C

# EF只在master分支上，CD只在experiment分支上        # 等价于


$ git log --left-right master...experiment 
&lt;F
&lt;E
&gt;D
&gt;C
</code></pre><h3 id="交互式暂存"><a href="#交互式暂存" class="headerlink" title="交互式暂存"></a>交互式暂存</h3><p><strong>略</strong></p>
<h3 id="git-stash-储藏与清理"><a href="#git-stash-储藏与清理" class="headerlink" title="git stash 储藏与清理"></a>git stash 储藏与清理</h3><h4 id="储藏工作"><a href="#储藏工作" class="headerlink" title="- 储藏工作"></a>- 储藏工作</h4><ul>
<li></li>
</ul>
]]></content>
      
        <categories>
            
            <category> dairy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 群英传 笔记]]></title>
      <url>/2017/05/20/AndroidHeros/</url>
      <content type="html"><![CDATA[<p>onStop</p>
<a id="more"></a>
<p><br></p>
<h2 id="第三章-控件架构与自定义控件"><a href="#第三章-控件架构与自定义控件" class="headerlink" title="第三章 控件架构与自定义控件"></a>第三章 控件架构与自定义控件</h2><hr>
<p><br></p>
<h3 id="Android-控件架构"><a href="#Android-控件架构" class="headerlink" title="Android 控件架构"></a>Android 控件架构</h3><hr>
<p><br></p>
<h4 id="控件"><a href="#控件" class="headerlink" title="控件"></a>控件</h4><ul>
<li>Android的每个控件都会在界面中获得一块矩形的区域</li>
<li>控件分为两类，View控件和ViewGroup控件</li>
<li>ViewGroup以包含多个View的方式令所有控件形成一个树形结构，上层控件负责处理下层子控件的测量与绘制并传递交互事件</li>
<li>findViewById以深度优先遍历来查找对应元素</li>
</ul>
<p><br></p>
<h4 id="视图架构"><a href="#视图架构" class="headerlink" title="视图架构"></a>视图架构</h4><ul>
<li>Window，每个Activity都包含一个Window负责控制视图，通常由PhoneWindow来实现，它包含一个封装了窗口操作方法的DectorView来作为整个应用的顶级视图</li>
<li>DectorView，包含一个ContentRoot为唯一子视图，一般为竖直的LinearLayout，上面是标题栏TitleView（可设置），下面是内容栏ContentView</li>
<li>ContentView，id为content的FrameLayout，是所有传入的view的父布局，因此也被命名为ContentParen</li>
<li>所有View的监听事件都通过WindowManagerService来接收并回调Activity的 * Listener来处理<br><br></li>
</ul>
<h3 id="View的测量"><a href="#View的测量" class="headerlink" title="View的测量"></a>View的测量</h3><p><strong>——系统在绘制View前必须在onMeasure( ) 中对View进行测量</strong></p>
<hr>
<p><br> </p>
<h4 id="三种测量模式"><a href="#三种测量模式" class="headerlink" title="三种测量模式"></a>三种测量模式</h4><ul>
<li><p>EXACTLY，指定数值的精确模式，如</p>
<pre><code>android:layout_width=&quot;100dp&quot;
android:layout_width=&quot;match_parent&quot;
</code></pre></li>
<li><p>AT_MOST</p>
</li>
<li>UNSPECIFIED</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 安卓 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[第一行代码 笔记]]></title>
      <url>/2017/04/30/firstCodeLine/</url>
      <content type="html"><![CDATA[<p>onRestart</p>
<a id="more"></a>
<h2 id="第一章-开始启程"><a href="#第一章-开始启程" class="headerlink" title="第一章 开始启程"></a>第一章 开始启程</h2><p><br></p>
<h3 id="Android-系统架构"><a href="#Android-系统架构" class="headerlink" title="Android 系统架构"></a>Android 系统架构</h3><hr>
<ul>
<li>Linux 内核层，为各种硬件提供底层驱动，如显示驱动，音频驱动，电源管理等</li>
<li>系统运行库层，包括提供主要特性支持的C/C++库，如SQLite库、Webkit库等，以及系统运行时库（提供java语言支持的核心库、Dalvik虚拟机）</li>
<li>应用框架层，提供构建各种应用可能用到的API</li>
<li>应用层，所有安装的应用都在这一层<br><br></li>
</ul>
<h3 id="项目中的资源"><a href="#项目中的资源" class="headerlink" title="项目中的资源"></a>项目中的资源</h3><hr>
<p><br></p>
<h4 id="资源文件夹"><a href="#资源文件夹" class="headerlink" title="- 资源文件夹"></a>- 资源文件夹</h4><ul>
<li>drawable，放置图片</li>
<li>mipmap，放置应用图标</li>
<li>value，放置字符串，样式，颜色等配置</li>
<li>layout，放置布局文件<br><br></li>
</ul>
<h4 id="资源使用方式"><a href="#资源使用方式" class="headerlink" title="- 资源使用方式"></a>- 资源使用方式</h4><ul>
<li>在代码中，形如 R.string.app_name</li>
<li>在xml中，形如 @string/app_name</li>
<li>同一xml文件不应该出现同名id，最好的做法是避免所有重名的情况</li>
</ul>
<pre><code>&lt;application
    android : allowBackup=&quot;true&quot;
    android : icon=&quot;@mipmap/ic_launcher&quot;
    android : laybel=&quot;@string/app_name&quot;
    android : supportsRtl=&quot;true&quot;
    android : theme=&quot;@style/AppTheme&quot;
    ...
&lt;/application&gt;
</code></pre><ul>
<li>关于各引用写法的含义以及区别，参考：<br><a href="http://blog.csdn.net/zfrong/article/details/7332545" target="_blank" rel="external">http://blog.csdn.net/zfrong/article/details/7332545</a></li>
</ul>
<p><br>     </p>
<h3 id="详解build-gradle"><a href="#详解build-gradle" class="headerlink" title="详解build.gradle"></a>详解build.gradle</h3><hr>
<p><br></p>
<h4 id="app目录下"><a href="#app目录下" class="headerlink" title="- app目录下"></a>- app目录下</h4><ul>
<li></li>
</ul>
<pre><code>apply plugin: &apos;com.android.application&apos;
// 应用一个插件，有两种可选值
// com.android.application 表示应用程序模块
// com.android.library 表示库模块
// 前者可以直接运行，后者依赖与其他应用程序模块运行

android {
// android闭包可以配置项目构建的各种属性

    compileSdkVersion 25
    // 指定项目的编译版本

    buildToolsVersion &quot;25.0.2&quot;
    // 指定项目的构建工具版本

    defaultConfig {
    // defaultConfig闭包可以进行更多细节的配置

        applicationId &quot;activitytest.example.com.myapplication&quot;
        // 指定项目的包名
        minSdkVersion 15
        // 指定项目最低兼容版本
        targetSdkVersion 25
        // 指定目标版本
        // 表示在该版本上已经进行了充分的测试，系统会启动一些最新的功能和特性

        versionCode 1
        // 指定版本编号
        versionName &quot;1.0&quot;
        // 指定版本名
        // 这两个属性在生成安装文件时非常重要

}
buildTypes {        
// buildTypes 闭包用于指定生成安装文件的相关配置
// buildTypes 通常有两个子包 debug 和 release
// debug 测试版安装文件配置，可以忽略不写
// release 正式版安装文件配置

    release {
        minifyEnabled false
        // 指定是否对代码进行混淆
        proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;
        // 指定混淆时使用的规则文件
        // proguard-android.txt 在SDK目录，proguard-rules.pro 在当前项目根目录
        // 通过Android Studio直接运行项目生成的都是测试版安装文件
           }
       }
    }

dependencies {
// dependencies 闭包用于指定当前所有的依赖关系
// Android Studio 项目有本地依赖，库依赖，远程依赖
// 本地依赖可以对本地的jar包或目录添加依赖关系
// 库依赖可以对项目中的库模块添加依赖关系
// 远程依赖可以对jcenter库上的开源项目添加依赖关系

    compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])
    // 本地依赖声明，将libs文件夹中所有jar后缀文件添加到项目的构建路径当中
    compile &apos;com.android.support:appcompat-v7:25.2.0&apos;
    // 远程依赖声明，&apos;com.android.support是域名部分，其后为组名称，用于和同一公司的不同库作区分
    compile project(&apos; :helper&apos;)
    // 库依赖声明 compile project后加上库名称

}
</code></pre><p><br>        </p>
<h4 id="最外层目"><a href="#最外层目" class="headerlink" title="- 最外层目"></a>- 最外层目</h4><ul>
<li><pre><code>buildscript {
    repositories {
        jcenter()
    // 使用jcenter 代码托管仓库
}
dependencies {
    classpath &apos;com.android.tools.build:gradle:2.3.0&apos;
    // 声明Gradel插件
       }
}

allprojects {
    repositories {
        jcenter()
    }
}
</code></pre></li>
</ul>
<p><br>    </p>
<h3 id="日志工具的使用"><a href="#日志工具的使用" class="headerlink" title="日志工具的使用"></a>日志工具的使用</h3><p><strong>—— 别再System.out.println()了</strong></p>
<hr>
<ul>
<li>Log.v() ，打印琐碎信息</li>
<li>Log.d() ，打印调试信息</li>
<li>Log.i() ，打印重要数据</li>
<li>Log.w() ，打印警告信息</li>
<li>Log.e() ，打印错误信息</li>
<li>用例：Log.d(“类名”,”内容”)</li>
</ul>
<h2 id="第二章-探究活动"><a href="#第二章-探究活动" class="headerlink" title="第二章 探究活动"></a>第二章 探究活动</h2><p><br></p>
<h3 id="创建和加载布局"><a href="#创建和加载布局" class="headerlink" title="创建和加载布局"></a>创建和加载布局</h3><p><strong>——Android讲究逻辑和视图分离，最好每个活动都能对应一个布局，布局就是用来显示界面内容的</strong></p>
<hr>
<ul>
<li>在app/src/main/res 中创建目录并新建布局资源文件</li>
</ul>
<pre><code>&lt;LinearLayout 
在创建布局时选择了LinearLayou为根元素，根元素自动创建
   ...            
   &lt;Button
   android:id=&quot;@+id/button_1&quot;
   给当前的元素定义一个标识符

   android:layout_width=&quot;match_parent&quot;
   指定当前元素的宽度，让元素和父元素一样宽

   android:layout_height=&quot;wrap_content&quot;
   指定当前元素的高度，让元素刚好能包含内容

   android:text=&quot;Button 1&quot;
   指定元素中显示的文字内容
   /&gt;            
&lt;/LinearLayout&gt;
</code></pre><ul>
<li>在app/src/main/java/*Activity中扩展onCreate()，任何活动都应该重写这个方法</li>
</ul>
<pre><code>setContentView(R.layout.first_layout);
//该方法给当前活动添加一个布局，它需要布局文件的id
//项目中任何添加的资源都会在R文件中生成相应的id，用文件名调用即可
</code></pre><ul>
<li>在AndroidManifest文件中注册，as已负责完成，只需添加主活动</li>
</ul>
<pre><code> &lt;activity android:name=&quot;.MainActivity&quot;
    android:label=&quot;This is a Activity&quot;&gt;
    指定活动标签栏的内容

    &lt;intent-fliter&gt;
        &lt;antion android:name=&quot;android.intent.action.MAIN&quot;/&gt;
        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;
    &lt;/intent-fliter&gt;
    配置主活动，这是程序最先运行的活动

&lt;/activity&gt;
</code></pre><h3 id="使用Toast"><a href="#使用Toast" class="headerlink" title="使用Toast"></a>使用Toast</h3><p><strong>——一种用于提示短小信息的方式</strong></p>
<hr>
<ul>
<li>在活动中通过findViewById()方法获取布局文件中定义的元素，该方法返回一个View对象，需要向下转型为View子类对象</li>
<li>使用静态makeText方法创建Toast对象</li>
</ul>
<pre><code> ...
 Button button1 = (Button)findViewById(R.id.button_1);
   button1.setOnClickListener(new View.OnClickListener(){
   public void onClick(View v){
   Toast.makeText(MainActivity.this,&quot;You Clicked it!&quot;,Toast.LENGTH_SHORT).show();
   //三个参数分别为上下文context，文本内容，时常Toast.LENGTH_SHORT或Toast.LENGTH_LONG
        }
    });
...
</code></pre><h3 id="使用Menu"><a href="#使用Menu" class="headerlink" title="使用Menu"></a>使用Menu</h3><p><strong>——不占用界面空间的菜单</strong></p>
<hr>
<ul>
<li>在res目录新建一个menu文件夹即可选择创建Menu resouce file，在main.xml中添加控件信息</li>
</ul>
<pre><code>&lt;item
    android:id=&quot;@+id/add_item&quot;
   android:title=&quot;Add&quot;/&gt;
&lt;item
    android:id=&quot;@+id/removed_item&quot;
    android:title=&quot;removed&quot; /&gt;
</code></pre><ul>
<li>重写onCreateOptionsMenu()方法</li>
</ul>
<pre><code>public boolean onOptionsItemSelected(MenuItem item){

   switch(item.getItemId()){
   case R.id.add_item:
       Toast.makeText(this,&quot;clicked add&quot;,Toast.LENGTH_SHORT).show();
   break;

   case R.id.removed_item:
       Toast.makeText(this,&quot;clicked removed&quot;,Toast.LENGTH_SHORT).show();
      break;

   default:
   }
   return true;
   }
</code></pre><ul>
<li>销毁一个活动，在适当的地方，如监听器中添加，finish()方法，活动会自行退出</li>
</ul>
<pre><code>...
button1.setOnClickListener(new View.OnClickListener(){
    public void onClick(View v){
        Toast.makeText(MainActivity.this,&quot;You Clicked it!&quot;,Toast.LENGTH_SHORT).show();
        finish();
    }
});
...
</code></pre><h3 id="使用Intent在活动之间穿梭"><a href="#使用Intent在活动之间穿梭" class="headerlink" title="使用Intent在活动之间穿梭"></a>使用Intent在活动之间穿梭</h3><p><strong>——组件间交互的方式</strong></p>
<hr>
<h4 id="显式Intent"><a href="#显式Intent" class="headerlink" title="- 显式Intent"></a>- 显式Intent</h4><ul>
<li>启动活动，调用Activity类的startActivity()方法，该方法接受一个Intent参数</li>
<li>Intent 有多个构造器，其中一个 Intent( Context packageContext, Class&lt;?&gt;cls )，要求传入一个启动活动的上下文和要启动的目标活动，这种构造方法很好地说明了意图，因此称它为显式的</li>
</ul>
<pre><code> ...
 button1.setOnClickListener(new View.OnClickListener(){
    public void onClick(View v){
        Intent intent = new Intent(MainActivity.this,SecondActivity.class);
        startActivity(intent);
    }
});
...
</code></pre><h4 id="隐式Intent"><a href="#隐式Intent" class="headerlink" title="- 隐式Intent"></a>- 隐式Intent</h4><ul>
<li>在<activity>标签下配置action和category内容</activity></li>
</ul>
<pre><code>...
&lt;activity
    android:name=&quot;.MainActivity&quot;
    android:label=&quot;This is a Activity&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
    &lt;/intent-filter&gt;
    &lt;/activity&gt;
    ...
</code></pre><ul>
<li>调用Intent的另一构造器，该构造器接受一个action字段</li>
<li>调用Intent的add()方法，该构造器接受一个category字段</li>
<li>一个Intent可以有多个category字段，默认为DEFAULT，但action只能有一个</li>
</ul>
<pre><code>...
button1.setOnClickListener(new View.OnClickListener(){
    public void onClick(View v){

    Intent intent = new Intent(&quot;activitytest.example.com.ACTION_START&quot;);
    intent.addCategory(&quot;activitytest.example.com.MY_CATEGORY&quot;);
    startActivity(intent);

    }
});
...
</code></pre><h4 id="更多隐式Intent-的用法"><a href="#更多隐式Intent-的用法" class="headerlink" title="- 更多隐式Intent 的用法"></a>- 更多隐式Intent 的用法</h4><ul>
<li>打开网页</li>
</ul>
<pre><code>...
Button button1 = (Button)findViewById(R.id.button_1);
button1.setOnClickListener(new View.OnClickListener(){
    public void onClick(View v){

       Intent intent = new Intent(Intent.ACTION_VIEW);
        //Intent.ACTION_VIEW是一个常量，值为android.intent.action.view

       intent.setData(Uri.parse(&quot;http://www.baidu.com&quot;));
        //Uri.parse()方法解析一个域名字符串，返回Uri对象，setData指定Intent正在操作的数据
        startActivity(intent);
    }
});
...
</code></pre><ul>
<li>拨号界面</li>
</ul>
<pre><code>...
Intent intent = new Intent(Intent.ACTION_VIEW);
    intent.setData(Uri.parse(&quot;tel:10086&quot;));
    //tel: 指定号码
    startActivity(intent);
...
</code></pre><ul>
<li>向下一个活动传递消息</li>
</ul>
<pre><code>     ...
         String data = &quot;hello SecondActivity&quot;;
         Intent intent = new Intent(MainActivity.this,SecondActivity.class);
         intent.putExtra(&quot;extra_data&quot;,data);
         // putExtra 用于放入要传递的数据
         startActivity(intent);
     ...

     ...
public class SecondActivity extends AppCompatActivity {

     @Override
     protected void onCreate(Bundle savedInstanceState) {
     super.onCreate(savedInstanceState);
     setContentView(R.layout.activity_second);

        Intent intent = getIntent();
         String data = intent.getStringExtra(&quot;extra_data&quot;);
         // 形如 get**Extra
     Log.d(&quot;SecondActivity&quot;,data);
     ...
</code></pre><ul>
<li>返回数据给上一个活动</li>
</ul>
<pre><code>// in MainActivity
button1.setOnClickListener(new View.OnClickListener(){
    public void onClick(View v){

        Intent intent = new Intent(MainActivity.this,SecondActivity.class);
        startActivityForResult(intent,1);
        // 1 为requestCode ，用于标识发送请求的活动

    }
});

// in SecondActivity
button2.setOnClickListener(new View.OnClickListener(){
    public void onClick(View v){
        Intent intent = new Intent();
        intent.putExtra(&quot;data_return&quot;,&quot;Hello MainActivity&quot;);
        setResult(RESULT_OK,intent);
        // resultCode 为处理结果。新建intent返回
        finish();
    }
});

 // in MainActivity
 protected void onActivityResult(int requestCode,int resultCode,Intent data){
switch (requestCode){
    case 1:
        if(resultCode == RESULT_OK){
            String returnedData = data.getStringExtra(&quot;data_return&quot;);
            Log.d(&quot;FirstActivity&quot;,returnedData);
            // 通过 requestCode 检查来源并提取数据
        }
        break;
    default:
    }
}
</code></pre><p><br>        </p>
<h3 id="活动生命周期"><a href="#活动生命周期" class="headerlink" title="活动生命周期"></a>活动生命周期</h3><hr>
<p><br>    </p>
<h4 id="返回栈"><a href="#返回栈" class="headerlink" title="- 返回栈"></a>- 返回栈</h4><ul>
<li>Android 使用任务（Task）来管理活动，一个任务就是一组存放在栈里的活动的集合，这个栈也被称作返回栈（Back Task）</li>
<li>启动活动，活动入栈</li>
<li>销毁活动，Back键或finish()，活动出栈<br><br>    </li>
</ul>
<h4 id="活动状态"><a href="#活动状态" class="headerlink" title="- 活动状态"></a>- 活动状态</h4><ul>
<li>运行，栈顶时</li>
<li>暂停，非栈顶但可见时</li>
<li>停止，非栈顶不可见时</li>
<li>销毁，从栈中移除之后</li>
<li>被回收可能性 运行&lt;暂停&lt;停止&lt;销毁<br><br>    </li>
</ul>
<h4 id="七个回调方法"><a href="#七个回调方法" class="headerlink" title="- 七个回调方法"></a>- 七个回调方法</h4><ul>
<li>Activity中定义了7个回调方法，覆盖了活动生命周期的每一个环节 </li>
<li>onCreate()，第一次被创建时调用，应在这个方法中完成活动的初始化操作</li>
<li>onStart()，活动由不可见变为可见时调用</li>
<li>onResume()，活动准备好和用户交互时调用</li>
<li>onPause()，启动或恢复另一个活动时调用</li>
<li>onStop()，活动变为不可见时调用</li>
<li>onDestory()，活动被销毁前调用</li>
<li>onRestar()，活动由停止变为运行状态时调用<br><br>    </li>
</ul>
<h4 id="三个生存期"><a href="#三个生存期" class="headerlink" title="- 三个生存期"></a>- 三个生存期</h4><ul>
<li>完整生存期，onCreate()和onDestory()之间</li>
<li>可见生存期，onStart()和onStop()之间，总是可见</li>
<li>前台生存期，onResume()和onPause()之间，可交互<br><br>    </li>
</ul>
<h4 id="四个启动模式"><a href="#四个启动模式" class="headerlink" title="- 四个启动模式"></a>- 四个启动模式</h4><ul>
<li>standard，不管活动是否已在栈中存在都会创建新实例</li>
<li>singleTop，启动活动时若栈顶已是该活动则不再创建新实例</li>
<li>singleTask，启动活动时若栈中含有该活动则将其上的活动全部出栈</li>
<li>singleInstance，使用单独的返回栈来管理活动，实现实例的共享</li>
<li>用例：</li>
</ul>
<pre><code>&lt;activity
    android:name=&quot;.FirstActivity&quot;
    android:laucMode=&quot;singleTask&quot;
    ....
</code></pre><p><br>    </p>
<h3 id="活动的实践技巧"><a href="#活动的实践技巧" class="headerlink" title="活动的实践技巧"></a>活动的实践技巧</h3><hr>
<ul>
<li>知晓当前活动</li>
</ul>
<pre><code>//让其他类继承这个类
public class BaseActivity extends AppCompatActivity {
protected void onCreate(Bundle savedInstanceState){
super.onCreate(savedInstanceState);
Log.d(&quot;BaseActivity&quot;,getClass().getSimpleName());
//获取活动名
｝
</code></pre><ul>
<li>随时随地退出程序</li>
</ul>
<pre><code>//创建一个类充当容器
public class ActivityCollector {

public static List&lt;Activity&gt; activities = new ArrayList&lt;&gt;();

public static void addActivity(Activity activity){
activities.add(activity);

}

public static void removeActivity(Activity activity){
activities.remove(activity);
}

public static void  finishAll(){
for(Activity activity:activities){
    if(!activity.isFinishing()){
        activity.finish();
        }
    }
    activities.clear();
    //别忘了清空容器 
    }
}

//在BaseActivity，使新建的对象加入到容器中
protected void onCreate(Bundle savedInstanceState){
super.onCreate(savedInstanceState);
ActivityCollector.addActivity(this);

}
    protected void onDestory(){
super.onDestroy();
ActivityCollector.removeActivity(this);
}

//在想要推出程序的地方，调用finishAll()
button2.setOnClickListener(new View.OnClickListener(){
    public void onClick(View v){

    ActivityCollector.finishAll();

    }
});
</code></pre><ul>
<li>启动活动的最佳写法</li>
</ul>
<pre><code>//在活动中写一个开启自己的静态方法
public static void actionStart(Context context, String data1, String data2){

Intent intent = new Intent(context,SecondActivity.class);
intent.putExtra(&quot;param1&quot;,data1);
intent.putExtra(&quot;param2&quot;,data2);
context.startActivity(intent);
}

//在任意地方调用这个方法
 button1.setOnClickListener(new View.OnClickListener(){
    public void onClick(View v){
SecondActivity.actionStart(MainActivity.this,&quot;data1&quot;,&quot;data2&quot;);

    }
});
</code></pre><p><br>     </p>
<h2 id="第三章-UI开发"><a href="#第三章-UI开发" class="headerlink" title="第三章 UI开发"></a>第三章 UI开发</h2><hr>
<p><br>    </p>
<h3 id="常用控件的使用方法"><a href="#常用控件的使用方法" class="headerlink" title="常用控件的使用方法"></a>常用控件的使用方法</h3><hr>
<ul>
<li>所有控件都直接或间接继承至View，View是最基本的一种控件</li>
<li>View在屏幕上绘制一块矩形区域，并响应这块区域的所有事件</li>
<li>TextView，显示文本信息</li>
</ul>
<pre><code>&lt;TextView
    android:id=&quot;@+id/text_view&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:gravity=&quot;center&quot;
    android:textSize=&quot;24sp&quot;
    android:textColor=&quot;#0033ff&quot;
    android:text=&quot;This is TextView&quot; /&gt;
</code></pre><ul>
<li>Button，按钮</li>
</ul>
<pre><code>&lt;Button
   android:id=&quot;@+id/button&quot;
   android:layout_width=&quot;match_parent&quot;
   android:layout_height=&quot;wrap_content&quot;
   android:text=&quot;Button&quot;/&gt;
</code></pre><ul>
<li>EditText，输入框</li>
</ul>
<pre><code>&lt;EditText
    android:id=&quot;@+id/edit_text&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:maxLines=&quot;2&quot;/&gt;
</code></pre><ul>
<li>ImageView，展示图片</li>
</ul>
<pre><code>&lt;ImageView
    android:id=&quot;@+id/image_view&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:src=&quot;@drawable/img_1&quot;/&gt;
</code></pre><ul>
<li>ProgressBar，进度条</li>
</ul>
<pre><code>&lt;ProgressBar
    android:id=&quot;@+id/progress_bar&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot; /&gt;
</code></pre><ul>
<li>监听器</li>
</ul>
<pre><code>public class MainActivity extends AppCompatActivity implements View.OnClickListener{

        private EditText editText;
        private ImageView imageView;
        private ProgressBar progressBar;

    @Override
    protected void onCreate(Bundle savedInstanceState) {

    super.onCreate(savedInstanceState);
    //恢复数据

    setContentView(R.layout.activity_main);        
    Button button = (Button)findViewById(R.id.button);
    editText = (EditText)findViewById(R.id.edit_text);
    imageView = (ImageView)findViewById(R.id.image_view);
    progressBar = (ProgressBar)findViewById(R.id.progress_bar);
    //调用实例

    button.setOnClickListener(this);
    //设置监听器
    }

    public void onClick(View v){

    switch(v.getId()){
        case R.id.button:
            String inputText = editText.getText().toString();
            //获取输入

            Toast.makeText(MainActivity.this,
            inputText,Toast.LENGTH_SHORT).show();

            imageView.setImageResource(R.drawable.img_2);
            //更换图片

            if(progressBar.getVisibility() == View.GONE){
                progressBar.setVisibility(View.VISIBLE);
            }else{
                progressBar.setVisibility(View.GONE);
            }
            //设置可见属性

            AlertDialog.Builder dialog = 
            new AlertDialog.Builder(MainActivity.this);
            dialog.setTitle(&quot;this is a dialog&quot;);
            dialog.setMessage(&quot;something important&quot;);
            dialog.setCancelable(false);
            dialog.setPositiveButton         
            (&quot;ok&quot;, new DialogInterface.OnClickListener() {
            @Override
              public void onClick(DialogInterface dialog, int which) {

            }
        });
            dialog.setNegativeButton
            (&quot;cancel&quot;, new DialogInterface.OnClickListener() {
            @Override
               public void onClick(DialogInterface dialog, int which) {

                }
            });
            dialog.show();
            //显示对话框

            ProgressDialog progressDialog =
            new ProgressDialog(MainActivity.this);
            progressDialog.setTitle(&quot;this is a progressDialog&quot;);
            progressDialog.setMessage(&quot;Loading&quot;);
            progressDialog.setCancelable(true);
            progressDialog.show();
            //进度对话框

            break;

        default:
            break;
        }
    }
}
</code></pre><p><br>    </p>
<h3 id="布局管理器"><a href="#布局管理器" class="headerlink" title="布局管理器"></a>布局管理器</h3><hr>
<ul>
<li>所有布局都直接或间接继承自ViewGroup，ViewGroup是一种特殊的View</li>
<li>ViewGroup可以包含很多的子View和子ViewGroup，是一个用于放置控件和容器的布局</li>
<li>线性布局，让控件在线性方向上依次排列，可以指定对其方式和比例</li>
<li>相对布局，让控件以相对定位方式排列</li>
<li>帧布局，简单的布局，控件会重叠</li>
<li>百分比布局，按任意比例分割布局</li>
<li>引入布局，创建布局xml，使用 <include layout="@layout/文件名"><br><br>    </include></li>
</ul>
<h3 id="自定义控件"><a href="#自定义控件" class="headerlink" title="自定义控件"></a>自定义控件</h3><hr>
<p><strong>（待续）</strong><br><br>    </p>
<h3 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h3><p><strong>——滚动列表</strong></p>
<hr>
<p><br>    </p>
<h4 id="简单用法"><a href="#简单用法" class="headerlink" title="-  简单用法"></a>-  简单用法</h4><ul>
<li>适配器，数组中的数据无法直接传给ListView，需要借助适配器来完成</li>
<li>ArrayAdapter，使用泛型，含有多个构造器的重载</li>
<li>布局</li>
</ul>
<pre><code>&lt;ListView
    android:id=&quot;@+id/list_view&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;&gt;
</code></pre><ul>
<li>使用</li>
</ul>
<pre><code>public class MainActivity extends AppCompatActivity{

    private String[] data ={&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;10&quot;,&quot;11&quot;,&quot;12&quot;};

    protected void onCreate(Bundle savedInstanceState){
        super.onCreate(savedInstanceState);
        setContentView(R.layout.list_view_test);

        ArrayAdapter&lt;String&gt; adapter = 
        new ArrayAdapter&lt;String&gt;(MainActivity.this,android.R.layout.simple_list_item_1,data);
        //传入当前上下文，ListView子项布局id，数据
        //simple_list_item_1，这是一个Android内置的布局文件，里面只有一个TextView

        ListView listView = (ListView)findViewById(R.id.list_view);
        istView.setAdapter(adapter);
    }
}
</code></pre><p><br>    </p>
<h4 id="界面定制"><a href="#界面定制" class="headerlink" title="- 界面定制"></a>- 界面定制</h4><ul>
<li>定义实体类，作为适配器的适配类型</li>
</ul>
<pre><code>public class ItemTest {

    private String name;
    private int imageId;

    public ItemTest(String name, int imageId) {
        this.name = name;
        this.imageId = imageId;
    }

    public String getName() {
        return name;
    }

    public int getImageId() {
        return imageId;
        }
}
</code></pre><ul>
<li>为ListView子项目定义布局</li>
</ul>
<pre><code>&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&gt;

&lt;ImageView
    android:id=&quot;@+id/item_image&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot; /&gt;
&lt;TextView
    android:id=&quot;@+id/text_view&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:layout_gravity=&quot;center_vertical&quot;
    android:layout_margin=&quot;10dp&quot;/&gt;
&lt;/LinearLayout&gt;
</code></pre><ul>
<li>自定义适配器</li>
</ul>
<pre><code>public class TestAdapter extends ArrayAdapter&lt;ItemTest&gt; {

private int resourceId;

public TestAdapter(Context context,int testViewResourceId,List&lt;ItemTest&gt; object){

    super(context,testViewResourceId,object);
    resourceId = testViewResourceId;

}

public int getResourceId() {
    return resourceId;
}

public void setResourceId(int resourceId) {
    this.resourceId = resourceId;
}

public View getView(int position,View convertView,ViewGroup parent){

    ItemTest item = getItem(position);
    View view = LayoutInflater.from(getContext()).inflate(
    resourceId,parent,false);
    // 只让 parent 中的layout属性生效，但不添加为父布局

    ImageView imageView = (ImageView)view.findViewById(R.id.item_image);
    TextView textView = (TextView)view.findViewById(R.id.text_view);
    imageView.setImageResource(item.getImageId());
    textView.setText(item.getName());
    return view;
    }

}
</code></pre><ul>
<li>使用</li>
</ul>
<pre><code>public class MainActivity extends AppCompatActivity{

private List data = new ArrayList();

protected void onCreate(Bundle savedInstanceState){
    super.onCreate(savedInstanceState);
    setContentView(R.layout.list_view_test);
    initItem();
    TestAdapter adapter = new TestAdapter(MainActivity.this, R.layout.test_item, data);

    ListView listView = (ListView)findViewById(R.id.list_view);
    listView.setAdapter(adapter);
}

private void initItem(){
    ItemTest item1 = new ItemTest(&quot;1&quot;,R.drawable.img_1);
    data.add(item1);
    ItemTest item2 = new ItemTest(&quot;2&quot;,R.drawable.img_2);
    data.add(item2);
    ItemTest item3 = new ItemTest(&quot;3&quot;,R.drawable.img_3);
    data.add(item3);
    ....
   }
}
</code></pre><p><br></p>
<h4 id="提升效率"><a href="#提升效率" class="headerlink" title="- 提升效率"></a>- 提升效率</h4><p><strong>（待续）</strong><br><br></p>
<h4 id="点击事件"><a href="#点击事件" class="headerlink" title="- 点击事件"></a>- 点击事件</h4><ul>
<li>添加监听器</li>
</ul>
<pre><code>listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
        @Override
        public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) {

            ItemTest itemTest = data.get(position);
            Toast.makeText(MainActivity.this,itemTest.getName(),Toast.LENGTH_SHORT).show();
        }
    });
</code></pre><p><br></p>
<h3 id="RecycleView"><a href="#RecycleView" class="headerlink" title="RecycleView"></a>RecycleView</h3><p><strong>——更强大的滚动控件</strong></p>
<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="- 基本用法"></a>- 基本用法</h4><ul>
<li>在 app/build.gradle 文件中的dependencies闭包中添加依赖库</li>
</ul>
<pre><code>compile &apos;com.android.support:recyclerview-v7:24.2.1&apos;
</code></pre><ul>
<li>创建item布局，注意RecyclerView本身不具备点击动画，需要自行设置</li>
</ul>
<pre><code>&lt;LinearLayout
xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
android:orientation=&quot;vertical&quot;
android:background=&quot;?android:attr/selectableItemBackground&quot;
android:clickable=&quot;true&quot;
android:focusable=&quot;true&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;wrap_content&quot;&gt;

&lt;ImageView
    android:background=&quot;?android:attr/selectableItemBackground&quot;
    android:clickable=&quot;true&quot;
    android:focusable=&quot;true&quot;
    android:id=&quot;@+id/item_iv&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot; /&gt;
&lt;TextView
    android:id=&quot;@+id/item_tv&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:layout_gravity=&quot;center_vertical&quot;
    android:layout_marginStart=&quot;10dp&quot;/&gt;
&lt;/LinearLayout&gt;
</code></pre><ul>
<li>创建adapter，应重写ViewHolder，onCreateViewHolder，onBindViewHolder，getItemCount，点击事件应该在onCreateViewHolder中实现</li>
</ul>
<pre><code>public class RecyclerViewAdapter extends RecyclerView.Adapter&lt;RecyclerViewAdapter.ViewHolder&gt; {

    private List&lt;String&gt; dataList;

    public RecyclerViewAdapter(){
        dataList = new ArrayList&lt;&gt;();
        for(int i = 0;i&lt;10;i++){
            dataList.add(&quot;item : &quot;+i);
        }
    }

static class ViewHolder extends RecyclerView.ViewHolder{

    ImageView imageView;
    TextView textView;

    public ViewHolder(View itemView) {
        super(itemView);
        imageView = (ImageView)itemView.findViewById(R.id.item_iv);
        textView = (TextView)itemView.findViewById(R.id.item_tv);
        imageView.setImageResource(R.mipmap.ic_launcher);

    }
}

@Override
public ViewHolder onCreateViewHolder(final ViewGroup parent, int viewType) {
    View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.recycler_item,parent,false);
    final ViewHolder holder = new ViewHolder(view);
    holder.imageView.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            Toast.makeText(v.getContext(),&quot;click &quot;+dataList.get(holder.getAdapterPosition()),Toast.LENGTH_SHORT).show();

        }
    });
    return holder;
}

@Override
public void onBindViewHolder(ViewHolder holder, int position) {

    String str = dataList.get(position);
    holder.textView.setText(&quot;item : &quot;+str);
}

@Override
public int getItemCount() {
    return dataList.size();
}

}
</code></pre><ul>
<li>通过指定LinearLayoutManager，GridLayoutManager，StaggeredGridLayoutManager 分别可以实现线性，网格布局，瀑布流布局    </li>
</ul>
<p><br></p>
<h2 id="第四章-探究碎片"><a href="#第四章-探究碎片" class="headerlink" title="第四章 探究碎片"></a>第四章 探究碎片</h2><hr>
<p><br></p>
<h3 id="碎片的使用方式"><a href="#碎片的使用方式" class="headerlink" title="碎片的使用方式"></a>碎片的使用方式</h3><hr>
<p><br></p>
<h4 id="简单用法-1"><a href="#简单用法-1" class="headerlink" title="- 简单用法"></a>- 简单用法</h4><ul>
<li>为碎片设置布局</li>
</ul>
<pre><code> ...
&lt;fragment
    android:id=&quot;@+id/left_fragment&quot;
    android:name=&quot;com.linjiamin.myapplication.LeftFragment&quot;
    android:layout_width=&quot;0dp&quot;
    android:layout_height=&quot;match_parent&quot;
    android:layout_weight=&quot;1&quot;/&gt;

&lt;fragment
    android:id=&quot;@+id/right_fragment&quot; 
    android:name=&quot;com.linjiamin.myapplication.RightFragment&quot;
    android:layout_width=&quot;0dp&quot;
    android:layout_height=&quot;match_parent&quot;
    android:layout_weight=&quot;1&quot;/&gt;
 ...
</code></pre><ul>
<li>创建碎片</li>
</ul>
<pre><code>public class LeftFragment extends Fragment{
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState){
        View view = inflater.inflate(R.layout.left_fragment,container,false);
        return view;
    }
}
</code></pre><p><br></p>
<h4 id="动态加载碎片"><a href="#动态加载碎片" class="headerlink" title="- 动态加载碎片"></a>- 动态加载碎片</h4><ul>
<li>创建待添加的碎片实例</li>
<li>获取FragmentManager，在活动中调用getSupportFragementManage 方法</li>
<li>开启一个事务，调用beginTransaction 方法</li>
<li>向容器类添加或替换碎片，调用事务的replace 方法，需要传入容器的id和待添加的碎片实例</li>
<li>提交事务，调用事务的commit 方法</li>
</ul>
<pre><code>public class MainActivity extends AppCompatActivity implements View.OnClickListener{

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button button = (Button)findViewById(R.id.button);
        button.setOnClickListener(this);
        replaceFragment(new RightFragment());
    }

    public void replaceFragment(Fragment fragment){
        FragmentManager fragmentManager = getSupportFragmentManager();
        FragmentTransaction transaction = fragmentManager.beginTransaction();
        transaction.replace(R.id.right_layout,fragment);
        transaction.commit();
    }

    @Override
    public void onClick(View v){
        switch (v.getId()){
            case R.id.button:
                replaceFragment(new AnotherFragment());
                break;
            default:
                break;
        }
    }
}
</code></pre><p><br></p>
<h4 id="模拟返回栈"><a href="#模拟返回栈" class="headerlink" title="- 模拟返回栈"></a>- 模拟返回栈</h4><ul>
<li>调用事务的addBackStack 方法，需要传入一个名字用于描述返回栈的状态，一般传入null即可</li>
</ul>
<p><br></p>
<h4 id="碎片与活动进行通信"><a href="#碎片与活动进行通信" class="headerlink" title="- 碎片与活动进行通信"></a>- 碎片与活动进行通信</h4><ul>
<li>调用FragmentManager的findViewById 方法，可以在活动中获取相应碎片的实例</li>
<li>调用Fragment的 getActivity 方法，可以在碎片中获取活动</li>
<li>利用活动为桥梁，可以在碎片和碎片之间通信</li>
</ul>
<p><br></p>
<h3 id="碎片的生命周期"><a href="#碎片的生命周期" class="headerlink" title="碎片的生命周期"></a>碎片的生命周期</h3><hr>
<p><br></p>
<h4 id="碎片的状态与回调"><a href="#碎片的状态与回调" class="headerlink" title="- 碎片的状态与回调"></a>- 碎片的状态与回调</h4><ul>
<li>Running，碎片可见，关联的活动正处于运行状态</li>
<li>Pause，碎片可见，关联的活动进入暂停状态，</li>
<li>Stop，碎片不可见，关联的活动进入停止状态，或调用了事务的remove，replace 方法</li>
<li>Killed，活动被销毁，或调用了事务的remove，replace 方法</li>
</ul>
<h4 id="附加的回调方法"><a href="#附加的回调方法" class="headerlink" title="- 附加的回调方法"></a>- 附加的回调方法</h4><ul>
<li>onAttach，碎片和活动建立关联的时候调用</li>
<li>onCreateView，为碎片创立视图的时候调用</li>
<li>onActivityCreated，确保碎片相关联的活动已经创立完毕的时候调用</li>
<li>onDestoryView，当碎片相关联的视图被移除的时候调用</li>
<li>onDetach，当碎片和活动接触关联的时候调用</li>
</ul>
<p><br></p>
<h3 id="动态加载布局"><a href="#动态加载布局" class="headerlink" title="动态加载布局"></a>动态加载布局</h3><hr>
<p><br></p>
<h4 id="使用限定符"><a href="#使用限定符" class="headerlink" title="- 使用限定符"></a>- 使用限定符</h4><ul>
<li>程序会通过在文件夹名称后追加 -限定符 来判断使用何种布局，形如 layout-large</li>
<li>small，normal，large，xlarge，提供给不同大小的屏幕使用</li>
<li>ldpi，mdpi，hdpi，xhdpi，xxhdpi，提供给不同分辨率的设备使用</li>
<li>land，port，提供横屏和竖屏的设备使用</li>
<li>swXXXdp，用于指定最小宽度</li>
</ul>
<p><br></p>
<h2 id="第五章-详解广播"><a href="#第五章-详解广播" class="headerlink" title="第五章 详解广播"></a>第五章 详解广播</h2><hr>
<p><br></p>
<h3 id="广播机制"><a href="#广播机制" class="headerlink" title="广播机制"></a>广播机制</h3><hr>
<p><br></p>
<h3 id="接受系统广播"><a href="#接受系统广播" class="headerlink" title="接受系统广播"></a>接受系统广播</h3><hr>
<p><br></p>
<h4 id="动态注册监听网络变化"><a href="#动态注册监听网络变化" class="headerlink" title="- 动态注册监听网络变化"></a>- 动态注册监听网络变化</h4><p><br></p>
<h4 id="静态注册开机启动"><a href="#静态注册开机启动" class="headerlink" title="- 静态注册开机启动"></a>- 静态注册开机启动</h4><p><br></p>
<h3 id="发送自定义广播"><a href="#发送自定义广播" class="headerlink" title="发送自定义广播"></a>发送自定义广播</h3><p><br></p>
<h4 id="发送标准广播"><a href="#发送标准广播" class="headerlink" title="- 发送标准广播"></a>- 发送标准广播</h4><p><br></p>
<h4 id="发送有序广播"><a href="#发送有序广播" class="headerlink" title="- 发送有序广播"></a>- 发送有序广播</h4><p><br></p>
<h4 id="使用本地广播"><a href="#使用本地广播" class="headerlink" title="- 使用本地广播"></a>- 使用本地广播</h4><p><br></p>
<h2 id="第六章-数据储存"><a href="#第六章-数据储存" class="headerlink" title="第六章 数据储存"></a>第六章 数据储存</h2><hr>
<p><br></p>
<h3 id="文件储存"><a href="#文件储存" class="headerlink" title="文件储存"></a>文件储存</h3><p><strong>——最基本的一种储存方式，不对内容进行任何格式化处理，所有数据原封不动地保存到文件当中</strong></p>
<hr>
<ul>
<li>文件储存比较适合于储存一些简单的文本数据或二进制数据</li>
<li>Context中提供一个openFileOutput方法，用于将数据储存到指定的文件当中</li>
<li>openFileOutput()的第一个参数是文件名，不可以包括路径，第二个参数是操作模式，有两种可选，MODE_PRIVATE 和 MODE_APPEND，表示覆盖和追加</li>
</ul>
<pre><code>public void save(){

    String data = &quot;data to save&quot;;
    FileOutputStream out = null;
    BufferedWriter writer = null;

    try{
        out = openFileOutput(&quot;data&quot;, Context.MODE_PRIVATE);
        writer = new BufferedWriter(new OutputStreamWriter(out));
        writer.write(data);
    }catch(IOException e){
        e.printStackTrace();
    }finally{
        try{
            if(writer != null){
                writer.close();
            }
        }catch (IOException e){
            e.printStackTrace();
        }
    }
}
</code></pre><ul>
<li>Context中提供一个openFileInput方法，用于从文件中读取数据，它只接受一个参数，即文件名</li>
</ul>
<pre><code>public String Load(){

        FileInputStream in ;
        BufferedReader reader = null;
        StringBuilder content = new StringBuilder();

        try{
            in = openFileInput(&quot;data&quot;);
            reader = new BufferedReader(new InputStreamReader(in));
            String line;
            while ((line = reader.readLine())!= null){
                content.append(line);
            }
        }catch (IOException e){
            e.printStackTrace();
        }finally{
            try {
                  if(reader != null){
                    reader.close();    
                 }               
            }catch (IOException e){
                e.printStackTrace();
            }
        }
    }
</code></pre><ul>
<li>可以考虑将save()和load()这样的方法写在onDestory()和onCreate()中<br><br></li>
</ul>
<h3 id="SharedPreferences储存"><a href="#SharedPreferences储存" class="headerlink" title="SharedPreferences储存"></a>SharedPreferences储存</h3><p><strong>——支持多类型、使用键值对的储存方</strong>     </p>
<hr>
<p><br></p>
<h4 id="三种方法获取对象"><a href="#三种方法获取对象" class="headerlink" title="- 三种方法获取对象"></a>- 三种方法获取对象</h4><ul>
<li>使用SharedPreferences存储数据必须获取SharedPreferences对象</li>
<li>Context类中的getSharedPreferences方法，接受两个参数，文件名和操作模式，操作模式只有MODE_PRIVATE一种可选，与0相同，表示只有当前应用程序可以对该文件进行读写</li>
<li>Activity类中的getPreferences方法，接受一个参数并自动将类名作为文件名</li>
<li>PreferenceManager类中的getDefaultSharedPreferences方法，静态方法，接受一个Context参数并将Context的包名作为前缀<br><br></li>
</ul>
<h4 id="三个步骤存储数据"><a href="#三个步骤存储数据" class="headerlink" title="- 三个步骤存储数据"></a>- 三个步骤存储数据</h4><ul>
<li>调用edit()方法获取一个SharedPreferences.Editor对象</li>
<li>向Editor中添加数据，如调用putBoolean()等*</li>
<li>调用apply()方法将添加的数据提交   </li>
</ul>
<pre><code>saveData.setOnClickListener(new View.OnClickListener(){

    public void onClick(View V) {
        SharedPreferences.Editor editor = getSharedPreferences(&quot;data&quot;,MODE_PRIVATE).edit();
        editor.putString(&quot;name&quot;,&quot;Tom&quot;);
        editor.putInt(&quot;age&quot;,29);
        editor.putBoolean(&quot;married&quot;,false);
        editor.apply();
    }
</code></pre><p><br></p>
<h4 id="两个步骤读取数据"><a href="#两个步骤读取数据" class="headerlink" title="- 两个步骤读取数据"></a>- 两个步骤读取数据</h4><ul>
<li>调用edit()方法获取一个SharedPreferences.Editor对象</li>
<li>从Editor中获取数据，如调用getBoolean()等</li>
</ul>
<pre><code>saveData.setOnClickListener(new View.OnClickListener(){
    public void onClick(View V) {
        SharedPreferences.Editor editor = getSharedPreferences(&quot;data&quot;,MODE_PRIVATE).edit();
        editor.putString(&quot;name&quot;,&quot;Tom&quot;);
        editor.putInt(&quot;age&quot;,29);
        editor.putBoolean(&quot;married&quot;,false);
        editor.apply();
    }
</code></pre><h3 id="SQLite数据库存储"><a href="#SQLite数据库存储" class="headerlink" title="SQLite数据库存储"></a>SQLite数据库存储</h3><p><strong>——一个轻量级关系型数据库</strong></p>
<hr>
<h4 id="创建更新数据库"><a href="#创建更新数据库" class="headerlink" title="- 创建更新数据库"></a>- 创建更新数据库</h4><ul>
<li>使用SQLiteOpenHelper帮助类可以非常简单地对数据库进行创建和升级</li>
<li>SQLiteOpenHelper有两个抽象方法，onCreate()和onUpgrade()用于创建和升级数据库的逻辑</li>
<li>SQLiteOpenHelper有两个实例方法，getReadableDatabase()和getWritableDatabase()，用于获取一个现有或新建的数据库</li>
<li>SQLiteOpenHelper有两个构造方法可供重写，其中一个接受Context，数据库名，Cursor，版本号为参数</li>
<li>使用数据库</li>
</ul>
<pre><code>public class MainActivity extends AppCompatActivity {

private MyDatabaseHelper dbHelper;

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    dbHelper = new MyDatabaseHelper(this,&quot;BookStore&quot;,null,3);
    //修改版本号可进行数据库的更新

    Button getData = (Button)findViewById(R.id.button);
    getData.setOnClickListener(new View.OnClickListener(){
        public void onClick(View V) {
            dbHelper.getWritableDatabase();
            //若硬盘空间已满则抛出异常

            }
        });
    }
}
</code></pre><ul>
<li>创建和更新数据库</li>
</ul>
<pre><code>public class MyDatabaseHelper extends SQLiteOpenHelper {

//建表语句，autoincrement
public static final String CREATE_BOOK = &quot;create table book(&quot;
        + &quot;id integer primary key autoincrement,&quot;
        + &quot;author text,&quot;
        + &quot;price real,&quot;
        + &quot;name text)&quot;;

public static final String CREATE_CATEGORY = &quot;create table Category(&quot;
        + &quot;id integer primary key autoincrement,&quot;
        + &quot;category_name text,&quot;
        + &quot;category_code integer)&quot;;

private  Context mContext;

public MyDatabaseHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) {
    super(context, name, factory, version);
    mContext = context;
}

//创建表格，如果表已存在则该onCreate()方法不执行
public void onCreate(SQLiteDatabase db) {
    db.execSQL(CREATE_BOOK);
    db.execSQL(CREATE_CATEGORY);
    Toast.makeText(mContext,&quot;Create succeeded&quot;,Toast.LENGTH_SHORT).show();
}

//更新表格，输入新版本号将会执行
public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
    db.execSQL(&quot;drop table if exists Book&quot;);
    db.execSQL(&quot;drop table if exists Category&quot;);
    //删除表格
    onCreate(db);
    //重新建表
    }
}
</code></pre><h4 id="增删查改数据库"><a href="#增删查改数据库" class="headerlink" title="- 增删查改数据库"></a>- 增删查改数据库</h4><ul>
<li>添加数据，SQLiteDatabase提供insert()方法专门用于添加数据</li>
<li>insert()方法接受3个参数，分别为表名，可以为空的列，ContentValues对象</li>
<li>ContentValues提供一系列的put()方法用于添加数据</li>
</ul>
<pre><code> SQLiteDatabase db = dbHelper.getWritableDatabase();
ContentValues values = new ContentValues();
values.put(&quot;name&quot;,&quot;The Da Vinci Code&quot;);
values.put(&quot;author&quot;,&quot;Dan Brown&quot;);
values.put(&quot;pages&quot;,454);
values.put(&quot;price&quot;,16.96);
db.insert(&quot;Book&quot;,null,values);
</code></pre><ul>
<li>删除数据，SQLiteDatabase提供delete()方法专门用于删除数据</li>
<li>delete()方法接受3个参数，分别为表名和对行列的约束</li>
</ul>
<pre><code> SQLiteDatabase db = dbHelper.getWritableDatabase();
db.delete(&quot;Book&quot;,&quot;pages &gt; ?&quot;,new String[]{&quot;500&quot;});
</code></pre><ul>
<li>查询数据，SQLiteDatabase提供query()方法专门用于查询数据</li>
<li>query()其中一个重载接受7个参数，分别为表名，列名，where约束条件，where中占位符的具体值，要group by的列，对group by的进一步约束，查询结果的排列方式，除表头外均可为null</li>
</ul>
<h2 id="第七章-跨程序共享数据"><a href="#第七章-跨程序共享数据" class="headerlink" title="第七章 跨程序共享数据"></a>第七章 跨程序共享数据</h2><hr>
<p><strong>（待续）</strong><br><br>    </p>
<h2 id="第八章-运用手机多媒体"><a href="#第八章-运用手机多媒体" class="headerlink" title="第八章 运用手机多媒体"></a>第八章 运用手机多媒体</h2><hr>
<p><strong>（待续）</strong><br><br>    </p>
<h3 id="使用通知"><a href="#使用通知" class="headerlink" title="使用通知"></a>使用通知</h3><p><strong>——通过状态栏发送消息</strong></p>
<hr>
<p><br>    </p>
<h4 id="通知的基本用法"><a href="#通知的基本用法" class="headerlink" title="- 通知的基本用法"></a>- 通知的基本用法</h4><ul>
<li>通过Context的getSystemService()方法获得NotificationManager对象对通知进行管理</li>
<li>getSystemService()接受一个字符串参数用于确定获取系统的哪个服务，传入Context.NOTIFICATION_SERVICE即可</li>
<li>使用NotificationCompat类的Bulider构造器创建Notification对象并设置各种属性</li>
<li>使用NotificationManager的notify()方法显示通知，该方法接受两个参数，id和Notification对象</li>
<li>实现通知的点击效果，需要调用setContentIntent()方法，该方法传入一个PendingIntent参数</li>
<li>关闭通知有两种方式setAutoCancel(true)和manager.cancel(id)</li>
</ul>
<pre><code>Intent intent = new Intent(this,MainActivity.class);
PendingIntent pi = PendingIntent.getActivity(this,0,intent,0);
NotificationManager manager = (NotificationManager)                        getSystemService(Context.NOTIFICATION_SERVICE);
Notification notification = new NotificationCompat.Builder(this)
        .setContentTitle(&quot;title&quot;)
        .setContentText(&quot;text&quot;)
        .setWhen(System.currentTimeMillis())
        .setSmallIcon(R.mipmap.ic_launcher)
        //小图必须设置否则无法显示通知
        .setLargeIcon(BitmapFactory.decodeResource(getResources(),R.mipmap.ic_launcher))
        .setContentIntent(pi)
        .setAutoCancel(true)
        .build();
manager.notify(1,notification);
</code></pre><p><br>    </p>
<h2 id="第九章-网络技术"><a href="#第九章-网络技术" class="headerlink" title="第九章 网络技术"></a>第九章 网络技术</h2><hr>
<p><br>    </p>
<h3 id="WebView用法"><a href="#WebView用法" class="headerlink" title="WebView用法"></a>WebView用法</h3><hr>
<ul>
<li>设置WebView    </li>
</ul>
<pre><code>protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    WebView webView = (WebView)findViewById(R.id.web_view);
    webView.getSettings().setJavaScriptEnabled(true);
    webView.setWebViewClient(new WebViewClient());
    webView.loadUrl(&quot;http://www.baidu.com&quot;);

}
</code></pre><ul>
<li>声明权限，访问网络需要声明权限，声明权限需要修改AndroidManifest.xml文件</li>
</ul>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;
</code></pre><p><br>    </p>
<h3 id="HTTP协议访问网络"><a href="#HTTP协议访问网络" class="headerlink" title="HTTP协议访问网络"></a>HTTP协议访问网络</h3><hr>
<p><br>    </p>
<h4 id="使用HttpURLConnection"><a href="#使用HttpURLConnection" class="headerlink" title="- 使用HttpURLConnection"></a>- 使用HttpURLConnection</h4><ul>
<li>使用流程</li>
</ul>
<pre><code>public class MainActivity extends AppCompatActivity implements View.OnClickListener {

private TextView responseText;

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    Button sendRequest = (Button)findViewById(R.id.button);
    responseText = (TextView)findViewById(R.id.response_text);
    sendRequest.setOnClickListener(this);
}

@Override
public void onClick(View v) {
    if(v.getId() == R.id.button){
        sendRequestWithHttpURLConnection();
    }
}

private void sendRequestWithHttpURLConnection(){
    new Thread(new Runnable() {
        @Override
        public void run() {
            HttpURLConnection connection = null;
            BufferedReader reader = null;
            try{

                URL url = new URL(&quot;https://www.baidu.com&quot;);
                // 获取HttpURLConnection实例需要new一个URL对象，并传入目标网络地址
                connection = (HttpURLConnection)url.openConnection();
                // 调用openConnection方法即返回需要的实例

                connection.setRequestMethod(&quot;GET&quot;);
                // 设置HTTP请求所使用的方法，一般为GET或POST，表示希望从服务器获取数据或者希望提交数据
                connection.setConnectTimeout(8000);
                // 设置连接超时毫秒数
                connection.setReadTimeout(8000);
                // 设置读取超时毫秒数
                InputStream in = connection.getInputStream();

                //读取输入流
                reader = new BufferedReader(new InputStreamReader(in));
                StringBuilder response = new StringBuilder();
                String line;
                while ((line = reader.readLine()) != null){
                    response.append(line);
                }
                showResponse(response.toString());
            }catch (Exception e){
                e.printStackTrace();
            }finally {
                if(reader != null){
                    try{
                        reader.close();
                    }catch (IOException e){
                        e.printStackTrace();
                    }
                }
                if (connection != null){
                    connection.disconnect();
                    // 将HTTP连接关闭
                }
            }
       }
    }).start();
}

private void showResponse(final String response){
    runOnUiThread(new Runnable() {
        @Override
        public void run() {
            responseText.setText(response);
            }
        });
    }
}
</code></pre><h4 id="解析JSON格式数据"><a href="#解析JSON格式数据" class="headerlink" title="- 解析JSON格式数据"></a>- 解析JSON格式数据</h4><p><strong>参考来源：<a href="http://www.cnblogs.com/SkySoot/archive/2012/04/17/2453010.html" target="_blank" rel="external">http://www.cnblogs.com/SkySoot/archive/2012/04/17/2453010.html</a></strong></p>
<ul>
<li>基础结构，JSON建构于两种结构，”名称/值”对的集合，值的有序列表</li>
<li>“名称/值”对：{ “firstName”: “Brett”, “lastName”:”McLaughlin”, “email”: “aaaa” }</li>
<li>“名称/数组”对</li>
</ul>
<pre><code>{ &quot;people&quot;: [
{ &quot;firstName&quot;: &quot;Brett&quot;, &quot;lastName&quot;:&quot;McLaughlin&quot;, &quot;email&quot;: &quot;aaaa&quot; },
{ &quot;firstName&quot;: &quot;Jason&quot;, &quot;lastName&quot;:&quot;Hunter&quot;, &quot;email&quot;: &quot;bbbb&quot;},
{ &quot;firstName&quot;: &quot;Elliotte&quot;, &quot;lastName&quot;:&quot;Harold&quot;, &quot;email&quot;: &quot;cccc&quot; }
}    
</code></pre><ul>
<li>用例</li>
</ul>
<pre><code>protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    Button sendRequest = (Button)findViewById(R.id.button);
    sendRequest.setOnClickListener(this);

}

@Override
public void onClick(View v) {
    getJsonWithHttpURLConnection();
}

private void getJsonWithHttpURLConnection() {
//不要试图在main的线程中打开网络连接
    new Thread(new Runnable() {
        @Override
        public void run() {
            BufferedReader rd = null;
            HttpURLConnection connection = null;
            JSONArray resultJsonArray;
            JSONObject json;

            try {
                URL url = new URL(&quot;http://news-at.zhihu.com/api/4/news/latest&quot;);
                connection = (HttpURLConnection) url.openConnection();
                connection.setRequestMethod(&quot;GET&quot;);
                rd = new BufferedReader(new InputStreamReader(connection.getInputStream()));

                //读取流中的字符
                StringBuilder sb = new StringBuilder();
                int cp;
                while ((cp = rd.read()) != -1) {
                sb.append((char) cp);
                }

                json = new JSONObject(sb.toString());
                resultJsonArray = json.getJSONArray(&quot;stories&quot;);
                // 获取Json数组

                Log.d(&quot;Main&quot;, resultJsonArray.getJSONObject(3).getString(&quot;title&quot;));
                // 获取数组中的值

            } catch (IOException e) {
                e.printStackTrace();
            } catch (JSONException e) {
                e.printStackTrace();
            } finally {
                if (rd != null) {
                    try {
                        rd.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
                if (connection != null) {
                    connection.disconnect();
                }
            }
        }
    }).start();
}
</code></pre><ul>
<li>回调机制，请求服务器时应该定义一个接口，在其中的onFinish方法中执行逻辑处理，而在onError方法中对异常状况进行处理</li>
<li>关于java、android的回调机制，参考<br><a href="http://blog.csdn.net/xiaanming/article/details/8703708/" target="_blank" rel="external">http://blog.csdn.net/xiaanming/article/details/8703708/</a><br><br></li>
</ul>
<h2 id="第十章-探究服务"><a href="#第十章-探究服务" class="headerlink" title="第十章 探究服务"></a>第十章 探究服务</h2><p><strong>——实现程序后台运行的方案</strong></p>
<hr>
<p><br>    </p>
<h3 id="Android-多线程编程"><a href="#Android-多线程编程" class="headerlink" title="Android 多线程编程"></a>Android 多线程编程</h3><hr>
<p><br>    </p>
<h4 id="线程的基本用法"><a href="#线程的基本用法" class="headerlink" title="- 线程的基本用法"></a>- 线程的基本用法</h4><ul>
<li>Runable 接口定义线程</li>
</ul>
<pre><code> class MyThread implements Runnable{
    @Override
    public void run() {

    }
}

...

MyThread myThread = new MyThread();
new Thread(myThread).start();
</code></pre><ul>
<li>匿名类实现接口</li>
</ul>
<pre><code>new Thread(new Runnable() {
            @Override
            public void run() {

            }
        }).start();
</code></pre><p><br>    </p>
<h4 id="异步消息处理机制"><a href="#异步消息处理机制" class="headerlink" title="- 异步消息处理机制"></a>- 异步消息处理机制</h4><ul>
<li>更新UI元素需要在主线程中进行</li>
<li>Android的异步消息由四个部分组成：Messag、handler、MessageQueue、Looper</li>
<li>Message，可以在内部携带少量消息，用于在不同线程之间传递数据，可选的字段类型有what，arg1，arg2，obj</li>
<li>Handler，用于发送和处理消息，发送消息使用sendMessage()方法，消息最终会传递到handleMessage中自动调用</li>
<li>MessageQueue，存放所有通过Handler发送的消息，每一个线程中只会有一个MessageQueue对象</li>
<li>Looper，调用loop()方法后开启取出和传递消息的循环发送到handler的handleMessage中，每一个线程只会有一个Looper对象</li>
</ul>
<pre><code>public  static final int UPDATE_TEXT = 1;
// 表示更新TextView的字段
private Handler handler = new Handler(){
    public void handleMessage(Message msg){
        switch (msg.what){
            case UPDATE_TEXT:
                text.setText(&quot;Nice to meet you&quot;);
                break;
            default:
                break;
        }
    }
};

public void onClick(View v) {
    switch (v.getId()){
        case R.id.button:
            new Thread(new Runnable() {
                @Override
                public void run() {
                    Message message = new Message();
                    message.what = UPDATE_TEXT;
                    handler.sendMessage(message);
                }
            }).start();
        }
    }
}
</code></pre><p><br>    </p>
<h4 id="使用AsyncTask"><a href="#使用AsyncTask" class="headerlink" title="- 使用AsyncTask"></a>- 使用AsyncTask</h4><ul>
<li>AsyncTask对异步消息处理做了很好的封装</li>
<li>AsyncTask包含三个泛型参数，Params，执行AsyncTask时需要使用的数据类型，Progress，进度单位的类型，Result，返回值类型</li>
<li>AsyncTask包含四个经常重写的方法:</li>
<li>onPreExecute()，后台任务开始之前调用，用于进行界面上的初始化操作</li>
<li>doInBackground(Params …)，用于运行耗时任务，所有代码都会在子线程中运行，不可以进行UI操作</li>
<li>onProgressUpdate(Progress …)，在调用publishProgress(Progress …)方法后马上被调用，可以进行UI操作，用参数中的数值进行相应的更新</li>
<li>onPostExecute，后台任务执行完毕并通过return返回时被调用，可以利用返回值进行一些收尾的UI操作</li>
<li>启动一个AsyncTask，使用new MyAsyncTask.execute()</li>
</ul>
<pre><code>public class DownloadTask extends AsyncTask&lt;Void,Integer,Boolean&gt;{

    @Override
    protected void onPreExecute(){
        progressDialog.show();      
    }

    @Override
    protected Boolean doInBackground(Void... params) {
        try{
            while (true){
                int downloadPrecent = doDownload();
                publishProgress(downloadPrecent);
                if (downloadPrecent&gt;=100){
                    break;
                }
            }
        }catch (Exception e){
            return false;
        }
        return true;
    }

    @Override
    protected void onProgressUpdate(Integer...values){       
        progressDialog.setMessage(&quot;Download&quot;+values[0]+&quot;%&quot;);
    }

    @Override
    protected void onPostExecute(Boolean result){
        progressDialog.dismiss();
        if(result){
            Toast.makeText(context,&quot;Download succeeded&quot;,
            Toast.LENGTH_SHORT).show();
        }
        else {
            Toast.makeText(context,&quot;Download failed&quot;,
            Toast.LENGTH_SHORT).show();
        }
    }
}
</code></pre><p><br>    </p>
<h3 id="服务的基本用法"><a href="#服务的基本用法" class="headerlink" title="服务的基本用法"></a>服务的基本用法</h3><hr>
<p><br>    </p>
<h4 id="定义一个服务"><a href="#定义一个服务" class="headerlink" title="- 定义一个服务"></a>- 定义一个服务</h4><ul>
<li>新建一个Service，有连个可选属性，Exported，表示是否让其他程序访问该服务，Enabled，表示是否启用这个服务</li>
<li>Service有三个常用方法，onCreated()会在服务创建时调用，onStartCommand()会在每次服务启动的时候调用，onDestroy()会在服务销毁的时候被调用</li>
<li>启用和停止服务，构建intent对象传入startService()和stopService()，这两个方法定义在context中，另外在Service的任何地方调用stopSelf()都可以让其停止下来</li>
</ul>
<pre><code>@Override
    public void onClick(View v) {
        switch (v.getId()){
            case R.id.start_service:
                Intent startIntent = new Intent(this,MyService.class);
                startService(startIntent);
                break;
            case R.id.stop_service:
                Intent stopIntent = new Intent(this,MyService.class);
                stopService(stopIntent);
                break;
            default:
                break;
        }
    }
</code></pre><p><br>    </p>
<h4 id="活动和服务进行通信"><a href="#活动和服务进行通信" class="headerlink" title="- 活动和服务进行通信"></a>- 活动和服务进行通信</h4><ul>
<li>在Service中新建继承自Binder的子类，在其中提供具体服务的方法，并在onBind中返回这个子类的实例</li>
<li>在活动中创建一个ServiceConnection类，重写onServiceConnected()方法和onServiceDisconnected()方法，分别在绑定与断开时会被调用</li>
<li>在onServiceConnected()方法中向下转型获得binder的实例，此时可以通过binder指挥服务</li>
<li>可能是书中的一个错误，应使用boolean值标记绑定状态并检查，否则重复解绑会抛出异常，参考 <a href="http://stackoverflow.com/questions/22079909/android-java-lang-illegalargumentexception-service-not-registered" target="_blank" rel="external">http://stackoverflow.com/questions/22079909/android-java-lang-illegalargumentexception-service-not-registered</a></li>
</ul>
<pre><code>public class MyService extends Service {

    private DownloadBinder mBinder = new DownloadBinder();

    class DownloadBinder extends Binder {

        public void startDownload(){
            Log.d(&quot;MyService&quot;,&quot;startDownload executed&quot;);
        }

        public int getProgress(){
            Log.d(&quot;MyService&quot;,&quot;getProgress executed&quot;);
            return 0;
        }
    }

    @Override
    public IBinder onBind(Intent intent) {
        return mBinder;
    }

    public MyService() {
    }

    @Override
    public void onCreate(){
        super.onCreate();
        Log.d(&quot;My Service&quot;,&quot;onCreate executed&quot;);
    }

    @Override
    public int onStartCommand(Intent intent,int flags,int startId){
        Log.d(&quot;My Service&quot;,&quot;onStartCommand executed&quot;);
        return super.onStartCommand(intent,flags,startId);
    }

    @Override
    public void onDestroy(){
        super.onDestroy();
        Log.d(&quot;My Service&quot;,&quot;onDestroy executed&quot;);
    }
}

...

private ServiceConnection connection = new ServiceConnection() {
        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            downloadBinder = (MyService.DownloadBinder)service;
            downloadBinder.startDownload();
            downloadBinder.getProgress();
        }

        @Override
        public void onServiceDisconnected(ComponentName name) {
        }
    };

    ...

        Intent bindIntent = new Intent(this,MyService.class);
        bindService(bindIntent,connection,BIND_AUTO_CREATE);
</code></pre><p><br>    </p>
<h4 id="服务的生命周期"><a href="#服务的生命周期" class="headerlink" title="- 服务的生命周期"></a>- 服务的生命周期</h4><ul>
<li>一个项目的任何位置调用了Context的startService()方法，相应的服务都会启动</li>
<li>每个服务只有一个实例，一个服务只要被启动或者绑定之后就会一直处于运行状态</li>
<li>只有当启动和绑定都取消时服务才会被销毁<br><br>    </li>
</ul>
<h3 id="服务的更多技巧"><a href="#服务的更多技巧" class="headerlink" title="服务的更多技巧"></a>服务的更多技巧</h3><hr>
<p><br>    </p>
<h4 id="使用前台服务"><a href="#使用前台服务" class="headerlink" title="-使用前台服务"></a>-使用前台服务</h4><ul>
<li>服务的系统优先级比较低，当出现内存不足时就有可能被被回收</li>
<li>若希望服务一直处于运行状态，考虑使用前台服务</li>
<li>创建前台服务，只需要修改Service的onCreate()方法，启动一个通知即可</li>
<li>startForeground方法接受两个参数，通知的id和Notification对象</li>
</ul>
<pre><code>public void onCreate(){
        super.onCreate();
        Log.d(&quot;My Service&quot;,&quot;onCreate executed&quot;);

        Intent intent = new Intent(this,MainActivity.class);
        PendingIntent pi = PendingIntent.getActivity(this,0,intent,0);
        Notification notification = new NotificationCompat.Builder(this)
                .setContentTitle(&quot;This is content title&quot;)
                .setContentText(&quot;This is content text&quot;)
                .setWhen(System.currentTimeMillis())
                .setSmallIcon(R.mipmap.ic_launcher)
                .setLargeIcon(BitmapFactory.decodeResource(getResources(),
                R.mipmap.ic_launcher))
                .setContentIntent(pi)
                .build();
        startForeground(1,notification);
    }
</code></pre><p><br>    </p>
<h4 id="使用IntentService"><a href="#使用IntentService" class="headerlink" title="- 使用IntentService"></a>- 使用IntentService</h4><ul>
<li>为避免出现ANR，耗时逻辑应该开启子线程去处理，一个比较标准的写法如下</li>
</ul>
<pre><code>@Override
public void onStartCommand(Intent intent, int flags,int startId){
    new Thread(new Runnable(){
        @Override
        public void run(){
        //处理耗时逻辑
        stopSelf();
        //可选
        }
    }).start();
}
</code></pre><ul>
<li>为避免忘记开启线程或停止服务，可以使用IntentService类</li>
</ul>
<pre><code>public class MyIntentService extends IntentService {

    public MyIntentService(){
        //调用父类的有参构造器
        super(&quot;MyIntentService&quot;);
    }

    @Override
    protected void onHandleIntent(Intent intent) {
        //处理具体逻辑
        Log.d(&quot;MyIntentService&quot;,&quot;Thread id is&quot;+Thread.currentThread().getId());
    }

    @Override
    public void onDestroy(){
        super.onDestroy();
        Log.d(&quot;MyIntentService&quot;,&quot;onDestroy executed&quot;);
    }
}
</code></pre><p><br>    </p>
<h2 id="第十一章-基于位置的服务"><a href="#第十一章-基于位置的服务" class="headerlink" title="第十一章 基于位置的服务"></a>第十一章 基于位置的服务</h2><hr>
<p><br>    </p>
<h2 id="第十二章-Material-Design"><a href="#第十二章-Material-Design" class="headerlink" title="第十二章 Material Design"></a>第十二章 Material Design</h2><hr>
<p><br>    </p>
<h2 id="第十三章-高级技巧"><a href="#第十三章-高级技巧" class="headerlink" title="第十三章 高级技巧"></a>第十三章 高级技巧</h2><hr>
<p><br>    </p>
<h3 id="全局获取Context"><a href="#全局获取Context" class="headerlink" title="全局获取Context"></a>全局获取Context</h3><hr>
<ul>
<li>在某些情况下无法获取Activity-Context，考虑使用全局获取Application-Context</li>
<li>需要在AndroidManifest中使用完整包名指定Application name为Application的子类</li>
<li>关于Activity-Context与Application-Context的区别，详见：<br><a href="http://www.jianshu.com/p/94e0f9ab3f1d" target="_blank" rel="external">http://www.jianshu.com/p/94e0f9ab3f1d</a><br><a href="http://www.cnblogs.com/wenjiang/archive/2012/10/15/2724923.html" target="_blank" rel="external">http://www.cnblogs.com/wenjiang/archive/2012/10/15/2724923.html</a></li>
</ul>
<pre><code>public class MyApplication extends Application {
    private static Context context;

    @Override
    public void onCreate() {
        super.onCreate();
        // 书中没有调用父类的onCreate()，编译器报错
        // 搜索之后发现两种做法都存在，估计影响不大
        context = getApplicationContext();
    }

    public static Context getContext() {
        return context;
    }
}
</code></pre><p><br>    </p>
<h3 id="使用Intent传递对象"><a href="#使用Intent传递对象" class="headerlink" title="使用Intent传递对象"></a>使用Intent传递对象</h3><hr>
<p><br>    </p>
<h4 id="Serializable-方式"><a href="#Serializable-方式" class="headerlink" title="- Serializable 方式"></a>- Serializable 方式</h4><ul>
<li>使用Intent的putExtra()方法传递自定义的类，需要实现Serializable</li>
<li>传入方法，intent.putExtra(“person_data”, person);</li>
<li>取出方法，Person person = (person) getIntent().getSerializableExtra(“person_data”);<br><br>    </li>
</ul>
<h4 id="Parcelable-方法"><a href="#Parcelable-方法" class="headerlink" title="- Parcelable 方法"></a>- Parcelable 方法</h4><ul>
<li>Serializable 方式传递对象会将对象序列化，效率较低，考虑使用Parcelable 方式</li>
<li>实现Parcelable接口需要重写describeContents()方法和writeToParcel方法()，还必须提供一个名为CREATER的常量</li>
<li>describeContents()方法直接返回0即可</li>
<li>writeToParcel()方法需将对象中的字段用write…()方法顺序写出</li>
<li>CREATER的泛型为被写入对象的类型，并要实现CreateFromName()方法和newArray方法</li>
<li>CreateFromName()方法需将对象中的字段用read…()方法顺序读出</li>
<li>newArray()方法只需new出一个被写入对象的数组，根据传入的变量作为数组大小即可</li>
<li>传入方法，intent.putExtra(“person_data”, person);</li>
<li>取出方法，Person person = (person) getIntent().getParcelableExtra(“person_data”);</li>
</ul>
<pre><code>public class Person implements Parcelable {
    private String name;
    private int age;

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
    dest.writeString(name);
    dest.writeInt(age);
    }

    public static final Parcelable.Creator&lt;Person&gt; CREATOR = new Parcelable.
            Creator&lt;Person&gt;(){

        @Override
        public Person createFromParcel(Parcel source){
            Person person = new Person();
            person.name = source.readString();
            person.age = source.readInt();
            return person;
        }

        @Override
        public Person[] newArray(int size){
            return new Person[size];
        }
    };
}
</code></pre><p><br>    </p>
]]></content>
      
        <categories>
            
            <category> 笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 安卓 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Core Java 笔记]]></title>
      <url>/2017/03/26/javaCore/</url>
      <content type="html"><![CDATA[<p>onRestart</p>
<a id="more"></a>
<h1 id="Core-Java-卷-1"><a href="#Core-Java-卷-1" class="headerlink" title="Core Java 卷 1"></a>Core Java 卷 1</h1><p><strong>（待续…）</strong></p>
<h2 id="第四章：类与对象"><a href="#第四章：类与对象" class="headerlink" title="第四章：类与对象"></a>第四章：类与对象</h2><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><ul>
<li>构造器与类同名</li>
<li>每个类可能有一个以上的构造器</li>
<li>构造器可以有0或多个参数</li>
<li><p>构造器没有返回值</p>
</li>
<li><p>构造器总是伴随着new操作一起调用</p>
</li>
<li>不要在构造器中定义与实例域重名的局部变量</li>
<li>仅当没有编写构造器时，系统才会提供一个无参构造器将实例域设置为默认</li>
<li>构造器的第一个语句若形如this（…），将调用同一个类的另一个构造器，可以重用代码</li>
</ul>
<h3 id="访问器"><a href="#访问器" class="headerlink" title="访问器"></a>访问器</h3><pre><code>public String getName()
{
    return name;
}
</code></pre><ul>
<li>访问器只返回实例域值</li>
<li>一个方法可以访问所属类的所有对象的私有数据</li>
<li>注意不要编写返回引用可变对象的访问器方法</li>
</ul>
<h3 id="域"><a href="#域" class="headerlink" title="域"></a>域</h3><ul>
<li>在实现一个类时，应该将所有的数据域都设为私有</li>
<li>获得和设置实例域的值，应提供私有的数据域，公有的访问器，公有的域更改器</li>
<li>每个对象的实例域都有一份自己的拷贝，每个类只有一个static静态域，静态域属于类而非对象</li>
<li>public static final double PI ， 用这种方法定义一个常量</li>
<li>初始化块</li>
</ul>
<pre><code>class Employee
{
private static int nextId；
private int id；
private String name；
{
id = nextId;
nextId++;
}
}
</code></pre><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li>java总是按值传递，方法得到的是参数的拷贝</li>
<li>方法不能修改一个基本数据类型的参数，但可以修改对象参数的状态</li>
<li>方法不能让对象参数引用一个新的对象</li>
<li>java允许重载任何方法，但返回类型不是方法签名的一部分，不能单独修改</li>
<li>参数变量会把同名的实例域屏蔽，用this.* 可以解除屏蔽<br>this.name=name</li>
<li>某个资源需要在使用完后立刻被关闭，应该使用close完成清理操作</li>
</ul>
<h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><ul>
<li>使用包的目的：组织自己的代码，方便与别人的代码库分开管理；确保类名唯一性</li>
<li>使用import或者类全名来引用各个包中的类 ,使用package将一个类放入包中</li>
<li>为实现类名的唯一性，通常将因特网域名以逆序的形式作为包名，如com.abc.efg</li>
<li>从编译器的角度来看，嵌套的包之间没有任何关系，例如java.util和java.util.jar</li>
<li>如果类名冲突</li>
</ul>
<pre><code>import java.util.*;
import java.sql.*;
import java.util.Date;//指明选定的类
</code></pre><ul>
<li>引入静态方法和静态域<br>import static java.lang,System.*;</li>
</ul>
<h3 id="类设计技巧"><a href="#类设计技巧" class="headerlink" title="类设计技巧"></a>类设计技巧</h3><ul>
<li>一定要保证数据私有</li>
<li>一定要对数据初始化</li>
<li>不要在类中使用过多的基本类型，用其他类去代替他们</li>
<li>将指责过多的类分解</li>
<li>类名和方法名要能够体现它们的职责</li>
<li>优先使用不可变的类</li>
</ul>
<h2 id="第五章：继承"><a href="#第五章：继承" class="headerlink" title="第五章：继承"></a>第五章：继承</h2><h3 id="is-a-关系"><a href="#is-a-关系" class="headerlink" title="is-a 关系"></a>is-a 关系</h3><ul>
<li>is-a 关系是继承的一个明显特征：它表明子类的每一个对象也是超类</li>
<li>is-a 规则的另一种表述法是置换法则：它表明程序中出现超类对象的任何地方都可以用子类对象置换</li>
</ul>
<h3 id="子类"><a href="#子类" class="headerlink" title="子类"></a>子类</h3><pre><code>public class Manager extends Employee
{
    添加方法和域
}
</code></pre><ul>
<li><p>子类的方法必须通过公有的接口（访问器）才能访问父类定义的私有域</p>
<pre><code>super.getSalary()
</code></pre></li>
<li><p>子类构造器：子类必须利用父类的构造器对父类的私有域进行初始化，如果没有显式的调用超类的构造器，则自动调用超类的默认无参构造器，若该构造器不存在则报错</p>
<pre><code>public Manager(String name,double salary,int  year,int mouth,int day)
{ 
  super(name l,salary,year,month,day);
 bonus=0;
 }
</code></pre></li>
<li><p>子类引用类型不能指向父类，  超类数组引用可以被赋予子类数组</p>
</li>
<li>用final阻止某类被继承，或某方法被覆盖</li>
</ul>
<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><ul>
<li>使用类型转换的唯一原因：使用对象的全部功能</li>
<li><p>在进行类型转换时先查看是否能成功地转换，否则可能产生编译错误</p>
<pre><code>  if(staff[1] instanceof Manager)
{
    boss = (Manager)staff[1];
}
</code></pre></li>
<li>只能在继承层次内进行类型转换</li>
<li>一般情况下应少用类型转换</li>
</ul>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ul>
<li>为了提高程序的清晰度，包含一个或多个抽象方法的类本身必须被声明为抽象</li>
<li>抽象类可以有具体的域和方法</li>
<li><p>抽象类不能被实例化，但可以有构造器给子类调用</p>
<pre><code>public abstract class Person
{
        private String name;
        public Person(String name)
        {
        this.name =name;
        }

        public abstract String getDescription();

        public String getName()
        {
            return name;
        }
}
</code></pre></li>
<li><p>扩展抽象类时定义部分或者不定义抽象方法，就必须把子类标记为抽象;定义全部抽象方法，则子类不再抽象</p>
</li>
<li>抽象类的非抽象方法可用不重写</li>
<li>可以定义一个抽象类的引用对象，但它只能引用非抽象子类的对象（多态）</li>
</ul>
<h3 id="受保护访问"><a href="#受保护访问" class="headerlink" title="受保护访问"></a>受保护访问</h3><ul>
<li>protected让类对本包和所有子类可见</li>
<li>prtected允许方法或域被子类访问</li>
</ul>
<h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><ul>
<li>Object类是所有类的超类，可以利用Object类的引用对象引用任何类的实例</li>
<li>java中只有基本类型不是对象</li>
<li>Oject类中，equals方法用于检测引用的相等性，然而许多类重写了equals方法，使其用来检测状态的相等性</li>
<li>如果在子类中重新定义equals，一般要包含调用super.equals（other）</li>
<li>hashCode方法，是由对象导出的一个整形值，Objec类的hashCode方法导出对象的存储地址，可以调用hash方法重写hashCode使根据内容导出</li>
<li>重写equals方法就要重写hashCod方法</li>
<li>toString方法，用于返回对象值的字符串</li>
</ul>
<h2 id="第六章-接口与内部类"><a href="#第六章-接口与内部类" class="headerlink" title="第六章 接口与内部类"></a>第六章 接口与内部类</h2><h3 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口 interface"></a>接口 interface</h3><ul>
<li>接口不是类，而是对类的一组需求描述，不能使用new来实例化</li>
<li>接口中的所有方法自动地属于public，所有域自动属于public static final，因此接口中的方法不必特地声明这些关键字</li>
<li>提供实例域和方法实现的任务应该由实现接口的那个类来完成</li>
<li><p>实现一个接口要在声明时使用关键字implement以及定义接口中的所有方法，一个类可以声明多个接口</p>
<pre><code>class Employe implements Cloneable,Comparable
</code></pre></li>
<li><p>可以用instanceof检查对象是否实现了某个特定的接口</p>
<pre><code>if(anObject instanceof Comparable)
//使用sort方法的对象必须实现这个接口，实现这个接口必须实现compareTo方法
</code></pre></li>
<li><p>与建立类的继承关系一样，接口也可以被扩展</p>
<pre><code>public interface Power extends Moveable
{
    double milesPerGallon;
    double SPEED_LIMIT=95;
}
</code></pre></li>
<li>有些接口只定义了常量，实现它们的类自动继承这些常量，但这种用法似乎偏离了接口设计的初衷，最好不要使用</li>
</ul>
<p><strong>第十版中新增的lambda表达式、静态方法、默认方法和对象克隆暂时略过</strong></p>
<h3 id="内部类-inner-class"><a href="#内部类-inner-class" class="headerlink" title="内部类 inner class"></a>内部类 inner class</h3><ul>
<li>内部类是一个定义在另一个类中的类</li>
<li>内部类，可以访问外部类的所有数据；可以对同一个包的其他类隐藏；可以用匿名内部类减小代码量</li>
<li>内部类中所有的静态域都必须是final</li>
<li>局部内部类，声明在方法中，可以访问外部类的域和局部变量，但局部变量必须是final</li>
<li><p>匿名内部类，在创造实例的时候定义，可以临时实现一个接口，也可以扩展一个类，这样的新类自然没有类名，也就没有构造器，但参数会传给父类的构造器</p>
<pre><code>new SuperType(construction parameter)
{
    inner class methods and data
    // SuperType可以是接口，也可以是类

}
</code></pre></li>
<li>静态内部类，内部类不需要引用外部对象时将其声明为static，静态内部类可以有静态域和方法</li>
<li>声明在接口中的内部类自动称为static和public</li>
</ul>
<h2 id="第七章-异常、断言和日志"><a href="#第七章-异常、断言和日志" class="headerlink" title="第七章 异常、断言和日志"></a>第七章 异常、断言和日志</h2><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><ul>
<li>某个方法不能够采取正常的途径完成任务，就可以通过抛出一个封装了错误信息的对象退出方法，此时方法不会返回任何值</li>
<li>异常对象都是派生于throwable类的一个实例</li>
<li>运行时异常，RumtimeException，包括：错误的类型转换，数组访问越界，访问null指针<blockquote>
<p>“如果出现RumtimeException，那么就一定是你的问题。”</p>
</blockquote>
</li>
<li>输入输出异常，IOException，包括：试图在文件尾部后面读取数据，试图打开一个不存在的文件，试图根据给定的字符串查找不存在的class对象等等</li>
<li>自己编写方法时不必声明所有抛出的异常，但必须声明所有可能抛出的受查异常，如果没有声明所有的受查异常，编译器将报错</li>
<li>如果一个方法声明将会抛出一个特定类型的异常，那么结果它可能抛出这个类型或其子类的异常</li>
<li><p>抛出已存在异常类的步骤：找到一个合适的异常类，创造这个类的一个对象，将对象抛出            </p>
<pre><code>String readData(Scanner in)throws EOFException
{
...
while(...)
{
    if(!in.hasNext())
    {
    if(n&lt;len)
    throw new EOFException();
    }
}
}
</code></pre></li>
<li><p>创建异常类：定义一个派生于Exception或其子类的类，该类应该包含两个构造器：一个为默认构造器，另一个为带有详细信息的构造器，超类Throwable的toString方法会打印出这些详细信息，e.getMessage可以得到错误信息</p>
<pre><code>Class FileFormatException extends IOException
{
    public FileFormatException(){}
    public FileFormatException(String gripe)
    {
        super(gripe);
    }
}
</code></pre></li>
</ul>
<h3 id="异常语块"><a href="#异常语块" class="headerlink" title="异常语块"></a>异常语块</h3><ul>
<li><p>使用try/catch语块，如果try中的任何代码抛出了catch说明的异常类，那么try中剩余的语句将被跳过，执行catch中的处理器代码</p>
<pre><code>try
{
    code
    more code
    more code
}
catch(ExceptionType e)
{
    handler for this type
}
catch(ExceptionType2 e)
{
    handler for this type
}
catch(ExceptionType3 e)
{
    handler for this type
}
</code></pre></li>
</ul>
<ul>
<li>最好的办法是方法只抛出异常，然后什么也不做，由调用者去处理，而不是尝试在方法中解决问题，唯一的例外是如果覆盖了超类的一个没有异常的方法，就必须捕获每一个异常</li>
<li><p>解决过程相同时可以捕获多个异常，但这些异常不能存在子类关系</p>
<pre><code>catch(FileNotFoundException|EOFException e)
</code></pre></li>
<li><p>包装异常，catch字句可以再次抛出一个异常，当要抛出更高级的异常时建议使用包装的技巧</p>
<pre><code>try
{
    access the database
}
catch(SQLException)
{
    Throwable se = new ServletException(&quot;database error&quot;);
    se.initCause(e);
    throw se; 
}

...
Throwable e=se.getCause();
...
</code></pre></li>
<li><p>finally 字句，不管是否有异常被捕获，finally字句中的代码都会被执行，try语句可以只有finally字句而没有catch字句</p>
<pre><code>InputStream in = new FileInputStream(...);
try
{
    code that might throw exception
}
catch(IOException)
{
    show error message
}
finally
{
    in.close
}
</code></pre></li>
<li><p>当利用return语句在try中退出时，finally字句中的内容将被执行，如果finally语句中含有return，返回值将被后者覆盖</p>
</li>
<li><p>带资源的try语句，假设资源属于一个实现了AutoCloseable接口的类，try块退出时会自动调用声明了异常的close方法，因此用于关闭资源的finally语句可以省略，另外可以指定多个资源</p>
<pre><code>try(Resoure res = ...)
{
        work with res
}
</code></pre></li>
</ul>
<hr>
<pre><code>try(Scanner in = new Scanner(new FileInputStream(&quot;/usr/share/dict/words&quot;),&quot;UTF-8&quot;);
PrintWriter out = new PrintWriter(&quot;out.txt&quot;))
{
    while(in.hasNext())
        out.println(in.next().toUpperCase());
}
</code></pre><ul>
<li>堆栈轨迹 <strong>(待续…)</strong></li>
</ul>
<h3 id="使用异常机制的技巧"><a href="#使用异常机制的技巧" class="headerlink" title="使用异常机制的技巧"></a>使用异常机制的技巧</h3><ul>
<li>异常处理不能代替简单的if测试，这样会会花费更多运行时间</li>
<li>不要过分细化异常，与其反复使用try-catch，不如让一个try语块捕获多个异常</li>
<li>利用异常的结构层次：不要只抛出RuntimeException异常，应该寻找更加适当的子类或者创建自己的异常类；不要只捕获Thowable异常，否则代码会更难读、更难维护</li>
<li>不要压制异常</li>
<li>有时传递异常比捕获异常更有必要</li>
</ul>
<h3 id="使用断言-assert"><a href="#使用断言-assert" class="headerlink" title="使用断言 assert"></a>使用断言 assert</h3><ul>
<li>开启与禁用断言，默认关闭，在运行程序时使用-ea选项启用</li>
<li>断言机制允许在测试期间向代码插入一段检查语句，当代码发布时，这些插入的检查语句会被自动移走</li>
<li>断言失败是致命的，不可恢复的错误；断言只用于开发和检查阶段<blockquote>
<p>“在靠近海岸时穿上救生衣，但在海中央时就把救生衣抛掉吧”</p>
</blockquote>
</li>
<li>断言的两种形式：assert 条件；  assert 条件：表达式；</li>
<li>表达式的值可以传入AssertionError的构造器转换成消息字符串显示出来</li>
</ul>
<h3 id="记录日志"><a href="#记录日志" class="headerlink" title="记录日志"></a>记录日志</h3><p><strong>Java自带的log工具已不再流行，取而代之的应该是用log4j，暂时先只学习自带log的用法</strong><br>*</p>
<pre><code>...        
log = Logger.getLogger(&quot;aLog&quot;);
//新建日志对象
log.setLevel(Level.INFO);
try{
    ConsoleHandler consoleHandler = new ConsoleHandler();
    consoleHandler.setLevel(Level.ALL);
    log.addHandler(consoleHandler);
    //ConsoleHandler 向控制台发送日志消息
    FileHandler fileHandler = new FileHandler(&quot;/Users/alberthumbert/Desktop/log.text&quot;);
    log.addHandler(fileHandler);
    //FileHandler 将日志消息发送到指定文件中
    }catch(IOException e){}

log.info(&quot;test&quot;);
//发送消息
</code></pre><h2 id="第八章-泛型程序设计"><a href="#第八章-泛型程序设计" class="headerlink" title="第八章 泛型程序设计"></a>第八章 泛型程序设计</h2><p><small><br>在泛型之前，如ArrayList的类只维护一个object类的数组，当获取一个值时必须进行强制类型转换，加入对象时也没有错误检查，而后泛型提供了很好的解决方案：参数化类型<br></small></p>
<blockquote>
<p>“泛型的魅力在于，使程序具有更好的可读性和安全性”</p>
</blockquote>
<h3 id="定义简单泛型类"><a href="#定义简单泛型类" class="headerlink" title="定义简单泛型类"></a>定义简单泛型类</h3><ul>
<li><p>一个泛型类就是具有一个或多个类型变量的类</p>
<pre><code>public class Pair&lt;T&gt;
{     //或者public class Pair&lt;T,U&gt;

    private T first;
    private T second;

    public Pair()
    { first = null ; second = nulll;    }
    public Pair( T first , T second )
    {    this.first = first; this.second =second; }

    public T getFirst(){ return first; }
    public T getSecond(){ return second; }

    public void setFirst( T newValue){ first = newValue ; }
    public void setSecond( T newValue){ Second = newValue ; }
</code></pre></li>
</ul>
<pre><code>}
</code></pre><ul>
<li>类型变量使用大写形式，且比较短，java库中变量E表示集合的元素类型，K和V分别表示表的关键字与值的类型。T、U、S等表示“任意类型”，用具体的类型替换类型变量就可以实例化泛型类型，如Pair<string></string></li>
</ul>
<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><ul>
<li><p>泛型方法可以定义在普通类中也可以定义在泛型类中，类型变量放在修饰符的后面，返回类型的前面</p>
<pre><code>class ArrayAlg
{
    public static &lt;T&gt; T getMiddle(T ... a)
    //省略号表示可变参数，用数组包裹
    {
        return a[a.length/2];
    }
}

...
String middle = ArrayAlg.&lt;String&gt;getMiddle(&quot;John&quot;,&quot;Q&quot;,&quot;Public&quot;);
...
</code></pre></li>
<li><p>在大多数情况下泛型方法可以省去泛型变量，参数给了编译器足够的信息进行判断</p>
</li>
</ul>
<h3 id="类型变量的限定"><a href="#类型变量的限定" class="headerlink" title="类型变量的限定"></a>类型变量的限定</h3><ul>
<li><p>有时要确信所属的类具有特定的IS-A关系，可以使用限定变量类型</p>
<pre><code>public static &lt; T extends Comparable &gt; T min( T[] a)
{
    code for someting...
}
</code></pre></li>
<li>类型变量和绑定类型可以是类也可以是接口，都使用extends关键字</li>
<li><p>一个类型变量或通配符可以有多个限定，如果用作为限定，它一定是列表中的第一个</p>
<pre><code>T extends Comparable &amp; Serializable
</code></pre></li>
<li></li>
</ul>
<p><strong>(待续…)</strong></p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h3><ul>
<li>以队列为例，每一个队列的实现都可以通过一个实现了Queue接口的类来表示</li>
<li>可以直接调用实现了集合接口的类，如ArrayDeque、LinkedList等</li>
<li><p>集合的基本接口是Collection和Map，Collection接口有两个基本方法，add方法用于添加元素，Iterator(迭代器)方法用于返回一个实现了Iterator接口的对象</p>
<pre><code>public interface Collection&lt;E&gt;
{    
        boolean add(E element);                                                                        Iterator&lt;E&gt; iterator();

}
</code></pre></li>
<li><p>迭代器，Iterator接口含有next方法和hasNext方法。想要查看集合中的每一个元素，就请求一个迭代器，在hasNext返回true时反复调用next方法，编译器将for each循环翻译为带有迭代器的循环，它可以与任何实现了Iterable接口的对象一起工作。Collection接口就扩展了Iterable接口</p>
</li>
</ul>
<h3 id="链表-LinkedList"><a href="#链表-LinkedList" class="headerlink" title="链表 LinkedList"></a>链表 LinkedList</h3><ul>
<li><p>在Java中所有链表其实都是双向链表，基本操作：            </p>
<pre><code>LinkedList&lt;String&gt; staff = new LinkedList&lt;String&gt;();
staff.add(&quot;amy&quot;);
staff.add(&quot;amy&quot;);
staff.add(&quot;amy&quot;);
staff.add(&quot;bob&quot;);
staff.add(&quot;carl&quot;);
//add方法把对象添加到尾部

Iterator&lt;String&gt; iter = staff.iterator();
//使用泛型避免强制转换
String first =  iter.next();
iter.remove();
//迭代器通常用于遍历容器
staff.remove(0);

String second = staff.get(1);
System.out.println(second);

for(String e:staff)
{
    System.out.println(e);

}
</code></pre></li>
<li>只有对自然有序的集合使用迭代器添加元素才有实际意义</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>ListIterator的迭代器的add和set都是在迭代器所在位置的前一个位置进行操作（实际上迭代器的位置应该理解为在两个元素之间），并且set会取代链表元素</li>
<li>不要用复数的迭代器同时遍历和结构性修改链表，那样会抛出异常，注意set不被视为结构性修改</li>
<li><p>链表不支持快速随机访问，它必定会从头开始查找，如果要用整数索引访问元素，通常不用链表，更不要写出下面这种效率极低的代码，请使用迭代器</p>
<pre><code>for（int i=0;i&lt;list.size;i++）
do something with list.get(i);
</code></pre></li>
<li>建议避免使用整数索引表示链表中位置的所有方法。如果需要对集合进行随机访问，请使用ArrayList</li>
<li>使用链表的唯一理由就是尽可能的减少在链表中间插入或删除元素所付出的代价，如果链表只有少数几个元素，完全可以使用ArrayList</li>
</ul>
<h3 id="数组列表-ArrayList"><a href="#数组列表-ArrayList" class="headerlink" title="数组列表 ArrayList"></a>数组列表 ArrayList</h3><ul>
<li>ArrayList封装了一个动态再分配的对象数组</li>
<li>在只使用一个线程， 或者不需要同步时使用ArrayList而非Vector，Vector的同步操作会耗费大量时间</li>
<li>使用索引的get和set方法对ArrayList类非常适用</li>
</ul>
<h3 id="散列集-hash-table"><a href="#散列集-hash-table" class="headerlink" title="散列集 hash table"></a>散列集 hash table</h3><ul>
<li>散列表可以快速地查找所需要的对象，它为每个对象准备一个散列码（整数），散列码是由对象实例域产生的一个整数，不同的数据域会有不同的散列码</li>
<li>在Java中，散列表用链表数组实现，每个链表被称为桶，对象的散列码与桶的总数取余所得到的就是对象的索引</li>
<li><p>散列表用语实现几种重要的数据结构，如HashSet类</p>
<pre><code>    public class SetText {
public static void main(String[] args)
{
Set&lt;String&gt; words =new HashSet&lt;String&gt;();
long totalTime = 0;
try(Scanner in = new Scanner(System.in))
{
    while(in.hasNext()){
    String word = in.next();
    if(word.equals(&quot;Q&quot;))break;
    long callTime = System.currentTimeMillis();
    words.add(word);
    callTime = System.currentTimeMillis()-callTime;
    totalTime += callTime;

    }
}

Iterator&lt;String&gt; iter = words.iterator();
for(int i=1;i&lt;=20&amp;&amp;iter.hasNext();i++)
System.out.println(iter.next());
System.out.println(&quot;...&quot;);
System.out.println(words.size()+&quot; words &quot;+totalTime+&quot; miliseconds.&quot;);

    }

}
</code></pre></li>
<li>散列集的迭代器只是依次访问所有桶，而元素的位置是随机的，所以只有不关心元素的顺序时才适用HashSet</li>
<li>contains方法用于快速查找某元素是否在集合中，它只在某个桶中查找元素，而不需要遍历整个集合</li>
<li>如果要自定义类就要负责实现这个类的散列码方法，并且让散列码方法与equals方法兼容</li>
</ul>
<h3 id="树集-TreeSet"><a href="#树集-TreeSet" class="headerlink" title="树集 TreeSet"></a>树集 TreeSet</h3><ul>
<li>树集是个有序集合，可以任意插入元素，每个元素将自动排序</li>
<li>树集添加元素比散列集要慢，但比算上检查重复的时间还是要比数组和链表快的</li>
<li>树集的任意两个元素必须可比，并且只有相等时才为0</li>
<li>通过使用一个定制的比较器来按照描述信息排序</li>
</ul>
<p><strong>(待续…)</strong></p>
<h3 id="队列-Quque"><a href="#队列-Quque" class="headerlink" title="队列 Quque"></a>队列 Quque</h3><ul>
<li>队列，可以在尾部添加元素，头部删除元素</li>
<li>双端队列，可以在头部和尾部同时添加或删除元素</li>
<li>优先级队列，可以按任意的顺序插入，却总是按排序检索，用自我调整的二叉树实现，添加和删除的元素会移动到根</li>
</ul>
<h3 id="映射-map"><a href="#映射-map" class="headerlink" title="映射 map"></a>映射 map</h3><ul>
<li><p>Java为映射提供了两个通用实现，HashMap和TreeMap，如果需要排序就使用TreeMap</p>
</li>
<li><p>每当往映射中添加对象时必须提供一个键，要检索对象时必须提供一个键, 如果在映射中没有给定键的对应信息，get返回null，也可以用getOrDefault (java 8) 方法将null修改为返回自定义的值</p>
</li>
</ul>
<pre><code>  Map&lt;String, Employee&gt; staff = new HashMap();
  // 这里的键是一个字符串
  Employee harry = new Employee(&quot;Harry Hacker&quot;);
  staff.put(&quot;987-98-9996&quot;,harry);

String id = &quot;987-98-9996&quot;;
e = staff.get(id);    

Map&lt;String, Integer&gt; scores=...;
int score = score.get(id , 0);
//若id不存在就返回0      
</code></pre><ul>
<li>对同一个键使用两次put方法，第二个值会代替第一个值，可以使用putIfAbsent (java 8) 方法，它只在原先键存在时才会放入一个值</li>
</ul>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><strong>(待续…)</strong></p>
<h2 id="第十-十二章-图形程序设计"><a href="#第十-十二章-图形程序设计" class="headerlink" title="第十 ~ 十二章 图形程序设计"></a>第十 ~ 十二章 图形程序设计</h2><h3 id="框架-JFrame"><a href="#框架-JFrame" class="headerlink" title="框架 JFrame"></a>框架 JFrame</h3><ul>
<li>顶层窗口（没有包含在其他窗口中的窗口）被称为框架</li>
<li>如果没有明确地指定框架的大小，所有的框架的默认值为0*0像素</li>
<li>JFrame有四层面板，程序员只用关心内容隔窗（content pane）</li>
<li>在1.4以后的版本中可以直接使用frame.add添加组件</li>
<li>使用ToolKit类得到本地窗口系统信息</li>
</ul>
<pre><code>class SizedFrame extends JFrame
{

public SizedFrame(){
Toolkit kit =Toolkit.getDefaultToolkit();
//Toolkit对象中有许多关于本地系统窗口的方法
//使用Toolkit有利于尺寸的兼容性
Dimension screenSize =kit.getScreenSize();
//这个方法会返回一个Dimension对象
//Dimension对象持有屏幕的尺寸
int screenHeight=screenSize.height;
int screenWidth=screenSize.width;

setSize(screenWidth/2,screenHeight/2);
//JFrame的setSize方法设置框架大小
setLocationByPlatform(true);
//该方法让窗口系统控制窗口位置
//通常会是距离最后一个窗口很少偏移量的位置

Image img =new ImageIcon(&quot;icon.gif&quot;).getImage();
//加载图标
setIconImage(img);
//设置标题栏图标

}
</code></pre><ul>
<li><p>新建一个框架，需要注意以下步骤</p>
<pre><code>JFrame frame = new SizedFrame();
frame.setTitle(&quot;SizedFrame&quot;);
//设置标题栏的文字frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    //定义关闭的响应动作
    frame.setVisible(true);
    //框架默认不可见，为了显示框架需要调用该方法
</code></pre></li>
</ul>
<h3 id="绘制组件"><a href="#绘制组件" class="headerlink" title="绘制组件"></a>绘制组件</h3><ul>
<li>绘制一个组件，需要定义一个扩展JComponent的类，并覆盖其中的paintComponent方法</li>
<li><p>paintComponent有一个Graphics类型的参数，它保存着用于绘制图形和文本的设置</p>
<pre><code>Class MyComponent extends JComponent
{
    public void paintComponent(Graphics g)
    {
        绘制的代码
    ｝
    ｝
</code></pre></li>
<li><p>一定不要自己调用paintComponent方法，这个方法将被系统在有需要的时候自动调用，程序员可以使用repaint方法刷新屏幕<br><strong>（待续…）</strong></p>
</li>
</ul>
<h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><ul>
<li>事件源是一个能够注册监听器对象并发出事件对象的对象</li>
<li>监听器对象是一个实现了特定监听器接口的类的实例</li>
<li>当事件发生时，事件源将事件对象传递给所有注册的监听器</li>
<li>监听器对象将利用事件对象中的信息决定如何对事件作出响应</li>
<li>事件相关的信息封装在一个事件对象中，所有的事件对象最终都派生于EventObject类</li>
<li><p>actionPerformed方法是ActionListener中唯一的方法，事件监听器对象通常需要执行一些对其他对象可能产生影响的操作，可以策略性地将监听器类放置在需要修改状态的那个类中</p>
<pre><code>class MyListener implements ActionListener
｛
...
public void actionPerformed（ActionEvent event）
{ 
//实现ActionListener接口，监听类必须有一个actionPerformed方法

            响应方法
}
}
</code></pre></li>
<li><p>使用匿名类可以相对简洁地定义监听类</p>
</li>
</ul>
<h3 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h3><ul>
<li>窗口监听类可以捕获窗口事件，但必须实现七个方法，为此，有一个窗口适配器实现了所有方法，但没有做任何事情</li>
<li><p>通过覆盖某一个方法扩展适配器的功能</p>
<pre><code>frame.addWindowListener(new WindowAdapter(){
//这便是一个匿名类
public void windowClosing(WindowEvent e)
{
if()....
}

})
</code></pre></li>
</ul>
<h3 id="动作和鼠标事件"><a href="#动作和鼠标事件" class="headerlink" title="动作和鼠标事件"></a>动作和鼠标事件</h3><p><strong>（待续…）</strong></p>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><ul>
<li>通常组件放在容器中，布局管理器决定容器中组件具体放置的位置和大小</li>
<li>按钮、文本域和其他用户界面元素都继承于Component类，组件可以放置在面板JPanel这样的容器中</li>
<li>JPanel默认使用流布局管理器，它完全控制每个组件的放置位置</li>
<li>JFrame默认使用边框布局管理器，它允许为每个组件选择一个位置（CENTER, NORTH,SOUTH,EAST,WEST），但可能会进行覆盖</li>
<li>使用panel.revalidate方法会重新计算所有组件的大小，然后立即重新布局</li>
</ul>
<h3 id="文本域-JTextField"><a href="#文本域-JTextField" class="headerlink" title="文本域 JTextField"></a>文本域 JTextField</h3><ul>
<li><p>文本域只能接受单行输入</p>
<pre><code>JPanel textPanel=new JPanel();
JTextField textField = new JTextField(&quot;default input&quot;,20);
//设置初始输入和显示长度
textPanel.add(textField);
frame.add(textPanel,BorderLayout.SOUTH);
textField.setClumns(10);
//设置长度
textPanel.revalidate;
String text = textField.getText.trim();
//trim方法取出前后多余的空格
</code></pre></li>
<li>在监听器中使用getText方法可以获取输入的文本</li>
</ul>
<h3 id="标签-JLabel"><a href="#标签-JLabel" class="headerlink" title="标签 JLabel"></a>标签 JLabel</h3><ul>
<li><p>标签是容纳文本的组件，它没有任何装饰，也不响应用户输入，但可以用来标示各种组件</p>
<pre><code>JLabel label = new JLabel(&quot;user name :&quot;,SwingContants.Right);
</code></pre></li>
<li><p>标签实现了SwingContants接口，接口中定义了几个指定排列方式的常量，因此可以制定标签的对齐方式</p>
</li>
<li>标签支持HTML语法</li>
</ul>
<h3 id="文本区-JTextArea"><a href="#文本区-JTextArea" class="headerlink" title="文本区 JTextArea"></a>文本区 JTextArea</h3><ul>
<li>文本区支持多行输入</li>
<li>文本区不限制输入的行数列数，设置参数只会影响显示的状态</li>
<li><p>如果文本超出显示范围，剩下的文本会被裁掉，通过开启换行可以避免这种状况</p>
<pre><code>JTextArea textArea = new JTextArea(8,40);
//设置显示大小
textArea.setLineWrap(true);
//开启自动换行
//建议将所有文本域放入滚动窗格之中
</code></pre></li>
</ul>
<h3 id="滚动窗格-JScrollPane"><a href="#滚动窗格-JScrollPane" class="headerlink" title="滚动窗格 JScrollPane"></a>滚动窗格 JScrollPane</h3><ul>
<li>这是一种为任意组件添加滚动功能的机制，不是文本区特有</li>
<li>滚动条会自动出现自动消失，无需另外编写程序</li>
</ul>
<pre><code>JScrollPane scrollPane = new JScrollPane(textArea);
frame.add(scrollPane,BorderLayout.CENTER);
</code></pre><h3 id="复选框-JCheckBox"><a href="#复选框-JCheckBox" class="headerlink" title="复选框 JCheckBox"></a>复选框 JCheckBox</h3><ul>
<li>用户点击复选框会激发一个事件</li>
<li>通常为多个复选框选定共同的监听器</li>
<li><p>用isSelected方法获取复选框状态</p>
<pre><code>final JCheckBox checkBox1 = new  JCheckBox(&quot;1&quot;);
final JCheckBox checkBox2 = new  JCheckBox(&quot;2&quot;);
ActionListener boxListener = new ActionListener(){
    public void actionPerformed(ActionEvent event){
        if(checkBox1.isSelected())
            System.out.println(&quot;1&quot;);
        if(checkBox2.isSelected())
            System.out.println(&quot;2&quot;);
    }
};
</code></pre></li>
</ul>
<h3 id="单选钮-JRadioButton"><a href="#单选钮-JRadioButton" class="headerlink" title="单选钮 JRadioButton"></a>单选钮 JRadioButton</h3><ul>
<li>多个关联的单选框中只能有一个被选择</li>
<li>通常为同一组中的每个单选钮设置独立的监听器</li>
</ul>
<pre><code>JPanel radioBoxPanel = new JPanel();
ButtonGroup group = new ButtonGroup();

JRadioButton radioButton1 = new JRadioButton(&quot;1&quot;,false);
JRadioButton radioButton2 = new JRadioButton(&quot;2&quot;,true);
//设置单循钮名字和初始状态

group.add(radioButton1);
group.add(radioButton2);
//将关联的单选钮加入到同一个组中

radioBoxPanel.add(radioButton1);
radioBoxPanel.add(radioButton2);
//ButtonGroup不是一个组件不能直接放入容器
//应该将每个按钮分别放入

frame.add(radioBoxPanel, BorderLayout.WEST);
</code></pre><h3 id="边框-Border"><a href="#边框-Border" class="headerlink" title="边框 Border"></a>边框 Border</h3><ul>
<li>表框在视觉上划分区域范围，面板默认不提供这样的元素</li>
<li>可以在任何继承了JCompoent的组件上应用边框</li>
<li>调用BorderFactory的静态方法创建边框对象</li>
<li><p>某些边框只能通过个别构造器创造，具体情况查看文档</p>
<pre><code>Border etched = BorderFactory.createEtchedBorder();
Border titled = BorderFactory.createTitledBorder(etched,&quot;A Title&quot;);
scrollPane.setBorder(titled);
</code></pre></li>
</ul>
<h3 id="表格-JTable"><a href="#表格-JTable" class="headerlink" title="表格 JTable"></a>表格 JTable</h3><ul>
<li>建议使用容器读取表格</li>
<li>需要以表头和表数据共同创建表格</li>
<li><p>使用DefaultTableModel 可以更改表格状态，系统会自动刷新表格</p>
<pre><code>String[] columnNames = {&quot;letter&quot;,&quot;Dec&quot;,&quot;Hex&quot;};
Object[][] data =
{
{&quot;a&quot;, new Integer(97),&quot;0x61&quot;},
         {&quot;b&quot;, new Integer(98),&quot;0x62&quot;},
         {&quot;c&quot;, new Integer(99),&quot;0x63&quot;},
         {&quot;d&quot;, new Integer(100),&quot;0x64&quot;},
};

JTable table = new JTable(data, columnNames);
frame.add(table, BorderLayout.WEST);
</code></pre></li>
</ul>
<h2 id="十三章-部署Java应用程序"><a href="#十三章-部署Java应用程序" class="headerlink" title="十三章 部署Java应用程序"></a>十三章 部署Java应用程序</h2><p><strong>（待续…）</strong></p>
<h2 id="十四章-并发"><a href="#十四章-并发" class="headerlink" title="十四章 并发"></a>十四章 并发</h2><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p><strong>多线程程序在较低的层次上扩展类多任务的概念：一个程序同时执行多个任务，通常每一个任务称为一个线程</strong></p>
<ul>
<li><p>在一个单独的线程中执行一个简单的任务，需要将任务代码放到一个实现了Runnable接口的类的run方法中，然后用它的实例创建一个Thread对象并调用Thread的start方法启动线程</p>
<pre><code>class MyRunable implements Runable
{
    public void run()
    {
        task code
    }
}
...
Runnable r = new MyRunnable();
Thread t = new Thread(r);
t.start();
</code></pre></li>
<li><p>不要直接调用Thread类或Runnable对象的run方法，直接调用run方法只会执行同一个线程的中任务，而不会启动新线程，应该调用Thread.start</p>
</li>
</ul>
<h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><ul>
<li>新创建 new，用new创建一个新线程时，该线程还没有开始运行，它的状态是new</li>
<li>可运行 Runable，用start启动一个线程后，线程处于runnable状态，一个可运行的线程可能在运行也可能没有运行，这取决于操作系统给线程提供的运行时间</li>
<li>被阻塞 Blocked，一个线程获取一个内部的对象锁时，如果锁被其他线程持有，则进入阻塞状态，当所有其他线程释放该锁且调度器允许时，线程变成非阻塞状态</li>
<li>等待 Waiting，当线程等待另一个线程通知调度器一个条件时，它自己进入等待状态</li>
<li>计时等待 Timed Waiting，有几个方法有一个超时参数时，调用它们导致线程进入计时等待</li>
<li>被终止，Terminated，run方法正常退出自然死亡，一个没有捕获的异常终止了run方法而意外死亡</li>
</ul>
<h3 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h3><ul>
<li>线程优先级，每一个线程有一个优先级，默认情况一个线程继承它父类的优先级</li>
<li>用serPriority方法提高或降低任何一个线程的优先级</li>
<li>线程调度器首先选择优先级高的线程，但是线程的优先级最终依赖于系统，windows有七个优先级，Oracle为linux提供的虚拟机只有一个优先级</li>
<li>几个高优先级线程没有进入非活动状态时，低优先级线程可能永远都不执行</li>
</ul>
<h3 id="未捕获异常处理器"><a href="#未捕获异常处理器" class="headerlink" title="未捕获异常处理器"></a>未捕获异常处理器</h3><p><strong>（待续…）</strong></p>
<h1 id="Core-Java-卷-2"><a href="#Core-Java-卷-2" class="headerlink" title="Core Java 卷 2"></a>Core Java 卷 2</h1><h2 id="第一章-流与文件"><a href="#第一章-流与文件" class="headerlink" title="第一章 流与文件"></a>第一章 流与文件</h2><h3 id="流-Stream"><a href="#流-Stream" class="headerlink" title="流 Stream"></a>流 Stream</h3><ul>
<li>输入流，可以从中读入一个字节序列的对象；输出流，可以向其中写入一个字节序列的对象。这些字节序列的来源地和目的地可以是文件，而且通常是文件，也可以是网络链接，甚至是内存块</li>
<li>操作文件内容的主要有两大类：字节流、字符流，两类都分为输入和输出操作。在字节流中输出数据主要是使用OutputStream完成，输入使的是InputStream，在字符流中输出主要是使用Writer类完成，输入流主要使用Reader类完成</li>
<li>字节流在操作的时候本身是不会用到缓冲区（内存）的，是与文件本身直接操作的，而字符流在操作的时候是使用到缓冲区的</li>
<li>字节流在操作文件时，即使不关闭资源（close方法），文件也能输出，但是如果字符流不使用close方法的话，则不会输出任何内容，说明字符流用的是缓冲区，并且可以使用flush方法强制进行刷新缓冲区，这时才能在不close的情况下输出内容</li>
<li>完成流读写时应该通过调用close方法来关闭它，这个调用会释放掉十分有限的操作系统资源</li>
<li>完整的流家族，与c单一的FILE * 类型不同，java的流家族包含各种流类型，数量超过60个</li>
<li>FileInputStream和FileOutStream可以提供一个附在磁盘上的输入流和输出流，所有提供的相对路径名解释以用户工作目录开始</li>
<li><p>组合流过滤器，流可自由组合，将希望得到的流置于最外层，中间的流只是提供所需要的功能</p>
<pre><code>FileOutputStream fin = new FileOutputStream(&quot;javaFile.txt&quot;);
</code></pre></li>
</ul>
<h3 id="读写二进制数据"><a href="#读写二进制数据" class="headerlink" title="读写二进制数据"></a>读写二进制数据</h3><ul>
<li>以二进制格式写出数据,需要使用 DataOutputStream</li>
</ul>
<p><strong>（待续…）</strong></p>
<h3 id="文本输入与输出"><a href="#文本输入与输出" class="headerlink" title="文本输入与输出"></a>文本输入与输出</h3><ul>
<li><p>创建文件</p>
<pre><code>File file = new File(&quot;./obj.dat&quot;);
try {
    if(!file.exists())
    file.createNewFile();
} catch (IOException e) {
    e.printStackTrace();
}
</code></pre></li>
<li><p>文本输出，可以使用PrintWriter，它可以链接到FileWriter，使用Print，println，printf方法可以打印数字、字符、布尔、字符串和对象</p>
<pre><code>PrintWriter out = new PrintWriter(new FileWriter(&quot;javaFlie3&quot;));
out.println(&quot;测试&quot;);
out.close();
//不要漏了close方法
</code></pre></li>
<li><p>文本读入</p>
<pre><code>try(Scanner file = new Scanner(new FlieReader(&quot;javaFlie3&quot;)))
{
    System.out.println(file.next());
    file.close();
</code></pre></li>
</ul>
<h3 id="文本格式存储对象"><a href="#文本格式存储对象" class="headerlink" title="文本格式存储对象"></a>文本格式存储对象</h3><ul>
<li>接写出所有的字断,每个字 后面跟着一个自定义的分隔符 ,而最后一个字端的后面跟着一个 ‘\n’</li>
<li>每次读入一行,然后分离所有的字 。我们使用一个扫描器来读入每一行,然后用 String.split 方法将这一行断开成一组标记</li>
</ul>
<pre><code>public class Employee {

    String name;
    int salary;
    Date hireDate;

public Employee(String name,int salary){

    this.name = name;
    this.salary = salary;
    this.hireDate = new Date();
    }

    public void writeData(PrintWriter out){

    GregorianCalendar calendar = new GregorianCalendar();
    calendar.setTime(hireDate);

    out.println(name + &quot;|&quot; + salary + &quot;|&quot; 
    + calendar.get(Calendar.YEAR)+&quot;|&quot;
    + calendar.get(Calendar.MONTH)+&quot;|&quot;
    + calendar.get(Calendar.DAY_OF_MONTH));
    }

    public String toString(){

    GregorianCalendar calendar = new GregorianCalendar();
    calendar.setTime(hireDate);

    return name + &quot;|&quot; + salary + &quot;|&quot; 
    + calendar.get(Calendar.YEAR)+&quot;|&quot;
    + calendar.get(Calendar.MONTH)+&quot;|&quot;
    + calendar.get(Calendar.DAY_OF_MONTH);
    }
}
</code></pre><h3 id="对象流与序列化"><a href="#对象流与序列化" class="headerlink" title="对象流与序列化"></a>对象流与序列化</h3><ul>
<li>对象流输出中包含所有对象的类型和数据域</li>
<li>每个对象都被赋予一个序列号</li>
<li>相同对象的重复出现将被存储为对这个对象的序列号的引用</li>
<li>静态域不能被序列化</li>
</ul>
<h3 id="序列化存储对象"><a href="#序列化存储对象" class="headerlink" title="序列化存储对象"></a>序列化存储对象</h3><ul>
<li>保存对象数据需要打开一个 ObjectOutputStream 对象，然后使用writeObject 方法</li>
<li>读回对象数据需要获得一个 ObjectInputStream 对象，然后,用readObject 方法以这些对象被写出时的顺序获得</li>
<li>希望在对象流中存储或恢复的所有类都应进行一下修改,这些类必须实现 Serializable 接口: 该接口没有任何方法,因此不需要对这些类进行任何改动</li>
<li>如果某些数据域是不可以序列化的，将它们标记成transient，如果这些域属于不可序列化的类, 也需要将它们标记成 transient ，瞬时的域在对象被序列化时总是被跳过</li>
</ul>
<pre><code>package objectStreamTest;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import testWrite.Employee;

public class test {
public static void main(String[] args)
{
Employee jack = new Employee(&quot;jack&quot;,7000);
Employee carls = new Employee(&quot;carls&quot;,8000);
Employee tony = new Employee(&quot;tony&quot;,9000);
Employee[] staff = new Employee[3];
staff[0]=jack;
staff[1]=carls;
staff[2]=tony;

    try(ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;/Users/alberthumbert/Desktop/obj.dat&quot;)))
{
    out.writeObject(staff);

}catch(Exception e){}

    try(ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;/Users/alberthumbert/Desktop/obj.dat&quot;)))
{
    Employee[] newStaff = (Employee[])in.readObject();
    System.out.println(newStaff[2]);
}catch(Exception e){}


    }
}
</code></pre><p><strong>（待续…）</strong></p>
<h2 id="可扩展标记语言-XML"><a href="#可扩展标记语言-XML" class="headerlink" title="可扩展标记语言 XML"></a>可扩展标记语言 XML</h2><p><strong> 大概不会经常用到，只做简要了解</strong></p>
<h3 id="XML文档简介"><a href="#XML文档简介" class="headerlink" title="XML文档简介"></a>XML文档简介</h3><ul>
<li>XML 被设计为传输和存储数据，其焦点是数据的内容，XML 格式能够表达层次结构,并且重复的元素不会被曲解</li>
<li><p>XML 文档应当以一个文档开始，虽然它是可选的</p>
<pre><code>&lt;? xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
</code></pre></li>
<li><p>文档头之后通常是文档类型的定义</p>
<pre><code>&lt;!DOCTYPE web-app PUBLIC
&quot;-//Sun Microsystem, Ins. //DTD Web Application 2.2//EN&quot;
&quot;http://java.sun.com/j2ee/dtds/web-app_2_2.dtd&quot;&gt;
</code></pre></li>
<li><p>最后，XML文档的正文包含根元素，根元素包含其他元素</p>
<pre><code>&lt;font&gt;
    &lt;name&gt;Helvetica&lt;/name&gt;
    &lt;size&gt;36&lt;/size&gt;
&lt;/font&gt;
</code></pre></li>
<li>元素和文本是 XML 文档“主要的支撑要素”,可能还会遇到的其他一些标记：字符引用  &amp;#233 &amp;#xE9 ；实体引用   &amp;name  ；注释  &lt; !– –&gt;</li>
</ul>
<h3 id="解析XML文档"><a href="#解析XML文档" class="headerlink" title="解析XML文档"></a>解析XML文档</h3><ul>
<li>要处理 XML 文档,就要先解 (parse)它，解析器是这样一个程序:它读入一个文件, 确认这个文件具有正确的格式,然后将其分解成各种元素,使得程序员能够访问这些元素</li>
<li><p>要读入一个 XML 文档,首先需要一个 DocumentBuilder 对象,可以从 DocumentBuilder Factory 中得到这个对象，然后从文件中读入某个文档，或者可以用一个 URL，甚至可以指定一个任意的输入流</p>
<pre><code>DocumentBuilderFactory factory=DocumentBuliderFactory.newInstance();
DocumentBuilder builder = factory.newDocumentBulider();

读入文档
File f= ...
Document doc = builder.parse(f);

或使用URL
URL u = ... 
Document doc = bulider.parse(u);

指定输入流
InputStream in = ...
Document doc = parse(in);
</code></pre></li>
<li><p>可以通过调用 getDocumentElement 方法来启动对文档内容的分析,它将返回根元素</p>
<pre><code>例如
&lt;? xml version = &quot;1.0&quot;?&gt;
&lt;font&gt;
    ...
&lt;/font&gt;

Element root = doc.getDocumentElement();        //返回font元素
String name = root.getTagName();
//返回标签名，此处为font
</code></pre></li>
</ul>
<ul>
<li>如果要得到该元素的子元素(可能是子元素、文本、注 或其他节点),请使用 getChild Nodes方法,这个方法返回一个类型为NodeList的集合<br>  <strong>(待续)</strong></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[unix网络编程 笔记]]></title>
      <url>/2017/02/21/unp/</url>
      <content type="html"><![CDATA[<p>onDestroy</p>
<a id="more"></a>
<h2 id="函数与头文件"><a href="#函数与头文件" class="headerlink" title="函数与头文件"></a>函数与头文件</h2><p>netinet/in.h</p>
<pre><code>struct sockaddr_in

{
short sin_family;
//Address family一般来说为AF_INET（地址族）PF_INET（协议族）

unsigned short sin_port;
//Port number 必须要采用网络数据格式
//普通数字可以用htons()函数转换成网络数据格式的数字

struct in_addr sin_addr;
//IP address in network byte order（Internet address）


unsigned char sin_zero[8];
//没有实际意义,只是为了跟SOCKADDR结构在内存中对齐
}
</code></pre><p>sys/socket.h </p>
<pre><code>int socket( int af, int type, int protocol)    
</code></pre><p>string.h</p>
<pre><code>void *memset(void *s, int ch, size_t n)
</code></pre><p>stdio.h</p>
<pre><code>int fputs(char * string, FILE * stream)
</code></pre><p>unistd.h</p>
<pre><code>ssize_t read(int fd,void * buf ,size_t count)
</code></pre><p>arpa/inet.h</p>
<pre><code>int inet_pton(int af, const char *src, void *dst)
</code></pre><p>time.h</p>
<pre><code>ctime()
</code></pre><h2 id="daytime客户端程序"><a href="#daytime客户端程序" class="headerlink" title="daytime客户端程序"></a>daytime客户端程序</h2><pre><code>#include &lt;stdio.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;unistd.h&gt;
#include &lt;time.h&gt;


int
main(int argc,char **argv)
{
</code></pre><p>用来保存文件描述符（fd = file descriptor）</p>
<pre><code>int sockfd,n;
</code></pre><p>用来保存返回的字符</p>
<pre><code>char recvline[41];

struct sockaddr_in servaddr;

if(argc !=2)
{ 
    printf(&quot;usage: a.out &lt;IPaddress&gt;&quot;);
    exit(0);
}
</code></pre><p>AF_INET：协议族，常量2，socket只能使用这个协议</p>
<p>SOCK_STREAM： 提供面向连接的稳定数据传输，即TCP协议</p>
<p>参数protocol : 指定socket所使用的传输协议编号,这一参数通常不具体设置，一般设置为0即可（0即为默认）</p>
<p>这里创建一个套接字，采用tcp协议，并获取这个socket的文件描述符</p>
<pre><code>if((sockfd = socket(AF_INET,SOCK_STREAM,0))&lt;0)
{
    printf(&quot;socket error&quot;);
    exit(0);
}
</code></pre><p>初始化一个sockaddr_in结构，采用相同协议族</p>
<pre><code>memset(&amp;servaddr,0,sizeof(servaddr));
servaddr.sin_family=AF_INET;
</code></pre><p>sin_port : 存储端口号（使用网络字节顺序）<br>htons：将整型变量从主机字节顺序转变成网络字节顺序<br>13：daytime端口</p>
<pre><code>servaddr.sin_port = htons(13);
</code></pre><p>inet_pton()将IP地址从字符串格式转换成网络地址格式，支持Ipv4和Ipv6</p>
<pre><code>if(inet_pton(AF_INET,argv[1],&amp;servaddr.sin_addr)&lt;=0)
{
    printf(&quot;inet_pton error for %s&quot;,argv[1]);
}
</code></pre><p>connect函数利用文件描述符与地址，为客户端建立tcp连接<br>sockaddr和sockaddr_in的结构是一致的<br>但sockaddr一般保留给计算机使用，所以需要强制转换</p>
<pre><code>if(connect(sockfd,(struct sockaddr*)&amp;servaddr,sizeof(servaddr))&lt;0)
{
    printf(&quot;connect error&quot;);
    exit(0);
}
</code></pre><p>read()读取服务器应答，无法保证一次读取完全部数据，因此使用循环</p>
<pre><code>while((n=read(sockfd,recvline,40))&gt;0)
{
  recvline[n]=0;
  if(fputs(recvline,stdout)==EOF) 
</code></pre><p>输出到控制台</p>
<pre><code>exit(0);

if(n&lt;0)
{
    printf(&quot;read error&quot;);
    exit(0);
}

}

exit(0);
}
</code></pre><h2 id="daytime服务器程序"><a href="#daytime服务器程序" class="headerlink" title="daytime服务器程序"></a>daytime服务器程序</h2><pre><code>int main(int argc,char **argv)
{


int listenfd,connfd;
socklen_t len;
struct sockaddr_in servaddr,cliaddr;
char buff[40];
time_t ticks;

if( ( listenfd = socket(AF_INET,SOCK_STREAM,0 ) )&lt;0)
printf(&quot;socket error&quot;),exit(0);
memset(&amp;servaddr,0,sizeof(servaddr));
servaddr.sin_family = AF_INET;
</code></pre><p>-</p>
<pre><code>servaddr.sin_port = htons(9999);
</code></pre><p>选择端口，1024以下的端口一般保留给系统内部使用，书中使用daytime的端口13，但是这么做并没有任何意义，该程序通过time()、ctime()获取系统时间</p>
<pre><code>servaddr.sin_addr.s_addr =htonl(INADDR_ANY);
if(bind(listenfd,(struct sockaddr *)&amp;servaddr ,sizeof(servaddr))==-1)
printf(&quot;bind error &quot;),exit(0);
</code></pre><p>当用socket()函数创建套接字以后，套接字在名称空间(网络地址族)中存在，但没有任何地址给它赋值。bind()把用addr指定的地址与文件描述符代表的套接字sockfd绑定。addrlen指定了以addr所指向的地址结构体的字节长度</p>
<p>使用tcp协议通信时客户端不需要使用bind()</p>
<pre><code>if(listen(listenfd,2)==-1)printf(&quot;listen error\n&quot;),exit(0);
</code></pre><p>listen函数使用主动连接套接口变为被连接套接口，使得一个进程可以接受其它进程的请求，从而成为一个服务器进程。在TCP服务器编程中listen函数把进程变为一个服务器，并指定相应的套接字变为被动连接</p>
<pre><code>for(;;)
 {
len=sizeof(cliaddr);
connfd = accept(listenfd,(struct sockaddr *)&amp;cliaddr,&amp;len);
</code></pre><p>accept()按照顺序提取用于监听的socket所监听到的连接请求，用相应的端口以及通信地址创建一个新的socket，并将其文件描述符返回</p>
<pre><code>if(connfd==-1)printf(&quot;accept error\n&quot;),exit(0);
printf(&quot;connection from %s,port %d\n&quot;,inet_ntop(AF_INET,
&amp;cliaddr.sin_addr,buff,sizeof(buff)),ntohs(cliaddr.sin_port));
</code></pre><p>ntohs()将一个无符号短整形数从网络络字节顺序转换为主机字节顺序</p>
<p> -</p>
<pre><code>ticks = time(NULL);
</code></pre><p>获取系统时间</p>
<pre><code>snprintf(buff,sizeof(buff),&quot;%.24s\r\n&quot;,ctime(&amp;ticks));
</code></pre><p>ctime()将参数&amp;ticks所指的time_t结构中的信息转换成真实世界所使用的时间日期表示方法，然后将结果以字符串形态返回。<br>snprintf()将可变个参数(…)按照format格式化成字符串，然后将其复制到str中</p>
<pre><code>write(connfd,buff,strlen(buff));
</code></pre><p>write函数将buff中的nbytes字节内容写入socket,成功时返回写的字节数</p>
<pre><code>if(close(connfd)==-1)printf(&quot;close error\n&quot;),exit(0);
</code></pre><p>关闭本进程的socket id，但链接还是开着的，用这个socket id的其它进程还能用这个链接，能读或写这个socket id</p>
<pre><code>  }
}
</code></pre><h2 id="概念说明"><a href="#概念说明" class="headerlink" title="概念说明"></a>概念说明</h2><p>socket: 一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭）</p>
<p>Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。<br>在设计模式中，Socket其实就是一个门面模式<br>它把复杂的TCP/IP协议族隐藏在Socket接口后面<br>对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议</p>
<p>OSI: open system insterconnection 开放系统互连模型</p>
<p>物理层、数据链路层：设备驱动程序、网络硬件<br>网络层：IPv4／IPv6<br>传输层：TCP、UDP<br>（这之间的接口是构建api的自然位置）<br>回话、表示、应用层：应用层<br>传输层：TCP、UDP和SCTP</p>
<p>UDP：一个简单的传输层协议，往一个UDP套接字写入消息，<br>    该消息随后被封装到一个UDP数据报，<br>    该UDP数据报进而又被封装到一个IP数据报，然后发送到目的地<br>    UDP的特点是记录边界，提供无连接服务，缺乏可靠性</p>
<p>TCP：提供客户与服务器之间的连接，TCP客户先与某个给定的服务器建立一个连接，<br>    再跨该连接与那个服务器交换数据，然后终止这个连接<br>    TCP的特点是自动重传，动态估算往返时间（RTT），数据排序<br>    流量控制，全双工</p>
<p>SCTP：类似TCP，但面向消息，有多宿性</p>
]]></content>
      
        <categories>
            
            <category> 笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> unix </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ubuntu 16.04 开启daytime服务（端口13）]]></title>
      <url>/2017/02/20/daytime/</url>
      <content type="html"><![CDATA[<hr>
<a id="more"></a>
<p>学习《unix网络编程》时，解决完编译问题，第一个程序又出现如下错误代码</p>
<pre><code>connect error: Connection refused
</code></pre><p>这个serve一般被系统默认关闭，用书中的daytimesrv程序可以暂时打开端口</p>
<p>不过最好通过xinetd（守护进程服务程序）开启</p>
<p>ubuntu不自带xinetd，因此</p>
<pre><code>sudo apt install xinetd
</code></pre><p>这个时候又报错 : (</p>
<pre><code>......
E: Unable to locate package xinetd
</code></pre><p>尝试用upgrade更新源依然失败<br>在系统设置-&gt;软件和更新-&gt;下载自：-&gt;其他站点中选择最佳服务区<br>再次安装xinetd成功</p>
<p>然后在/etc/xinetd.d中将daytime的两个disable改为no<br>（注意在vim中修改只读模式仍然可能无法保存，建议使用sudo chmod）</p>
<p>最后重新启动xinetd</p>
<pre><code>/etc/init.d/xinetd restart
</code></pre><p>运行，正常</p>
<pre><code>$ ./daytimetcpcli 127.0.0.1

20 FEB 2017 23:39:29 CST
counter = 1
</code></pre>]]></content>
      
        
        <tags>
            
            <tag> unix </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[新年贺图]]></title>
      <url>/2017/01/25/2017/</url>
      <content type="html"><![CDATA[<p>不肝了，不肝了<br><a id="more"></a></p>
<p><img src="http://p1.bqimg.com/567571/9c34ec604599fff3.jpg"></p>
<p>魔学第一集的设定<br>线稿阶段本来没想那么多，然而越画越复杂<br>顺便尝试一下多色块的赛璐璐，结果是配色配到头晕</p>
<p>过几天再来看才感觉饱和度用低了，这个习惯很难改啊</p>
<p>pixiv地址：<a href="http://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=61224806" target="_blank" rel="external">http://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=61224806</a></p>
<p>个人页面：<a href="http://www.pixiv.net/member.php?id=7314348" target="_blank" rel="external">http://www.pixiv.net/member.php?id=7314348</a></p>
<p>whatever：<a href="https://alberthumbert.github.io/2016/10/15/mypaintings/">https://alberthumbert.github.io/2016/10/15/mypaintings/</a></p>
]]></content>
      
        <categories>
            
            <category> 创作 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 涂鸦 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[简单栈和树的简单操作]]></title>
      <url>/2017/01/23/linear-list2/</url>
      <content type="html"><![CDATA[<hr>
<a id="more"></a>
<h2 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">    #include &lt;stdio.h&gt;</div><div class="line">    #include &lt;stdlib.h&gt;</div><div class="line">    #include&lt;time.h&gt;</div><div class="line">    #define OK 1</div><div class="line">    #define ERROR 0      </div><div class="line">    #define MAXSIZE 30</div><div class="line">   </div><div class="line">   typedef int SElemType;</div><div class="line">   typedef int Status;</div><div class="line">   typedef struct</div><div class="line">   &#123;</div><div class="line">   SElemType data[MAXSIZE];</div><div class="line">   int top;</div><div class="line">   &#125;SqStack;</div><div class="line"></div><div class="line">   void StackPrint(SqStack *sp);</div><div class="line">   Status Push(SqStack *sp,SElemType e);</div><div class="line">   Status Pop(SqStack *sp,SElemType * ep);</div><div class="line"></div><div class="line">   int</div><div class="line">   main(void)</div><div class="line">   &#123;</div><div class="line">   int i,e,k,*ep=&amp;e;</div><div class="line">   SqStack S;</div><div class="line">   SqStack *sp=&amp;S;</div><div class="line">   srand(time(0));</div><div class="line"></div><div class="line">   //初始化随机栈</div><div class="line">i=rand()%10;</div><div class="line">S.top=i;</div><div class="line">for(k=0;k&lt;=i;k++)</div><div class="line">    S.data[k]=rand()%100+1;</div><div class="line">    StackPrint(sp);</div><div class="line"></div><div class="line">//进栈操作</div><div class="line">e=rand()%100+1;</div><div class="line">Push(sp,e);</div><div class="line">StackPrint(sp);</div><div class="line"></div><div class="line">//出栈操作</div><div class="line">Pop(sp,ep);</div><div class="line">StackPrint(sp);</div><div class="line"></div><div class="line">printf(&quot;done !\n\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void StackPrint(SqStack * sp)</div><div class="line">&#123;</div><div class="line">printf(&quot;new list: &quot;);</div><div class="line">for(int i=0;i&lt;=sp-&gt;top;i++)</div><div class="line">    printf(&quot;%d &quot;,sp-&gt;data[i]);</div><div class="line">    printf(&quot;\n&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">Status Push(SqStack *sp,SElemType e)</div><div class="line">&#123;</div><div class="line">if(sp-&gt;top==MAXSIZE-1)</div><div class="line">&#123;</div><div class="line">    printf(&quot;Push Failed\n&quot;);</div><div class="line">    return ERROR;</div><div class="line">&#125;</div><div class="line">sp-&gt;top++;</div><div class="line">sp-&gt;data[sp-&gt;top]=e;</div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status Pop(SqStack *sp,SElemType * ep)</div><div class="line">&#123;</div><div class="line">if(sp-&gt;top==-1)</div><div class="line">&#123;</div><div class="line">    printf(&quot;Pop Failed\n&quot;);</div><div class="line">    return ERROR;</div><div class="line">&#125;</div><div class="line">*ep=sp-&gt;data[sp-&gt;top];</div><div class="line">sp-&gt;top--;</div><div class="line">return OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="两栈共享空间"><a href="#两栈共享空间" class="headerlink" title="两栈共享空间"></a>两栈共享空间</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include&lt;time.h&gt;</div><div class="line">#define OK 1</div><div class="line">#define ERROR 0</div><div class="line">#define MAXSIZE 30</div><div class="line">typedef int ElemType;</div><div class="line">typedef int Status;</div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">ElemType data[MAXSIZE];</div><div class="line">int top1;</div><div class="line">int top2;</div><div class="line">&#125;DoubleStack;</div><div class="line"></div><div class="line">Status Push(DoubleStack *S,ElemType e,int StackNumber);</div><div class="line">Status Pop(DoubleStack *S,ElemType *e,int StackNumber);</div><div class="line">Status StackInit(DoubleStack *S);</div><div class="line">Status stackprint(DoubleStack *S);</div><div class="line"></div><div class="line">int</div><div class="line">main()</div><div class="line">&#123;</div><div class="line">DoubleStack S;</div><div class="line">StackInit(&amp;S);</div><div class="line">int e,*pe=&amp;e;</div><div class="line"></div><div class="line">e=1;</div><div class="line">Push(&amp;S,e,1);</div><div class="line">stackprint(&amp;S);</div><div class="line"></div><div class="line">e=2;</div><div class="line">Push(&amp;S,e,2);</div><div class="line">stackprint(&amp;S);</div><div class="line"></div><div class="line">Pop(&amp;S,pe,1);</div><div class="line">stackprint(&amp;S);</div><div class="line"></div><div class="line">Pop(&amp;S,pe,2);</div><div class="line">stackprint(&amp;S);</div><div class="line">   </div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status StackInit(DoubleStack *S)</div><div class="line">&#123;</div><div class="line">S-&gt;top1=-1;</div><div class="line">S-&gt;top2=MAXSIZE;</div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status Push(DoubleStack *S,ElemType e,int StackNumber)</div><div class="line">&#123;</div><div class="line">if(S-&gt;top2+1==S-&gt;top2)</div><div class="line">    return ERROR;</div><div class="line">if(StackNumber==1)S-&gt;data[++S-&gt;top1]=e;</div><div class="line">if(StackNumber==2)S-&gt;data[--S-&gt;top2]=e;</div><div class="line"></div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status Pop(DoubleStack *S,ElemType *e,int StackNumber)</div><div class="line">&#123;</div><div class="line">if(StackNumber==1)</div><div class="line">&#123;</div><div class="line">    if(S-&gt;top1==-1)return ERROR;</div><div class="line">    *e=S-&gt;data[S-&gt;top1--];</div><div class="line">&#125;</div><div class="line"></div><div class="line">if(StackNumber==2)</div><div class="line">&#123;</div><div class="line">    if(S-&gt;top2==MAXSIZE)return ERROR;</div><div class="line">    *e=S-&gt;data[S-&gt;top2++];</div><div class="line">&#125;</div><div class="line"></div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status stackprint(DoubleStack *S)</div><div class="line">&#123;</div><div class="line">for(int i=0;i&lt;=S-&gt;top1;i++)</div><div class="line">    printf(&quot; %d &quot;,S-&gt;data[i]);</div><div class="line"></div><div class="line">for(int i=MAXSIZE-1;i&gt;=S-&gt;top2;i--)</div><div class="line">    printf(&quot; %d &quot;,S-&gt;data[i]);</div><div class="line">printf(&quot;\n&quot;);</div><div class="line"></div><div class="line"></div><div class="line">return OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include&lt;time.h&gt;</div><div class="line">#define OK 1</div><div class="line">#define ERROR 0</div><div class="line">#define MAXSIZE 30</div><div class="line"></div><div class="line">typedef int ElemType;</div><div class="line">typedef int Status;</div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line"> ElemType data;</div><div class="line"> struct StackNode *next;</div><div class="line">&#125;StackNode,*LinkStackPtr;</div><div class="line"></div><div class="line">typedef struct LinkStack</div><div class="line">&#123;</div><div class="line">LinkStackPtr top;</div><div class="line">int count;</div><div class="line">&#125;LinkStack;</div><div class="line"> </div><div class="line">Status Push(LinkStack *S,ElemType e);</div><div class="line">Status Pop(LinkStack *S,ElemType *e);</div><div class="line">Status StackInit(LinkStack *S);</div><div class="line">Status stackprint(LinkStack S);</div><div class="line"></div><div class="line">int </div><div class="line">main()</div><div class="line">&#123;</div><div class="line">LinkStack S;</div><div class="line">int e,*pe=&amp;e;</div><div class="line">StackInit(&amp;S);</div><div class="line"></div><div class="line">e=1;</div><div class="line">Push(&amp;S, e);</div><div class="line">stackprint(S);</div><div class="line"></div><div class="line">e=2;</div><div class="line">Push(&amp;S, e);</div><div class="line">stackprint(S);</div><div class="line"></div><div class="line"></div><div class="line">Pop(&amp;S, pe);</div><div class="line">stackprint(S);</div><div class="line"></div><div class="line">Pop(&amp;S, pe);</div><div class="line">stackprint(S)；</div><div class="line"></div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status Push(LinkStack *S,ElemType e)</div><div class="line">&#123;</div><div class="line">LinkStackPtr tmp=(LinkStackPtr)malloc(sizeof(StackNode));</div><div class="line">tmp-&gt;next=S-&gt;top;</div><div class="line">tmp-&gt;data=e;</div><div class="line">S-&gt;count++;</div><div class="line">S-&gt;top=tmp;</div><div class="line"></div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status Pop(LinkStack *S,ElemType *pe)</div><div class="line">&#123;</div><div class="line">LinkStackPtr tmp;</div><div class="line">if(S-&gt;top==NULL)</div><div class="line">    return ERROR;</div><div class="line">*pe=S-&gt;top-&gt;data;</div><div class="line">tmp=S-&gt;top;</div><div class="line">S-&gt;top=S-&gt;top-&gt;next;</div><div class="line">free(tmp);</div><div class="line">S-&gt;count--;</div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status StackInit(LinkStack *S)</div><div class="line">&#123;</div><div class="line">S-&gt;top=NULL;</div><div class="line">S-&gt;count=0;</div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status stackprint(LinkStack S)</div><div class="line">&#123;</div><div class="line">LinkStackPtr seek=S.top;</div><div class="line">while(seek)</div><div class="line">&#123;</div><div class="line">printf(&quot;%d &quot;,seek-&gt;data);</div><div class="line">seek=seek-&gt;next;</div><div class="line">&#125;</div><div class="line">printf(&quot;\n&quot;);</div><div class="line">return OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line">   </div><div class="line">     #include &lt;stdio.h&gt;</div><div class="line">     #include &lt;stdlib.h&gt;</div><div class="line">#include&lt;time.h&gt;</div><div class="line">#define OK 1</div><div class="line">#define ERROR 0</div><div class="line">#define MAXSIZE 20</div><div class="line">typedef int ElemType;</div><div class="line">typedef int Status;</div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">     ElemType data[MAXSIZE];</div><div class="line">     int front;</div><div class="line">     int rear;</div><div class="line">&#125;Queue;</div><div class="line"></div><div class="line">Status QueueInit(Queue *Q);</div><div class="line">Status QueueEn(Queue *Q,ElemType e);</div><div class="line">Status QueueDe(Queue *Q,ElemType *e);</div><div class="line">Status QueuePr(Queue Q);</div><div class="line">int QueueLength(Queue Q);</div><div class="line"></div><div class="line">int</div><div class="line">main()</div><div class="line">&#123;</div><div class="line">   int e;</div><div class="line">   //初始化队列</div><div class="line">   Queue Q;</div><div class="line">   QueueInit(&amp;Q);</div><div class="line">   </div><div class="line">   //入队列操作</div><div class="line">   for(e=1;e&lt;=MAXSIZE;e++)</div><div class="line">   &#123;</div><div class="line">   QueueEn(&amp;Q, e);</div><div class="line">   QueuePr(Q);</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   //出队列操作</div><div class="line">   for(e=1;e&lt;=MAXSIZE;e++)</div><div class="line">   &#123;</div><div class="line">       QueueDe(&amp;Q, &amp;e);</div><div class="line">       QueuePr(Q);</div><div class="line">   &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">&#125;</div><div class="line">Status QueueInit(Queue *Q)</div><div class="line">&#123;</div><div class="line">    Q-&gt;front=0;</div><div class="line">    Q-&gt;rear=0;</div><div class="line">   </div><div class="line">   return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status QueueEn(Queue *Q,ElemType e)</div><div class="line">&#123;</div><div class="line">    if((Q-&gt;rear+1)%MAXSIZE==Q-&gt;front)</div><div class="line">    &#123;</div><div class="line">       printf(&quot;QueueEn failed\n&quot;);</div><div class="line">       return ERROR;</div><div class="line">    &#125;</div><div class="line">    Q-&gt;data[Q-&gt;rear]=e;</div><div class="line">    Q-&gt;rear=(Q-&gt;rear+1)%MAXSIZE;</div><div class="line">   </div><div class="line">   return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status QueueDe(Queue *Q,ElemType *e)</div><div class="line">&#123;</div><div class="line">     if(Q-&gt;front==Q-&gt;rear)</div><div class="line">    &#123;</div><div class="line">       printf(&quot;QueueDe failed!\n&quot;);</div><div class="line">       return ERROR;</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">     Q-&gt;front=(Q-&gt;front+1)%MAXSIZE;</div><div class="line">   </div><div class="line">     return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int QueueLength(Queue Q)</div><div class="line">&#123;</div><div class="line">     return (Q.rear+MAXSIZE-Q.front)%MAXSIZE;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status QueuePr(Queue Q)</div><div class="line">&#123;</div><div class="line">     if(QueueLength(Q)==0)</div><div class="line">     &#123;</div><div class="line">       return ERROR;</div><div class="line">     &#125;</div><div class="line">   </div><div class="line">     for(int seek=Q.front;seek!=Q.rear;seek=(seek+1)%MAXSIZE)</div><div class="line">     printf(&quot;%d &quot;,Q.data[seek]);</div><div class="line">     printf(&quot;\n&quot;);</div><div class="line">   </div><div class="line">     return OK;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="链队列"><a href="#链队列" class="headerlink" title="链队列"></a>链队列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include&lt;time.h&gt;</div><div class="line">#define OK 1</div><div class="line">#define ERROR 0</div><div class="line">#define MAXSIZE 20</div><div class="line">typedef int ElemType;</div><div class="line">typedef int Status;</div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">     ElemType data;</div><div class="line">     struct Node *next;</div><div class="line">&#125;Node,*QueuePtr;</div><div class="line"></div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">    QueuePtr front,rear;</div><div class="line">&#125;LinkQueue;</div><div class="line"></div><div class="line">Status EnQueue(LinkQueue *Q,ElemType e);</div><div class="line">Status DeQueue(LinkQueue *Q,ElemType *e);</div><div class="line">Status InQueue(LinkQueue *Q);</div><div class="line">Status PrQueue(LinkQueue Q);</div><div class="line"></div><div class="line">int</div><div class="line">main()</div><div class="line">   &#123;</div><div class="line">   LinkQueue Q;</div><div class="line">   int e,*pe=&amp;e;</div><div class="line">   InQueue(&amp;Q);</div><div class="line">   </div><div class="line">   for(e=1;e&lt;=20;e++)</div><div class="line">   &#123;</div><div class="line">   EnQueue(&amp;Q, e);</div><div class="line">   PrQueue(Q);</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   for(e=1;e&lt;=20;e++)</div><div class="line">   &#123;</div><div class="line"></div><div class="line">   DeQueue(&amp;Q, pe);</div><div class="line">   PrQueue(Q);</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   return OK;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">Status EnQueue(LinkQueue *Q,ElemType e)</div><div class="line">&#123;</div><div class="line">   QueuePtr new=(QueuePtr)malloc(sizeof(Node));</div><div class="line">   new-&gt;data=e;</div><div class="line">   new-&gt;next=NULL;</div><div class="line">   Q-&gt;rear-&gt;next=new;</div><div class="line">   Q-&gt;rear=new;</div><div class="line">   </div><div class="line">   </div><div class="line">   return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status DeQueue(LinkQueue *Q,ElemType *e)</div><div class="line">&#123;</div><div class="line">   if(Q-&gt;front==Q-&gt;rear)</div><div class="line">     &#123;</div><div class="line">       printf(&quot;delete failed\n&quot;);</div><div class="line">       return ERROR;</div><div class="line">     &#125;</div><div class="line">   </div><div class="line">   QueuePtr del=Q-&gt;front-&gt;next;</div><div class="line">   *e=del-&gt;data;</div><div class="line">   Q-&gt;front-&gt;next=del-&gt;next;</div><div class="line">   if(del==Q-&gt;rear)</div><div class="line">       Q-&gt;rear=Q-&gt;front;</div><div class="line">   free(del);</div><div class="line">   </div><div class="line">   </div><div class="line">   return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status InQueue(LinkQueue *Q)</div><div class="line">&#123;</div><div class="line">    QueuePtr new=(QueuePtr)malloc(sizeof(Node));</div><div class="line">    Q-&gt;front=new;</div><div class="line">    Q-&gt;rear=new;</div><div class="line">    return OK;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">   Status PrQueue(LinkQueue Q)</div><div class="line">   &#123;</div><div class="line">    if(Q.front==Q.rear)</div><div class="line">   &#123;</div><div class="line">       printf(&quot;PrQueue failed\n&quot;);</div><div class="line">       return ERROR;</div><div class="line">   </div><div class="line">   &#125;</div><div class="line">   QueuePtr seek=Q.front-&gt;next;</div><div class="line">   while(seek!=NULL)</div><div class="line">   &#123;</div><div class="line">       printf(&quot;%d &quot;,seek-&gt;data);</div><div class="line">       seek=seek-&gt;next;</div><div class="line">   &#125;</div><div class="line">   printf(&quot;\n&quot;);</div><div class="line">   </div><div class="line">   return OK;</div><div class="line"></div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/*</div><div class="line">//几种树的结构</div><div class="line">#define MAX_TREE_SIZE 100</div><div class="line">typedef int ElemType;</div><div class="line">typedef  struct Node</div><div class="line">&#123;</div><div class="line">   	ElemType data;</div><div class="line">   	int parent;</div><div class="line">&#125;Node;</div><div class="line"></div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">   	Node nodes[MAX_TREE_SIZE];</div><div class="line">   	int r,n;</div><div class="line">&#125;Tree;</div><div class="line">*/</div><div class="line"></div><div class="line">/*</div><div class="line">#define MAX_TREE_SIZE 100</div><div class="line">typedef int ElemType;</div><div class="line">typedef struct Node</div><div class="line">&#123;</div><div class="line">   	int child;</div><div class="line">   	struct Node *next;</div><div class="line">&#125;* ChildPtr;</div><div class="line"></div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">   ElemType data;</div><div class="line">   ChildPtr firstchild;</div><div class="line">&#125;Box;</div><div class="line"></div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">   Box nodes[MAX_TREE_SIZE];</div><div class="line">   int r,n;</div><div class="line">&#125;Tree;</div><div class="line">*/</div><div class="line"></div><div class="line">/*</div><div class="line">#define MAX_TREE_SIZE 100</div><div class="line">typedef int ElemType;</div><div class="line">typedef struct Node</div><div class="line">&#123;</div><div class="line">   	ElemType data;</div><div class="line">   	struct Node *firstchild,*rightsib;</div><div class="line">&#125;Node,*Tree;</div><div class="line">*/</div><div class="line"></div><div class="line">#include&lt;stdio.h&gt;</div><div class="line">typedef char ElemType;</div><div class="line">typedef struct Node</div><div class="line">&#123;</div><div class="line">   	ElemType data;</div><div class="line">   	struct Node * lchild,*rchild;</div><div class="line"></div><div class="line">&#125;Node,* Tree;</div><div class="line">void CreatTree(Tree *T);</div><div class="line">void PreOrderTraverse(Tree T);</div><div class="line">void InOrderTreaverse(Tree T);</div><div class="line">void PostOrderTraverse(Tree T);</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line"></div><div class="line">//创建二叉树</div><div class="line">   Tree T;</div><div class="line">   CreatTree(&amp;T);</div><div class="line">   </div><div class="line">   //前序遍历二叉树</div><div class="line">   PreOrderTraverse(T);</div><div class="line">   printf(&quot;\n&quot;);</div><div class="line">   </div><div class="line">   //中序遍历二叉树</div><div class="line">   InOrderTreaverse(T);</div><div class="line">   printf(&quot;\n&quot;);</div><div class="line">   </div><div class="line">   //后序遍历二叉树</div><div class="line">   PostOrderTraverse(T);</div><div class="line">   printf(&quot;\n\n&quot;);</div><div class="line">   return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void CreatTree(Tree *T)</div><div class="line">&#123;</div><div class="line">   ElemType ch;</div><div class="line">   scanf(&quot;%c&quot;,&amp;ch);</div><div class="line">   if(ch==&apos;#&apos;)*T=NULL;</div><div class="line">   else</div><div class="line">     &#123;</div><div class="line">       (*T)=(Tree)malloc(sizeof(Node));</div><div class="line">       if(!*T)return;</div><div class="line">        (*T)-&gt;data=ch;</div><div class="line">       CreatTree(&amp;(*T)-&gt;lchild);</div><div class="line">       CreatTree(&amp;(*T)-&gt;rchild);</div><div class="line">      </div><div class="line"></div><div class="line">   	&#125;</div><div class="line">   </div><div class="line">&#125;</div><div class="line"></div><div class="line">void PreOrderTraverse(Tree T)</div><div class="line">&#123;</div><div class="line">   if(T==NULL)</div><div class="line">          return;</div><div class="line"></div><div class="line">   printf(&quot;%c&quot;,T-&gt;data);</div><div class="line">   PreOrderTraverse(T-&gt;lchild);</div><div class="line">   PreOrderTraverse(T-&gt;rchild);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void InOrderTreaverse(Tree T)</div><div class="line">&#123;</div><div class="line">   if(T==NULL)</div><div class="line">       return;</div><div class="line">   </div><div class="line">   PreOrderTraverse(T-&gt;lchild);</div><div class="line">   printf(&quot;%c&quot;,T-&gt;data);</div><div class="line">   PreOrderTraverse(T-&gt;rchild);</div><div class="line"></div><div class="line">&#125;	</div><div class="line">void PostOrderTraverse(Tree T)</div><div class="line">&#123;</div><div class="line">     if(T==NULL)</div><div class="line">           return;</div><div class="line">   </div><div class="line">     PreOrderTraverse(T-&gt;lchild);</div><div class="line">     PreOrderTraverse(T-&gt;rchild);</div><div class="line">   	printf(&quot;%c&quot;,T-&gt;data);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 代码 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[各类简单线性表的简单操作]]></title>
      <url>/2017/01/11/linear-list/</url>
      <content type="html"><![CDATA[<hr>
<a id="more"></a>
<h2 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h2><p>   指的是用一段地址连续的存储单元依次存储线性的数据元素， c中以数组实现</p>
<p>   对于线性表顺序存储结构：<br>   查找 时间复杂度为o[1]<br>   插入，删除 时间复杂度为o[n]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div></pre></td><td class="code"><pre><div class="line">   </div><div class="line">#define MAXSIZE 20</div><div class="line">#define OK 1</div><div class="line">#define ERROR 0</div><div class="line">#define TURE 1</div><div class="line">#define FALSE 10</div><div class="line"></div><div class="line">typedef int ElemType;</div><div class="line">typedef int Status;</div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">ElemType data[MAXSIZE];</div><div class="line">int length;</div><div class="line">&#125;SqList;</div><div class="line"></div><div class="line">Status Initialize(SqList * pL);</div><div class="line">Status GetElem(SqList L,int i,ElemType *pe);</div><div class="line">Status ListInsert(SqList * pL,int i,ElemType e);</div><div class="line">Status ListPrint(SqList * pL);</div><div class="line">Status ListDelete(SqList *pL,ElemType e);</div><div class="line"></div><div class="line">int</div><div class="line">main(void)</div><div class="line">&#123;</div><div class="line">ElemType e;</div><div class="line">ElemType * pe=&amp;e;</div><div class="line">SqList L;</div><div class="line">SqList *pL=&amp;L;</div><div class="line">L.length=10;</div><div class="line">int i;</div><div class="line"></div><div class="line">Initialize(pL);</div><div class="line">ListPrint(pL);</div><div class="line"></div><div class="line">//读取元素</div><div class="line">printf(&quot;intput a number of element :&quot;);</div><div class="line">scanf(&quot;%d&quot;,&amp;i);</div><div class="line">GetElem(L, i, pe);</div><div class="line">printf(&quot;GetElem :%d\n\n&quot;,e);</div><div class="line"></div><div class="line">//插入元素</div><div class="line">printf(&quot;intput a number to insert :&quot;);</div><div class="line">scanf(&quot;%d&quot;,&amp;e);</div><div class="line">printf(&quot;intput location to insert :&quot;);</div><div class="line">scanf(&quot;%d&quot;,&amp;i);</div><div class="line"></div><div class="line">ListInsert(pL,i,e);</div><div class="line">printf(&quot;new list :&quot;);</div><div class="line">ListPrint(pL);</div><div class="line">printf(&quot;\n&quot;);</div><div class="line"></div><div class="line">//删除元素</div><div class="line">printf(&quot;intput location to delete :&quot;);</div><div class="line">scanf(&quot;%d&quot;,&amp;i);</div><div class="line">ListDelete(pL, i);</div><div class="line">printf(&quot;new list :&quot;);</div><div class="line">ListPrint(pL);</div><div class="line">printf(&quot;\n&quot;);</div><div class="line"></div><div class="line">return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status GetElem(SqList L,int i,ElemType *pe)</div><div class="line">&#123;</div><div class="line">if(i&lt;1||L.length==0||i&gt;MAXSIZE)return ERROR;</div><div class="line">else *pe=L.data[i-1];</div><div class="line"></div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"> Status Initialize(SqList * pL)</div><div class="line">&#123;</div><div class="line">for(int i=0;i&lt;10;i++)</div><div class="line">    pL-&gt;data[i]=i;</div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status ListPrint(SqList * pL)</div><div class="line">&#123;</div><div class="line">for(int i=0;i&lt;pL-&gt;length;i++)</div><div class="line">    printf(&quot;%d &quot;,pL-&gt;data[i]);</div><div class="line">printf(&quot;\n&quot;);</div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status ListInsert(SqList * pL,int i,ElemType e)</div><div class="line">&#123;</div><div class="line">if(pL-&gt;length==MAXSIZE)return ERROR;</div><div class="line">if(i&lt;1||i&gt;=pL-&gt;length+2)return ERROR;</div><div class="line">if(i&lt;=pL-&gt;length)</div><div class="line">    for(int k=pL-&gt;length-1;k&gt;=i-1;k--)</div><div class="line">        pL-&gt;data[k+1]=pL-&gt;data[k];</div><div class="line"></div><div class="line">pL-&gt;data[i-1]=e;</div><div class="line">pL-&gt;length++;</div><div class="line"></div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status ListDelete(SqList *pL,ElemType i)</div><div class="line">&#123;</div><div class="line">if(pL-&gt;length==0)return ERROR;</div><div class="line">if(i&lt;1||i&gt;pL-&gt;length)return ERROR;</div><div class="line">if(i&lt;=pL-&gt;length)</div><div class="line">    for(int k=i;k&lt;pL-&gt;length;k++)</div><div class="line">        pL-&gt;data[k-1]=pL-&gt;data[k];</div><div class="line">pL-&gt;length--;</div><div class="line"></div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include&lt;time.h&gt;</div><div class="line">#define OK 1</div><div class="line">#define ERROR 0</div><div class="line">typedef int ElemType;</div><div class="line">typedef int Status;</div><div class="line">typedef struct Node</div><div class="line">&#123;</div><div class="line">ElemType data;</div><div class="line">struct Node * next;</div><div class="line">&#125;Node;</div><div class="line">typedef struct Node * LinkList;</div><div class="line"> </div><div class="line">void CreateListTail(LinkList L,int n);</div><div class="line">void ListPrint(LinkList L);</div><div class="line">Status GetElem(LinkList L,int i,ElemType * pe);</div><div class="line">Status ListInsert(LinkList L,int i,ElemType e);</div><div class="line">Status ListDelete(LinkList L,int i,ElemType * pe);</div><div class="line">Status ListClear(LinkList L);</div></pre></td></tr></table></figure>
<p>xcode下运行通过（下同）</p>
<h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><p>指用链式存储结构，用一组任意的存储单元存放线性表的元素</p>
<p>对于单链表：<br>查找 时间复杂度为o[n]<br>插入，删除 时间复杂度为o[1]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include&lt;time.h&gt;</div><div class="line">#define OK 1</div><div class="line">#define ERROR 0</div><div class="line">typedef int ElemType;</div><div class="line">typedef int Status;</div><div class="line">typedef struct Node</div><div class="line">&#123;</div><div class="line">ElemType data;</div><div class="line">struct Node * next;</div><div class="line">&#125;Node;</div><div class="line">typedef struct Node * LinkList;</div><div class="line"> </div><div class="line">void CreateListTail(LinkList L,int n);</div><div class="line">void ListPrint(LinkList L);</div><div class="line">Status GetElem(LinkList L,int i,ElemType * pe);</div><div class="line">Status ListInsert(LinkList L,int i,ElemType e);</div><div class="line">Status ListDelete(LinkList L,int i,ElemType * pe);</div><div class="line">Status ListClear(LinkList L);</div><div class="line"></div><div class="line">int</div><div class="line">main(void)</div><div class="line">&#123;</div><div class="line">LinkList L=(LinkList)malloc(sizeof(Node));</div><div class="line">int n,i,e;</div><div class="line">int *pe=&amp;e;</div><div class="line"> </div><div class="line">//初始化链表(尾插法)</div><div class="line">//注意：该链表头节点记录链表长度，从头节点的相邻节点开始计数</div><div class="line">printf(&quot;Input total number of nodes :&quot;);</div><div class="line">scanf(&quot;%d&quot;,&amp;n);</div><div class="line">CreateListTail(L,n);</div><div class="line">ListPrint(L);</div><div class="line"> </div><div class="line">//读取节点数据</div><div class="line">printf(&quot;Input location of node &quot;);</div><div class="line">scanf(&quot;%d&quot;,&amp;i);</div><div class="line">GetElem(L,i,pe);</div><div class="line">printf(&quot;GetElem :&quot;);</div><div class="line">printf(&quot;%d\n\n&quot;,e);</div><div class="line"> </div><div class="line">//插入节点</div><div class="line">printf(&quot;Input location to insert :&quot;);</div><div class="line">scanf(&quot;%d&quot;,&amp;i);</div><div class="line">printf(&quot;Input data to insert :&quot;);</div><div class="line">scanf(&quot;%d&quot;,&amp;e);</div><div class="line">ListInsert(L,i,e);</div><div class="line">ListPrint(L);</div><div class="line"> </div><div class="line">//删除节点</div><div class="line">printf(&quot;Input location to delete :&quot;);</div><div class="line">scanf(&quot;%d&quot;,&amp;i);</div><div class="line">ListDelete(L,i,pe);</div><div class="line">ListPrint(L);</div><div class="line"> </div><div class="line">//删除链表</div><div class="line">ListClear(L);</div><div class="line">printf(&quot;ListClear :&quot;);</div><div class="line">ListPrint(L);</div><div class="line">printf(&quot;Well done!\n\n&quot;);</div><div class="line">  </div><div class="line">return 0;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">void CreateListTail(LinkList L,int n)</div><div class="line">&#123;</div><div class="line">LinkList tmp,tail;</div><div class="line">L-&gt;data=n;</div><div class="line">tail=L;</div><div class="line">srand(time(0));</div><div class="line">for(int i=0;i&lt;n;i++)</div><div class="line">&#123;</div><div class="line">tmp=(LinkList)malloc(sizeof(Node));</div><div class="line">tmp-&gt;data=rand()%100+1;</div><div class="line">tail-&gt;next=tmp;</div><div class="line">tail=tmp;</div><div class="line">&#125;</div><div class="line">tail-&gt;next=NULL;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">void ListPrint(LinkList L)</div><div class="line">&#123;</div><div class="line">LinkList s;</div><div class="line">s=L;</div><div class="line">printf(&quot;new list :&quot;);</div><div class="line">while(s!=NULL)</div><div class="line">&#123;</div><div class="line">printf(&quot;%d &quot;,s-&gt;data);</div><div class="line">s=s-&gt;next;</div><div class="line">&#125;</div><div class="line">printf(&quot;\n\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status GetElem(LinkList L,int i,ElemType * pe)</div><div class="line">&#123;</div><div class="line">LinkList tmp;</div><div class="line">tmp=L-&gt;next;</div><div class="line">for(int j=1;tmp&amp;&amp;j&lt;i;j++)</div><div class="line">tmp=tmp-&gt;next;</div><div class="line"> </div><div class="line">if(!tmp||i&lt;1)</div><div class="line">&#123;   printf(&quot;\nerror!\n&quot;);</div><div class="line"> return ERROR;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">*pe=tmp-&gt;data;</div><div class="line"> </div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status ListInsert(LinkList L,int i,ElemType e)</div><div class="line">&#123;</div><div class="line"> LinkList tmp,new;</div><div class="line"> tmp=L;</div><div class="line"> for(int j=1;j&lt;i;j++)</div><div class="line">     tmp=tmp-&gt;next;</div><div class="line"> if(!tmp||i&lt;1)</div><div class="line"> &#123;   printf(&quot;\nerror!\n&quot;);</div><div class="line">     return ERROR;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> new=(LinkList)malloc(sizeof(Node));</div><div class="line"> new-&gt;data=e;</div><div class="line"> new-&gt;next=tmp-&gt;next;</div><div class="line"> tmp-&gt;next=new;</div><div class="line"> L-&gt;data++;</div><div class="line">     return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status ListDelete(LinkList L,int i,ElemType * pe)</div><div class="line">&#123;</div><div class="line"> LinkList tmp,dele;</div><div class="line"> //tmp-&gt;next指向第一元素</div><div class="line"> tmp=L;</div><div class="line"> for(int j=1;tmp-&gt;next&amp;&amp;j&lt;i;j++)</div><div class="line">     tmp=tmp-&gt;next;</div><div class="line"> if(!tmp-&gt;next||i&lt;1)</div><div class="line"> &#123;   printf(&quot;\nerror!\n&quot;);</div><div class="line">     return ERROR;</div><div class="line"> &#125;</div><div class="line"> dele=tmp-&gt;next;</div><div class="line"> * pe=dele-&gt;data;</div><div class="line"> tmp-&gt;next=dele-&gt;next;</div><div class="line"> free(dele);</div><div class="line"> L-&gt;data--;</div><div class="line"> return OK;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> Status ListClear(LinkList L)</div><div class="line">&#123;</div><div class="line"> LinkList dele,tmp;</div><div class="line"> dele=L-&gt;next;</div><div class="line"> while(dele)</div><div class="line"> &#123;</div><div class="line">     tmp=dele-&gt;next;</div><div class="line">     free(dele);</div><div class="line">     dele=tmp;</div><div class="line"> &#125;</div><div class="line"> L-&gt;data=0;</div><div class="line"> L-&gt;next=NULL;</div><div class="line"> return OK;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h2 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h2><p>指用数组描述的链表，也叫游标实现法<br>为没有指针的高级语言提供一种链表的实现方法</p>
<p>查找 时间复杂度为o[n]<br>插入，删除 时间复杂度为o[1]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include&lt;time.h&gt;</div><div class="line">#define OK 1</div><div class="line">#define ERROR 0</div><div class="line">#define MAXSIZE 30</div><div class="line">typedef int Status;</div><div class="line">typedef int ElemType;</div><div class="line"></div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">ElemType data;</div><div class="line">int cur;</div><div class="line">&#125;Component,StaticLinkList[MAXSIZE];</div><div class="line"></div><div class="line">Status ListInit(StaticLinkList L);</div><div class="line">Status ListPrint(StaticLinkList L);</div><div class="line">int MallocSLL(StaticLinkList L);</div><div class="line">int ListLength(StaticLinkList L);</div><div class="line">void FreeSSL(StaticLinkList L,int k);</div><div class="line">Status ListInsert(StaticLinkList L,int i,ElemType e);</div><div class="line">Status ListDelete(StaticLinkList L,int i);</div><div class="line">  </div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">StaticLinkList L;</div><div class="line">int i,e;</div><div class="line">srand(time(0));</div><div class="line"></div><div class="line">//初始化链表</div><div class="line">//第一个元素的cur存放第一个空闲节点的下标</div><div class="line">//最后一个元素的cur存放第一个占用节点的下标，相当于头节点</div><div class="line">   </div><div class="line">printf(&quot;new list :&quot;);</div><div class="line">ListInit(L);</div><div class="line">ListPrint(L);</div><div class="line">printf(&quot;\n&quot;);</div><div class="line"></div><div class="line">//生成随机链表</div><div class="line">printf(&quot;input the total number of element :&quot;);</div><div class="line">scanf(&quot;%d&quot;,&amp;i);</div><div class="line">for(int j=0;j&lt;i;j++)</div><div class="line">&#123;</div><div class="line">    e=rand()%100+1;</div><div class="line">    ListInsert(L,1,e);</div><div class="line">&#125;</div><div class="line">printf(&quot;new list :&quot;);</div><div class="line">ListPrint(L);</div><div class="line">printf(&quot;\n&quot;);</div><div class="line"></div><div class="line">//插入单个元素</div><div class="line">printf(&quot;input positio to insert :&quot;);</div><div class="line">scanf(&quot;%d&quot;,&amp;i);</div><div class="line">printf(&quot;input data to insert :&quot;);</div><div class="line">scanf(&quot;%d&quot;,&amp;e);</div><div class="line">ListInsert(L,i,e);</div><div class="line">printf(&quot;new list :&quot;);</div><div class="line">ListPrint(L);</div><div class="line">printf(&quot;\n&quot;);</div><div class="line"></div><div class="line">//删除元素</div><div class="line">printf(&quot;input positio to delete :&quot;);</div><div class="line">scanf(&quot;%d&quot;,&amp;i);</div><div class="line">ListDelete(L, i);</div><div class="line">printf(&quot;new list: &quot;);</div><div class="line">ListPrint(L);</div><div class="line">printf(&quot;\n&quot;);</div><div class="line"></div><div class="line">printf(&quot;done !\n\n&quot;); </div><div class="line">&#125;</div><div class="line"></div><div class="line">Status ListInit(StaticLinkList L)</div><div class="line">&#123;</div><div class="line">int i;</div><div class="line">for(i=0;i&lt;MAXSIZE-1;i++)</div><div class="line">    L[i].cur=i+1;</div><div class="line">L[MAXSIZE-1].cur=0;</div><div class="line">L[0].data=0;</div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status ListPrint(StaticLinkList L)</div><div class="line">&#123;</div><div class="line">int i=L[MAXSIZE-1].cur;</div><div class="line">if(!i)printf(&quot;init !&quot;);</div><div class="line">while(i)</div><div class="line">&#123;</div><div class="line">    printf(&quot;%d &quot;,L[i].data);</div><div class="line">    i=L[i].cur;</div><div class="line">&#125;</div><div class="line">printf(&quot;\n&quot;);</div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int MallocSLL(StaticLinkList L)</div><div class="line">&#123;   </div><div class="line">int i=L[0].cur;</div><div class="line">if(L[0].cur)</div><div class="line">    L[0].cur=L[i].cur;</div><div class="line">return i;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void FreeSSL(StaticLinkList L,int k)</div><div class="line">&#123;</div><div class="line">L[0].cur=L[k].cur;</div><div class="line">L[k].cur=0;</div><div class="line">return;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status ListInsert(StaticLinkList L,int i,ElemType e)</div><div class="line">&#123;</div><div class="line">int seek,new,k;</div><div class="line">seek=MAXSIZE-1;</div><div class="line">if(i&lt;0||i&gt;ListLength(L)+1)</div><div class="line">&#123;</div><div class="line">    printf(&quot;Insert Failed!\n&quot;);</div><div class="line">    return ERROR;</div><div class="line">&#125;</div><div class="line">new=MallocSLL(L);</div><div class="line">if(new)</div><div class="line">&#123;</div><div class="line">    L[new].data=e;</div><div class="line">    for(k=0;k&lt;i-1;k++)</div><div class="line">        seek=L[seek].cur;</div><div class="line">    L[new].cur=L[seek].cur;</div><div class="line">    L[seek].cur=new;</div><div class="line">    L[0].data++;</div><div class="line">    return OK;</div><div class="line">&#125;</div><div class="line">else</div><div class="line">&#123;</div><div class="line">    printf(&quot;Malloc Failed!\n&quot;);</div><div class="line">    return ERROR;</div><div class="line">&#125;</div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status ListDelete(StaticLinkList L,int i)</div><div class="line">&#123;</div><div class="line">int j,k;</div><div class="line">if(i&lt;1||i&gt;ListLength(L))</div><div class="line">&#123;   printf(&quot;Delete Failed\n&quot;);</div><div class="line">    return ERROR;</div><div class="line">&#125;</div><div class="line">k=MAXSIZE-1;</div><div class="line">for(j=1;j&lt;=i-1;j++)</div><div class="line">    k=L[k].cur;</div><div class="line">j=L[k].cur;</div><div class="line">L[k].cur=L[j].cur;</div><div class="line">FreeSSL(L, j);</div><div class="line">L[0].data--;</div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int ListLength(StaticLinkList L)</div><div class="line">&#123;</div><div class="line">int j=0,i=MAXSIZE-1;</div><div class="line">while(i)</div><div class="line">&#123;</div><div class="line">    i=L[i].cur;</div><div class="line">    j++;</div><div class="line">&#125;</div><div class="line">return j;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h2><p>头尾相连的环状单链表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include&lt;time.h&gt;</div><div class="line">#define OK 1</div><div class="line">#define ERROR 0</div><div class="line">typedef int ElemType;</div><div class="line">typedef int Status;</div><div class="line">typedef struct Node</div><div class="line">&#123;</div><div class="line">ElemType data;</div><div class="line">struct Node * next;</div><div class="line">&#125;Node;</div><div class="line">typedef struct Node * LinkList;</div><div class="line"></div><div class="line">Status ListInit(LinkList * L,int n);</div><div class="line">void ListPrint(LinkList L);</div><div class="line">Status GetElem(LinkList L,int i,ElemType * pe);</div><div class="line">Status ListInsert(LinkList *L,int i,ElemType e);</div><div class="line">Status ListDelete(LinkList *L,int i,ElemType * pe);</div><div class="line">Status ListClear(LinkList *L);</div><div class="line"></div><div class="line">int</div><div class="line">main(void)</div><div class="line">&#123;</div><div class="line">LinkList L;</div><div class="line">srand(time(0));</div><div class="line">int n=rand()%10+1;</div><div class="line">int e,*pe=&amp;e;</div><div class="line"></div><div class="line">//初始化链表</div><div class="line">ListInit(&amp;L,n);</div><div class="line">ListPrint(L);</div><div class="line"></div><div class="line">//获取节点数据</div><div class="line">printf(&quot;input number of node :&quot;);</div><div class="line">scanf(&quot;%d&quot;,&amp;n);</div><div class="line">GetElem(L, n, pe);</div><div class="line"></div><div class="line">//删除节点</div><div class="line">printf(&quot;input number of node to delete :&quot;);</div><div class="line">scanf(&quot;%d&quot;,&amp;n);</div><div class="line">ListDelete(&amp;L, n, pe);</div><div class="line">ListPrint(L);</div><div class="line"></div><div class="line">//清空链表</div><div class="line">ListClear(&amp;L);</div><div class="line">ListPrint(L);</div><div class="line"></div><div class="line">printf(&quot;done!\n\n&quot;);</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">Status ListInit(LinkList * L,int n)</div><div class="line">&#123;</div><div class="line">(*L)=(LinkList)malloc(sizeof(struct Node));</div><div class="line">if(!*L)</div><div class="line">&#123;</div><div class="line">    printf(&quot;malloc failed&quot;);</div><div class="line">    return ERROR;</div><div class="line">&#125;</div><div class="line">(*L)-&gt;next=*L;</div><div class="line">(*L)-&gt;data=1;</div><div class="line">for(int i=1;i&lt;=n;i++)</div><div class="line">&#123;</div><div class="line">    int e=rand()%100+1;</div><div class="line">    ListInsert(L, i, e);</div><div class="line">&#125;</div><div class="line">printf(&quot;Init!\n&quot;);</div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line">  </div><div class="line">void ListPrint(LinkList L)</div><div class="line">&#123;</div><div class="line">LinkList seek;</div><div class="line">seek=L-&gt;next;</div><div class="line">printf(&quot;new list:&quot;);</div><div class="line">while(seek!=L)</div><div class="line">&#123;</div><div class="line">    printf(&quot;%d &quot;,seek-&gt;data);</div><div class="line">    seek=seek-&gt;next;</div><div class="line">&#125;</div><div class="line">printf(&quot;\n\n&quot;);</div><div class="line">return;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">Status GetElem(LinkList L,int i,ElemType * pe)</div><div class="line">&#123;</div><div class="line">LinkList seek;</div><div class="line">int k=1;</div><div class="line">seek=L-&gt;next;</div><div class="line">while(k&lt;i)</div><div class="line">&#123;</div><div class="line">    seek=seek-&gt;next;</div><div class="line">    k++;</div><div class="line">&#125;</div><div class="line">*pe=seek-&gt;data;</div><div class="line">printf(&quot;GetElem: %d\n\n&quot;,*pe);</div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"> Status ListInsert(LinkList *L,int i,ElemType e)</div><div class="line">&#123;</div><div class="line">int k=0;</div><div class="line">LinkList seek=(*L)-&gt;next;</div><div class="line">LinkList tmp;</div><div class="line">if(i&lt;0||i&gt;(*L)-&gt;data)</div><div class="line">&#123;</div><div class="line">    printf(&quot;Insert failed&quot;);</div><div class="line">    return ERROR;</div><div class="line">&#125;</div><div class="line"></div><div class="line">while(k&lt;i-1)</div><div class="line">&#123;</div><div class="line">    seek=seek-&gt;next;</div><div class="line">    k++; </div><div class="line">&#125;</div><div class="line">    tmp=(LinkList)malloc(sizeof(struct Node));</div><div class="line">    tmp-&gt;next=seek-&gt;next;</div><div class="line">    tmp-&gt;data=e;</div><div class="line">    seek-&gt;next=tmp;</div><div class="line">    (*L)-&gt;data++;</div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status ListDelete(LinkList *L,int i,ElemType * pe)</div><div class="line">&#123;</div><div class="line"></div><div class="line">LinkList seek;</div><div class="line">int k=1;</div><div class="line">if(i&lt;0||i&gt;(*L)-&gt;data)</div><div class="line">&#123;</div><div class="line">    printf(&quot;Delete failed&quot;);</div><div class="line">    return ERROR;</div><div class="line">&#125;</div><div class="line">seek=(*L)-&gt;next;</div><div class="line">while(k&lt;i-1)</div><div class="line">&#123;</div><div class="line">    seek=seek-&gt;next;</div><div class="line">    k++;</div><div class="line">&#125;</div><div class="line">LinkList tmp=seek-&gt;next;</div><div class="line">seek-&gt;next=tmp-&gt;next;</div><div class="line">*pe=tmp-&gt;data;</div><div class="line">free(tmp);</div><div class="line">(*L)-&gt;data--;</div><div class="line">return OK;  </div><div class="line">&#125;</div><div class="line"></div><div class="line">Status ListClear(LinkList *L)</div><div class="line">&#123;</div><div class="line">LinkList seek,tmp;</div><div class="line">seek=(*L)-&gt;next;</div><div class="line">while(seek!=*L)</div><div class="line">&#123;</div><div class="line">    tmp=seek;</div><div class="line">    seek=seek-&gt;next;</div><div class="line">    free(tmp);</div><div class="line">&#125;</div><div class="line">(*L)-&gt;next=*L;</div><div class="line">(*L)-&gt;data=1;</div><div class="line">return OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>具有前驱指针与后继指针的链表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include&lt;time.h&gt;</div><div class="line">#define OK 1</div><div class="line">#define ERROR 0</div><div class="line">typedef int ElemType;</div><div class="line">typedef int Status;</div><div class="line">typedef struct Node</div><div class="line">&#123;</div><div class="line">ElemType data;</div><div class="line">struct Node * prev;</div><div class="line">struct Node * next;</div><div class="line">&#125;Node;</div><div class="line">typedef struct Node * LinkList;</div><div class="line"></div><div class="line">Status ListInit(LinkList * L,int n);</div><div class="line">void ListPrint(LinkList L);</div><div class="line">Status GetElem(LinkList L,int i,ElemType * pe);</div><div class="line">Status GetPrevElem(LinkList tmp,ElemType * pe);</div><div class="line">Status ListInsert(LinkList *L,int i,ElemType e);</div><div class="line">Status ListDelete(LinkList *L,int i,ElemType * pe);</div><div class="line">Status ListClear(LinkList *L);</div><div class="line"></div><div class="line">int</div><div class="line">main()</div><div class="line">&#123;</div><div class="line">LinkList L;</div><div class="line">srand(time(0));</div><div class="line">int n=rand()%10+1;</div><div class="line">int e,*pe=&amp;e;</div><div class="line">  </div><div class="line"></div><div class="line">//初始化链表</div><div class="line">ListInit(&amp;L,n);</div><div class="line">ListPrint(L);</div><div class="line"></div><div class="line">//读取节点数据</div><div class="line">printf(&quot;input number of node :&quot;);</div><div class="line">scanf(&quot;%d&quot;,&amp;n);</div><div class="line">GetElem(L, n, pe);</div><div class="line">printf(&quot;GetElem: %d\n\n&quot;,*pe);</div><div class="line"></div><div class="line">//读取前一节点数据</div><div class="line">printf(&quot;input number of node :&quot;);</div><div class="line">scanf(&quot;%d&quot;,&amp;n);</div><div class="line">LinkList seek=L-&gt;next;</div><div class="line">for(int k=1;k&lt;=n;k++)</div><div class="line">&#123;</div><div class="line">seek=seek-&gt;next;</div><div class="line">k++;</div><div class="line">&#125;</div><div class="line">GetPrevElem(seek, pe);</div><div class="line">printf(&quot;GetPrevElem: %d\n\n&quot;,*pe);</div><div class="line"></div><div class="line">//删除节点数据</div><div class="line">printf(&quot;input number of node to delete :&quot;);</div><div class="line">scanf(&quot;%d&quot;,&amp;n);</div><div class="line">ListDelete(&amp;L, n, pe);</div><div class="line">ListPrint(L);</div><div class="line"></div><div class="line">//清空链表</div><div class="line">ListClear(&amp;L);</div><div class="line">printf(&quot;ListClear \n&quot;);</div><div class="line">ListPrint(L);</div><div class="line"></div><div class="line">printf(&quot;done!\n\n&quot;);</div><div class="line">return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line"> Status ListInit(LinkList * L,int n)</div><div class="line">&#123;</div><div class="line">(*L)=(LinkList)malloc(sizeof(Node));</div><div class="line">if(!*L)</div><div class="line">&#123;</div><div class="line">    printf(&quot;malloc failed!\n&quot;);</div><div class="line">    return ERROR;</div><div class="line">&#125;</div><div class="line"></div><div class="line">(*L)-&gt;data=1;</div><div class="line">(*L)-&gt;next=NULL;</div><div class="line">(*L)-&gt;prev=NULL;</div><div class="line">for(int i=1;i&lt;=n;i++)</div><div class="line">&#123;</div><div class="line">    int e=rand()%100+1;</div><div class="line">    ListInsert(L, i, e);</div><div class="line">&#125;</div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void ListPrint(LinkList L)</div><div class="line">&#123;</div><div class="line">LinkList seek=L-&gt;next;</div><div class="line">printf(&quot;new list :&quot;);</div><div class="line">while(seek)</div><div class="line">&#123;</div><div class="line">    printf(&quot;%d &quot;,seek-&gt;data);</div><div class="line">    seek=seek-&gt;next;</div><div class="line">&#125;</div><div class="line">printf(&quot;\n\n&quot;);</div><div class="line">return;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status GetElem(LinkList L,int i,ElemType * pe)</div><div class="line">&#123;</div><div class="line">LinkList seek=L-&gt;next;</div><div class="line">if(i&lt;1||i&gt;L-&gt;data)</div><div class="line">&#123;</div><div class="line">    printf(&quot;GetElem failed!\n&quot;);</div><div class="line">    return ERROR;</div><div class="line">&#125;</div><div class="line"></div><div class="line">for(int k=1;k&lt;i;k++)</div><div class="line">    seek=seek-&gt;next;</div><div class="line">*pe=seek-&gt;data;</div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">Status GetPrevElem(LinkList tmp,ElemType * pe)</div><div class="line">&#123;</div><div class="line">*pe=tmp-&gt;prev-&gt;data;</div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">Status ListInsert(LinkList *L,int i,ElemType e)</div><div class="line">&#123;</div><div class="line">int k=1;</div><div class="line">LinkList seek=(*L);</div><div class="line">if(i&lt;1||i&gt;(*L)-&gt;data)</div><div class="line">&#123;</div><div class="line">    printf(&quot;ListInsert failed!\n&quot;);</div><div class="line">    return ERROR;</div><div class="line">&#125;</div><div class="line"></div><div class="line">while(k&lt;i)</div><div class="line">&#123;</div><div class="line">    seek=seek-&gt;next;</div><div class="line">    k++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">LinkList tmp=(LinkList)malloc(sizeof(struct Node));</div><div class="line">tmp-&gt;data=rand()%100+1;</div><div class="line">tmp-&gt;next=seek-&gt;next;</div><div class="line">tmp-&gt;prev=seek;</div><div class="line">seek-&gt;next=tmp;</div><div class="line">(*L)-&gt;data++;</div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status ListDelete(LinkList *L,int i,ElemType * pe)</div><div class="line">&#123;</div><div class="line">LinkList seek=(*L)-&gt;next;</div><div class="line">if(i&lt;1||i&gt;(*L)-&gt;data)</div><div class="line">&#123;</div><div class="line">    printf(&quot;ListDeletet failed!\n&quot;);</div><div class="line">    return ERROR;</div><div class="line">&#125;</div><div class="line"></div><div class="line">for(int k=1;k&lt;i-1;k++)</div><div class="line">    seek=seek-&gt;next;</div><div class="line"></div><div class="line">LinkList tmp=seek-&gt;next;</div><div class="line">seek-&gt;next=tmp-&gt;next;</div><div class="line">free(tmp);</div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status ListClear(LinkList *L)</div><div class="line">&#123;</div><div class="line">LinkList seek=(*L)-&gt;next;</div><div class="line">LinkList tmp;</div><div class="line">while(seek)</div><div class="line">&#123;</div><div class="line">    tmp=seek;</div><div class="line">    seek=seek-&gt;next;</div><div class="line">    free(tmp);</div><div class="line">&#125;</div><div class="line">(*L)-&gt;next=NULL;</div><div class="line">(*L)-&gt;data=1;</div><div class="line">return OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="循环双链表"><a href="#循环双链表" class="headerlink" title="循环双链表"></a>循环双链表</h2><p>具有双指针的环状链表<br>这里的几种链表的实现代码其实并没有太大区别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include&lt;time.h&gt;</div><div class="line">#define OK 1</div><div class="line">#define ERROR 0</div><div class="line">typedef int ElemType;</div><div class="line">typedef int Status;</div><div class="line">typedef struct Node</div><div class="line">&#123;</div><div class="line">ElemType data;</div><div class="line">struct Node * prev;</div><div class="line">struct Node * next;</div><div class="line">&#125;Node;</div><div class="line">typedef struct Node * LinkList;</div><div class="line">Status ListInit(LinkList * L,int n);</div><div class="line">void ListPrint(LinkList L);</div><div class="line">Status GetElem(LinkList L,int i,ElemType * pe);</div><div class="line">Status GetPrevElem(LinkList tmp,ElemType * pe);</div><div class="line">Status ListInsert(LinkList *L,int i,ElemType e);</div><div class="line">Status ListDelete(LinkList *L,int i,ElemType * pe);</div><div class="line">Status ListClear(LinkList *L);</div><div class="line"> </div><div class="line">int</div><div class="line">main()</div><div class="line">&#123;  </div><div class="line"> LinkList L;</div><div class="line">srand(time(0));</div><div class="line">int n=rand()%10+1;</div><div class="line">int e,*pe=&amp;e;</div><div class="line"> </div><div class="line">//初始化链表</div><div class="line">//尾插法</div><div class="line">ListInit(&amp;L,n);</div><div class="line">ListPrint(L);</div><div class="line"> </div><div class="line">//读取节点数据</div><div class="line">printf(&quot;input number of node :&quot;);</div><div class="line">scanf(&quot;%d&quot;,&amp;n);</div><div class="line">GetElem(L, n, pe);</div><div class="line">printf(&quot;GetElem: %d\n\n&quot;,*pe);</div><div class="line"> </div><div class="line">//读取前一节点数据</div><div class="line">printf(&quot;input number of node :&quot;);</div><div class="line">scanf(&quot;%d&quot;,&amp;n);</div><div class="line">LinkList seek=L-&gt;next;</div><div class="line">for(int k=1;k&lt;=n;k++)</div><div class="line">&#123;</div><div class="line">seek=seek-&gt;next;</div><div class="line">k++;</div><div class="line">&#125;</div><div class="line">GetPrevElem(seek, pe);</div><div class="line">printf(&quot;GetPrevElem: %d\n\n&quot;,*pe);</div><div class="line"> </div><div class="line">//删除节点数据</div><div class="line">printf(&quot;input number of node to delete :&quot;);</div><div class="line">scanf(&quot;%d&quot;,&amp;n);</div><div class="line">ListDelete(&amp;L, n, pe);</div><div class="line">ListPrint(L);</div><div class="line"> </div><div class="line">//清空链表</div><div class="line">ListClear(&amp;L);</div><div class="line">printf(&quot;ListClear \n&quot;);</div><div class="line">ListPrint(L);</div><div class="line">   </div><div class="line">printf(&quot;done!\n\n&quot;);</div><div class="line"></div><div class="line">return 0;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">Status ListInit(LinkList * L,int n)</div><div class="line">&#123;</div><div class="line">(*L)=(LinkList)malloc(sizeof(Node));</div><div class="line">if(!*L)</div><div class="line">&#123;</div><div class="line">printf(&quot;malloc failed!\n&quot;);</div><div class="line">return ERROR;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">(*L)-&gt;data=1;</div><div class="line">(*L)-&gt;next=(*L);</div><div class="line">(*L)-&gt;prev=(*L);</div><div class="line">LinkList new,tail;</div><div class="line">tail=(*L);</div><div class="line"> </div><div class="line">for(int i=1;i&lt;=n;i++)</div><div class="line"> &#123;</div><div class="line"> int e=rand()%100+1;</div><div class="line"> new=(LinkList)malloc(sizeof(Node));</div><div class="line"> new-&gt;data=e;</div><div class="line"> </div><div class="line"> tail-&gt;next=new;</div><div class="line"> new-&gt;prev=tail;</div><div class="line"> new-&gt;next=(*L);</div><div class="line"> (*L)-&gt;prev=new;</div><div class="line"> tail=new;</div><div class="line"> (*L)-&gt;data++;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">void ListPrint(LinkList L)</div><div class="line">&#123;</div><div class="line">LinkList seek=L-&gt;next;</div><div class="line">printf(&quot;new list :&quot;);</div><div class="line">while(seek!=L)</div><div class="line">&#123;</div><div class="line">printf(&quot;%d &quot;,seek-&gt;data);</div><div class="line">seek=seek-&gt;next;</div><div class="line">&#125;</div><div class="line">printf(&quot;\n\n&quot;);</div><div class="line">return;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"> </div><div class="line">Status GetElem(LinkList L,int i,ElemType * pe)</div><div class="line">&#123;</div><div class="line">LinkList seek=L-&gt;next;</div><div class="line">if(i&lt;1||i&gt;L-&gt;data)</div><div class="line">&#123;</div><div class="line">printf(&quot;GetElem failed!\n&quot;);</div><div class="line">return ERROR;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">for(int k=1;k&lt;i;k++)</div><div class="line">seek=seek-&gt;next;</div><div class="line">*pe=seek-&gt;data;</div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">Status GetPrevElem(LinkList tmp,ElemType * pe)</div><div class="line">&#123;</div><div class="line">*pe=tmp-&gt;prev-&gt;data;</div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"> </div><div class="line">Status ListInsert(LinkList *L,int i,ElemType e)</div><div class="line">&#123;</div><div class="line">int k=1;</div><div class="line">LinkList seek=(*L);</div><div class="line">if(i&lt;1||i&gt;(*L)-&gt;data)</div><div class="line">&#123;</div><div class="line">printf(&quot;ListInsert failed!\n&quot;);</div><div class="line">return ERROR;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">while(k&lt;i)</div><div class="line">&#123;</div><div class="line">seek=seek-&gt;next;</div><div class="line">k++;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">LinkList tmp=(LinkList)malloc(sizeof(struct Node));</div><div class="line">tmp-&gt;data=rand()%100+1;</div><div class="line">tmp-&gt;next=seek-&gt;next;</div><div class="line">tmp-&gt;prev=seek;</div><div class="line">seek-&gt;next=tmp;</div><div class="line">(*L)-&gt;data++;</div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">Status ListDelete(LinkList *L,int i,ElemType * pe)</div><div class="line">&#123;</div><div class="line">LinkList seek=(*L)-&gt;next;</div><div class="line">if(i&lt;1||i&gt;(*L)-&gt;data)</div><div class="line">&#123;</div><div class="line">printf(&quot;ListDeletet failed!\n&quot;);</div><div class="line">return ERROR;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">for(int k=1;k&lt;i-1;k++)</div><div class="line">seek=seek-&gt;next;</div><div class="line"> </div><div class="line">LinkList tmp=seek-&gt;next;</div><div class="line">seek-&gt;next=tmp-&gt;next;</div><div class="line">free(tmp);</div><div class="line">(*L)-&gt;data--;</div><div class="line"> </div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">Status ListClear(LinkList *L)</div><div class="line">&#123;</div><div class="line">LinkList seek=(*L)-&gt;next;</div><div class="line">LinkList tmp;</div><div class="line">while(seek!=(*L))</div><div class="line">&#123;</div><div class="line">tmp=seek;</div><div class="line">seek=seek-&gt;next;</div><div class="line">free(tmp);</div><div class="line">&#125;</div><div class="line">(*L)-&gt;next=(*L);</div><div class="line">(*L)-&gt;prev=(*L);</div><div class="line">(*L)-&gt;data=1;</div><div class="line"> </div><div class="line">return OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h2><p>栈是限定仅在表尾进行插入和删除操作的线性表<br>顺序存储结构的栈简称顺序栈</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include&lt;time.h&gt;</div><div class="line">#define OK 1</div><div class="line">#define ERROR 0</div><div class="line">#define MAXSIZE 30</div><div class="line">typedef int SElemType;</div><div class="line">typedef int Status;</div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">SElemType data[MAXSIZE];</div><div class="line">int top;</div><div class="line">&#125;SqStack;</div><div class="line"></div><div class="line">void StackPrint(SqStack *sp);</div><div class="line">Status Push(SqStack *sp,SElemType e);</div><div class="line">Status Pop(SqStack *sp,SElemType * ep);</div><div class="line"></div><div class="line">int</div><div class="line">main(void)</div><div class="line">&#123;</div><div class="line">int i,e,k,*ep=&amp;e;</div><div class="line">SqStack S;</div><div class="line">SqStack *sp=&amp;S;</div><div class="line">srand(time(0));</div><div class="line"></div><div class="line">//初始化随机栈</div><div class="line">i=rand()%10;</div><div class="line">S.top=i;</div><div class="line">for(k=0;k&lt;=i;k++)</div><div class="line">    S.data[k]=rand()%100+1;</div><div class="line">StackPrint(sp);</div><div class="line"></div><div class="line">//进栈操作</div><div class="line">e=rand()%100+1;</div><div class="line">Push(sp,e);</div><div class="line">StackPrint(sp);</div><div class="line"></div><div class="line">//出栈操作</div><div class="line">Pop(sp,ep);</div><div class="line">StackPrint(sp);</div><div class="line"></div><div class="line">printf(&quot;done !\n\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void StackPrint(SqStack * sp)</div><div class="line">&#123;</div><div class="line">printf(&quot;new list: &quot;);</div><div class="line">for(int i=0;i&lt;=sp-&gt;top;i++)</div><div class="line">    printf(&quot;%d &quot;,sp-&gt;data[i]);</div><div class="line">printf(&quot;\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status Push(SqStack *sp,SElemType e)</div><div class="line">&#123;</div><div class="line">if(sp-&gt;top==MAXSIZE-1)</div><div class="line">&#123;</div><div class="line">    printf(&quot;Push Failed\n&quot;);</div><div class="line">    return ERROR;</div><div class="line">&#125;</div><div class="line">sp-&gt;top++;</div><div class="line">sp-&gt;data[sp-&gt;top]=e;</div><div class="line">return OK;</div><div class="line">&#125;</div><div class="line">   </div><div class="line">Status Pop(SqStack *sp,SElemType * ep)</div><div class="line">&#123;</div><div class="line">if(sp-&gt;top==-1)</div><div class="line">&#123;</div><div class="line">    printf(&quot;Pop Failed\n&quot;);</div><div class="line">    return ERROR;</div><div class="line">&#125;</div><div class="line">*ep=sp-&gt;data[sp-&gt;top];</div><div class="line">sp-&gt;top--;</div><div class="line">return OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>栈的其它几种结构以及进一步操作看上一篇</p>
]]></content>
      
        <categories>
            
            <category> 代码 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[git学习笔记]]></title>
      <url>/2016/12/06/git/</url>
      <content type="html"><![CDATA[<p>onDestroy<br><img src="http://p1.bpimg.com/4851/923b28f3dcd37179.jpg" class="img-topic"></p>
<a id="more"></a>
<h2 id="提交版本"><a href="#提交版本" class="headerlink" title="提交版本"></a>提交版本</h2><p>初始Git仓库：</p>
<pre><code>git init
</code></pre><p>   添加文件到Git仓库</p>
<pre><code>git add &lt;file&gt;   
</code></pre><p>   提交到版本库    </p>
<pre><code>git commit -m “ ”
</code></pre><p>   掌握工作区状态 </p>
<pre><code>git status
</code></pre><p>   git status告知有文件被修改，查看修改</p>
<pre><code>git diff
</code></pre><hr>
<pre><code>git add把文件修改添加到暂存区stage（或叫index）
git commit提交更改，实际上是把暂存区的所有内容提交到当前分支
.git/index 是一个包含文件索引的目录树
.git/master 是master分支所代表的目录树
这里目录树像是一个虚拟的工作区，当中记录了文件名、文件的状态信息（时间戳、文件长度等）
文件内容并不存储其中，而是保存在 Git 对象库（.git/objects）
</code></pre><h2 id="版本穿梭"><a href="#版本穿梭" class="headerlink" title="版本穿梭"></a>版本穿梭</h2><p>  HEAD指向当前版本，在版本的历史之间穿梭，使用命令</p>
<pre><code>git reset --hard commit_id 
</code></pre><hr>
<pre><code>git reset --hard^
</code></pre><hr>
<pre><code>git reset --hard^^
</code></pre><hr>
<pre><code>git reset --hard~100
</code></pre><p>   查看提交历史，确定回退版本 </p>
<pre><code>git log
</code></pre><hr>
<pre><code>＃精简输出 git log —pretty=oneline
</code></pre><p>  查看命令历史，确定未来版本 </p>
<pre><code>git reflog
</code></pre><h2 id="丢弃修改"><a href="#丢弃修改" class="headerlink" title="丢弃修改"></a>丢弃修改</h2><p>   未add，丢弃工作区的修改 </p>
<pre><code>git checkout -- file
</code></pre><p>   已add，丢弃修改</p>
<pre><code>git reset HEAD file
git checkout -- file
</code></pre><p>   已commit，撤销提交</p>
<pre><code>git reset —hard^
</code></pre><h2 id="删除恢复"><a href="#删除恢复" class="headerlink" title="删除恢复"></a>删除恢复</h2><p>   删除文件导致工作区版本库不一致，查看被删除文件</p>
<pre><code>git status
</code></pre><p>   确定要从版本库中删除该文件  </p>
<p>   添加删除信息到暂存区</p>
<pre><code>git rm &lt;&gt;
</code></pre><p>   更新版本库</p>
<pre><code>git commit
</code></pre><p>   恢复文件       </p>
<pre><code>git checkout -- file 
</code></pre><h2 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a>克隆仓库</h2><p>   克隆仓库  </p>
<pre><code>git clone
</code></pre><hr>
<pre><code>#Git支持多种协议，包括https
通过ssh支持的原生git协议速度最快
</code></pre><h2 id="控制分支"><a href="#控制分支" class="headerlink" title="控制分支"></a>控制分支</h2><p>   Git鼓励大量使用分支：</p>
<p>   查看分支：</p>
<pre><code>git branch
</code></pre><p>   创建分支：</p>
<pre><code>git branch &lt;name&gt;
</code></pre><p>   切换分支：</p>
<pre><code>git checkout &lt;name&gt; 
</code></pre><p>   创建+切换分支：</p>
<pre><code>git checkout -b &lt;name&gt;
</code></pre><p>   合并某分支到当前分支：</p>
<pre><code>git merge &lt;name&gt;
</code></pre><p>   删除已合并分支：</p>
<pre><code>git branch -d &lt;name&gt;
</code></pre><p>   删除未合并分支：</p>
<pre><code>git branch -D &lt;name&gt;
</code></pre><p>   合并分支：</p>
<p>   默认Fast forward模式，删除分支后丢掉分支信息</p>
<p>   禁用Fast forward模式 —no-ff 生成新commit</p>
<pre><code>git merge --no-ff -m “ ” &lt;branch name&gt;
</code></pre><p>   查看分支信息</p>
<pre><code>git log
</code></pre><h2 id="储藏工作区"><a href="#储藏工作区" class="headerlink" title="储藏工作区"></a>储藏工作区</h2><p>   储藏工作现场：   </p>
<pre><code>git stash   
</code></pre><p>   查看：            </p>
<pre><code>git stash list
</code></pre><p>   恢复：                    </p>
<pre><code>git stash apply
</code></pre><p>  删除：           </p>
<pre><code>git stash drop   
</code></pre><p>  恢复并删除：     </p>
<pre><code>git stash pop        
</code></pre><h2 id="远程库"><a href="#远程库" class="headerlink" title="远程库"></a>远程库</h2><p>   关联远程库</p>
<pre><code>git remote add origin git@server-name:path/repo-name.git
</code></pre><p>   关联后第一次推送master分支所有内容</p>
<pre><code>git push -u origin master
</code></pre><p>   推送最新修改</p>
<pre><code>git push origin master
</code></pre><p>   查看远程库信息: </p>
<pre><code>git remote -v
</code></pre><p> 从本地推送分支：</p>
<pre><code>git push origin branch-name
</code></pre><p>   推送失败,抓取远程的新提交 </p>
<pre><code>git pull
</code></pre><hr>
<pre><code>＃本地新建的分支不推送到远程，他人不可见
＃如有冲突,先处理冲突
</code></pre><p>   本地创建和远程分支对应的分支 </p>
<pre><code>git checkout -b branch-name origin/branch-name
</code></pre><p>   建立本地分支和远程分支的关联</p>
<pre><code>git branch --set-upstream branch-name origin/branch-name
</code></pre><hr>
<pre><code>＃本地和远程分支的名称最好一致
</code></pre><h2 id="使用标签"><a href="#使用标签" class="headerlink" title="使用标签"></a>使用标签</h2><p>   新建标签 </p>
<pre><code>git tag &lt;name&gt;
</code></pre><p>   查看标签</p>
<pre><code>git tag
</code></pre><p>   默认为HEAD，可以指定commit id</p>
<p>   指定标签信息 </p>
<pre><code>git tag -a &lt;tagname&gt; -m “ ”
</code></pre><p>   PGP签名标签 </p>
<pre><code>git tag -s &lt;tagname&gt; -m “ ”
</code></pre><p>   推送本地标签 </p>
<pre><code>git push origin &lt;tagname&gt;
</code></pre><p>   推送全部未推送的本地标签 </p>
<pre><code>git push origin —tags
</code></pre><p>   删除本地标签 </p>
<pre><code>git tag -d &lt;tagname&gt;
</code></pre><p>   删除远程标签 </p>
<pre><code>git push origin :refs/tags/&lt;tagname&gt;
</code></pre><h2 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h2><p>   忽略文件编写 .gitignore 放到版本库</p>
<p>   强制添加  </p>
<pre><code>git add -f &lt;file&gt;
</code></pre><p>   检查配置  </p>
<pre><code>git check-ignore &lt;file&gt;
</code></pre><h2 id="设置别名"><a href="#设置别名" class="headerlink" title="设置别名 "></a>设置别名 </h2><p>   配置别名</p>
<pre><code>git config --global alias.&lt;..&gt;  &lt;…….&gt;
</code></pre><hr>
<pre><code>git config --global alias.lg &quot;log --color --graph —pretty=format:&apos;%Cred%h %Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; —abbrev-commit&quot;
</code></pre><h2 id="搭建Git服务器"><a href="#搭建Git服务器" class="headerlink" title="搭建Git服务器"></a>搭建Git服务器</h2><p>   安装git</p>
<pre><code>sudo apt-get install git
</code></pre><p>   创建一个git用户</p>
<pre><code>sudo adduser git
</code></pre><p>   创建证书登录：<br>   收集所有需要登录的用户的公钥id_rsa.pub，把所<br>   有公钥导入到/home/git/.ssh/authorized_keys</p>
<p>   初始化Git仓库：<br>   先选定一个目录作为Git仓库，在目录下输入命令</p>
<pre><code>sudo git init --bare sample.git
</code></pre><p>   禁用shell登录：<br>   编辑/etc/passwd</p>
<pre><code>git:x:1001:1001:,,,:/home/git:/bin/bash
</code></pre><p>   改为</p>
<pre><code>git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell
</code></pre><p>   克隆远程仓库：</p>
<p>   通过git clone命令克隆远程仓库,在各自的电脑上运行</p>
<pre><code>git clone git@server:/srv/sample.git
</code></pre><p><img src="http://p1.bpimg.com/4851/e8b3de05b5049f9e.jpg"></p>
<pre><code>http://www.cnblogs.com/hutaoer/archive/2013/05/07/git_checkout.html?utm_source=tuicool&amp;utm_medium=referral
</code></pre><hr>
<pre><code>http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000
</code></pre>]]></content>
      
        <categories>
            
            <category> 笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[混乱的贪吃蛇C代码]]></title>
      <url>/2016/11/14/snakec/</url>
      <content type="html"><![CDATA[<p>咳咳！</p>
<a id="more"></a>
<p>看懂别人的大致思路之后<br>自己动手用vim写了一个贪吃蛇出来，<br>然后感觉太简陋了，于是改了两个bug，<br>增加了积分、难度、记名排名、储存的功能，<br>改得不成样子了，再过几天估计自己都看不懂，<br>有空再整理了…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include&lt;stdio.h&gt;</div><div class="line">#include&lt;conio.h&gt;</div><div class="line">#include&lt;string.h&gt;</div><div class="line">#include&lt;time.h&gt;</div><div class="line">#include&lt;stdlib.h&gt;</div><div class="line">#define H 6</div><div class="line">#define L 10</div><div class="line">char map[H][L];</div><div class="line">const char head=&apos;@&apos;;</div><div class="line">const char body=&apos;O&apos;;</div><div class="line">const char ground=&apos;.&apos;;</div><div class="line">const char food=&apos;Q&apos;;</div><div class="line">int st=300;</div><div class="line">int sp=0;</div><div class="line">int end=0;</div><div class="line">int point=1;</div><div class="line">int level=1;</div><div class="line">int maxsp=0;</div><div class="line">int key;</div><div class="line"></div><div class="line">struct snake</div><div class="line">&#123;</div><div class="line">int x,y;</div><div class="line">int dir;</div><div class="line">&#125;snake[H*L];</div><div class="line"></div><div class="line">struct player</div><div class="line">&#123;</div><div class="line">char name[10];</div><div class="line">int sp;</div><div class="line">int level;</div><div class="line">&#125;player[11],new;</div><div class="line"></div><div class="line"></div><div class="line">int dx[]=&#123;0,0,-1,1&#125;;</div><div class="line">int dy[]=&#123;-1,1,0,0&#125;;</div><div class="line">void mapcreat();</div><div class="line">void ref();</div><div class="line">void foodcreat();</div><div class="line">void rmove();</div><div class="line">void check(int x,int y);</div><div class="line">void foodcheck();</div><div class="line">void filecreat();</div><div class="line">void fileload();</div><div class="line">void filesave();</div><div class="line">void playerset();</div><div class="line">void sort();</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">playerset();</div><div class="line">filecreat();</div><div class="line">fileload();</div><div class="line">mapcreat();</div><div class="line">getch();</div><div class="line">ref();</div><div class="line">return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void mapcreat()</div><div class="line">&#123;</div><div class="line">int hx,hy;</div><div class="line">int i,j;</div><div class="line">memset(map,ground,sizeof map);</div><div class="line">system(&quot;title 贪吃蛇&quot;);</div><div class="line">system(&quot;cls&quot;);</div><div class="line">srand(time(0));</div><div class="line">hx=rand()%H;</div><div class="line">hy=rand()%L;</div><div class="line">map[hx][hy]=head;</div><div class="line">snake[0].x=hx,snake[0].y=hy,snake[0].dir=0;</div><div class="line">foodcreat();</div><div class="line">printf(&quot;\n\n\t\t请按方向键操作&quot;);</div><div class="line">printf(&quot;\n\n\t\t &quot;);</div><div class="line">for(i=0;i&lt;H;i++)</div><div class="line">&#123;for(j=0;j&lt;L;j++)</div><div class="line">&#123;</div><div class="line">    printf(&quot;%c&quot;,map[i][j]);</div><div class="line">    </div><div class="line">&#125;</div><div class="line">    printf(&quot;\n\t\t &quot;);</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">void foodcreat()</div><div class="line">&#123;</div><div class="line">int fx,fy;</div><div class="line">fx=rand()%H;</div><div class="line">fy=rand()%L;</div><div class="line">while(map[fy][fx]!=ground)</div><div class="line">&#123;</div><div class="line">    fx=rand()%H;</div><div class="line">    fy=rand()%L;</div><div class="line">&#125;</div><div class="line"></div><div class="line">map[fy][fx]=food;</div><div class="line">&#125;</div><div class="line">   </div><div class="line">void ref()</div><div class="line">&#123;</div><div class="line">int i,j;</div><div class="line">while(1)</div><div class="line">&#123;</div><div class="line">    _sleep(st);</div><div class="line">    rmove();</div><div class="line">    if(end==1)</div><div class="line">    &#123;</div><div class="line">        system(&quot;cls&quot;);</div><div class="line">        printf(&quot;\n\n\t\t   游戏结束! &quot;);</div><div class="line">        printf(&quot;\n\n\t\t此局得分 : %d&quot;,sp);</div><div class="line">        printf(&quot;\n\n\t\t最高得分 : %d&quot;,maxsp);</div><div class="line">        printf(&quot;\n\n\n\t\t   留下大名!&quot;);</div><div class="line">        printf(&quot;\n\n\t\t君の名は。:&quot;);</div><div class="line">        filesave();</div><div class="line">        fileload();</div><div class="line">        system(&quot;cls&quot;);</div><div class="line">        printf(&quot;\n\n\t\t    得分排行&quot;);</div><div class="line">        printf(&quot;\n\n\t  玩家:\t\t得分:\t难度:\t\n&quot;);</div><div class="line">        for(i=0;i&lt;10;i++)</div><div class="line">        &#123;</div><div class="line">            printf(&quot;\n\t   %-4s \t %-4d \t %-4d \t\n\</div><div class="line">                   &quot;,player[i].name,player[i].sp,player[i].level);</div><div class="line">        &#125;</div><div class="line">        printf(&quot;\n\t  本次纪录:&quot;);</div><div class="line">        printf(&quot;\n\t   %-4s \t %-4d \t %-4d \t\n\</div><div class="line">               &quot;,new.name,new.sp,new.level);</div><div class="line">        printf(&quot;\n\t   &quot;);</div><div class="line">        getchar();</div><div class="line">        getchar();</div><div class="line">        system(&quot;cls&quot;);</div><div class="line">        mapcreat();</div><div class="line">        getch();</div><div class="line">        point=1;</div><div class="line">        end=0;</div><div class="line">        st=300;</div><div class="line">        sp=0;</div><div class="line">        level=0;</div><div class="line">        system(&quot;cls&quot;);</div><div class="line">        end=0;</div><div class="line">    &#125;</div><div class="line">    else</div><div class="line">        system(&quot;cls&quot;);</div><div class="line">    </div><div class="line">    printf(&quot;\n\n\t\tEp:%-4d&quot;,sp);</div><div class="line">    printf(&quot; Lv:%d&quot;,level);</div><div class="line">    printf(&quot;\n\n\t\t &quot;);</div><div class="line">    foodcheck();</div><div class="line">    for(i=0;i&lt;H;i++)</div><div class="line">    &#123;for(j=0;j&lt;L;j++)</div><div class="line">        </div><div class="line">    &#123;</div><div class="line">        printf(&quot;%c&quot;,map[i][j]);</div><div class="line">        </div><div class="line">        </div><div class="line">    &#125;</div><div class="line">        printf(&quot;\n\t\t &quot;);</div><div class="line">        </div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    </div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">   </div><div class="line">void rmove()</div><div class="line">&#123;</div><div class="line"></div><div class="line">int i,x,y;</div><div class="line">int t=point;</div><div class="line">if(kbhit())</div><div class="line">&#123;</div><div class="line">    while(kbhit())</div><div class="line">        key=getch();</div><div class="line">    switch(key)</div><div class="line">    &#123;</div><div class="line">        case 75: if(snake[0].dir!=1||point==1)snake[0].dir=0;break;</div><div class="line">        case 77: if(snake[0].dir!=0||point==1)snake[0].dir=1;break;</div><div class="line">        case 72: if(snake[0].dir!=3||point==1)snake[0].dir=2;break;</div><div class="line">        case 80: if(snake[0].dir!=2||point==1)snake[0].dir=3;break;</div><div class="line">            </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">x=snake[0].x,y=snake[0].y;</div><div class="line">map[x][y]=ground;</div><div class="line">snake[0].x=snake[0].x+dx[snake[0].dir];</div><div class="line">snake[0].y=snake[0].y+dy[snake[0].dir];</div><div class="line">check(x,y);</div><div class="line">if(point==t)</div><div class="line">    for(i=1;i&lt;point;i++)</div><div class="line">    &#123;</div><div class="line">        if(i==1)</div><div class="line">            map[snake[i].x][snake[i].y]=ground;</div><div class="line">        if(i==point-1)</div><div class="line">        &#123;</div><div class="line">            snake[i].x=x,snake[i].y=y;</div><div class="line">            snake[i].dir=snake[0].dir;</div><div class="line">        &#125;</div><div class="line">        else</div><div class="line">        &#123;</div><div class="line">            snake[i].x=snake[i+1].x;</div><div class="line">            snake[i].y=snake[i+1].y;</div><div class="line">            snake[i].dir=snake[i+1].dir;</div><div class="line">        &#125;</div><div class="line">        map[snake[i].x][snake[i].y]=&apos;O&apos;;</div><div class="line">    &#125;</div><div class="line">    &#125;</div><div class="line">void check(int x,int y)</div><div class="line">&#123;</div><div class="line">if(snake[0].x&lt;0||snake[0].x&gt;H||snake[0].y&lt;0||snake[0].y&gt;L)</div><div class="line">    end=1;</div><div class="line"></div><div class="line">if(map[snake[0].x][snake[0].y]==ground)</div><div class="line">&#123;</div><div class="line">    map[snake[0].x][snake[0].y]=head;</div><div class="line">    </div><div class="line">&#125;</div><div class="line">else if(map[snake[0].x][snake[0].y]==food)</div><div class="line">&#123;</div><div class="line">    map[snake[0].x][snake[0].y]=head;</div><div class="line">    foodcreat();</div><div class="line">    snake[point].x=x;</div><div class="line">    snake[point].y=y;</div><div class="line">    snake[point].dir=snake[0].dir;</div><div class="line">    point++;</div><div class="line">    if(st&gt;=50)</div><div class="line">    &#123;</div><div class="line">        st=st-10;</div><div class="line">        level=level+1;</div><div class="line">        sp=sp+30;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div><div class="line">else</div><div class="line">&#123;   if(sp&gt;maxsp)</div><div class="line">    maxsp=sp;</div><div class="line">    end=1;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">void foodcheck()</div><div class="line">&#123;</div><div class="line">int i,j,check=0;</div><div class="line">for(i=0;i&lt;H;i++)</div><div class="line">    for(j=0;j&lt;L;j++)</div><div class="line">        if(map[i][j]==food)check=1;</div><div class="line">if(check==0)foodcreat();</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">void filecreat()</div><div class="line">&#123;</div><div class="line"></div><div class="line">FILE *fp;</div><div class="line">if((fp=fopen(&quot;player.dat&quot;,&quot;ab&quot;))==NULL)</div><div class="line">&#123;</div><div class="line">    printf(&quot;error,cannot open file player.dat&quot;);&#125;</div><div class="line">fwrite(player,sizeof(struct player),11,fp);</div><div class="line">fclose(fp);</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">void fileload()</div><div class="line">&#123;</div><div class="line">FILE *fp;</div><div class="line">fp=fopen(&quot;player.dat&quot;,&quot;rb&quot;);</div><div class="line">fread(player,sizeof(struct player),11,fp);</div><div class="line">fclose(fp);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">void filesave()</div><div class="line">&#123;</div><div class="line">FILE *fp;</div><div class="line">fp=fopen(&quot;player.dat&quot;,&quot;wb&quot;);</div><div class="line">scanf(&quot;%s&quot;,player[10].name);</div><div class="line">player[10].sp=sp;</div><div class="line">player[10].level=level;</div><div class="line">sort();</div><div class="line">fwrite(player,sizeof(struct player),11,fp);</div><div class="line">fclose(fp);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void playerset()</div><div class="line">&#123;</div><div class="line">int i;</div><div class="line">for(i=0;i&lt;11;i++)</div><div class="line">&#123;</div><div class="line">    strcpy(player[i].name,&quot;空&quot;);</div><div class="line">    player[i].sp=0;</div><div class="line">    player[i].level=0;</div><div class="line">    </div><div class="line">    </div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">void sort()</div><div class="line">&#123;</div><div class="line">struct player temp;</div><div class="line">int i,j,max;</div><div class="line">new.level=player[10].level;</div><div class="line">new.sp=player[10].sp;</div><div class="line">strcpy(new.name,player[10].name);</div><div class="line">for(i=0;i&lt;11;i++)</div><div class="line">&#123;   max=i;</div><div class="line">    for(j=i+1;j&lt;11;j++)</div><div class="line">    &#123;</div><div class="line">        if(player[max].sp&lt;player[j].sp)max=j;</div><div class="line">        &#123;</div><div class="line">            temp.level=player[i].level;</div><div class="line">            temp.sp=player[i].sp;</div><div class="line">            strcpy(temp.name,player[i].name);</div><div class="line">        &#125;</div><div class="line">        player[i].level=player[max].level;</div><div class="line">        player[i].sp=player[max].sp;</div><div class="line">        strcpy(player[i].name,player[max].name);</div><div class="line">        player[max].level=temp.level;</div><div class="line">        player[max].sp=temp.sp;</div><div class="line">        strcpy(player[max].name,temp.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 代码 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[酷炫的终端配置入门指南]]></title>
      <url>/2016/11/13/iTerm2/</url>
      <content type="html"><![CDATA[<p><img src="http://p1.bqimg.com/4851/fa551cd95e4fdbc4.jpg" class="img-topic"><br>记录一些自己的配置，只是入门级别而已<br><a id="more"></a></p>
<h2 id="iTerm2-mac上最好用的终端"><a href="#iTerm2-mac上最好用的终端" class="headerlink" title="iTerm2 : mac上最好用的终端"></a>iTerm2 : mac上最好用的终端</h2><p>有多好用看看快捷键功能就知道了<br>插件都是通用的,linux可以使用tmux </p>
<pre><code>⌘ + —/+/0 : 调整字体大小
⌘ + r : 清屏
⌘ + 数字 : 切换标签页
⌘ + 方向键 : 按方向切换标签页
⌘ + enter : 切换全屏
⌘ + d: 垂直分屏
⌘ + shift + d : 水平分屏
⌘ + ] ⌘ + [ : 在最近使用的分屏直接切换 
⌘ + opt + 方向键 : 切换到指定位置的分屏
⌘ + t : 新的标签页
⌘ + w : 关闭当前标签页
⌘ + ；: 自动补全历史命令
space + opt : 呼出悬浮窗
ctrl + u : 清空当前行
ctrl + a : 到行首
ctrl + e : 行末
ctrl + f/b : 前进后退
ctrl + p : 上一条命令
ctrl + r : 搜索命令历史
ctrl + d : 删除当前字符
ctrl + h : 删除之前的字符
ctrl + w : 删除光标前的单词
ctrl + k : 删除到文本末尾
ctrl + t : 交换光标处文本 
</code></pre><h2 id="zsh-终极-Shell"><a href="#zsh-终极-Shell" class="headerlink" title="zsh : 终极 Shell"></a>zsh : 终极 Shell</h2><p>1.确保已安装git</p>
<p>2.然后安装oh my zsh :</p>
<pre><code>git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh
</code></pre><p>3.创建zsh的配置文件</p>
<pre><code>cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc
</code></pre><p>4.设置默认 </p>
<pre><code>chsh -s /bin/zsh
</code></pre><p>5.选择主题</p>
<pre><code>~/.oh-my-zsh/themes 
</code></pre><p> 这里有上百种主题可供选择</p>
<pre><code>vim ~/.zshrc
</code></pre><p> 修改ZSH_THEME=你的主题</p>
<p> 最后</p>
<pre><code>source ~/.zshrc
</code></pre><h2 id="autojump-智能跳转"><a href="#autojump-智能跳转" class="headerlink" title="autojump : 智能跳转"></a>autojump : 智能跳转</h2><p>1.确保已安装homebrew</p>
<p>2.安装autojump</p>
<pre><code>brew install autojump
</code></pre><p>3.修改zsh配置</p>
<pre><code>vim ~/.zshrc
</code></pre><p>加入</p>
<pre><code>[[ -s ~/.autojump/etc/profile.d/autojump.sh ]] &amp;&amp; . ~/.autojump/etc/profile.d/autojump.sh
</code></pre><h2 id="pathogen-vim插件管理"><a href="#pathogen-vim插件管理" class="headerlink" title="pathogen : vim插件管理"></a>pathogen : vim插件管理</h2><p>1.安装pathogen</p>
<pre><code>git clone git://github.com/tpope/vim-pathogen
</code></pre><p>2.进入.vim, 没有就建一个</p>
<pre><code>mkdir autoload bundle
</code></pre><p>  以后vim插件最好都在bundle中下载<br>  将下载到的pathogen.vim复制到autoload目录</p>
<p>3.打开.vimrc, 没有也建一个<br>（vim的配置可以实现很多功能，要是觉得麻烦，网上有现成）</p>
<p>加入</p>
<pre><code>call pathogen#infect()
</code></pre><h2 id="NERDTree：树形目录"><a href="#NERDTree：树形目录" class="headerlink" title="NERDTree：树形目录"></a>NERDTree：树形目录</h2><p>1.在.vim/bundle下安装NERDTree</p>
<pre><code>git clone git://github.com/scrooloose/nerdtree.git
</code></pre><p>2.进入目录内的doc，在vim内使用:Helptags</p>
<h2 id="powerline：状态栏插件"><a href="#powerline：状态栏插件" class="headerlink" title="powerline：状态栏插件"></a>powerline：状态栏插件</h2><p>1.安装powerline</p>
<pre><code>git clone git://github.com/Lokaltog/powerline.git 
</code></pre><p>2.设置zsh </p>
<pre><code>vim ~/.zshrc
</code></pre><p>添加</p>
<pre><code>. /Users/～/PowerLine/powerline/bindings/zsh/powerline.zsh
</code></pre><p>  以上路径需要自行修改</p>
<p>3.设置vim</p>
<pre><code>vim ~/.vimrc
</code></pre><p>加入</p>
<pre><code>&quot;powerline 
set rtp+=/Users/～/PowerLine/  
powerline/bindings/vim
set guifont=PowerlineSymbols\ for\ Powerline
set laststatus=2
let g:Powerline_symbols = &apos;fancy&apos;
let g:Powerline_symbols = &apos;unicode&apos;
set encoding=utf-8
set t_Co=256
set number
set fillchars+=stl:\ ,stlnc:\
set term=xterm-256color
set termencoding=utf-8
</code></pre><p>路径同样需要自行修改</p>
<p>4.在iTerm2的profiles中把字体改为powerline字体</p>
<h2 id="Solarized-完善的配色方案"><a href="#Solarized-完善的配色方案" class="headerlink" title="Solarized : 完善的配色方案"></a>Solarized : 完善的配色方案</h2><p>1.安装Solarized</p>
<pre><code>git clone git://github.com/altercation/solarized.git
</code></pre><p>2.执行下列命令行</p>
<hr>
<pre><code>cd solarized
</code></pre><hr>
<pre><code>cd vim-colors-solarized/colors
</code></pre><hr>
<pre><code>mkdir -p ~/.vim/colors
</code></pre><hr>
<pre><code>cp solarized.vim ~/.vim/colors/
</code></pre><hr>
<pre><code>vim ~/.vimrc
</code></pre><hr>
<p>3.修改vim设置，加入</p>
<pre><code>syntax enable
set background=dark
colorscheme solarized
</code></pre><p>4.在profiles中选择Solarized主题</p>
<h2 id="ctags-生成索引"><a href="#ctags-生成索引" class="headerlink" title="ctags : 生成索引"></a>ctags : 生成索引</h2><p>os x自带了ctags，但是这并没有什么卵用</p>
<p>1.下载ctags</p>
<pre><code>http://ctags.sourceforge.net/
</code></pre><p>并解压</p>
<pre><code>tar zxvf ctags-5.8.tar.gz
</code></pre><p>安装</p>
<pre><code>sudo ./configure &amp;&amp; make all &amp;&amp; sudo make install 
</code></pre><p>2.打开 ~/.profile, 如果没有，还是那句，建一个</p>
<p>加入</p>
<pre><code>export PATH=&quot;/usr/local/bin:/usr/local/sbin:$PATH&quot; 
</code></pre><p>3.修改PATH </p>
<pre><code>vim ~/.zshrc  
</code></pre><p>添加</p>
<pre><code>PATH=&quot;/usr/local/bin:$PATH&quot;
</code></pre><h2 id="taglist：代码概览"><a href="#taglist：代码概览" class="headerlink" title="taglist：代码概览"></a>taglist：代码概览</h2><p>1.下载taglist</p>
<pre><code>git clone git://github.com/vim-scripts/taglist.vim
</code></pre><p>2.修改vimrc<br>加入</p>
<pre><code>&quot;taglist{
let Tlist_Show_One_File = 1         
let Tlist_Exit_OnlyWindow = 1          
let Tlist_Use_Right_Window = 1         
let Tlist_GainFocus_On_ToggleOpen = 1  
let Tlist_Ctags_Cmd=&apos;/usr/local/bin/ctags&apos;  
nnoremap &lt;leader&gt;tl : Tlist&lt;CR&gt;        
}  
</code></pre><p>注：taglist需要使用ctags生成的tags    </p>
]]></content>
      
        
        <tags>
            
            <tag> 终端配置 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[搭建hexo＋github博客]]></title>
      <url>/2016/10/15/hexo/</url>
      <content type="html"><![CDATA[<p><img src="http://p1.bpimg.com/567571/334398904d749981.jpg" class="img-topic"></p>
<p>花一天半的时间搭了hexo博客，<br>整理一下参考链接<br><a id="more"></a></p>
<p><a href="http://lijianchang.xyz/2016/03/16/小白独立搭建博客-Github-Pages和Hexo简明教程/" target="_blank" rel="external">http://lijianchang.xyz/2016/03/16/小白独立搭建博客-Github-Pages和Hexo简明教程/</a></p>
<p>在主题的部分参考下面的jacman，这是一个相当美观的主题<br>有详细的配置指南，注意末尾的常见问题：</p>
<p><a href="http://jacman.wuchong.me/2014/11/20/how-to-use-jacman/#more" target="_blank" rel="external">http://jacman.wuchong.me/2014/11/20/how-to-use-jacman/#more</a></p>
<p>不会使用markdown的请粗略地阅读：</p>
<p><a href="http://wowubuntu.com/markdown/#overview" target="_blank" rel="external">http://wowubuntu.com/markdown/#overview</a></p>
<p>有必要时再来翻阅即可</p>
<p>终端不能保存请set noreadonly 再:wq</p>
<p>关于如何安装rss插件：</p>
<p><a href="http://blog.csdn.net/u011303443/article/details/52333695" target="_blank" rel="external">http://blog.csdn.net/u011303443/article/details/52333695</a></p>
<p>关于图床：<br><a href="http://yotuku.cn" target="_blank" rel="external">http://yotuku.cn</a></p>
<p>关于购买域名：<br>腾讯云有一个适合入门者的 1元=服务器+域名 活动<br>每日12时可抢购（据说以前是不用抢的<br><a href="https://www.qcloud.com/act/campus" target="_blank" rel="external">https://www.qcloud.com/act/campus</a></p>
<p>关于如何将域名关联到Github：<br>返回参考第一个链接 </p>
]]></content>
      
        
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[我的涂鸦]]></title>
      <url>/2016/10/15/mypaintings/</url>
      <content type="html"><![CDATA[<p>这是一个存放半成品的地方，线稿居多</p>
<p>也许哪天会想要继续画的东西，大概吧<br><a id="more"></a><br><img src="http://p1.bqimg.com/567571/2b22b63555a8a112.jpg" alt="光影部分没有完成，不肝了:("></p>
<p><img src="http://p1.bpimg.com/567571/49b24aac8aef4874.jpg" alt="自用的logo（并没有用 "></p>
<p><img src="http://p1.bqimg.com/567571/9c34ec604599fff3.jpg" alt="久违的同人"></p>
<p><img src="http://p1.bqimg.com/567571/095305f6498ebb45.jpg" alt="为什么以前总是能画出现在都没办法上色的稿呢:("></p>
<p><img src="http://p1.bqimg.com/567571/e61bab9ccfe04d9d.jpg" alt="维持线描风更好吧！"></p>
<p><img src="http://p1.bqimg.com/567571/96551e32716e8e5c.jpg" alt="看完岚少的夜回，徊，佪，廻..hui字有几种写法，本来打算做生贺图的，但是sai文件丢了"></p>
<p><img src="http://p1.bqimg.com/567571/006ca391246954a4.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 创作 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 涂鸦 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hello world]]></title>
      <url>/2016/10/14/hello-world/</url>
      <content type="html"><![CDATA[<p>缘起</p>
<p>欢迎来到我的小窝</p>
]]></content>
      
        
    </entry>
    
  
  
</search>
